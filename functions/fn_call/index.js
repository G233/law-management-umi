var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) =>
  __defProp(target, '__esModule', { value: true });
var __commonJS = (callback, module2) => () => {
  if (!module2) {
    module2 = { exports: {} };
    callback(module2.exports, module2);
  }
  return module2.exports;
};
var __exportStar = (target, module2, desc) => {
  if (
    (module2 && typeof module2 === 'object') ||
    typeof module2 === 'function'
  ) {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== 'default')
        __defProp(target, key, {
          get: () => module2[key],
          enumerable:
            !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable,
        });
  }
  return target;
};
var __toModule = (module2) => {
  if (module2 && module2.__esModule) return module2;
  return __exportStar(
    __markAsModule(
      __defProp(
        module2 != null ? __create(__getProtoOf(module2)) : {},
        'default',
        { value: module2, enumerable: true },
      ),
    ),
    module2,
  );
};

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/constant.js
var require_constant = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var ErrorCode;
  (function (ErrorCode2) {
    ErrorCode2['DocIDError'] = '\u6587\u6863ID\u4E0D\u5408\u6CD5';
    ErrorCode2['CollNameError'] = '\u96C6\u5408\u540D\u79F0\u4E0D\u5408\u6CD5';
    ErrorCode2['OpStrError'] = '\u64CD\u4F5C\u7B26\u4E0D\u5408\u6CD5';
    ErrorCode2['DirectionError'] = '\u6392\u5E8F\u5B57\u7B26\u4E0D\u5408\u6CD5';
    ErrorCode2['IntergerError'] = 'must be integer';
    ErrorCode2['BooleanError'] = 'must be boolean';
    ErrorCode2['ArrayError'] = 'must be array';
    ErrorCode2['QueryParamTypeError'] =
      '\u67E5\u8BE2\u53C2\u6570\u5FC5\u987B\u4E3A\u5BF9\u8C61';
    ErrorCode2['QueryParamValueError'] =
      '\u67E5\u8BE2\u53C2\u6570\u5BF9\u8C61\u503C\u4E0D\u80FD\u5747\u4E3Aundefined';
    ErrorCode2['CentersPhereError'] =
      'centersPhere\u7ED3\u6784\u4E0D\u5408\u6CD5';
  })(ErrorCode || (ErrorCode = {}));
  exports2.ErrorCode = ErrorCode;
  var FieldType = {
    String: 'String',
    Number: 'Number',
    Object: 'Object',
    Array: 'Array',
    Boolean: 'Boolean',
    Null: 'Null',
    GeoPoint: 'GeoPoint',
    GeoLineString: 'GeoLineString',
    GeoPolygon: 'GeoPolygon',
    GeoMultiPoint: 'GeoMultiPoint',
    GeoMultiLineString: 'GeoMultiLineString',
    GeoMultiPolygon: 'GeoMultiPolygon',
    Date: 'Date',
    Command: 'Command',
    ServerDate: 'ServerDate',
    BsonDate: 'BsonDate',
  };
  exports2.FieldType = FieldType;
  var OrderDirectionList = ['desc', 'asc'];
  exports2.OrderDirectionList = OrderDirectionList;
  var WhereFilterOpList = ['<', '<=', '==', '>=', '>'];
  exports2.WhereFilterOpList = WhereFilterOpList;
  var Opeartor;
  (function (Opeartor2) {
    Opeartor2['lt'] = '<';
    Opeartor2['gt'] = '>';
    Opeartor2['lte'] = '<=';
    Opeartor2['gte'] = '>=';
    Opeartor2['eq'] = '==';
  })(Opeartor || (Opeartor = {}));
  exports2.Opeartor = Opeartor;
  var OperatorMap = {
    [Opeartor.eq]: '$eq',
    [Opeartor.lt]: '$lt',
    [Opeartor.lte]: '$lte',
    [Opeartor.gt]: '$gt',
    [Opeartor.gte]: '$gte',
  };
  exports2.OperatorMap = OperatorMap;
  var UpdateOperatorList = [
    '$set',
    '$inc',
    '$mul',
    '$unset',
    '$push',
    '$pop',
    '$unshift',
    '$shift',
    '$currentDate',
    '$each',
    '$position',
  ];
  exports2.UpdateOperatorList = UpdateOperatorList;
  var QueryType;
  (function (QueryType2) {
    QueryType2['WHERE'] = 'WHERE';
    QueryType2['DOC'] = 'DOC';
  })(QueryType || (QueryType = {}));
  exports2.QueryType = QueryType;
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/util.js
var require_util = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var constant_1 = require_constant();
  var index_1 = require_geo();
  var Util = class {};
  exports2.Util = Util;
  Util.formatResDocumentData = (documents) => {
    return documents.map((document2) => {
      return Util.formatField(document2);
    });
  };
  Util.formatField = (document2) => {
    const keys = Object.keys(document2);
    let protoField = {};
    if (Array.isArray(document2)) {
      protoField = [];
    }
    keys.forEach((key) => {
      const item = document2[key];
      const type = Util.whichType(item);
      let realValue;
      switch (type) {
        case constant_1.FieldType.GeoPoint:
          realValue = new index_1.Point(
            item.coordinates[0],
            item.coordinates[1],
          );
          break;
        case constant_1.FieldType.GeoLineString:
          realValue = new index_1.LineString(
            item.coordinates.map(
              (point) => new index_1.Point(point[0], point[1]),
            ),
          );
          break;
        case constant_1.FieldType.GeoPolygon:
          realValue = new index_1.Polygon(
            item.coordinates.map(
              (line) =>
                new index_1.LineString(
                  line.map(([lng, lat]) => new index_1.Point(lng, lat)),
                ),
            ),
          );
          break;
        case constant_1.FieldType.GeoMultiPoint:
          realValue = new index_1.MultiPoint(
            item.coordinates.map(
              (point) => new index_1.Point(point[0], point[1]),
            ),
          );
          break;
        case constant_1.FieldType.GeoMultiLineString:
          realValue = new index_1.MultiLineString(
            item.coordinates.map(
              (line) =>
                new index_1.LineString(
                  line.map(([lng, lat]) => new index_1.Point(lng, lat)),
                ),
            ),
          );
          break;
        case constant_1.FieldType.GeoMultiPolygon:
          realValue = new index_1.MultiPolygon(
            item.coordinates.map(
              (polygon) =>
                new index_1.Polygon(
                  polygon.map(
                    (line) =>
                      new index_1.LineString(
                        line.map(([lng, lat]) => new index_1.Point(lng, lat)),
                      ),
                  ),
                ),
            ),
          );
          break;
        case constant_1.FieldType.Date:
          realValue = item;
          break;
        case constant_1.FieldType.Object:
        case constant_1.FieldType.Array:
          realValue = Util.formatField(item);
          break;
        case constant_1.FieldType.ServerDate:
          realValue = new Date(item.$date);
          break;
        default:
          realValue = item;
      }
      if (Array.isArray(protoField)) {
        protoField.push(realValue);
      } else {
        protoField[key] = realValue;
      }
    });
    return protoField;
  };
  Util.whichType = (obj) => {
    let type = Object.prototype.toString.call(obj).slice(8, -1);
    if (type === constant_1.FieldType.Date) {
      return constant_1.FieldType.Date;
    }
    if (type === constant_1.FieldType.Object) {
      if (obj.$date) {
        type = constant_1.FieldType.ServerDate;
      } else if (index_1.Point.validate(obj)) {
        type = constant_1.FieldType.GeoPoint;
      } else if (index_1.LineString.validate(obj)) {
        type = constant_1.FieldType.GeoLineString;
      } else if (index_1.Polygon.validate(obj)) {
        type = constant_1.FieldType.GeoPolygon;
      } else if (index_1.MultiPoint.validate(obj)) {
        type = constant_1.FieldType.GeoMultiPoint;
      } else if (index_1.MultiLineString.validate(obj)) {
        type = constant_1.FieldType.GeoMultiLineString;
      } else if (index_1.MultiPolygon.validate(obj)) {
        type = constant_1.FieldType.GeoMultiPolygon;
      }
    }
    return type;
  };
  Util.generateDocId = () => {
    let chars = 'ABCDEFabcdef0123456789';
    let autoId = '';
    for (let i = 0; i < 24; i++) {
      autoId += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return autoId;
  };
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/const/code.js
var require_code = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  exports2.ERRORS = {
    CREATE_WATCH_NET_ERROR: {
      code: 'CREATE_WATCH_NET_ERROR',
      message: 'create watch network error',
    },
    CREATE_WACTH_EXCEED_ERROR: {
      code: 'CREATE_WACTH_EXCEED_ERROR',
      message: 'maximum connections exceed',
    },
    CREATE_WATCH_SERVER_ERROR: {
      code: 'CREATE_WATCH_SERVER_ERROR',
      message: 'create watch server error',
    },
    CONN_ERROR: {
      code: 'CONN_ERROR',
      message: 'connection error',
    },
    INVALID_PARAM: {
      code: 'INVALID_PARAM',
      message: 'Invalid request param',
    },
    INSERT_DOC_FAIL: {
      code: 'INSERT_DOC_FAIL',
      message: 'insert document failed',
    },
    DATABASE_TRANSACTION_CONFLICT: {
      code: 'DATABASE_TRANSACTION_CONFLICT',
      message: 'database transaction conflict',
    },
    DATABASE_REQUEST_FAILED: {
      code: 'DATABASE_REQUEST_FAILED',
      message: 'database request failed',
    },
  };
});

// node_modules/@cloudbase/node-sdk/node_modules/bson/lib/parser/utils.js
var require_utils = __commonJS((exports2) => {
  'use strict';
  var __spreadArrays =
    (exports2 && exports2.__spreadArrays) ||
    function () {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
  Object.defineProperty(exports2, '__esModule', { value: true });
  exports2.deprecate = exports2.isObjectLike = exports2.isDate = exports2.isBuffer = exports2.haveBuffer = exports2.isBigUInt64Array = exports2.isBigInt64Array = exports2.isUint8Array = exports2.randomBytes = exports2.normalizedFunctionString = void 0;
  var buffer_1 = require('buffer');
  function normalizedFunctionString(fn) {
    return fn.toString().replace('function(', 'function (');
  }
  exports2.normalizedFunctionString = normalizedFunctionString;
  function insecureRandomBytes(size) {
    var result = buffer_1.Buffer.alloc(size);
    for (var i = 0; i < size; ++i) result[i] = Math.floor(Math.random() * 256);
    return result;
  }
  exports2.randomBytes = insecureRandomBytes;
  if (
    typeof window !== 'undefined' &&
    window.crypto &&
    window.crypto.getRandomValues
  ) {
    exports2.randomBytes = function (size) {
      return window.crypto.getRandomValues(buffer_1.Buffer.alloc(size));
    };
  } else {
    try {
      exports2.randomBytes = require('crypto').randomBytes;
    } catch (e) {}
    if (exports2.randomBytes == null) {
      exports2.randomBytes = insecureRandomBytes;
    }
  }
  function isUint8Array(value) {
    return Object.prototype.toString.call(value) === '[object Uint8Array]';
  }
  exports2.isUint8Array = isUint8Array;
  function isBigInt64Array(value) {
    return Object.prototype.toString.call(value) === '[object BigInt64Array]';
  }
  exports2.isBigInt64Array = isBigInt64Array;
  function isBigUInt64Array(value) {
    return Object.prototype.toString.call(value) === '[object BigUint64Array]';
  }
  exports2.isBigUInt64Array = isBigUInt64Array;
  function haveBuffer() {
    return (
      typeof global !== 'undefined' && typeof global.Buffer !== 'undefined'
    );
  }
  exports2.haveBuffer = haveBuffer;
  function isBuffer(value) {
    var _a;
    return (
      typeof value === 'object' &&
      ((_a =
        value === null || value === void 0 ? void 0 : value.constructor) ===
        null || _a === void 0
        ? void 0
        : _a.name) === 'Buffer'
    );
  }
  exports2.isBuffer = isBuffer;
  function isDate(d) {
    return (
      isObjectLike(d) && Object.prototype.toString.call(d) === '[object Date]'
    );
  }
  exports2.isDate = isDate;
  function isObjectLike(candidate) {
    return typeof candidate === 'object' && candidate !== null;
  }
  exports2.isObjectLike = isObjectLike;
  function deprecate(fn, message) {
    if (typeof window === 'undefined' && typeof self === 'undefined') {
      return require('util').deprecate(fn, message);
    }
    var warned = false;
    function deprecated() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (!warned) {
        console.warn(message);
        warned = true;
      }
      return fn.apply.apply(fn, __spreadArrays([this], args));
    }
    return deprecated;
  }
  exports2.deprecate = deprecate;
});

// node_modules/@cloudbase/node-sdk/node_modules/bson/lib/ensure_buffer.js
var require_ensure_buffer = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  exports2.ensureBuffer = void 0;
  var buffer_1 = require('buffer');
  var utils_1 = require_utils();
  function ensureBuffer(potentialBuffer) {
    if (utils_1.isBuffer(potentialBuffer)) {
      return potentialBuffer;
    }
    if (ArrayBuffer.isView(potentialBuffer)) {
      return buffer_1.Buffer.from(potentialBuffer.buffer);
    }
    if (potentialBuffer instanceof ArrayBuffer) {
      return buffer_1.Buffer.from(potentialBuffer);
    }
    throw new TypeError('Must use either Buffer or TypedArray');
  }
  exports2.ensureBuffer = ensureBuffer;
});

// node_modules/@cloudbase/node-sdk/node_modules/bson/lib/uuid.js
var require_uuid = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  exports2.parseUUID = void 0;
  var UUID_RX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  function parseUUID(uuid) {
    if (typeof uuid !== 'string') {
      throw new TypeError(
        'Invalid type for UUID, expected string but got ' + typeof uuid,
      );
    }
    if (!UUID_RX.test(uuid)) {
      throw new TypeError('Invalid format for UUID: ' + uuid);
    }
    var v;
    var arr = new Uint8Array(16);
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = (v >>> 16) & 255;
    arr[2] = (v >>> 8) & 255;
    arr[3] = v & 255;
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 255;
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 255;
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 255;
    arr[10] = ((v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776) & 255;
    arr[11] = (v / 4294967296) & 255;
    arr[12] = (v >>> 24) & 255;
    arr[13] = (v >>> 16) & 255;
    arr[14] = (v >>> 8) & 255;
    arr[15] = v & 255;
    return arr;
  }
  exports2.parseUUID = parseUUID;
});

// node_modules/@cloudbase/node-sdk/node_modules/bson/lib/binary.js
var require_binary = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  exports2.Binary = void 0;
  var buffer_1 = require('buffer');
  var ensure_buffer_1 = require_ensure_buffer();
  var uuid_1 = require_uuid();
  var Binary = (function () {
    function Binary2(buffer, subType) {
      if (!(this instanceof Binary2)) return new Binary2(buffer, subType);
      if (
        !(buffer == null) &&
        !(typeof buffer === 'string') &&
        !ArrayBuffer.isView(buffer) &&
        !(buffer instanceof ArrayBuffer) &&
        !Array.isArray(buffer)
      ) {
        throw new TypeError(
          'Binary can only be constructed from string, Buffer, TypedArray, or Array<number>',
        );
      }
      this.sub_type =
        subType !== null && subType !== void 0
          ? subType
          : Binary2.BSON_BINARY_SUBTYPE_DEFAULT;
      if (buffer == null) {
        this.buffer = buffer_1.Buffer.alloc(Binary2.BUFFER_SIZE);
        this.position = 0;
      } else {
        if (typeof buffer === 'string') {
          this.buffer = buffer_1.Buffer.from(buffer, 'binary');
        } else if (Array.isArray(buffer)) {
          this.buffer = buffer_1.Buffer.from(buffer);
        } else {
          this.buffer = ensure_buffer_1.ensureBuffer(buffer);
        }
        this.position = this.buffer.byteLength;
      }
    }
    Binary2.prototype.put = function (byteValue) {
      if (typeof byteValue === 'string' && byteValue.length !== 1) {
        throw new TypeError('only accepts single character String');
      } else if (typeof byteValue !== 'number' && byteValue.length !== 1)
        throw new TypeError(
          'only accepts single character Uint8Array or Array',
        );
      var decodedByte;
      if (typeof byteValue === 'string') {
        decodedByte = byteValue.charCodeAt(0);
      } else if (typeof byteValue === 'number') {
        decodedByte = byteValue;
      } else {
        decodedByte = byteValue[0];
      }
      if (decodedByte < 0 || decodedByte > 255) {
        throw new TypeError(
          'only accepts number in a valid unsigned byte range 0-255',
        );
      }
      if (this.buffer.length > this.position) {
        this.buffer[this.position++] = decodedByte;
      } else {
        var buffer = buffer_1.Buffer.alloc(
          Binary2.BUFFER_SIZE + this.buffer.length,
        );
        this.buffer.copy(buffer, 0, 0, this.buffer.length);
        this.buffer = buffer;
        this.buffer[this.position++] = decodedByte;
      }
    };
    Binary2.prototype.write = function (sequence, offset) {
      offset = typeof offset === 'number' ? offset : this.position;
      if (this.buffer.length < offset + sequence.length) {
        var buffer = buffer_1.Buffer.alloc(
          this.buffer.length + sequence.length,
        );
        this.buffer.copy(buffer, 0, 0, this.buffer.length);
        this.buffer = buffer;
      }
      if (ArrayBuffer.isView(sequence)) {
        this.buffer.set(ensure_buffer_1.ensureBuffer(sequence), offset);
        this.position =
          offset + sequence.byteLength > this.position
            ? offset + sequence.length
            : this.position;
      } else if (typeof sequence === 'string') {
        this.buffer.write(sequence, offset, sequence.length, 'binary');
        this.position =
          offset + sequence.length > this.position
            ? offset + sequence.length
            : this.position;
      }
    };
    Binary2.prototype.read = function (position, length) {
      length = length && length > 0 ? length : this.position;
      return this.buffer.slice(position, position + length);
    };
    Binary2.prototype.value = function (asRaw) {
      asRaw = !!asRaw;
      if (asRaw && this.buffer.length === this.position) {
        return this.buffer;
      }
      if (asRaw) {
        return this.buffer.slice(0, this.position);
      }
      return this.buffer.toString('binary', 0, this.position);
    };
    Binary2.prototype.length = function () {
      return this.position;
    };
    Binary2.prototype.toJSON = function () {
      return this.buffer.toString('base64');
    };
    Binary2.prototype.toString = function (format) {
      return this.buffer.toString(format);
    };
    Binary2.prototype.toExtendedJSON = function (options) {
      options = options || {};
      var base64String = this.buffer.toString('base64');
      var subType = Number(this.sub_type).toString(16);
      if (options.legacy) {
        return {
          $binary: base64String,
          $type: subType.length === 1 ? '0' + subType : subType,
        };
      }
      return {
        $binary: {
          base64: base64String,
          subType: subType.length === 1 ? '0' + subType : subType,
        },
      };
    };
    Binary2.fromExtendedJSON = function (doc, options) {
      options = options || {};
      var data;
      var type;
      if ('$binary' in doc) {
        if (
          options.legacy &&
          typeof doc.$binary === 'string' &&
          '$type' in doc
        ) {
          type = doc.$type ? parseInt(doc.$type, 16) : 0;
          data = buffer_1.Buffer.from(doc.$binary, 'base64');
        } else {
          if (typeof doc.$binary !== 'string') {
            type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;
            data = buffer_1.Buffer.from(doc.$binary.base64, 'base64');
          }
        }
      } else if ('$uuid' in doc) {
        type = 4;
        data = buffer_1.Buffer.from(uuid_1.parseUUID(doc.$uuid));
      }
      if (!data) {
        throw new TypeError(
          'Unexpected Binary Extended JSON format ' + JSON.stringify(doc),
        );
      }
      return new Binary2(data, type);
    };
    Binary2.prototype[Symbol.for('nodejs.util.inspect.custom')] = function () {
      return this.inspect();
    };
    Binary2.prototype.inspect = function () {
      var asBuffer = this.value(true);
      return (
        'new Binary(Buffer.from("' +
        asBuffer.toString('hex') +
        '", "hex"), ' +
        this.sub_type +
        ')'
      );
    };
    Binary2.BSON_BINARY_SUBTYPE_DEFAULT = 0;
    Binary2.BUFFER_SIZE = 256;
    Binary2.SUBTYPE_DEFAULT = 0;
    Binary2.SUBTYPE_FUNCTION = 1;
    Binary2.SUBTYPE_BYTE_ARRAY = 2;
    Binary2.SUBTYPE_UUID_OLD = 3;
    Binary2.SUBTYPE_UUID = 4;
    Binary2.SUBTYPE_MD5 = 5;
    Binary2.SUBTYPE_USER_DEFINED = 128;
    return Binary2;
  })();
  exports2.Binary = Binary;
  Object.defineProperty(Binary.prototype, '_bsontype', { value: 'Binary' });
});

// node_modules/@cloudbase/node-sdk/node_modules/bson/lib/code.js
var require_code2 = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  exports2.Code = void 0;
  var Code = (function () {
    function Code2(code, scope) {
      if (!(this instanceof Code2)) return new Code2(code, scope);
      this.code = code;
      this.scope = scope;
    }
    Code2.prototype.toJSON = function () {
      return { code: this.code, scope: this.scope };
    };
    Code2.prototype.toExtendedJSON = function () {
      if (this.scope) {
        return { $code: this.code, $scope: this.scope };
      }
      return { $code: this.code };
    };
    Code2.fromExtendedJSON = function (doc) {
      return new Code2(doc.$code, doc.$scope);
    };
    Code2.prototype[Symbol.for('nodejs.util.inspect.custom')] = function () {
      return this.inspect();
    };
    Code2.prototype.inspect = function () {
      var codeJson = this.toJSON();
      return (
        'new Code("' +
        codeJson.code +
        '"' +
        (codeJson.scope ? ', ' + JSON.stringify(codeJson.scope) : '') +
        ')'
      );
    };
    return Code2;
  })();
  exports2.Code = Code;
  Object.defineProperty(Code.prototype, '_bsontype', { value: 'Code' });
});

// node_modules/@cloudbase/node-sdk/node_modules/bson/lib/db_ref.js
var require_db_ref = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  exports2.DBRef = exports2.isDBRefLike = void 0;
  var utils_1 = require_utils();
  function isDBRefLike(value) {
    return (
      utils_1.isObjectLike(value) &&
      value['$id'] != null &&
      value['$ref'] != null
    );
  }
  exports2.isDBRefLike = isDBRefLike;
  var DBRef = (function () {
    function DBRef2(collection, oid, db2, fields) {
      if (!(this instanceof DBRef2))
        return new DBRef2(collection, oid, db2, fields);
      var parts = collection.split('.');
      if (parts.length === 2) {
        db2 = parts.shift();
        collection = parts.shift();
      }
      this.collection = collection;
      this.oid = oid;
      this.db = db2;
      this.fields = fields || {};
    }
    Object.defineProperty(DBRef2.prototype, 'namespace', {
      get: function () {
        return this.collection;
      },
      set: function (value) {
        this.collection = value;
      },
      enumerable: false,
      configurable: true,
    });
    DBRef2.prototype.toJSON = function () {
      var o = Object.assign(
        {
          $ref: this.collection,
          $id: this.oid,
        },
        this.fields,
      );
      if (this.db != null) o.$db = this.db;
      return o;
    };
    DBRef2.prototype.toExtendedJSON = function (options) {
      options = options || {};
      var o = {
        $ref: this.collection,
        $id: this.oid,
      };
      if (options.legacy) {
        return o;
      }
      if (this.db) o.$db = this.db;
      o = Object.assign(o, this.fields);
      return o;
    };
    DBRef2.fromExtendedJSON = function (doc) {
      var copy = Object.assign({}, doc);
      delete copy.$ref;
      delete copy.$id;
      delete copy.$db;
      return new DBRef2(doc.$ref, doc.$id, doc.$db, copy);
    };
    DBRef2.prototype[Symbol.for('nodejs.util.inspect.custom')] = function () {
      return this.inspect();
    };
    DBRef2.prototype.inspect = function () {
      var oid =
        this.oid === void 0 || this.oid.toString === void 0
          ? this.oid
          : this.oid.toString();
      return (
        'new DBRef("' +
        this.namespace +
        '", new ObjectId("' +
        oid +
        '")' +
        (this.db ? ', "' + this.db + '"' : '') +
        ')'
      );
    };
    return DBRef2;
  })();
  exports2.DBRef = DBRef;
  Object.defineProperty(DBRef.prototype, '_bsontype', { value: 'DBRef' });
});

// node_modules/@cloudbase/node-sdk/node_modules/bson/lib/long.js
var require_long = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  exports2.Long = void 0;
  var utils_1 = require_utils();
  var wasm = void 0;
  try {
    wasm = new WebAssembly.Instance(
      new WebAssembly.Module(
        new Uint8Array([
          0,
          97,
          115,
          109,
          1,
          0,
          0,
          0,
          1,
          13,
          2,
          96,
          0,
          1,
          127,
          96,
          4,
          127,
          127,
          127,
          127,
          1,
          127,
          3,
          7,
          6,
          0,
          1,
          1,
          1,
          1,
          1,
          6,
          6,
          1,
          127,
          1,
          65,
          0,
          11,
          7,
          50,
          6,
          3,
          109,
          117,
          108,
          0,
          1,
          5,
          100,
          105,
          118,
          95,
          115,
          0,
          2,
          5,
          100,
          105,
          118,
          95,
          117,
          0,
          3,
          5,
          114,
          101,
          109,
          95,
          115,
          0,
          4,
          5,
          114,
          101,
          109,
          95,
          117,
          0,
          5,
          8,
          103,
          101,
          116,
          95,
          104,
          105,
          103,
          104,
          0,
          0,
          10,
          191,
          1,
          6,
          4,
          0,
          35,
          0,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          126,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          127,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          128,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          129,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          130,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
        ]),
      ),
      {},
    ).exports;
  } catch (_a) {}
  var TWO_PWR_16_DBL = 1 << 16;
  var TWO_PWR_24_DBL = 1 << 24;
  var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
  var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
  var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
  var INT_CACHE = {};
  var UINT_CACHE = {};
  var Long = (function () {
    function Long2(low, high, unsigned) {
      if (low === void 0) {
        low = 0;
      }
      if (high === void 0) {
        high = 0;
      }
      if (!(this instanceof Long2)) return new Long2(low, high, unsigned);
      this.low = low | 0;
      this.high = high | 0;
      this.unsigned = !!unsigned;
      Object.defineProperty(this, '__isLong__', {
        value: true,
        configurable: false,
        writable: false,
        enumerable: false,
      });
    }
    Long2.fromBits = function (lowBits, highBits, unsigned) {
      return new Long2(lowBits, highBits, unsigned);
    };
    Long2.fromInt = function (value, unsigned) {
      var obj, cachedObj, cache;
      if (unsigned) {
        value >>>= 0;
        if ((cache = 0 <= value && value < 256)) {
          cachedObj = UINT_CACHE[value];
          if (cachedObj) return cachedObj;
        }
        obj = Long2.fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache) UINT_CACHE[value] = obj;
        return obj;
      } else {
        value |= 0;
        if ((cache = -128 <= value && value < 128)) {
          cachedObj = INT_CACHE[value];
          if (cachedObj) return cachedObj;
        }
        obj = Long2.fromBits(value, value < 0 ? -1 : 0, false);
        if (cache) INT_CACHE[value] = obj;
        return obj;
      }
    };
    Long2.fromNumber = function (value, unsigned) {
      if (isNaN(value)) return unsigned ? Long2.UZERO : Long2.ZERO;
      if (unsigned) {
        if (value < 0) return Long2.UZERO;
        if (value >= TWO_PWR_64_DBL) return Long2.MAX_UNSIGNED_VALUE;
      } else {
        if (value <= -TWO_PWR_63_DBL) return Long2.MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL) return Long2.MAX_VALUE;
      }
      if (value < 0) return Long2.fromNumber(-value, unsigned).neg();
      return Long2.fromBits(
        value % TWO_PWR_32_DBL | 0,
        (value / TWO_PWR_32_DBL) | 0,
        unsigned,
      );
    };
    Long2.fromBigInt = function (value, unsigned) {
      return Long2.fromString(value.toString(), unsigned);
    };
    Long2.fromString = function (str, unsigned, radix) {
      if (str.length === 0) throw Error('empty string');
      if (
        str === 'NaN' ||
        str === 'Infinity' ||
        str === '+Infinity' ||
        str === '-Infinity'
      )
        return Long2.ZERO;
      if (typeof unsigned === 'number') {
        (radix = unsigned), (unsigned = false);
      } else {
        unsigned = !!unsigned;
      }
      radix = radix || 10;
      if (radix < 2 || 36 < radix) throw RangeError('radix');
      var p;
      if ((p = str.indexOf('-')) > 0) throw Error('interior hyphen');
      else if (p === 0) {
        return Long2.fromString(str.substring(1), unsigned, radix).neg();
      }
      var radixToPower = Long2.fromNumber(Math.pow(radix, 8));
      var result = Long2.ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
          value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = Long2.fromNumber(Math.pow(radix, size));
          result = result.mul(power).add(Long2.fromNumber(value));
        } else {
          result = result.mul(radixToPower);
          result = result.add(Long2.fromNumber(value));
        }
      }
      result.unsigned = unsigned;
      return result;
    };
    Long2.fromBytes = function (bytes, unsigned, le) {
      return le
        ? Long2.fromBytesLE(bytes, unsigned)
        : Long2.fromBytesBE(bytes, unsigned);
    };
    Long2.fromBytesLE = function (bytes, unsigned) {
      return new Long2(
        bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24),
        bytes[4] | (bytes[5] << 8) | (bytes[6] << 16) | (bytes[7] << 24),
        unsigned,
      );
    };
    Long2.fromBytesBE = function (bytes, unsigned) {
      return new Long2(
        (bytes[4] << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7],
        (bytes[0] << 24) | (bytes[1] << 16) | (bytes[2] << 8) | bytes[3],
        unsigned,
      );
    };
    Long2.isLong = function (value) {
      return utils_1.isObjectLike(value) && value['__isLong__'] === true;
    };
    Long2.fromValue = function (val, unsigned) {
      if (typeof val === 'number') return Long2.fromNumber(val, unsigned);
      if (typeof val === 'string') return Long2.fromString(val, unsigned);
      return Long2.fromBits(
        val.low,
        val.high,
        typeof unsigned === 'boolean' ? unsigned : val.unsigned,
      );
    };
    Long2.prototype.add = function (addend) {
      if (!Long2.isLong(addend)) addend = Long2.fromValue(addend);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 65535;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 65535;
      var c48 = 0,
        c32 = 0,
        c16 = 0,
        c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return Long2.fromBits(
        (c16 << 16) | c00,
        (c48 << 16) | c32,
        this.unsigned,
      );
    };
    Long2.prototype.and = function (other) {
      if (!Long2.isLong(other)) other = Long2.fromValue(other);
      return Long2.fromBits(
        this.low & other.low,
        this.high & other.high,
        this.unsigned,
      );
    };
    Long2.prototype.compare = function (other) {
      if (!Long2.isLong(other)) other = Long2.fromValue(other);
      if (this.eq(other)) return 0;
      var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
      if (thisNeg && !otherNeg) return -1;
      if (!thisNeg && otherNeg) return 1;
      if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 ||
        (other.high === this.high && other.low >>> 0 > this.low >>> 0)
        ? -1
        : 1;
    };
    Long2.prototype.comp = function (other) {
      return this.compare(other);
    };
    Long2.prototype.divide = function (divisor) {
      if (!Long2.isLong(divisor)) divisor = Long2.fromValue(divisor);
      if (divisor.isZero()) throw Error('division by zero');
      if (wasm) {
        if (
          !this.unsigned &&
          this.high === -2147483648 &&
          divisor.low === -1 &&
          divisor.high === -1
        ) {
          return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
          this.low,
          this.high,
          divisor.low,
          divisor.high,
        );
        return Long2.fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (this.isZero()) return this.unsigned ? Long2.UZERO : Long2.ZERO;
      var approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(Long2.MIN_VALUE)) {
          if (divisor.eq(Long2.ONE) || divisor.eq(Long2.NEG_ONE))
            return Long2.MIN_VALUE;
          else if (divisor.eq(Long2.MIN_VALUE)) return Long2.ONE;
          else {
            var halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(Long2.ZERO)) {
              return divisor.isNegative() ? Long2.ONE : Long2.NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(Long2.MIN_VALUE))
          return this.unsigned ? Long2.UZERO : Long2.ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative()) return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
        res = Long2.ZERO;
      } else {
        if (!divisor.unsigned) divisor = divisor.toUnsigned();
        if (divisor.gt(this)) return Long2.UZERO;
        if (divisor.gt(this.shru(1))) return Long2.UONE;
        res = Long2.UZERO;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2);
        var delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);
        var approxRes = Long2.fromNumber(approx);
        var approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = Long2.fromNumber(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero()) approxRes = Long2.ONE;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    };
    Long2.prototype.div = function (divisor) {
      return this.divide(divisor);
    };
    Long2.prototype.equals = function (other) {
      if (!Long2.isLong(other)) other = Long2.fromValue(other);
      if (
        this.unsigned !== other.unsigned &&
        this.high >>> 31 === 1 &&
        other.high >>> 31 === 1
      )
        return false;
      return this.high === other.high && this.low === other.low;
    };
    Long2.prototype.eq = function (other) {
      return this.equals(other);
    };
    Long2.prototype.getHighBits = function () {
      return this.high;
    };
    Long2.prototype.getHighBitsUnsigned = function () {
      return this.high >>> 0;
    };
    Long2.prototype.getLowBits = function () {
      return this.low;
    };
    Long2.prototype.getLowBitsUnsigned = function () {
      return this.low >>> 0;
    };
    Long2.prototype.getNumBitsAbs = function () {
      if (this.isNegative()) {
        return this.eq(Long2.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      }
      var val = this.high !== 0 ? this.high : this.low;
      var bit;
      for (bit = 31; bit > 0; bit--) if ((val & (1 << bit)) !== 0) break;
      return this.high !== 0 ? bit + 33 : bit + 1;
    };
    Long2.prototype.greaterThan = function (other) {
      return this.comp(other) > 0;
    };
    Long2.prototype.gt = function (other) {
      return this.greaterThan(other);
    };
    Long2.prototype.greaterThanOrEqual = function (other) {
      return this.comp(other) >= 0;
    };
    Long2.prototype.gte = function (other) {
      return this.greaterThanOrEqual(other);
    };
    Long2.prototype.ge = function (other) {
      return this.greaterThanOrEqual(other);
    };
    Long2.prototype.isEven = function () {
      return (this.low & 1) === 0;
    };
    Long2.prototype.isNegative = function () {
      return !this.unsigned && this.high < 0;
    };
    Long2.prototype.isOdd = function () {
      return (this.low & 1) === 1;
    };
    Long2.prototype.isPositive = function () {
      return this.unsigned || this.high >= 0;
    };
    Long2.prototype.isZero = function () {
      return this.high === 0 && this.low === 0;
    };
    Long2.prototype.lessThan = function (other) {
      return this.comp(other) < 0;
    };
    Long2.prototype.lt = function (other) {
      return this.lessThan(other);
    };
    Long2.prototype.lessThanOrEqual = function (other) {
      return this.comp(other) <= 0;
    };
    Long2.prototype.lte = function (other) {
      return this.lessThanOrEqual(other);
    };
    Long2.prototype.modulo = function (divisor) {
      if (!Long2.isLong(divisor)) divisor = Long2.fromValue(divisor);
      if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
          this.low,
          this.high,
          divisor.low,
          divisor.high,
        );
        return Long2.fromBits(low, wasm.get_high(), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    };
    Long2.prototype.mod = function (divisor) {
      return this.modulo(divisor);
    };
    Long2.prototype.rem = function (divisor) {
      return this.modulo(divisor);
    };
    Long2.prototype.multiply = function (multiplier) {
      if (this.isZero()) return Long2.ZERO;
      if (!Long2.isLong(multiplier)) multiplier = Long2.fromValue(multiplier);
      if (wasm) {
        var low = wasm.mul(
          this.low,
          this.high,
          multiplier.low,
          multiplier.high,
        );
        return Long2.fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (multiplier.isZero()) return Long2.ZERO;
      if (this.eq(Long2.MIN_VALUE))
        return multiplier.isOdd() ? Long2.MIN_VALUE : Long2.ZERO;
      if (multiplier.eq(Long2.MIN_VALUE))
        return this.isOdd() ? Long2.MIN_VALUE : Long2.ZERO;
      if (this.isNegative()) {
        if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());
        else return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();
      if (this.lt(Long2.TWO_PWR_24) && multiplier.lt(Long2.TWO_PWR_24))
        return Long2.fromNumber(
          this.toNumber() * multiplier.toNumber(),
          this.unsigned,
        );
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 65535;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 65535;
      var c48 = 0,
        c32 = 0,
        c16 = 0,
        c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return Long2.fromBits(
        (c16 << 16) | c00,
        (c48 << 16) | c32,
        this.unsigned,
      );
    };
    Long2.prototype.mul = function (multiplier) {
      return this.multiply(multiplier);
    };
    Long2.prototype.negate = function () {
      if (!this.unsigned && this.eq(Long2.MIN_VALUE)) return Long2.MIN_VALUE;
      return this.not().add(Long2.ONE);
    };
    Long2.prototype.neg = function () {
      return this.negate();
    };
    Long2.prototype.not = function () {
      return Long2.fromBits(~this.low, ~this.high, this.unsigned);
    };
    Long2.prototype.notEquals = function (other) {
      return !this.equals(other);
    };
    Long2.prototype.neq = function (other) {
      return this.notEquals(other);
    };
    Long2.prototype.ne = function (other) {
      return this.notEquals(other);
    };
    Long2.prototype.or = function (other) {
      if (!Long2.isLong(other)) other = Long2.fromValue(other);
      return Long2.fromBits(
        this.low | other.low,
        this.high | other.high,
        this.unsigned,
      );
    };
    Long2.prototype.shiftLeft = function (numBits) {
      if (Long2.isLong(numBits)) numBits = numBits.toInt();
      if ((numBits &= 63) === 0) return this;
      else if (numBits < 32)
        return Long2.fromBits(
          this.low << numBits,
          (this.high << numBits) | (this.low >>> (32 - numBits)),
          this.unsigned,
        );
      else return Long2.fromBits(0, this.low << (numBits - 32), this.unsigned);
    };
    Long2.prototype.shl = function (numBits) {
      return this.shiftLeft(numBits);
    };
    Long2.prototype.shiftRight = function (numBits) {
      if (Long2.isLong(numBits)) numBits = numBits.toInt();
      if ((numBits &= 63) === 0) return this;
      else if (numBits < 32)
        return Long2.fromBits(
          (this.low >>> numBits) | (this.high << (32 - numBits)),
          this.high >> numBits,
          this.unsigned,
        );
      else
        return Long2.fromBits(
          this.high >> (numBits - 32),
          this.high >= 0 ? 0 : -1,
          this.unsigned,
        );
    };
    Long2.prototype.shr = function (numBits) {
      return this.shiftRight(numBits);
    };
    Long2.prototype.shiftRightUnsigned = function (numBits) {
      if (Long2.isLong(numBits)) numBits = numBits.toInt();
      numBits &= 63;
      if (numBits === 0) return this;
      else {
        var high = this.high;
        if (numBits < 32) {
          var low = this.low;
          return Long2.fromBits(
            (low >>> numBits) | (high << (32 - numBits)),
            high >>> numBits,
            this.unsigned,
          );
        } else if (numBits === 32)
          return Long2.fromBits(high, 0, this.unsigned);
        else return Long2.fromBits(high >>> (numBits - 32), 0, this.unsigned);
      }
    };
    Long2.prototype.shr_u = function (numBits) {
      return this.shiftRightUnsigned(numBits);
    };
    Long2.prototype.shru = function (numBits) {
      return this.shiftRightUnsigned(numBits);
    };
    Long2.prototype.subtract = function (subtrahend) {
      if (!Long2.isLong(subtrahend)) subtrahend = Long2.fromValue(subtrahend);
      return this.add(subtrahend.neg());
    };
    Long2.prototype.sub = function (subtrahend) {
      return this.subtract(subtrahend);
    };
    Long2.prototype.toInt = function () {
      return this.unsigned ? this.low >>> 0 : this.low;
    };
    Long2.prototype.toNumber = function () {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };
    Long2.prototype.toBigInt = function () {
      return BigInt(this.toString());
    };
    Long2.prototype.toBytes = function (le) {
      return le ? this.toBytesLE() : this.toBytesBE();
    };
    Long2.prototype.toBytesLE = function () {
      var hi = this.high,
        lo = this.low;
      return [
        lo & 255,
        (lo >>> 8) & 255,
        (lo >>> 16) & 255,
        lo >>> 24,
        hi & 255,
        (hi >>> 8) & 255,
        (hi >>> 16) & 255,
        hi >>> 24,
      ];
    };
    Long2.prototype.toBytesBE = function () {
      var hi = this.high,
        lo = this.low;
      return [
        hi >>> 24,
        (hi >>> 16) & 255,
        (hi >>> 8) & 255,
        hi & 255,
        lo >>> 24,
        (lo >>> 16) & 255,
        (lo >>> 8) & 255,
        lo & 255,
      ];
    };
    Long2.prototype.toSigned = function () {
      if (!this.unsigned) return this;
      return Long2.fromBits(this.low, this.high, false);
    };
    Long2.prototype.toString = function (radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix) throw RangeError('radix');
      if (this.isZero()) return '0';
      if (this.isNegative()) {
        if (this.eq(Long2.MIN_VALUE)) {
          var radixLong = Long2.fromNumber(radix),
            div = this.div(radixLong),
            rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix) + rem1.toInt().toString(radix);
        } else return '-' + this.neg().toString(radix);
      }
      var radixToPower = Long2.fromNumber(Math.pow(radix, 6), this.unsigned);
      var rem = this;
      var result = '';
      while (true) {
        var remDiv = rem.div(radixToPower);
        var intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0;
        var digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero()) {
          return digits + result;
        } else {
          while (digits.length < 6) digits = '0' + digits;
          result = '' + digits + result;
        }
      }
    };
    Long2.prototype.toUnsigned = function () {
      if (this.unsigned) return this;
      return Long2.fromBits(this.low, this.high, true);
    };
    Long2.prototype.xor = function (other) {
      if (!Long2.isLong(other)) other = Long2.fromValue(other);
      return Long2.fromBits(
        this.low ^ other.low,
        this.high ^ other.high,
        this.unsigned,
      );
    };
    Long2.prototype.eqz = function () {
      return this.isZero();
    };
    Long2.prototype.le = function (other) {
      return this.lessThanOrEqual(other);
    };
    Long2.prototype.toExtendedJSON = function (options) {
      if (options && options.relaxed) return this.toNumber();
      return { $numberLong: this.toString() };
    };
    Long2.fromExtendedJSON = function (doc, options) {
      var result = Long2.fromString(doc.$numberLong);
      return options && options.relaxed ? result.toNumber() : result;
    };
    Long2.prototype[Symbol.for('nodejs.util.inspect.custom')] = function () {
      return this.inspect();
    };
    Long2.prototype.inspect = function () {
      return 'new Long("' + this.toString() + '")';
    };
    Long2.TWO_PWR_24 = Long2.fromInt(TWO_PWR_24_DBL);
    Long2.MAX_UNSIGNED_VALUE = Long2.fromBits(
      4294967295 | 0,
      4294967295 | 0,
      true,
    );
    Long2.ZERO = Long2.fromInt(0);
    Long2.UZERO = Long2.fromInt(0, true);
    Long2.ONE = Long2.fromInt(1);
    Long2.UONE = Long2.fromInt(1, true);
    Long2.NEG_ONE = Long2.fromInt(-1);
    Long2.MAX_VALUE = Long2.fromBits(4294967295 | 0, 2147483647 | 0, false);
    Long2.MIN_VALUE = Long2.fromBits(0, 2147483648 | 0, false);
    return Long2;
  })();
  exports2.Long = Long;
  Object.defineProperty(Long.prototype, '__isLong__', { value: true });
  Object.defineProperty(Long.prototype, '_bsontype', { value: 'Long' });
});

// node_modules/@cloudbase/node-sdk/node_modules/bson/lib/decimal128.js
var require_decimal128 = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  exports2.Decimal128 = void 0;
  var buffer_1 = require('buffer');
  var long_1 = require_long();
  var PARSE_STRING_REGEXP = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/;
  var PARSE_INF_REGEXP = /^(\+|-)?(Infinity|inf)$/i;
  var PARSE_NAN_REGEXP = /^(\+|-)?NaN$/i;
  var EXPONENT_MAX = 6111;
  var EXPONENT_MIN = -6176;
  var EXPONENT_BIAS = 6176;
  var MAX_DIGITS = 34;
  var NAN_BUFFER = [124, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0].reverse();
  var INF_NEGATIVE_BUFFER = [
    248,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
  ].reverse();
  var INF_POSITIVE_BUFFER = [
    120,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
  ].reverse();
  var EXPONENT_REGEX = /^([-+])?(\d+)?$/;
  var COMBINATION_MASK = 31;
  var EXPONENT_MASK = 16383;
  var COMBINATION_INFINITY = 30;
  var COMBINATION_NAN = 31;
  function isDigit(value) {
    return !isNaN(parseInt(value, 10));
  }
  function divideu128(value) {
    var DIVISOR = long_1.Long.fromNumber(1e3 * 1e3 * 1e3);
    var _rem = long_1.Long.fromNumber(0);
    if (
      !value.parts[0] &&
      !value.parts[1] &&
      !value.parts[2] &&
      !value.parts[3]
    ) {
      return { quotient: value, rem: _rem };
    }
    for (var i = 0; i <= 3; i++) {
      _rem = _rem.shiftLeft(32);
      _rem = _rem.add(new long_1.Long(value.parts[i], 0));
      value.parts[i] = _rem.div(DIVISOR).low;
      _rem = _rem.modulo(DIVISOR);
    }
    return { quotient: value, rem: _rem };
  }
  function multiply64x2(left, right) {
    if (!left && !right) {
      return {
        high: long_1.Long.fromNumber(0),
        low: long_1.Long.fromNumber(0),
      };
    }
    var leftHigh = left.shiftRightUnsigned(32);
    var leftLow = new long_1.Long(left.getLowBits(), 0);
    var rightHigh = right.shiftRightUnsigned(32);
    var rightLow = new long_1.Long(right.getLowBits(), 0);
    var productHigh = leftHigh.multiply(rightHigh);
    var productMid = leftHigh.multiply(rightLow);
    var productMid2 = leftLow.multiply(rightHigh);
    var productLow = leftLow.multiply(rightLow);
    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
    productMid = new long_1.Long(productMid.getLowBits(), 0)
      .add(productMid2)
      .add(productLow.shiftRightUnsigned(32));
    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
    productLow = productMid
      .shiftLeft(32)
      .add(new long_1.Long(productLow.getLowBits(), 0));
    return { high: productHigh, low: productLow };
  }
  function lessThan(left, right) {
    var uhleft = left.high >>> 0;
    var uhright = right.high >>> 0;
    if (uhleft < uhright) {
      return true;
    } else if (uhleft === uhright) {
      var ulleft = left.low >>> 0;
      var ulright = right.low >>> 0;
      if (ulleft < ulright) return true;
    }
    return false;
  }
  function invalidErr(string, message) {
    throw new TypeError(
      '"' + string + '" is not a valid Decimal128 string - ' + message,
    );
  }
  var Decimal128 = (function () {
    function Decimal1282(bytes) {
      if (!(this instanceof Decimal1282)) return new Decimal1282(bytes);
      this.bytes = bytes;
    }
    Decimal1282.fromString = function (representation) {
      var isNegative = false;
      var sawRadix = false;
      var foundNonZero = false;
      var significantDigits = 0;
      var nDigitsRead = 0;
      var nDigits = 0;
      var radixPosition = 0;
      var firstNonZero = 0;
      var digits = [0];
      var nDigitsStored = 0;
      var digitsInsert = 0;
      var firstDigit = 0;
      var lastDigit = 0;
      var exponent = 0;
      var i = 0;
      var significandHigh = new long_1.Long(0, 0);
      var significandLow = new long_1.Long(0, 0);
      var biasedExponent = 0;
      var index = 0;
      if (representation.length >= 7e3) {
        throw new TypeError(
          '' + representation + ' not a valid Decimal128 string',
        );
      }
      var stringMatch = representation.match(PARSE_STRING_REGEXP);
      var infMatch = representation.match(PARSE_INF_REGEXP);
      var nanMatch = representation.match(PARSE_NAN_REGEXP);
      if (
        (!stringMatch && !infMatch && !nanMatch) ||
        representation.length === 0
      ) {
        throw new TypeError(
          '' + representation + ' not a valid Decimal128 string',
        );
      }
      if (stringMatch) {
        var unsignedNumber = stringMatch[2];
        var e = stringMatch[4];
        var expSign = stringMatch[5];
        var expNumber = stringMatch[6];
        if (e && expNumber === void 0)
          invalidErr(representation, 'missing exponent power');
        if (e && unsignedNumber === void 0)
          invalidErr(representation, 'missing exponent base');
        if (e === void 0 && (expSign || expNumber)) {
          invalidErr(representation, 'missing e before exponent');
        }
      }
      if (representation[index] === '+' || representation[index] === '-') {
        isNegative = representation[index++] === '-';
      }
      if (!isDigit(representation[index]) && representation[index] !== '.') {
        if (representation[index] === 'i' || representation[index] === 'I') {
          return new Decimal1282(
            buffer_1.Buffer.from(
              isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER,
            ),
          );
        } else if (representation[index] === 'N') {
          return new Decimal1282(buffer_1.Buffer.from(NAN_BUFFER));
        }
      }
      while (isDigit(representation[index]) || representation[index] === '.') {
        if (representation[index] === '.') {
          if (sawRadix) invalidErr(representation, 'contains multiple periods');
          sawRadix = true;
          index = index + 1;
          continue;
        }
        if (nDigitsStored < 34) {
          if (representation[index] !== '0' || foundNonZero) {
            if (!foundNonZero) {
              firstNonZero = nDigitsRead;
            }
            foundNonZero = true;
            digits[digitsInsert++] = parseInt(representation[index], 10);
            nDigitsStored = nDigitsStored + 1;
          }
        }
        if (foundNonZero) nDigits = nDigits + 1;
        if (sawRadix) radixPosition = radixPosition + 1;
        nDigitsRead = nDigitsRead + 1;
        index = index + 1;
      }
      if (sawRadix && !nDigitsRead)
        throw new TypeError(
          '' + representation + ' not a valid Decimal128 string',
        );
      if (representation[index] === 'e' || representation[index] === 'E') {
        var match = representation.substr(++index).match(EXPONENT_REGEX);
        if (!match || !match[2])
          return new Decimal1282(buffer_1.Buffer.from(NAN_BUFFER));
        exponent = parseInt(match[0], 10);
        index = index + match[0].length;
      }
      if (representation[index])
        return new Decimal1282(buffer_1.Buffer.from(NAN_BUFFER));
      firstDigit = 0;
      if (!nDigitsStored) {
        firstDigit = 0;
        lastDigit = 0;
        digits[0] = 0;
        nDigits = 1;
        nDigitsStored = 1;
        significantDigits = 0;
      } else {
        lastDigit = nDigitsStored - 1;
        significantDigits = nDigits;
        if (significantDigits !== 1) {
          while (representation[firstNonZero + significantDigits - 1] === '0') {
            significantDigits = significantDigits - 1;
          }
        }
      }
      if (exponent <= radixPosition && radixPosition - exponent > 1 << 14) {
        exponent = EXPONENT_MIN;
      } else {
        exponent = exponent - radixPosition;
      }
      while (exponent > EXPONENT_MAX) {
        lastDigit = lastDigit + 1;
        if (lastDigit - firstDigit > MAX_DIGITS) {
          var digitsString = digits.join('');
          if (digitsString.match(/^0+$/)) {
            exponent = EXPONENT_MAX;
            break;
          }
          invalidErr(representation, 'overflow');
        }
        exponent = exponent - 1;
      }
      while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
        if (lastDigit === 0 && significantDigits < nDigitsStored) {
          exponent = EXPONENT_MIN;
          significantDigits = 0;
          break;
        }
        if (nDigitsStored < nDigits) {
          nDigits = nDigits - 1;
        } else {
          lastDigit = lastDigit - 1;
        }
        if (exponent < EXPONENT_MAX) {
          exponent = exponent + 1;
        } else {
          var digitsString = digits.join('');
          if (digitsString.match(/^0+$/)) {
            exponent = EXPONENT_MAX;
            break;
          }
          invalidErr(representation, 'overflow');
        }
      }
      if (lastDigit - firstDigit + 1 < significantDigits) {
        var endOfString = nDigitsRead;
        if (sawRadix) {
          firstNonZero = firstNonZero + 1;
          endOfString = endOfString + 1;
        }
        if (isNegative) {
          firstNonZero = firstNonZero + 1;
          endOfString = endOfString + 1;
        }
        var roundDigit = parseInt(
          representation[firstNonZero + lastDigit + 1],
          10,
        );
        var roundBit = 0;
        if (roundDigit >= 5) {
          roundBit = 1;
          if (roundDigit === 5) {
            roundBit = digits[lastDigit] % 2 === 1 ? 1 : 0;
            for (i = firstNonZero + lastDigit + 2; i < endOfString; i++) {
              if (parseInt(representation[i], 10)) {
                roundBit = 1;
                break;
              }
            }
          }
        }
        if (roundBit) {
          var dIdx = lastDigit;
          for (; dIdx >= 0; dIdx--) {
            if (++digits[dIdx] > 9) {
              digits[dIdx] = 0;
              if (dIdx === 0) {
                if (exponent < EXPONENT_MAX) {
                  exponent = exponent + 1;
                  digits[dIdx] = 1;
                } else {
                  return new Decimal1282(
                    buffer_1.Buffer.from(
                      isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER,
                    ),
                  );
                }
              }
            }
          }
        }
      }
      significandHigh = long_1.Long.fromNumber(0);
      significandLow = long_1.Long.fromNumber(0);
      if (significantDigits === 0) {
        significandHigh = long_1.Long.fromNumber(0);
        significandLow = long_1.Long.fromNumber(0);
      } else if (lastDigit - firstDigit < 17) {
        var dIdx = firstDigit;
        significandLow = long_1.Long.fromNumber(digits[dIdx++]);
        significandHigh = new long_1.Long(0, 0);
        for (; dIdx <= lastDigit; dIdx++) {
          significandLow = significandLow.multiply(long_1.Long.fromNumber(10));
          significandLow = significandLow.add(
            long_1.Long.fromNumber(digits[dIdx]),
          );
        }
      } else {
        var dIdx = firstDigit;
        significandHigh = long_1.Long.fromNumber(digits[dIdx++]);
        for (; dIdx <= lastDigit - 17; dIdx++) {
          significandHigh = significandHigh.multiply(
            long_1.Long.fromNumber(10),
          );
          significandHigh = significandHigh.add(
            long_1.Long.fromNumber(digits[dIdx]),
          );
        }
        significandLow = long_1.Long.fromNumber(digits[dIdx++]);
        for (; dIdx <= lastDigit; dIdx++) {
          significandLow = significandLow.multiply(long_1.Long.fromNumber(10));
          significandLow = significandLow.add(
            long_1.Long.fromNumber(digits[dIdx]),
          );
        }
      }
      var significand = multiply64x2(
        significandHigh,
        long_1.Long.fromString('100000000000000000'),
      );
      significand.low = significand.low.add(significandLow);
      if (lessThan(significand.low, significandLow)) {
        significand.high = significand.high.add(long_1.Long.fromNumber(1));
      }
      biasedExponent = exponent + EXPONENT_BIAS;
      var dec = {
        low: long_1.Long.fromNumber(0),
        high: long_1.Long.fromNumber(0),
      };
      if (
        significand.high
          .shiftRightUnsigned(49)
          .and(long_1.Long.fromNumber(1))
          .equals(long_1.Long.fromNumber(1))
      ) {
        dec.high = dec.high.or(long_1.Long.fromNumber(3).shiftLeft(61));
        dec.high = dec.high.or(
          long_1.Long.fromNumber(biasedExponent).and(
            long_1.Long.fromNumber(16383).shiftLeft(47),
          ),
        );
        dec.high = dec.high.or(
          significand.high.and(long_1.Long.fromNumber(140737488355327)),
        );
      } else {
        dec.high = dec.high.or(
          long_1.Long.fromNumber(biasedExponent & 16383).shiftLeft(49),
        );
        dec.high = dec.high.or(
          significand.high.and(long_1.Long.fromNumber(562949953421311)),
        );
      }
      dec.low = significand.low;
      if (isNegative) {
        dec.high = dec.high.or(long_1.Long.fromString('9223372036854775808'));
      }
      var buffer = buffer_1.Buffer.alloc(16);
      index = 0;
      buffer[index++] = dec.low.low & 255;
      buffer[index++] = (dec.low.low >> 8) & 255;
      buffer[index++] = (dec.low.low >> 16) & 255;
      buffer[index++] = (dec.low.low >> 24) & 255;
      buffer[index++] = dec.low.high & 255;
      buffer[index++] = (dec.low.high >> 8) & 255;
      buffer[index++] = (dec.low.high >> 16) & 255;
      buffer[index++] = (dec.low.high >> 24) & 255;
      buffer[index++] = dec.high.low & 255;
      buffer[index++] = (dec.high.low >> 8) & 255;
      buffer[index++] = (dec.high.low >> 16) & 255;
      buffer[index++] = (dec.high.low >> 24) & 255;
      buffer[index++] = dec.high.high & 255;
      buffer[index++] = (dec.high.high >> 8) & 255;
      buffer[index++] = (dec.high.high >> 16) & 255;
      buffer[index++] = (dec.high.high >> 24) & 255;
      return new Decimal1282(buffer);
    };
    Decimal1282.prototype.toString = function () {
      var biased_exponent;
      var significand_digits = 0;
      var significand = new Array(36);
      for (var i = 0; i < significand.length; i++) significand[i] = 0;
      var index = 0;
      var is_zero = false;
      var significand_msb;
      var significand128 = { parts: [0, 0, 0, 0] };
      var j, k;
      var string = [];
      index = 0;
      var buffer = this.bytes;
      var low =
        buffer[index++] |
        (buffer[index++] << 8) |
        (buffer[index++] << 16) |
        (buffer[index++] << 24);
      var midl =
        buffer[index++] |
        (buffer[index++] << 8) |
        (buffer[index++] << 16) |
        (buffer[index++] << 24);
      var midh =
        buffer[index++] |
        (buffer[index++] << 8) |
        (buffer[index++] << 16) |
        (buffer[index++] << 24);
      var high =
        buffer[index++] |
        (buffer[index++] << 8) |
        (buffer[index++] << 16) |
        (buffer[index++] << 24);
      index = 0;
      var dec = {
        low: new long_1.Long(low, midl),
        high: new long_1.Long(midh, high),
      };
      if (dec.high.lessThan(long_1.Long.ZERO)) {
        string.push('-');
      }
      var combination = (high >> 26) & COMBINATION_MASK;
      if (combination >> 3 === 3) {
        if (combination === COMBINATION_INFINITY) {
          return string.join('') + 'Infinity';
        } else if (combination === COMBINATION_NAN) {
          return 'NaN';
        } else {
          biased_exponent = (high >> 15) & EXPONENT_MASK;
          significand_msb = 8 + ((high >> 14) & 1);
        }
      } else {
        significand_msb = (high >> 14) & 7;
        biased_exponent = (high >> 17) & EXPONENT_MASK;
      }
      var exponent = biased_exponent - EXPONENT_BIAS;
      significand128.parts[0] = (high & 16383) + ((significand_msb & 15) << 14);
      significand128.parts[1] = midh;
      significand128.parts[2] = midl;
      significand128.parts[3] = low;
      if (
        significand128.parts[0] === 0 &&
        significand128.parts[1] === 0 &&
        significand128.parts[2] === 0 &&
        significand128.parts[3] === 0
      ) {
        is_zero = true;
      } else {
        for (k = 3; k >= 0; k--) {
          var least_digits = 0;
          var result = divideu128(significand128);
          significand128 = result.quotient;
          least_digits = result.rem.low;
          if (!least_digits) continue;
          for (j = 8; j >= 0; j--) {
            significand[k * 9 + j] = least_digits % 10;
            least_digits = Math.floor(least_digits / 10);
          }
        }
      }
      if (is_zero) {
        significand_digits = 1;
        significand[index] = 0;
      } else {
        significand_digits = 36;
        while (!significand[index]) {
          significand_digits = significand_digits - 1;
          index = index + 1;
        }
      }
      var scientific_exponent = significand_digits - 1 + exponent;
      if (
        scientific_exponent >= 34 ||
        scientific_exponent <= -7 ||
        exponent > 0
      ) {
        if (significand_digits > 34) {
          string.push('' + 0);
          if (exponent > 0) string.push('E+' + exponent);
          else if (exponent < 0) string.push('E' + exponent);
          return string.join('');
        }
        string.push('' + significand[index++]);
        significand_digits = significand_digits - 1;
        if (significand_digits) {
          string.push('.');
        }
        for (var i = 0; i < significand_digits; i++) {
          string.push('' + significand[index++]);
        }
        string.push('E');
        if (scientific_exponent > 0) {
          string.push('+' + scientific_exponent);
        } else {
          string.push('' + scientific_exponent);
        }
      } else {
        if (exponent >= 0) {
          for (var i = 0; i < significand_digits; i++) {
            string.push('' + significand[index++]);
          }
        } else {
          var radix_position = significand_digits + exponent;
          if (radix_position > 0) {
            for (var i = 0; i < radix_position; i++) {
              string.push('' + significand[index++]);
            }
          } else {
            string.push('0');
          }
          string.push('.');
          while (radix_position++ < 0) {
            string.push('0');
          }
          for (
            var i = 0;
            i < significand_digits - Math.max(radix_position - 1, 0);
            i++
          ) {
            string.push('' + significand[index++]);
          }
        }
      }
      return string.join('');
    };
    Decimal1282.prototype.toJSON = function () {
      return { $numberDecimal: this.toString() };
    };
    Decimal1282.prototype.toExtendedJSON = function () {
      return { $numberDecimal: this.toString() };
    };
    Decimal1282.fromExtendedJSON = function (doc) {
      return Decimal1282.fromString(doc.$numberDecimal);
    };
    Decimal1282.prototype[
      Symbol.for('nodejs.util.inspect.custom')
    ] = function () {
      return this.inspect();
    };
    Decimal1282.prototype.inspect = function () {
      return 'Decimal128.fromString("' + this.toString() + '")';
    };
    return Decimal1282;
  })();
  exports2.Decimal128 = Decimal128;
  Object.defineProperty(Decimal128.prototype, '_bsontype', {
    value: 'Decimal128',
  });
});

// node_modules/@cloudbase/node-sdk/node_modules/bson/lib/double.js
var require_double = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  exports2.Double = void 0;
  var Double = (function () {
    function Double2(value) {
      if (!(this instanceof Double2)) return new Double2(value);
      if (value instanceof Number) {
        value = value.valueOf();
      }
      this.value = +value;
    }
    Double2.prototype.valueOf = function () {
      return this.value;
    };
    Double2.prototype.toJSON = function () {
      return this.value;
    };
    Double2.prototype.toExtendedJSON = function (options) {
      if (
        options &&
        (options.legacy || (options.relaxed && isFinite(this.value)))
      ) {
        return this.value;
      }
      if (Object.is(Math.sign(this.value), -0)) {
        return { $numberDouble: '-' + this.value.toFixed(1) };
      }
      var $numberDouble;
      if (Number.isInteger(this.value)) {
        $numberDouble = this.value.toFixed(1);
        if ($numberDouble.length >= 13) {
          $numberDouble = this.value.toExponential(13).toUpperCase();
        }
      } else {
        $numberDouble = this.value.toString();
      }
      return { $numberDouble };
    };
    Double2.fromExtendedJSON = function (doc, options) {
      var doubleValue = parseFloat(doc.$numberDouble);
      return options && options.relaxed
        ? doubleValue
        : new Double2(doubleValue);
    };
    Double2.prototype[Symbol.for('nodejs.util.inspect.custom')] = function () {
      return this.inspect();
    };
    Double2.prototype.inspect = function () {
      var eJSON = this.toExtendedJSON();
      return 'new Double(' + eJSON.$numberDouble + ')';
    };
    return Double2;
  })();
  exports2.Double = Double;
  Object.defineProperty(Double.prototype, '_bsontype', { value: 'Double' });
});

// node_modules/@cloudbase/node-sdk/node_modules/bson/lib/int_32.js
var require_int_32 = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  exports2.Int32 = void 0;
  var Int32 = (function () {
    function Int322(value) {
      if (!(this instanceof Int322)) return new Int322(value);
      if (value instanceof Number) {
        value = value.valueOf();
      }
      this.value = +value;
    }
    Int322.prototype.valueOf = function () {
      return this.value;
    };
    Int322.prototype.toJSON = function () {
      return this.value;
    };
    Int322.prototype.toExtendedJSON = function (options) {
      if (options && (options.relaxed || options.legacy)) return this.value;
      return { $numberInt: this.value.toString() };
    };
    Int322.fromExtendedJSON = function (doc, options) {
      return options && options.relaxed
        ? parseInt(doc.$numberInt, 10)
        : new Int322(doc.$numberInt);
    };
    Int322.prototype[Symbol.for('nodejs.util.inspect.custom')] = function () {
      return this.inspect();
    };
    Int322.prototype.inspect = function () {
      return 'new Int32(' + this.valueOf() + ')';
    };
    return Int322;
  })();
  exports2.Int32 = Int32;
  Object.defineProperty(Int32.prototype, '_bsontype', { value: 'Int32' });
});

// node_modules/@cloudbase/node-sdk/node_modules/bson/lib/max_key.js
var require_max_key = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  exports2.MaxKey = void 0;
  var MaxKey = (function () {
    function MaxKey2() {
      if (!(this instanceof MaxKey2)) return new MaxKey2();
    }
    MaxKey2.prototype.toExtendedJSON = function () {
      return { $maxKey: 1 };
    };
    MaxKey2.fromExtendedJSON = function () {
      return new MaxKey2();
    };
    MaxKey2.prototype[Symbol.for('nodejs.util.inspect.custom')] = function () {
      return this.inspect();
    };
    MaxKey2.prototype.inspect = function () {
      return 'new MaxKey()';
    };
    return MaxKey2;
  })();
  exports2.MaxKey = MaxKey;
  Object.defineProperty(MaxKey.prototype, '_bsontype', { value: 'MaxKey' });
});

// node_modules/@cloudbase/node-sdk/node_modules/bson/lib/min_key.js
var require_min_key = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  exports2.MinKey = void 0;
  var MinKey = (function () {
    function MinKey2() {
      if (!(this instanceof MinKey2)) return new MinKey2();
    }
    MinKey2.prototype.toExtendedJSON = function () {
      return { $minKey: 1 };
    };
    MinKey2.fromExtendedJSON = function () {
      return new MinKey2();
    };
    MinKey2.prototype[Symbol.for('nodejs.util.inspect.custom')] = function () {
      return this.inspect();
    };
    MinKey2.prototype.inspect = function () {
      return 'new MinKey()';
    };
    return MinKey2;
  })();
  exports2.MinKey = MinKey;
  Object.defineProperty(MinKey.prototype, '_bsontype', { value: 'MinKey' });
});

// node_modules/@cloudbase/node-sdk/node_modules/bson/lib/objectid.js
var require_objectid = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  exports2.ObjectId = void 0;
  var buffer_1 = require('buffer');
  var ensure_buffer_1 = require_ensure_buffer();
  var utils_1 = require_utils();
  var PROCESS_UNIQUE = utils_1.randomBytes(5);
  var checkForHexRegExp = new RegExp('^[0-9a-fA-F]{24}$');
  var hexTable = [];
  for (var i_1 = 0; i_1 < 256; i_1++) {
    hexTable[i_1] = (i_1 <= 15 ? '0' : '') + i_1.toString(16);
  }
  var decodeLookup = [];
  var i = 0;
  while (i < 10) decodeLookup[48 + i] = i++;
  while (i < 16) decodeLookup[65 - 10 + i] = decodeLookup[97 - 10 + i] = i++;
  var kId = Symbol('id');
  var ObjectId = (function () {
    function ObjectId2(id) {
      if (!(this instanceof ObjectId2)) return new ObjectId2(id);
      if (id instanceof ObjectId2) {
        this[kId] = id.id;
        this.__id = id.__id;
      }
      if (typeof id === 'object' && id && 'id' in id) {
        if ('toHexString' in id && typeof id.toHexString === 'function') {
          this[kId] = buffer_1.Buffer.from(id.toHexString(), 'hex');
        } else {
          this[kId] =
            typeof id.id === 'string' ? buffer_1.Buffer.from(id.id) : id.id;
        }
      }
      if (id == null || typeof id === 'number') {
        this[kId] = ObjectId2.generate(typeof id === 'number' ? id : void 0);
        if (ObjectId2.cacheHexString) {
          this.__id = this.id.toString('hex');
        }
      }
      if (ArrayBuffer.isView(id) && id.byteLength === 12) {
        this[kId] = ensure_buffer_1.ensureBuffer(id);
      }
      if (typeof id === 'string') {
        if (id.length === 12) {
          var bytes = buffer_1.Buffer.from(id);
          if (bytes.byteLength === 12) {
            this[kId] = bytes;
          }
        } else if (id.length === 24 && checkForHexRegExp.test(id)) {
          this[kId] = buffer_1.Buffer.from(id, 'hex');
        } else {
          throw new TypeError(
            'Argument passed in must be a Buffer or string of 12 bytes or a string of 24 hex characters',
          );
        }
      }
      if (ObjectId2.cacheHexString) {
        this.__id = this.id.toString('hex');
      }
    }
    Object.defineProperty(ObjectId2.prototype, 'id', {
      get: function () {
        return this[kId];
      },
      set: function (value) {
        this[kId] = value;
        if (ObjectId2.cacheHexString) {
          this.__id = value.toString('hex');
        }
      },
      enumerable: false,
      configurable: true,
    });
    Object.defineProperty(ObjectId2.prototype, 'generationTime', {
      get: function () {
        return this.id.readInt32BE(0);
      },
      set: function (value) {
        this.id.writeUInt32BE(value, 0);
      },
      enumerable: false,
      configurable: true,
    });
    ObjectId2.prototype.toHexString = function () {
      if (ObjectId2.cacheHexString && this.__id) {
        return this.__id;
      }
      var hexString = this.id.toString('hex');
      if (ObjectId2.cacheHexString && !this.__id) {
        this.__id = hexString;
      }
      return hexString;
    };
    ObjectId2.getInc = function () {
      return (ObjectId2.index = (ObjectId2.index + 1) % 16777215);
    };
    ObjectId2.generate = function (time) {
      if (typeof time !== 'number') {
        time = ~~(Date.now() / 1e3);
      }
      var inc = ObjectId2.getInc();
      var buffer = buffer_1.Buffer.alloc(12);
      buffer.writeUInt32BE(time, 0);
      buffer[4] = PROCESS_UNIQUE[0];
      buffer[5] = PROCESS_UNIQUE[1];
      buffer[6] = PROCESS_UNIQUE[2];
      buffer[7] = PROCESS_UNIQUE[3];
      buffer[8] = PROCESS_UNIQUE[4];
      buffer[11] = inc & 255;
      buffer[10] = (inc >> 8) & 255;
      buffer[9] = (inc >> 16) & 255;
      return buffer;
    };
    ObjectId2.prototype.toString = function (format) {
      if (format) return this.id.toString(format);
      return this.toHexString();
    };
    ObjectId2.prototype.toJSON = function () {
      return this.toHexString();
    };
    ObjectId2.prototype.equals = function (otherId) {
      if (otherId === void 0 || otherId === null) {
        return false;
      }
      if (otherId instanceof ObjectId2) {
        return this.toString() === otherId.toString();
      }
      if (
        typeof otherId === 'string' &&
        ObjectId2.isValid(otherId) &&
        otherId.length === 12 &&
        this.id instanceof buffer_1.Buffer
      ) {
        return otherId === this.id.toString('binary');
      }
      if (
        typeof otherId === 'string' &&
        ObjectId2.isValid(otherId) &&
        otherId.length === 24
      ) {
        return otherId.toLowerCase() === this.toHexString();
      }
      if (
        typeof otherId === 'string' &&
        ObjectId2.isValid(otherId) &&
        otherId.length === 12
      ) {
        return buffer_1.Buffer.from(otherId).equals(this.id);
      }
      if (
        typeof otherId === 'object' &&
        'toHexString' in otherId &&
        typeof otherId.toHexString === 'function'
      ) {
        return otherId.toHexString() === this.toHexString();
      }
      return false;
    };
    ObjectId2.prototype.getTimestamp = function () {
      var timestamp = new Date();
      var time = this.id.readUInt32BE(0);
      timestamp.setTime(Math.floor(time) * 1e3);
      return timestamp;
    };
    ObjectId2.createPk = function () {
      return new ObjectId2();
    };
    ObjectId2.createFromTime = function (time) {
      var buffer = buffer_1.Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      buffer.writeUInt32BE(time, 0);
      return new ObjectId2(buffer);
    };
    ObjectId2.createFromHexString = function (hexString) {
      if (
        typeof hexString === 'undefined' ||
        (hexString != null && hexString.length !== 24)
      ) {
        throw new TypeError(
          'Argument passed in must be a single String of 12 bytes or a string of 24 hex characters',
        );
      }
      return new ObjectId2(buffer_1.Buffer.from(hexString, 'hex'));
    };
    ObjectId2.isValid = function (id) {
      if (id == null) return false;
      if (typeof id === 'number') {
        return true;
      }
      if (typeof id === 'string') {
        return (
          id.length === 12 || (id.length === 24 && checkForHexRegExp.test(id))
        );
      }
      if (id instanceof ObjectId2) {
        return true;
      }
      if (id instanceof buffer_1.Buffer && id.length === 12) {
        return true;
      }
      if (
        typeof id === 'object' &&
        'toHexString' in id &&
        typeof id.toHexString === 'function'
      ) {
        if (typeof id.id === 'string') {
          return id.id.length === 12;
        }
        return (
          id.toHexString().length === 24 &&
          checkForHexRegExp.test(id.id.toString('hex'))
        );
      }
      return false;
    };
    ObjectId2.prototype.toExtendedJSON = function () {
      if (this.toHexString) return { $oid: this.toHexString() };
      return { $oid: this.toString('hex') };
    };
    ObjectId2.fromExtendedJSON = function (doc) {
      return new ObjectId2(doc.$oid);
    };
    ObjectId2.prototype[
      Symbol.for('nodejs.util.inspect.custom')
    ] = function () {
      return this.inspect();
    };
    ObjectId2.prototype.inspect = function () {
      return 'new ObjectId("' + this.toHexString() + '")';
    };
    ObjectId2.index = ~~(Math.random() * 16777215);
    return ObjectId2;
  })();
  exports2.ObjectId = ObjectId;
  Object.defineProperty(ObjectId.prototype, 'generate', {
    value: utils_1.deprecate(function (time) {
      return ObjectId.generate(time);
    }, 'Please use the static `ObjectId.generate(time)` instead'),
  });
  Object.defineProperty(ObjectId.prototype, 'getInc', {
    value: utils_1.deprecate(function () {
      return ObjectId.getInc();
    }, 'Please use the static `ObjectId.getInc()` instead'),
  });
  Object.defineProperty(ObjectId.prototype, 'get_inc', {
    value: utils_1.deprecate(function () {
      return ObjectId.getInc();
    }, 'Please use the static `ObjectId.getInc()` instead'),
  });
  Object.defineProperty(ObjectId, 'get_inc', {
    value: utils_1.deprecate(function () {
      return ObjectId.getInc();
    }, 'Please use the static `ObjectId.getInc()` instead'),
  });
  Object.defineProperty(ObjectId.prototype, '_bsontype', { value: 'ObjectID' });
});

// node_modules/@cloudbase/node-sdk/node_modules/bson/lib/regexp.js
var require_regexp = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  exports2.BSONRegExp = void 0;
  function alphabetize(str) {
    return str.split('').sort().join('');
  }
  var BSONRegExp = (function () {
    function BSONRegExp2(pattern, options) {
      if (!(this instanceof BSONRegExp2))
        return new BSONRegExp2(pattern, options);
      this.pattern = pattern;
      this.options = options !== null && options !== void 0 ? options : '';
      alphabetize(this.options);
      for (var i = 0; i < this.options.length; i++) {
        if (
          !(
            this.options[i] === 'i' ||
            this.options[i] === 'm' ||
            this.options[i] === 'x' ||
            this.options[i] === 'l' ||
            this.options[i] === 's' ||
            this.options[i] === 'u'
          )
        ) {
          throw new Error(
            'The regular expression option [' +
              this.options[i] +
              '] is not supported',
          );
        }
      }
    }
    BSONRegExp2.parseOptions = function (options) {
      return options ? options.split('').sort().join('') : '';
    };
    BSONRegExp2.prototype.toExtendedJSON = function (options) {
      options = options || {};
      if (options.legacy) {
        return { $regex: this.pattern, $options: this.options };
      }
      return {
        $regularExpression: { pattern: this.pattern, options: this.options },
      };
    };
    BSONRegExp2.fromExtendedJSON = function (doc) {
      if ('$regex' in doc) {
        if (typeof doc.$regex !== 'string') {
          if (doc.$regex._bsontype === 'BSONRegExp') {
            return doc;
          }
        } else {
          return new BSONRegExp2(
            doc.$regex,
            BSONRegExp2.parseOptions(doc.$options),
          );
        }
      }
      if ('$regularExpression' in doc) {
        return new BSONRegExp2(
          doc.$regularExpression.pattern,
          BSONRegExp2.parseOptions(doc.$regularExpression.options),
        );
      }
      throw new TypeError(
        'Unexpected BSONRegExp EJSON object form: ' + JSON.stringify(doc),
      );
    };
    return BSONRegExp2;
  })();
  exports2.BSONRegExp = BSONRegExp;
  Object.defineProperty(BSONRegExp.prototype, '_bsontype', {
    value: 'BSONRegExp',
  });
});

// node_modules/@cloudbase/node-sdk/node_modules/bson/lib/symbol.js
var require_symbol = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  exports2.BSONSymbol = void 0;
  var BSONSymbol = (function () {
    function BSONSymbol2(value) {
      if (!(this instanceof BSONSymbol2)) return new BSONSymbol2(value);
      this.value = value;
    }
    BSONSymbol2.prototype.valueOf = function () {
      return this.value;
    };
    BSONSymbol2.prototype.toString = function () {
      return this.value;
    };
    BSONSymbol2.prototype.inspect = function () {
      return 'new BSONSymbol("' + this.value + '")';
    };
    BSONSymbol2.prototype.toJSON = function () {
      return this.value;
    };
    BSONSymbol2.prototype.toExtendedJSON = function () {
      return { $symbol: this.value };
    };
    BSONSymbol2.fromExtendedJSON = function (doc) {
      return new BSONSymbol2(doc.$symbol);
    };
    BSONSymbol2.prototype[
      Symbol.for('nodejs.util.inspect.custom')
    ] = function () {
      return this.inspect();
    };
    return BSONSymbol2;
  })();
  exports2.BSONSymbol = BSONSymbol;
  Object.defineProperty(BSONSymbol.prototype, '_bsontype', { value: 'Symbol' });
});

// node_modules/@cloudbase/node-sdk/node_modules/bson/lib/timestamp.js
var require_timestamp = __commonJS((exports2) => {
  'use strict';
  var __extends =
    (exports2 && exports2.__extends) ||
    (function () {
      var extendStatics = function (d, b) {
        extendStatics =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (d2, b2) {
              d2.__proto__ = b2;
            }) ||
          function (d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
        return extendStatics(d, b);
      };
      return function (d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype =
          b === null
            ? Object.create(b)
            : ((__.prototype = b.prototype), new __());
      };
    })();
  Object.defineProperty(exports2, '__esModule', { value: true });
  exports2.Timestamp = exports2.LongWithoutOverridesClass = void 0;
  var long_1 = require_long();
  exports2.LongWithoutOverridesClass = long_1.Long;
  var Timestamp = (function (_super) {
    __extends(Timestamp2, _super);
    function Timestamp2(low, high) {
      var _this = this;
      if (!(_this instanceof Timestamp2)) return new Timestamp2(low, high);
      if (long_1.Long.isLong(low)) {
        _this = _super.call(this, low.low, low.high, true) || this;
      } else {
        _this = _super.call(this, low, high, true) || this;
      }
      Object.defineProperty(_this, '_bsontype', {
        value: 'Timestamp',
        writable: false,
        configurable: false,
        enumerable: false,
      });
      return _this;
    }
    Timestamp2.prototype.toJSON = function () {
      return {
        $timestamp: this.toString(),
      };
    };
    Timestamp2.fromInt = function (value) {
      return new Timestamp2(long_1.Long.fromInt(value, true));
    };
    Timestamp2.fromNumber = function (value) {
      return new Timestamp2(long_1.Long.fromNumber(value, true));
    };
    Timestamp2.fromBits = function (lowBits, highBits) {
      return new Timestamp2(lowBits, highBits);
    };
    Timestamp2.fromString = function (str, optRadix) {
      return new Timestamp2(long_1.Long.fromString(str, true, optRadix));
    };
    Timestamp2.prototype.toExtendedJSON = function () {
      return { $timestamp: { t: this.high >>> 0, i: this.low >>> 0 } };
    };
    Timestamp2.fromExtendedJSON = function (doc) {
      return new Timestamp2(doc.$timestamp.i, doc.$timestamp.t);
    };
    Timestamp2.prototype[
      Symbol.for('nodejs.util.inspect.custom')
    ] = function () {
      return this.inspect();
    };
    Timestamp2.prototype.inspect = function () {
      return (
        'new Timestamp(' +
        this.getLowBits().toString() +
        ', ' +
        this.getHighBits().toString() +
        ')'
      );
    };
    Timestamp2.MAX_VALUE = long_1.Long.MAX_UNSIGNED_VALUE;
    return Timestamp2;
  })(exports2.LongWithoutOverridesClass);
  exports2.Timestamp = Timestamp;
});

// node_modules/@cloudbase/node-sdk/node_modules/bson/lib/extended_json.js
var require_extended_json = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  exports2.EJSON = exports2.isBSONType = void 0;
  var binary_1 = require_binary();
  var code_1 = require_code2();
  var db_ref_1 = require_db_ref();
  var decimal128_1 = require_decimal128();
  var double_1 = require_double();
  var int_32_1 = require_int_32();
  var long_1 = require_long();
  var max_key_1 = require_max_key();
  var min_key_1 = require_min_key();
  var objectid_1 = require_objectid();
  var utils_1 = require_utils();
  var regexp_1 = require_regexp();
  var symbol_1 = require_symbol();
  var timestamp_1 = require_timestamp();
  function isBSONType(value) {
    return (
      utils_1.isObjectLike(value) &&
      Reflect.has(value, '_bsontype') &&
      typeof value._bsontype === 'string'
    );
  }
  exports2.isBSONType = isBSONType;
  var BSON_INT32_MAX = 2147483647;
  var BSON_INT32_MIN = -2147483648;
  var BSON_INT64_MAX = 9223372036854776e3;
  var BSON_INT64_MIN = -9223372036854776e3;
  var keysToCodecs = {
    $oid: objectid_1.ObjectId,
    $binary: binary_1.Binary,
    $uuid: binary_1.Binary,
    $symbol: symbol_1.BSONSymbol,
    $numberInt: int_32_1.Int32,
    $numberDecimal: decimal128_1.Decimal128,
    $numberDouble: double_1.Double,
    $numberLong: long_1.Long,
    $minKey: min_key_1.MinKey,
    $maxKey: max_key_1.MaxKey,
    $regex: regexp_1.BSONRegExp,
    $regularExpression: regexp_1.BSONRegExp,
    $timestamp: timestamp_1.Timestamp,
  };
  function deserializeValue(value, options) {
    if (options === void 0) {
      options = {};
    }
    if (typeof value === 'number') {
      if (options.relaxed || options.legacy) {
        return value;
      }
      if (Math.floor(value) === value) {
        if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX)
          return new int_32_1.Int32(value);
        if (value >= BSON_INT64_MIN && value <= BSON_INT64_MAX)
          return long_1.Long.fromNumber(value);
      }
      return new double_1.Double(value);
    }
    if (value == null || typeof value !== 'object') return value;
    if (value.$undefined) return null;
    var keys = Object.keys(value).filter(function (k) {
      return k.startsWith('$') && value[k] != null;
    });
    for (var i = 0; i < keys.length; i++) {
      var c = keysToCodecs[keys[i]];
      if (c) return c.fromExtendedJSON(value, options);
    }
    if (value.$date != null) {
      var d = value.$date;
      var date = new Date();
      if (options.legacy) {
        if (typeof d === 'number') date.setTime(d);
        else if (typeof d === 'string') date.setTime(Date.parse(d));
      } else {
        if (typeof d === 'string') date.setTime(Date.parse(d));
        else if (long_1.Long.isLong(d)) date.setTime(d.toNumber());
        else if (typeof d === 'number' && options.relaxed) date.setTime(d);
      }
      return date;
    }
    if (value.$code != null) {
      var copy = Object.assign({}, value);
      if (value.$scope) {
        copy.$scope = deserializeValue(value.$scope);
      }
      return code_1.Code.fromExtendedJSON(value);
    }
    if (value.$ref != null || value.$dbPointer != null) {
      var v = value.$ref ? value : value.$dbPointer;
      if (v instanceof db_ref_1.DBRef) return v;
      var dollarKeys = Object.keys(v).filter(function (k) {
        return k.startsWith('$');
      });
      var valid_1 = true;
      dollarKeys.forEach(function (k) {
        if (['$ref', '$id', '$db'].indexOf(k) === -1) valid_1 = false;
      });
      if (valid_1) return db_ref_1.DBRef.fromExtendedJSON(v);
    }
    return value;
  }
  function serializeArray(array, options) {
    return array.map(function (v) {
      return serializeValue(v, options);
    });
  }
  function getISOString(date) {
    var isoStr = date.toISOString();
    return date.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + 'Z';
  }
  function serializeValue(value, options) {
    if (Array.isArray(value)) return serializeArray(value, options);
    if (value === void 0) return null;
    if (value instanceof Date) {
      var dateNum = value.getTime(),
        inRange = dateNum > -1 && dateNum < 2534023188e5;
      if (options.legacy) {
        return options.relaxed && inRange
          ? { $date: value.getTime() }
          : { $date: getISOString(value) };
      }
      return options.relaxed && inRange
        ? { $date: getISOString(value) }
        : { $date: { $numberLong: value.getTime().toString() } };
    }
    if (typeof value === 'number' && !options.relaxed) {
      if (Math.floor(value) === value) {
        var int32Range = value >= BSON_INT32_MIN && value <= BSON_INT32_MAX,
          int64Range = value >= BSON_INT64_MIN && value <= BSON_INT64_MAX;
        if (int32Range) return { $numberInt: value.toString() };
        if (int64Range) return { $numberLong: value.toString() };
      }
      return { $numberDouble: value.toString() };
    }
    if (value instanceof RegExp) {
      var flags = value.flags;
      if (flags === void 0) {
        var match = value.toString().match(/[gimuy]*$/);
        if (match) {
          flags = match[0];
        }
      }
      var rx = new regexp_1.BSONRegExp(value.source, flags);
      return rx.toExtendedJSON(options);
    }
    if (value != null && typeof value === 'object')
      return serializeDocument(value, options);
    return value;
  }
  var BSON_TYPE_MAPPINGS = {
    Binary: function (o) {
      return new binary_1.Binary(o.value(), o.sub_type);
    },
    Code: function (o) {
      return new code_1.Code(o.code, o.scope);
    },
    DBRef: function (o) {
      return new db_ref_1.DBRef(
        o.collection || o.namespace,
        o.oid,
        o.db,
        o.fields,
      );
    },
    Decimal128: function (o) {
      return new decimal128_1.Decimal128(o.bytes);
    },
    Double: function (o) {
      return new double_1.Double(o.value);
    },
    Int32: function (o) {
      return new int_32_1.Int32(o.value);
    },
    Long: function (o) {
      return long_1.Long.fromBits(
        o.low != null ? o.low : o.low_,
        o.low != null ? o.high : o.high_,
        o.low != null ? o.unsigned : o.unsigned_,
      );
    },
    MaxKey: function () {
      return new max_key_1.MaxKey();
    },
    MinKey: function () {
      return new min_key_1.MinKey();
    },
    ObjectID: function (o) {
      return new objectid_1.ObjectId(o);
    },
    ObjectId: function (o) {
      return new objectid_1.ObjectId(o);
    },
    BSONRegExp: function (o) {
      return new regexp_1.BSONRegExp(o.pattern, o.options);
    },
    Symbol: function (o) {
      return new symbol_1.BSONSymbol(o.value);
    },
    Timestamp: function (o) {
      return timestamp_1.Timestamp.fromBits(o.low, o.high);
    },
  };
  function serializeDocument(doc, options) {
    if (doc == null || typeof doc !== 'object')
      throw new Error('not an object instance');
    var bsontype = doc._bsontype;
    if (typeof bsontype === 'undefined') {
      var _doc = {};
      for (var name in doc) {
        _doc[name] = serializeValue(doc[name], options);
      }
      return _doc;
    } else if (isBSONType(doc)) {
      var outDoc = doc;
      if (typeof outDoc.toExtendedJSON !== 'function') {
        var mapper = BSON_TYPE_MAPPINGS[doc._bsontype];
        if (!mapper) {
          throw new TypeError(
            'Unrecognized or invalid _bsontype: ' + doc._bsontype,
          );
        }
        outDoc = mapper(outDoc);
      }
      if (bsontype === 'Code' && outDoc.scope) {
        outDoc = new code_1.Code(
          outDoc.code,
          serializeValue(outDoc.scope, options),
        );
      } else if (bsontype === 'DBRef' && outDoc.oid) {
        outDoc = new db_ref_1.DBRef(
          outDoc.collection,
          serializeValue(outDoc.oid, options),
          outDoc.db,
          outDoc.fields,
        );
      }
      return outDoc.toExtendedJSON(options);
    } else {
      throw new Error(
        '_bsontype must be a string, but was: ' + typeof bsontype,
      );
    }
  }
  var EJSON;
  (function (EJSON2) {
    function parse(text, options) {
      var finalOptions = Object.assign(
        {},
        { relaxed: true, legacy: false },
        options,
      );
      if (typeof finalOptions.relaxed === 'boolean')
        finalOptions.strict = !finalOptions.relaxed;
      if (typeof finalOptions.strict === 'boolean')
        finalOptions.relaxed = !finalOptions.strict;
      return JSON.parse(text, function (_key, value) {
        return deserializeValue(value, finalOptions);
      });
    }
    EJSON2.parse = parse;
    function stringify(value, replacer, space, options) {
      if (space != null && typeof space === 'object') {
        options = space;
        space = 0;
      }
      if (
        replacer != null &&
        typeof replacer === 'object' &&
        !Array.isArray(replacer)
      ) {
        options = replacer;
        replacer = void 0;
        space = 0;
      }
      options = Object.assign({}, { relaxed: true, legacy: false }, options);
      var doc = serializeValue(value, options);
      return JSON.stringify(doc, replacer, space);
    }
    EJSON2.stringify = stringify;
    function serialize(value, options) {
      options = options || {};
      return JSON.parse(stringify(value, options));
    }
    EJSON2.serialize = serialize;
    function deserialize(ejson, options) {
      options = options || {};
      return parse(JSON.stringify(ejson), options);
    }
    EJSON2.deserialize = deserialize;
  })((EJSON = exports2.EJSON || (exports2.EJSON = {})));
});

// node_modules/@cloudbase/node-sdk/node_modules/bson/lib/map.js
var require_map = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  exports2.Map = void 0;
  var bsonMap;
  exports2.Map = bsonMap;
  var check = function (potentialGlobal) {
    return potentialGlobal && potentialGlobal.Math == Math && potentialGlobal;
  };
  function getGlobal() {
    return (
      check(typeof globalThis === 'object' && globalThis) ||
      check(typeof window === 'object' && window) ||
      check(typeof self === 'object' && self) ||
      check(typeof global === 'object' && global) ||
      Function('return this')()
    );
  }
  var bsonGlobal = getGlobal();
  if (Object.prototype.hasOwnProperty.call(bsonGlobal, 'Map')) {
    exports2.Map = bsonMap = bsonGlobal.Map;
  } else {
    exports2.Map = bsonMap = (function () {
      function Map2(array) {
        if (array === void 0) {
          array = [];
        }
        this._keys = [];
        this._values = {};
        for (var i = 0; i < array.length; i++) {
          if (array[i] == null) continue;
          var entry = array[i];
          var key = entry[0];
          var value = entry[1];
          this._keys.push(key);
          this._values[key] = { v: value, i: this._keys.length - 1 };
        }
      }
      Map2.prototype.clear = function () {
        this._keys = [];
        this._values = {};
      };
      Map2.prototype.delete = function (key) {
        var value = this._values[key];
        if (value == null) return false;
        delete this._values[key];
        this._keys.splice(value.i, 1);
        return true;
      };
      Map2.prototype.entries = function () {
        var _this = this;
        var index = 0;
        return {
          next: function () {
            var key = _this._keys[index++];
            return {
              value: key !== void 0 ? [key, _this._values[key].v] : void 0,
              done: key !== void 0 ? false : true,
            };
          },
        };
      };
      Map2.prototype.forEach = function (callback, self2) {
        self2 = self2 || this;
        for (var i = 0; i < this._keys.length; i++) {
          var key = this._keys[i];
          callback.call(self2, this._values[key].v, key, self2);
        }
      };
      Map2.prototype.get = function (key) {
        return this._values[key] ? this._values[key].v : void 0;
      };
      Map2.prototype.has = function (key) {
        return this._values[key] != null;
      };
      Map2.prototype.keys = function () {
        var _this = this;
        var index = 0;
        return {
          next: function () {
            var key = _this._keys[index++];
            return {
              value: key !== void 0 ? key : void 0,
              done: key !== void 0 ? false : true,
            };
          },
        };
      };
      Map2.prototype.set = function (key, value) {
        if (this._values[key]) {
          this._values[key].v = value;
          return this;
        }
        this._keys.push(key);
        this._values[key] = { v: value, i: this._keys.length - 1 };
        return this;
      };
      Map2.prototype.values = function () {
        var _this = this;
        var index = 0;
        return {
          next: function () {
            var key = _this._keys[index++];
            return {
              value: key !== void 0 ? _this._values[key].v : void 0,
              done: key !== void 0 ? false : true,
            };
          },
        };
      };
      Object.defineProperty(Map2.prototype, 'size', {
        get: function () {
          return this._keys.length;
        },
        enumerable: false,
        configurable: true,
      });
      return Map2;
    })();
  }
});

// node_modules/@cloudbase/node-sdk/node_modules/bson/lib/constants.js
var require_constants = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  exports2.BSON_BINARY_SUBTYPE_USER_DEFINED = exports2.BSON_BINARY_SUBTYPE_MD5 = exports2.BSON_BINARY_SUBTYPE_UUID_NEW = exports2.BSON_BINARY_SUBTYPE_UUID = exports2.BSON_BINARY_SUBTYPE_BYTE_ARRAY = exports2.BSON_BINARY_SUBTYPE_FUNCTION = exports2.BSON_BINARY_SUBTYPE_DEFAULT = exports2.BSON_DATA_MAX_KEY = exports2.BSON_DATA_MIN_KEY = exports2.BSON_DATA_DECIMAL128 = exports2.BSON_DATA_LONG = exports2.BSON_DATA_TIMESTAMP = exports2.BSON_DATA_INT = exports2.BSON_DATA_CODE_W_SCOPE = exports2.BSON_DATA_SYMBOL = exports2.BSON_DATA_CODE = exports2.BSON_DATA_DBPOINTER = exports2.BSON_DATA_REGEXP = exports2.BSON_DATA_NULL = exports2.BSON_DATA_DATE = exports2.BSON_DATA_BOOLEAN = exports2.BSON_DATA_OID = exports2.BSON_DATA_UNDEFINED = exports2.BSON_DATA_BINARY = exports2.BSON_DATA_ARRAY = exports2.BSON_DATA_OBJECT = exports2.BSON_DATA_STRING = exports2.BSON_DATA_NUMBER = exports2.JS_INT_MIN = exports2.JS_INT_MAX = exports2.BSON_INT64_MIN = exports2.BSON_INT64_MAX = exports2.BSON_INT32_MIN = exports2.BSON_INT32_MAX = void 0;
  exports2.BSON_INT32_MAX = 2147483647;
  exports2.BSON_INT32_MIN = -2147483648;
  exports2.BSON_INT64_MAX = Math.pow(2, 63) - 1;
  exports2.BSON_INT64_MIN = -Math.pow(2, 63);
  exports2.JS_INT_MAX = Math.pow(2, 53);
  exports2.JS_INT_MIN = -Math.pow(2, 53);
  exports2.BSON_DATA_NUMBER = 1;
  exports2.BSON_DATA_STRING = 2;
  exports2.BSON_DATA_OBJECT = 3;
  exports2.BSON_DATA_ARRAY = 4;
  exports2.BSON_DATA_BINARY = 5;
  exports2.BSON_DATA_UNDEFINED = 6;
  exports2.BSON_DATA_OID = 7;
  exports2.BSON_DATA_BOOLEAN = 8;
  exports2.BSON_DATA_DATE = 9;
  exports2.BSON_DATA_NULL = 10;
  exports2.BSON_DATA_REGEXP = 11;
  exports2.BSON_DATA_DBPOINTER = 12;
  exports2.BSON_DATA_CODE = 13;
  exports2.BSON_DATA_SYMBOL = 14;
  exports2.BSON_DATA_CODE_W_SCOPE = 15;
  exports2.BSON_DATA_INT = 16;
  exports2.BSON_DATA_TIMESTAMP = 17;
  exports2.BSON_DATA_LONG = 18;
  exports2.BSON_DATA_DECIMAL128 = 19;
  exports2.BSON_DATA_MIN_KEY = 255;
  exports2.BSON_DATA_MAX_KEY = 127;
  exports2.BSON_BINARY_SUBTYPE_DEFAULT = 0;
  exports2.BSON_BINARY_SUBTYPE_FUNCTION = 1;
  exports2.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
  exports2.BSON_BINARY_SUBTYPE_UUID = 3;
  exports2.BSON_BINARY_SUBTYPE_UUID_NEW = 4;
  exports2.BSON_BINARY_SUBTYPE_MD5 = 5;
  exports2.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;
});

// node_modules/@cloudbase/node-sdk/node_modules/bson/lib/parser/calculate_size.js
var require_calculate_size = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  exports2.calculateObjectSize = void 0;
  var buffer_1 = require('buffer');
  var binary_1 = require_binary();
  var constants = require_constants();
  var utils_1 = require_utils();
  function calculateObjectSize(object, serializeFunctions, ignoreUndefined) {
    var totalLength = 4 + 1;
    if (Array.isArray(object)) {
      for (var i = 0; i < object.length; i++) {
        totalLength += calculateElement(
          i.toString(),
          object[i],
          serializeFunctions,
          true,
          ignoreUndefined,
        );
      }
    } else {
      if (object.toBSON) {
        object = object.toBSON();
      }
      for (var key in object) {
        totalLength += calculateElement(
          key,
          object[key],
          serializeFunctions,
          false,
          ignoreUndefined,
        );
      }
    }
    return totalLength;
  }
  exports2.calculateObjectSize = calculateObjectSize;
  function calculateElement(
    name,
    value,
    serializeFunctions,
    isArray,
    ignoreUndefined,
  ) {
    if (serializeFunctions === void 0) {
      serializeFunctions = false;
    }
    if (isArray === void 0) {
      isArray = false;
    }
    if (ignoreUndefined === void 0) {
      ignoreUndefined = false;
    }
    if (value && value.toBSON) {
      value = value.toBSON();
    }
    switch (typeof value) {
      case 'string':
        return (
          1 +
          buffer_1.Buffer.byteLength(name, 'utf8') +
          1 +
          4 +
          buffer_1.Buffer.byteLength(value, 'utf8') +
          1
        );
      case 'number':
        if (
          Math.floor(value) === value &&
          value >= constants.JS_INT_MIN &&
          value <= constants.JS_INT_MAX
        ) {
          if (
            value >= constants.BSON_INT32_MIN &&
            value <= constants.BSON_INT32_MAX
          ) {
            return (
              (name != null
                ? buffer_1.Buffer.byteLength(name, 'utf8') + 1
                : 0) +
              (4 + 1)
            );
          } else {
            return (
              (name != null
                ? buffer_1.Buffer.byteLength(name, 'utf8') + 1
                : 0) +
              (8 + 1)
            );
          }
        } else {
          return (
            (name != null ? buffer_1.Buffer.byteLength(name, 'utf8') + 1 : 0) +
            (8 + 1)
          );
        }
      case 'undefined':
        if (isArray || !ignoreUndefined)
          return (
            (name != null ? buffer_1.Buffer.byteLength(name, 'utf8') + 1 : 0) +
            1
          );
        return 0;
      case 'boolean':
        return (
          (name != null ? buffer_1.Buffer.byteLength(name, 'utf8') + 1 : 0) +
          (1 + 1)
        );
      case 'object':
        if (
          value == null ||
          value['_bsontype'] === 'MinKey' ||
          value['_bsontype'] === 'MaxKey'
        ) {
          return (
            (name != null ? buffer_1.Buffer.byteLength(name, 'utf8') + 1 : 0) +
            1
          );
        } else if (
          value['_bsontype'] === 'ObjectId' ||
          value['_bsontype'] === 'ObjectID'
        ) {
          return (
            (name != null ? buffer_1.Buffer.byteLength(name, 'utf8') + 1 : 0) +
            (12 + 1)
          );
        } else if (value instanceof Date || utils_1.isDate(value)) {
          return (
            (name != null ? buffer_1.Buffer.byteLength(name, 'utf8') + 1 : 0) +
            (8 + 1)
          );
        } else if (ArrayBuffer.isView(value) || value instanceof ArrayBuffer) {
          return (
            (name != null ? buffer_1.Buffer.byteLength(name, 'utf8') + 1 : 0) +
            (1 + 4 + 1) +
            value.byteLength
          );
        } else if (
          value['_bsontype'] === 'Long' ||
          value['_bsontype'] === 'Double' ||
          value['_bsontype'] === 'Timestamp'
        ) {
          return (
            (name != null ? buffer_1.Buffer.byteLength(name, 'utf8') + 1 : 0) +
            (8 + 1)
          );
        } else if (value['_bsontype'] === 'Decimal128') {
          return (
            (name != null ? buffer_1.Buffer.byteLength(name, 'utf8') + 1 : 0) +
            (16 + 1)
          );
        } else if (value['_bsontype'] === 'Code') {
          if (value.scope != null && Object.keys(value.scope).length > 0) {
            return (
              (name != null
                ? buffer_1.Buffer.byteLength(name, 'utf8') + 1
                : 0) +
              1 +
              4 +
              4 +
              buffer_1.Buffer.byteLength(value.code.toString(), 'utf8') +
              1 +
              calculateObjectSize(
                value.scope,
                serializeFunctions,
                ignoreUndefined,
              )
            );
          } else {
            return (
              (name != null
                ? buffer_1.Buffer.byteLength(name, 'utf8') + 1
                : 0) +
              1 +
              4 +
              buffer_1.Buffer.byteLength(value.code.toString(), 'utf8') +
              1
            );
          }
        } else if (value['_bsontype'] === 'Binary') {
          if (value.sub_type === binary_1.Binary.SUBTYPE_BYTE_ARRAY) {
            return (
              (name != null
                ? buffer_1.Buffer.byteLength(name, 'utf8') + 1
                : 0) +
              (value.position + 1 + 4 + 1 + 4)
            );
          } else {
            return (
              (name != null
                ? buffer_1.Buffer.byteLength(name, 'utf8') + 1
                : 0) +
              (value.position + 1 + 4 + 1)
            );
          }
        } else if (value['_bsontype'] === 'Symbol') {
          return (
            (name != null ? buffer_1.Buffer.byteLength(name, 'utf8') + 1 : 0) +
            buffer_1.Buffer.byteLength(value.value, 'utf8') +
            4 +
            1 +
            1
          );
        } else if (value['_bsontype'] === 'DBRef') {
          var ordered_values = Object.assign(
            {
              $ref: value.collection,
              $id: value.oid,
            },
            value.fields,
          );
          if (value.db != null) {
            ordered_values['$db'] = value.db;
          }
          return (
            (name != null ? buffer_1.Buffer.byteLength(name, 'utf8') + 1 : 0) +
            1 +
            calculateObjectSize(
              ordered_values,
              serializeFunctions,
              ignoreUndefined,
            )
          );
        } else if (
          value instanceof RegExp ||
          Object.prototype.toString.call(value) === '[object RegExp]'
        ) {
          return (
            (name != null ? buffer_1.Buffer.byteLength(name, 'utf8') + 1 : 0) +
            1 +
            buffer_1.Buffer.byteLength(value.source, 'utf8') +
            1 +
            (value.global ? 1 : 0) +
            (value.ignoreCase ? 1 : 0) +
            (value.multiline ? 1 : 0) +
            1
          );
        } else if (value['_bsontype'] === 'BSONRegExp') {
          return (
            (name != null ? buffer_1.Buffer.byteLength(name, 'utf8') + 1 : 0) +
            1 +
            buffer_1.Buffer.byteLength(value.pattern, 'utf8') +
            1 +
            buffer_1.Buffer.byteLength(value.options, 'utf8') +
            1
          );
        } else {
          return (
            (name != null ? buffer_1.Buffer.byteLength(name, 'utf8') + 1 : 0) +
            calculateObjectSize(value, serializeFunctions, ignoreUndefined) +
            1
          );
        }
      case 'function':
        if (
          value instanceof RegExp ||
          Object.prototype.toString.call(value) === '[object RegExp]' ||
          String.call(value) === '[object RegExp]'
        ) {
          return (
            (name != null ? buffer_1.Buffer.byteLength(name, 'utf8') + 1 : 0) +
            1 +
            buffer_1.Buffer.byteLength(value.source, 'utf8') +
            1 +
            (value.global ? 1 : 0) +
            (value.ignoreCase ? 1 : 0) +
            (value.multiline ? 1 : 0) +
            1
          );
        } else {
          if (
            serializeFunctions &&
            value.scope != null &&
            Object.keys(value.scope).length > 0
          ) {
            return (
              (name != null
                ? buffer_1.Buffer.byteLength(name, 'utf8') + 1
                : 0) +
              1 +
              4 +
              4 +
              buffer_1.Buffer.byteLength(
                utils_1.normalizedFunctionString(value),
                'utf8',
              ) +
              1 +
              calculateObjectSize(
                value.scope,
                serializeFunctions,
                ignoreUndefined,
              )
            );
          } else if (serializeFunctions) {
            return (
              (name != null
                ? buffer_1.Buffer.byteLength(name, 'utf8') + 1
                : 0) +
              1 +
              4 +
              buffer_1.Buffer.byteLength(
                utils_1.normalizedFunctionString(value),
                'utf8',
              ) +
              1
            );
          }
        }
    }
    return 0;
  }
});

// node_modules/@cloudbase/node-sdk/node_modules/bson/lib/validate_utf8.js
var require_validate_utf8 = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  exports2.validateUtf8 = void 0;
  var FIRST_BIT = 128;
  var FIRST_TWO_BITS = 192;
  var FIRST_THREE_BITS = 224;
  var FIRST_FOUR_BITS = 240;
  var FIRST_FIVE_BITS = 248;
  var TWO_BIT_CHAR = 192;
  var THREE_BIT_CHAR = 224;
  var FOUR_BIT_CHAR = 240;
  var CONTINUING_CHAR = 128;
  function validateUtf8(bytes, start, end) {
    var continuation = 0;
    for (var i = start; i < end; i += 1) {
      var byte = bytes[i];
      if (continuation) {
        if ((byte & FIRST_TWO_BITS) !== CONTINUING_CHAR) {
          return false;
        }
        continuation -= 1;
      } else if (byte & FIRST_BIT) {
        if ((byte & FIRST_THREE_BITS) === TWO_BIT_CHAR) {
          continuation = 1;
        } else if ((byte & FIRST_FOUR_BITS) === THREE_BIT_CHAR) {
          continuation = 2;
        } else if ((byte & FIRST_FIVE_BITS) === FOUR_BIT_CHAR) {
          continuation = 3;
        } else {
          return false;
        }
      }
    }
    return !continuation;
  }
  exports2.validateUtf8 = validateUtf8;
});

// node_modules/@cloudbase/node-sdk/node_modules/bson/lib/parser/deserializer.js
var require_deserializer = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  exports2.deserialize = void 0;
  var buffer_1 = require('buffer');
  var binary_1 = require_binary();
  var code_1 = require_code2();
  var constants = require_constants();
  var db_ref_1 = require_db_ref();
  var decimal128_1 = require_decimal128();
  var double_1 = require_double();
  var int_32_1 = require_int_32();
  var long_1 = require_long();
  var max_key_1 = require_max_key();
  var min_key_1 = require_min_key();
  var objectid_1 = require_objectid();
  var regexp_1 = require_regexp();
  var symbol_1 = require_symbol();
  var timestamp_1 = require_timestamp();
  var validate_utf8_1 = require_validate_utf8();
  var JS_INT_MAX_LONG = long_1.Long.fromNumber(constants.JS_INT_MAX);
  var JS_INT_MIN_LONG = long_1.Long.fromNumber(constants.JS_INT_MIN);
  var functionCache = {};
  function deserialize(buffer, options, isArray) {
    options = options == null ? {} : options;
    var index = options && options.index ? options.index : 0;
    var size =
      buffer[index] |
      (buffer[index + 1] << 8) |
      (buffer[index + 2] << 16) |
      (buffer[index + 3] << 24);
    if (size < 5) {
      throw new Error('bson size must be >= 5, is ' + size);
    }
    if (options.allowObjectSmallerThanBufferSize && buffer.length < size) {
      throw new Error(
        'buffer length ' + buffer.length + ' must be >= bson size ' + size,
      );
    }
    if (!options.allowObjectSmallerThanBufferSize && buffer.length !== size) {
      throw new Error(
        'buffer length ' + buffer.length + ' must === bson size ' + size,
      );
    }
    if (size + index > buffer.byteLength) {
      throw new Error(
        '(bson size ' +
          size +
          ' + options.index ' +
          index +
          ' must be <= buffer length ' +
          buffer.byteLength +
          ')',
      );
    }
    if (buffer[index + size - 1] !== 0) {
      throw new Error(
        "One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00",
      );
    }
    return deserializeObject(buffer, index, options, isArray);
  }
  exports2.deserialize = deserialize;
  function deserializeObject(buffer, index, options, isArray) {
    if (isArray === void 0) {
      isArray = false;
    }
    var evalFunctions =
      options['evalFunctions'] == null ? false : options['evalFunctions'];
    var cacheFunctions =
      options['cacheFunctions'] == null ? false : options['cacheFunctions'];
    var fieldsAsRaw =
      options['fieldsAsRaw'] == null ? null : options['fieldsAsRaw'];
    var raw = options['raw'] == null ? false : options['raw'];
    var bsonRegExp =
      typeof options['bsonRegExp'] === 'boolean'
        ? options['bsonRegExp']
        : false;
    var promoteBuffers =
      options['promoteBuffers'] == null ? false : options['promoteBuffers'];
    var promoteLongs =
      options['promoteLongs'] == null ? true : options['promoteLongs'];
    var promoteValues =
      options['promoteValues'] == null ? true : options['promoteValues'];
    var startIndex = index;
    if (buffer.length < 5)
      throw new Error('corrupt bson message < 5 bytes long');
    var size =
      buffer[index++] |
      (buffer[index++] << 8) |
      (buffer[index++] << 16) |
      (buffer[index++] << 24);
    if (size < 5 || size > buffer.length)
      throw new Error('corrupt bson message');
    var object = isArray ? [] : {};
    var arrayIndex = 0;
    var done = false;
    while (!done) {
      var elementType = buffer[index++];
      if (elementType === 0) break;
      var i = index;
      while (buffer[i] !== 0 && i < buffer.length) {
        i++;
      }
      if (i >= buffer.byteLength)
        throw new Error('Bad BSON Document: illegal CString');
      var name = isArray ? arrayIndex++ : buffer.toString('utf8', index, i);
      index = i + 1;
      if (elementType === constants.BSON_DATA_STRING) {
        var stringSize =
          buffer[index++] |
          (buffer[index++] << 8) |
          (buffer[index++] << 16) |
          (buffer[index++] << 24);
        if (
          stringSize <= 0 ||
          stringSize > buffer.length - index ||
          buffer[index + stringSize - 1] !== 0
        )
          throw new Error('bad string length in bson');
        if (
          !validate_utf8_1.validateUtf8(buffer, index, index + stringSize - 1)
        ) {
          throw new Error('Invalid UTF-8 string in BSON document');
        }
        var s = buffer.toString('utf8', index, index + stringSize - 1);
        object[name] = s;
        index = index + stringSize;
      } else if (elementType === constants.BSON_DATA_OID) {
        var oid = buffer_1.Buffer.alloc(12);
        buffer.copy(oid, 0, index, index + 12);
        object[name] = new objectid_1.ObjectId(oid);
        index = index + 12;
      } else if (
        elementType === constants.BSON_DATA_INT &&
        promoteValues === false
      ) {
        object[name] = new int_32_1.Int32(
          buffer[index++] |
            (buffer[index++] << 8) |
            (buffer[index++] << 16) |
            (buffer[index++] << 24),
        );
      } else if (elementType === constants.BSON_DATA_INT) {
        object[name] =
          buffer[index++] |
          (buffer[index++] << 8) |
          (buffer[index++] << 16) |
          (buffer[index++] << 24);
      } else if (
        elementType === constants.BSON_DATA_NUMBER &&
        promoteValues === false
      ) {
        object[name] = new double_1.Double(buffer.readDoubleLE(index));
        index = index + 8;
      } else if (elementType === constants.BSON_DATA_NUMBER) {
        object[name] = buffer.readDoubleLE(index);
        index = index + 8;
      } else if (elementType === constants.BSON_DATA_DATE) {
        var lowBits =
          buffer[index++] |
          (buffer[index++] << 8) |
          (buffer[index++] << 16) |
          (buffer[index++] << 24);
        var highBits =
          buffer[index++] |
          (buffer[index++] << 8) |
          (buffer[index++] << 16) |
          (buffer[index++] << 24);
        object[name] = new Date(new long_1.Long(lowBits, highBits).toNumber());
      } else if (elementType === constants.BSON_DATA_BOOLEAN) {
        if (buffer[index] !== 0 && buffer[index] !== 1)
          throw new Error('illegal boolean type value');
        object[name] = buffer[index++] === 1;
      } else if (elementType === constants.BSON_DATA_OBJECT) {
        var _index = index;
        var objectSize =
          buffer[index] |
          (buffer[index + 1] << 8) |
          (buffer[index + 2] << 16) |
          (buffer[index + 3] << 24);
        if (objectSize <= 0 || objectSize > buffer.length - index)
          throw new Error('bad embedded document length in bson');
        if (raw) {
          object[name] = buffer.slice(index, index + objectSize);
        } else {
          object[name] = deserializeObject(buffer, _index, options, false);
        }
        index = index + objectSize;
      } else if (elementType === constants.BSON_DATA_ARRAY) {
        var _index = index;
        var objectSize =
          buffer[index] |
          (buffer[index + 1] << 8) |
          (buffer[index + 2] << 16) |
          (buffer[index + 3] << 24);
        var arrayOptions = options;
        var stopIndex = index + objectSize;
        if (fieldsAsRaw && fieldsAsRaw[name]) {
          arrayOptions = {};
          for (var n in options) {
            arrayOptions[n] = options[n];
          }
          arrayOptions['raw'] = true;
        }
        object[name] = deserializeObject(buffer, _index, arrayOptions, true);
        index = index + objectSize;
        if (buffer[index - 1] !== 0)
          throw new Error('invalid array terminator byte');
        if (index !== stopIndex) throw new Error('corrupted array bson');
      } else if (elementType === constants.BSON_DATA_UNDEFINED) {
        object[name] = void 0;
      } else if (elementType === constants.BSON_DATA_NULL) {
        object[name] = null;
      } else if (elementType === constants.BSON_DATA_LONG) {
        var lowBits =
          buffer[index++] |
          (buffer[index++] << 8) |
          (buffer[index++] << 16) |
          (buffer[index++] << 24);
        var highBits =
          buffer[index++] |
          (buffer[index++] << 8) |
          (buffer[index++] << 16) |
          (buffer[index++] << 24);
        var long = new long_1.Long(lowBits, highBits);
        if (promoteLongs && promoteValues === true) {
          object[name] =
            long.lessThanOrEqual(JS_INT_MAX_LONG) &&
            long.greaterThanOrEqual(JS_INT_MIN_LONG)
              ? long.toNumber()
              : long;
        } else {
          object[name] = long;
        }
      } else if (elementType === constants.BSON_DATA_DECIMAL128) {
        var bytes = buffer_1.Buffer.alloc(16);
        buffer.copy(bytes, 0, index, index + 16);
        index = index + 16;
        var decimal128 = new decimal128_1.Decimal128(bytes);
        if (
          'toObject' in decimal128 &&
          typeof decimal128.toObject === 'function'
        ) {
          object[name] = decimal128.toObject();
        } else {
          object[name] = decimal128;
        }
      } else if (elementType === constants.BSON_DATA_BINARY) {
        var binarySize =
          buffer[index++] |
          (buffer[index++] << 8) |
          (buffer[index++] << 16) |
          (buffer[index++] << 24);
        var totalBinarySize = binarySize;
        var subType = buffer[index++];
        if (binarySize < 0)
          throw new Error('Negative binary type element size found');
        if (binarySize > buffer.byteLength)
          throw new Error('Binary type size larger than document size');
        if (buffer['slice'] != null) {
          if (subType === binary_1.Binary.SUBTYPE_BYTE_ARRAY) {
            binarySize =
              buffer[index++] |
              (buffer[index++] << 8) |
              (buffer[index++] << 16) |
              (buffer[index++] << 24);
            if (binarySize < 0)
              throw new Error(
                'Negative binary type element size found for subtype 0x02',
              );
            if (binarySize > totalBinarySize - 4)
              throw new Error(
                'Binary type with subtype 0x02 contains too long binary size',
              );
            if (binarySize < totalBinarySize - 4)
              throw new Error(
                'Binary type with subtype 0x02 contains too short binary size',
              );
          }
          if (promoteBuffers && promoteValues) {
            object[name] = buffer.slice(index, index + binarySize);
          } else {
            object[name] = new binary_1.Binary(
              buffer.slice(index, index + binarySize),
              subType,
            );
          }
        } else {
          var _buffer = buffer_1.Buffer.alloc(binarySize);
          if (subType === binary_1.Binary.SUBTYPE_BYTE_ARRAY) {
            binarySize =
              buffer[index++] |
              (buffer[index++] << 8) |
              (buffer[index++] << 16) |
              (buffer[index++] << 24);
            if (binarySize < 0)
              throw new Error(
                'Negative binary type element size found for subtype 0x02',
              );
            if (binarySize > totalBinarySize - 4)
              throw new Error(
                'Binary type with subtype 0x02 contains too long binary size',
              );
            if (binarySize < totalBinarySize - 4)
              throw new Error(
                'Binary type with subtype 0x02 contains too short binary size',
              );
          }
          for (i = 0; i < binarySize; i++) {
            _buffer[i] = buffer[index + i];
          }
          if (promoteBuffers && promoteValues) {
            object[name] = _buffer;
          } else {
            object[name] = new binary_1.Binary(_buffer, subType);
          }
        }
        index = index + binarySize;
      } else if (
        elementType === constants.BSON_DATA_REGEXP &&
        bsonRegExp === false
      ) {
        i = index;
        while (buffer[i] !== 0 && i < buffer.length) {
          i++;
        }
        if (i >= buffer.length)
          throw new Error('Bad BSON Document: illegal CString');
        var source = buffer.toString('utf8', index, i);
        index = i + 1;
        i = index;
        while (buffer[i] !== 0 && i < buffer.length) {
          i++;
        }
        if (i >= buffer.length)
          throw new Error('Bad BSON Document: illegal CString');
        var regExpOptions = buffer.toString('utf8', index, i);
        index = i + 1;
        var optionsArray = new Array(regExpOptions.length);
        for (i = 0; i < regExpOptions.length; i++) {
          switch (regExpOptions[i]) {
            case 'm':
              optionsArray[i] = 'm';
              break;
            case 's':
              optionsArray[i] = 'g';
              break;
            case 'i':
              optionsArray[i] = 'i';
              break;
          }
        }
        object[name] = new RegExp(source, optionsArray.join(''));
      } else if (
        elementType === constants.BSON_DATA_REGEXP &&
        bsonRegExp === true
      ) {
        i = index;
        while (buffer[i] !== 0 && i < buffer.length) {
          i++;
        }
        if (i >= buffer.length)
          throw new Error('Bad BSON Document: illegal CString');
        var source = buffer.toString('utf8', index, i);
        index = i + 1;
        i = index;
        while (buffer[i] !== 0 && i < buffer.length) {
          i++;
        }
        if (i >= buffer.length)
          throw new Error('Bad BSON Document: illegal CString');
        var regExpOptions = buffer.toString('utf8', index, i);
        index = i + 1;
        object[name] = new regexp_1.BSONRegExp(source, regExpOptions);
      } else if (elementType === constants.BSON_DATA_SYMBOL) {
        var stringSize =
          buffer[index++] |
          (buffer[index++] << 8) |
          (buffer[index++] << 16) |
          (buffer[index++] << 24);
        if (
          stringSize <= 0 ||
          stringSize > buffer.length - index ||
          buffer[index + stringSize - 1] !== 0
        )
          throw new Error('bad string length in bson');
        var symbol = buffer.toString('utf8', index, index + stringSize - 1);
        object[name] = promoteValues ? symbol : new symbol_1.BSONSymbol(symbol);
        index = index + stringSize;
      } else if (elementType === constants.BSON_DATA_TIMESTAMP) {
        var lowBits =
          buffer[index++] |
          (buffer[index++] << 8) |
          (buffer[index++] << 16) |
          (buffer[index++] << 24);
        var highBits =
          buffer[index++] |
          (buffer[index++] << 8) |
          (buffer[index++] << 16) |
          (buffer[index++] << 24);
        object[name] = new timestamp_1.Timestamp(lowBits, highBits);
      } else if (elementType === constants.BSON_DATA_MIN_KEY) {
        object[name] = new min_key_1.MinKey();
      } else if (elementType === constants.BSON_DATA_MAX_KEY) {
        object[name] = new max_key_1.MaxKey();
      } else if (elementType === constants.BSON_DATA_CODE) {
        var stringSize =
          buffer[index++] |
          (buffer[index++] << 8) |
          (buffer[index++] << 16) |
          (buffer[index++] << 24);
        if (
          stringSize <= 0 ||
          stringSize > buffer.length - index ||
          buffer[index + stringSize - 1] !== 0
        )
          throw new Error('bad string length in bson');
        var functionString = buffer.toString(
          'utf8',
          index,
          index + stringSize - 1,
        );
        if (evalFunctions) {
          if (cacheFunctions) {
            object[name] = isolateEval(functionString, functionCache, object);
          } else {
            object[name] = isolateEval(functionString);
          }
        } else {
          object[name] = new code_1.Code(functionString);
        }
        index = index + stringSize;
      } else if (elementType === constants.BSON_DATA_CODE_W_SCOPE) {
        var totalSize =
          buffer[index++] |
          (buffer[index++] << 8) |
          (buffer[index++] << 16) |
          (buffer[index++] << 24);
        if (totalSize < 4 + 4 + 4 + 1) {
          throw new Error(
            'code_w_scope total size shorter minimum expected length',
          );
        }
        var stringSize =
          buffer[index++] |
          (buffer[index++] << 8) |
          (buffer[index++] << 16) |
          (buffer[index++] << 24);
        if (
          stringSize <= 0 ||
          stringSize > buffer.length - index ||
          buffer[index + stringSize - 1] !== 0
        )
          throw new Error('bad string length in bson');
        var functionString = buffer.toString(
          'utf8',
          index,
          index + stringSize - 1,
        );
        index = index + stringSize;
        var _index = index;
        var objectSize =
          buffer[index] |
          (buffer[index + 1] << 8) |
          (buffer[index + 2] << 16) |
          (buffer[index + 3] << 24);
        var scopeObject = deserializeObject(buffer, _index, options, false);
        index = index + objectSize;
        if (totalSize < 4 + 4 + objectSize + stringSize) {
          throw new Error(
            'code_w_scope total size is too short, truncating scope',
          );
        }
        if (totalSize > 4 + 4 + objectSize + stringSize) {
          throw new Error(
            'code_w_scope total size is too long, clips outer document',
          );
        }
        if (evalFunctions) {
          if (cacheFunctions) {
            object[name] = isolateEval(functionString, functionCache, object);
          } else {
            object[name] = isolateEval(functionString);
          }
          object[name].scope = scopeObject;
        } else {
          object[name] = new code_1.Code(functionString, scopeObject);
        }
      } else if (elementType === constants.BSON_DATA_DBPOINTER) {
        var stringSize =
          buffer[index++] |
          (buffer[index++] << 8) |
          (buffer[index++] << 16) |
          (buffer[index++] << 24);
        if (
          stringSize <= 0 ||
          stringSize > buffer.length - index ||
          buffer[index + stringSize - 1] !== 0
        )
          throw new Error('bad string length in bson');
        if (
          !validate_utf8_1.validateUtf8(buffer, index, index + stringSize - 1)
        ) {
          throw new Error('Invalid UTF-8 string in BSON document');
        }
        var namespace = buffer.toString('utf8', index, index + stringSize - 1);
        index = index + stringSize;
        var oidBuffer = buffer_1.Buffer.alloc(12);
        buffer.copy(oidBuffer, 0, index, index + 12);
        var oid = new objectid_1.ObjectId(oidBuffer);
        index = index + 12;
        object[name] = new db_ref_1.DBRef(namespace, oid);
      } else {
        throw new Error(
          'Detected unknown BSON type ' +
            elementType.toString(16) +
            ' for fieldname "' +
            name +
            '"',
        );
      }
    }
    if (size !== index - startIndex) {
      if (isArray) throw new Error('corrupt array bson');
      throw new Error('corrupt object bson');
    }
    var dollarKeys = Object.keys(object).filter(function (k) {
      return k.startsWith('$');
    });
    var valid = true;
    dollarKeys.forEach(function (k) {
      if (['$ref', '$id', '$db'].indexOf(k) === -1) valid = false;
    });
    if (!valid) return object;
    if (db_ref_1.isDBRefLike(object)) {
      var copy = Object.assign({}, object);
      delete copy.$ref;
      delete copy.$id;
      delete copy.$db;
      return new db_ref_1.DBRef(object.$ref, object.$id, object.$db, copy);
    }
    return object;
  }
  function isolateEval(functionString, functionCache2, object) {
    if (!functionCache2) return new Function(functionString);
    if (functionCache2[functionString] == null) {
      functionCache2[functionString] = new Function(functionString);
    }
    return functionCache2[functionString].bind(object);
  }
});

// node_modules/@cloudbase/node-sdk/node_modules/bson/lib/float_parser.js
var require_float_parser = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  exports2.writeIEEE754 = exports2.readIEEE754 = void 0;
  function readIEEE754(buffer, offset, endian, mLen, nBytes) {
    var e;
    var m;
    var bBE = endian === 'big';
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = bBE ? 0 : nBytes - 1;
    var d = bBE ? 1 : -1;
    var s = buffer[offset + i];
    i += d;
    e = s & ((1 << -nBits) - 1);
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & ((1 << -nBits) - 1);
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  }
  exports2.readIEEE754 = readIEEE754;
  function writeIEEE754(buffer, value, offset, endian, mLen, nBytes) {
    var e;
    var m;
    var c;
    var bBE = endian === 'big';
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = bBE ? nBytes - 1 : 0;
    var d = bBE ? -1 : 1;
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    if (isNaN(value)) m = 0;
    while (mLen >= 8) {
      buffer[offset + i] = m & 255;
      i += d;
      m /= 256;
      mLen -= 8;
    }
    e = (e << mLen) | m;
    if (isNaN(value)) e += 8;
    eLen += mLen;
    while (eLen > 0) {
      buffer[offset + i] = e & 255;
      i += d;
      e /= 256;
      eLen -= 8;
    }
    buffer[offset + i - d] |= s * 128;
  }
  exports2.writeIEEE754 = writeIEEE754;
});

// node_modules/@cloudbase/node-sdk/node_modules/bson/lib/parser/serializer.js
var require_serializer = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  exports2.serializeInto = void 0;
  var binary_1 = require_binary();
  var constants = require_constants();
  var ensure_buffer_1 = require_ensure_buffer();
  var extended_json_1 = require_extended_json();
  var float_parser_1 = require_float_parser();
  var long_1 = require_long();
  var map_1 = require_map();
  var utils_1 = require_utils();
  var regexp = /\x00/;
  var ignoreKeys = new Set(['$db', '$ref', '$id', '$clusterTime']);
  function isRegExp(d) {
    return Object.prototype.toString.call(d) === '[object RegExp]';
  }
  function serializeString(buffer, key, value, index, isArray) {
    buffer[index++] = constants.BSON_DATA_STRING;
    var numberOfWrittenBytes = !isArray
      ? buffer.write(key, index, void 0, 'utf8')
      : buffer.write(key, index, void 0, 'ascii');
    index = index + numberOfWrittenBytes + 1;
    buffer[index - 1] = 0;
    var size = buffer.write(value, index + 4, void 0, 'utf8');
    buffer[index + 3] = ((size + 1) >> 24) & 255;
    buffer[index + 2] = ((size + 1) >> 16) & 255;
    buffer[index + 1] = ((size + 1) >> 8) & 255;
    buffer[index] = (size + 1) & 255;
    index = index + 4 + size;
    buffer[index++] = 0;
    return index;
  }
  function serializeNumber(buffer, key, value, index, isArray) {
    if (
      Number.isInteger(value) &&
      value >= constants.BSON_INT32_MIN &&
      value <= constants.BSON_INT32_MAX
    ) {
      buffer[index++] = constants.BSON_DATA_INT;
      var numberOfWrittenBytes = !isArray
        ? buffer.write(key, index, void 0, 'utf8')
        : buffer.write(key, index, void 0, 'ascii');
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      buffer[index++] = value & 255;
      buffer[index++] = (value >> 8) & 255;
      buffer[index++] = (value >> 16) & 255;
      buffer[index++] = (value >> 24) & 255;
    } else {
      buffer[index++] = constants.BSON_DATA_NUMBER;
      var numberOfWrittenBytes = !isArray
        ? buffer.write(key, index, void 0, 'utf8')
        : buffer.write(key, index, void 0, 'ascii');
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      float_parser_1.writeIEEE754(buffer, value, index, 'little', 52, 8);
      index = index + 8;
    }
    return index;
  }
  function serializeNull(buffer, key, _2, index, isArray) {
    buffer[index++] = constants.BSON_DATA_NULL;
    var numberOfWrittenBytes = !isArray
      ? buffer.write(key, index, void 0, 'utf8')
      : buffer.write(key, index, void 0, 'ascii');
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    return index;
  }
  function serializeBoolean(buffer, key, value, index, isArray) {
    buffer[index++] = constants.BSON_DATA_BOOLEAN;
    var numberOfWrittenBytes = !isArray
      ? buffer.write(key, index, void 0, 'utf8')
      : buffer.write(key, index, void 0, 'ascii');
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    buffer[index++] = value ? 1 : 0;
    return index;
  }
  function serializeDate(buffer, key, value, index, isArray) {
    buffer[index++] = constants.BSON_DATA_DATE;
    var numberOfWrittenBytes = !isArray
      ? buffer.write(key, index, void 0, 'utf8')
      : buffer.write(key, index, void 0, 'ascii');
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    var dateInMilis = long_1.Long.fromNumber(value.getTime());
    var lowBits = dateInMilis.getLowBits();
    var highBits = dateInMilis.getHighBits();
    buffer[index++] = lowBits & 255;
    buffer[index++] = (lowBits >> 8) & 255;
    buffer[index++] = (lowBits >> 16) & 255;
    buffer[index++] = (lowBits >> 24) & 255;
    buffer[index++] = highBits & 255;
    buffer[index++] = (highBits >> 8) & 255;
    buffer[index++] = (highBits >> 16) & 255;
    buffer[index++] = (highBits >> 24) & 255;
    return index;
  }
  function serializeRegExp(buffer, key, value, index, isArray) {
    buffer[index++] = constants.BSON_DATA_REGEXP;
    var numberOfWrittenBytes = !isArray
      ? buffer.write(key, index, void 0, 'utf8')
      : buffer.write(key, index, void 0, 'ascii');
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    if (value.source && value.source.match(regexp) != null) {
      throw Error('value ' + value.source + ' must not contain null bytes');
    }
    index = index + buffer.write(value.source, index, void 0, 'utf8');
    buffer[index++] = 0;
    if (value.ignoreCase) buffer[index++] = 105;
    if (value.global) buffer[index++] = 115;
    if (value.multiline) buffer[index++] = 109;
    buffer[index++] = 0;
    return index;
  }
  function serializeBSONRegExp(buffer, key, value, index, isArray) {
    buffer[index++] = constants.BSON_DATA_REGEXP;
    var numberOfWrittenBytes = !isArray
      ? buffer.write(key, index, void 0, 'utf8')
      : buffer.write(key, index, void 0, 'ascii');
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    if (value.pattern.match(regexp) != null) {
      throw Error('pattern ' + value.pattern + ' must not contain null bytes');
    }
    index = index + buffer.write(value.pattern, index, void 0, 'utf8');
    buffer[index++] = 0;
    index =
      index +
      buffer.write(
        value.options.split('').sort().join(''),
        index,
        void 0,
        'utf8',
      );
    buffer[index++] = 0;
    return index;
  }
  function serializeMinMax(buffer, key, value, index, isArray) {
    if (value === null) {
      buffer[index++] = constants.BSON_DATA_NULL;
    } else if (value._bsontype === 'MinKey') {
      buffer[index++] = constants.BSON_DATA_MIN_KEY;
    } else {
      buffer[index++] = constants.BSON_DATA_MAX_KEY;
    }
    var numberOfWrittenBytes = !isArray
      ? buffer.write(key, index, void 0, 'utf8')
      : buffer.write(key, index, void 0, 'ascii');
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    return index;
  }
  function serializeObjectId(buffer, key, value, index, isArray) {
    buffer[index++] = constants.BSON_DATA_OID;
    var numberOfWrittenBytes = !isArray
      ? buffer.write(key, index, void 0, 'utf8')
      : buffer.write(key, index, void 0, 'ascii');
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    if (typeof value.id === 'string') {
      buffer.write(value.id, index, void 0, 'binary');
    } else if (value.id && value.id.copy) {
      value.id.copy(buffer, index, 0, 12);
    } else {
      throw new TypeError(
        'object [' + JSON.stringify(value) + '] is not a valid ObjectId',
      );
    }
    return index + 12;
  }
  function serializeBuffer(buffer, key, value, index, isArray) {
    buffer[index++] = constants.BSON_DATA_BINARY;
    var numberOfWrittenBytes = !isArray
      ? buffer.write(key, index, void 0, 'utf8')
      : buffer.write(key, index, void 0, 'ascii');
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    var size = value.length;
    buffer[index++] = size & 255;
    buffer[index++] = (size >> 8) & 255;
    buffer[index++] = (size >> 16) & 255;
    buffer[index++] = (size >> 24) & 255;
    buffer[index++] = constants.BSON_BINARY_SUBTYPE_DEFAULT;
    buffer.set(ensure_buffer_1.ensureBuffer(value), index);
    index = index + size;
    return index;
  }
  function serializeObject(
    buffer,
    key,
    value,
    index,
    checkKeys,
    depth,
    serializeFunctions,
    ignoreUndefined,
    isArray,
    path,
  ) {
    if (checkKeys === void 0) {
      checkKeys = false;
    }
    if (depth === void 0) {
      depth = 0;
    }
    if (serializeFunctions === void 0) {
      serializeFunctions = false;
    }
    if (ignoreUndefined === void 0) {
      ignoreUndefined = true;
    }
    if (isArray === void 0) {
      isArray = false;
    }
    if (path === void 0) {
      path = [];
    }
    for (var i = 0; i < path.length; i++) {
      if (path[i] === value) throw new Error('cyclic dependency detected');
    }
    path.push(value);
    buffer[index++] = Array.isArray(value)
      ? constants.BSON_DATA_ARRAY
      : constants.BSON_DATA_OBJECT;
    var numberOfWrittenBytes = !isArray
      ? buffer.write(key, index, void 0, 'utf8')
      : buffer.write(key, index, void 0, 'ascii');
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    var endIndex = serializeInto(
      buffer,
      value,
      checkKeys,
      index,
      depth + 1,
      serializeFunctions,
      ignoreUndefined,
      path,
    );
    path.pop();
    return endIndex;
  }
  function serializeDecimal128(buffer, key, value, index, isArray) {
    buffer[index++] = constants.BSON_DATA_DECIMAL128;
    var numberOfWrittenBytes = !isArray
      ? buffer.write(key, index, void 0, 'utf8')
      : buffer.write(key, index, void 0, 'ascii');
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    value.bytes.copy(buffer, index, 0, 16);
    return index + 16;
  }
  function serializeLong(buffer, key, value, index, isArray) {
    buffer[index++] =
      value._bsontype === 'Long'
        ? constants.BSON_DATA_LONG
        : constants.BSON_DATA_TIMESTAMP;
    var numberOfWrittenBytes = !isArray
      ? buffer.write(key, index, void 0, 'utf8')
      : buffer.write(key, index, void 0, 'ascii');
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    var lowBits = value.getLowBits();
    var highBits = value.getHighBits();
    buffer[index++] = lowBits & 255;
    buffer[index++] = (lowBits >> 8) & 255;
    buffer[index++] = (lowBits >> 16) & 255;
    buffer[index++] = (lowBits >> 24) & 255;
    buffer[index++] = highBits & 255;
    buffer[index++] = (highBits >> 8) & 255;
    buffer[index++] = (highBits >> 16) & 255;
    buffer[index++] = (highBits >> 24) & 255;
    return index;
  }
  function serializeInt32(buffer, key, value, index, isArray) {
    value = value.valueOf();
    buffer[index++] = constants.BSON_DATA_INT;
    var numberOfWrittenBytes = !isArray
      ? buffer.write(key, index, void 0, 'utf8')
      : buffer.write(key, index, void 0, 'ascii');
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    buffer[index++] = value & 255;
    buffer[index++] = (value >> 8) & 255;
    buffer[index++] = (value >> 16) & 255;
    buffer[index++] = (value >> 24) & 255;
    return index;
  }
  function serializeDouble(buffer, key, value, index, isArray) {
    buffer[index++] = constants.BSON_DATA_NUMBER;
    var numberOfWrittenBytes = !isArray
      ? buffer.write(key, index, void 0, 'utf8')
      : buffer.write(key, index, void 0, 'ascii');
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    float_parser_1.writeIEEE754(buffer, value.value, index, 'little', 52, 8);
    index = index + 8;
    return index;
  }
  function serializeFunction(
    buffer,
    key,
    value,
    index,
    _checkKeys,
    _depth,
    isArray,
  ) {
    if (_checkKeys === void 0) {
      _checkKeys = false;
    }
    if (_depth === void 0) {
      _depth = 0;
    }
    buffer[index++] = constants.BSON_DATA_CODE;
    var numberOfWrittenBytes = !isArray
      ? buffer.write(key, index, void 0, 'utf8')
      : buffer.write(key, index, void 0, 'ascii');
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    var functionString = utils_1.normalizedFunctionString(value);
    var size = buffer.write(functionString, index + 4, void 0, 'utf8') + 1;
    buffer[index] = size & 255;
    buffer[index + 1] = (size >> 8) & 255;
    buffer[index + 2] = (size >> 16) & 255;
    buffer[index + 3] = (size >> 24) & 255;
    index = index + 4 + size - 1;
    buffer[index++] = 0;
    return index;
  }
  function serializeCode(
    buffer,
    key,
    value,
    index,
    checkKeys,
    depth,
    serializeFunctions,
    ignoreUndefined,
    isArray,
  ) {
    if (checkKeys === void 0) {
      checkKeys = false;
    }
    if (depth === void 0) {
      depth = 0;
    }
    if (serializeFunctions === void 0) {
      serializeFunctions = false;
    }
    if (ignoreUndefined === void 0) {
      ignoreUndefined = true;
    }
    if (isArray === void 0) {
      isArray = false;
    }
    if (value.scope && typeof value.scope === 'object') {
      buffer[index++] = constants.BSON_DATA_CODE_W_SCOPE;
      var numberOfWrittenBytes = !isArray
        ? buffer.write(key, index, void 0, 'utf8')
        : buffer.write(key, index, void 0, 'ascii');
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var startIndex = index;
      var functionString =
        typeof value.code === 'string' ? value.code : value.code.toString();
      index = index + 4;
      var codeSize =
        buffer.write(functionString, index + 4, void 0, 'utf8') + 1;
      buffer[index] = codeSize & 255;
      buffer[index + 1] = (codeSize >> 8) & 255;
      buffer[index + 2] = (codeSize >> 16) & 255;
      buffer[index + 3] = (codeSize >> 24) & 255;
      buffer[index + 4 + codeSize - 1] = 0;
      index = index + codeSize + 4;
      var endIndex = serializeInto(
        buffer,
        value.scope,
        checkKeys,
        index,
        depth + 1,
        serializeFunctions,
        ignoreUndefined,
      );
      index = endIndex - 1;
      var totalSize = endIndex - startIndex;
      buffer[startIndex++] = totalSize & 255;
      buffer[startIndex++] = (totalSize >> 8) & 255;
      buffer[startIndex++] = (totalSize >> 16) & 255;
      buffer[startIndex++] = (totalSize >> 24) & 255;
      buffer[index++] = 0;
    } else {
      buffer[index++] = constants.BSON_DATA_CODE;
      var numberOfWrittenBytes = !isArray
        ? buffer.write(key, index, void 0, 'utf8')
        : buffer.write(key, index, void 0, 'ascii');
      index = index + numberOfWrittenBytes;
      buffer[index++] = 0;
      var functionString = value.code.toString();
      var size = buffer.write(functionString, index + 4, void 0, 'utf8') + 1;
      buffer[index] = size & 255;
      buffer[index + 1] = (size >> 8) & 255;
      buffer[index + 2] = (size >> 16) & 255;
      buffer[index + 3] = (size >> 24) & 255;
      index = index + 4 + size - 1;
      buffer[index++] = 0;
    }
    return index;
  }
  function serializeBinary(buffer, key, value, index, isArray) {
    buffer[index++] = constants.BSON_DATA_BINARY;
    var numberOfWrittenBytes = !isArray
      ? buffer.write(key, index, void 0, 'utf8')
      : buffer.write(key, index, void 0, 'ascii');
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    var data = value.value(true);
    var size = value.position;
    if (value.sub_type === binary_1.Binary.SUBTYPE_BYTE_ARRAY) size = size + 4;
    buffer[index++] = size & 255;
    buffer[index++] = (size >> 8) & 255;
    buffer[index++] = (size >> 16) & 255;
    buffer[index++] = (size >> 24) & 255;
    buffer[index++] = value.sub_type;
    if (value.sub_type === binary_1.Binary.SUBTYPE_BYTE_ARRAY) {
      size = size - 4;
      buffer[index++] = size & 255;
      buffer[index++] = (size >> 8) & 255;
      buffer[index++] = (size >> 16) & 255;
      buffer[index++] = (size >> 24) & 255;
    }
    buffer.set(data, index);
    index = index + value.position;
    return index;
  }
  function serializeSymbol(buffer, key, value, index, isArray) {
    buffer[index++] = constants.BSON_DATA_SYMBOL;
    var numberOfWrittenBytes = !isArray
      ? buffer.write(key, index, void 0, 'utf8')
      : buffer.write(key, index, void 0, 'ascii');
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    var size = buffer.write(value.value, index + 4, void 0, 'utf8') + 1;
    buffer[index] = size & 255;
    buffer[index + 1] = (size >> 8) & 255;
    buffer[index + 2] = (size >> 16) & 255;
    buffer[index + 3] = (size >> 24) & 255;
    index = index + 4 + size - 1;
    buffer[index++] = 0;
    return index;
  }
  function serializeDBRef(
    buffer,
    key,
    value,
    index,
    depth,
    serializeFunctions,
    isArray,
  ) {
    buffer[index++] = constants.BSON_DATA_OBJECT;
    var numberOfWrittenBytes = !isArray
      ? buffer.write(key, index, void 0, 'utf8')
      : buffer.write(key, index, void 0, 'ascii');
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    var startIndex = index;
    var output = {
      $ref: value.collection || value.namespace,
      $id: value.oid,
    };
    if (value.db != null) {
      output.$db = value.db;
    }
    output = Object.assign(output, value.fields);
    var endIndex = serializeInto(
      buffer,
      output,
      false,
      index,
      depth + 1,
      serializeFunctions,
    );
    var size = endIndex - startIndex;
    buffer[startIndex++] = size & 255;
    buffer[startIndex++] = (size >> 8) & 255;
    buffer[startIndex++] = (size >> 16) & 255;
    buffer[startIndex++] = (size >> 24) & 255;
    return endIndex;
  }
  function serializeInto(
    buffer,
    object,
    checkKeys,
    startingIndex,
    depth,
    serializeFunctions,
    ignoreUndefined,
    path,
  ) {
    if (checkKeys === void 0) {
      checkKeys = false;
    }
    if (startingIndex === void 0) {
      startingIndex = 0;
    }
    if (depth === void 0) {
      depth = 0;
    }
    if (serializeFunctions === void 0) {
      serializeFunctions = false;
    }
    if (ignoreUndefined === void 0) {
      ignoreUndefined = true;
    }
    if (path === void 0) {
      path = [];
    }
    startingIndex = startingIndex || 0;
    path = path || [];
    path.push(object);
    var index = startingIndex + 4;
    if (Array.isArray(object)) {
      for (var i = 0; i < object.length; i++) {
        var key = '' + i;
        var value = object[i];
        if (value && value.toBSON) {
          if (typeof value.toBSON !== 'function')
            throw new TypeError('toBSON is not a function');
          value = value.toBSON();
        }
        if (typeof value === 'string') {
          index = serializeString(buffer, key, value, index, true);
        } else if (typeof value === 'number') {
          index = serializeNumber(buffer, key, value, index, true);
        } else if (typeof value === 'bigint') {
          throw new TypeError('Unsupported type BigInt, please use Decimal128');
        } else if (typeof value === 'boolean') {
          index = serializeBoolean(buffer, key, value, index, true);
        } else if (value instanceof Date || utils_1.isDate(value)) {
          index = serializeDate(buffer, key, value, index, true);
        } else if (value === void 0) {
          index = serializeNull(buffer, key, value, index, true);
        } else if (value === null) {
          index = serializeNull(buffer, key, value, index, true);
        } else if (
          value['_bsontype'] === 'ObjectId' ||
          value['_bsontype'] === 'ObjectID'
        ) {
          index = serializeObjectId(buffer, key, value, index, true);
        } else if (utils_1.isBuffer(value) || utils_1.isUint8Array(value)) {
          index = serializeBuffer(buffer, key, value, index, true);
        } else if (value instanceof RegExp || isRegExp(value)) {
          index = serializeRegExp(buffer, key, value, index, true);
        } else if (typeof value === 'object' && value['_bsontype'] == null) {
          index = serializeObject(
            buffer,
            key,
            value,
            index,
            checkKeys,
            depth,
            serializeFunctions,
            ignoreUndefined,
            true,
            path,
          );
        } else if (
          typeof value === 'object' &&
          extended_json_1.isBSONType(value) &&
          value._bsontype === 'Decimal128'
        ) {
          index = serializeDecimal128(buffer, key, value, index, true);
        } else if (
          value['_bsontype'] === 'Long' ||
          value['_bsontype'] === 'Timestamp'
        ) {
          index = serializeLong(buffer, key, value, index, true);
        } else if (value['_bsontype'] === 'Double') {
          index = serializeDouble(buffer, key, value, index, true);
        } else if (typeof value === 'function' && serializeFunctions) {
          index = serializeFunction(
            buffer,
            key,
            value,
            index,
            checkKeys,
            depth,
            true,
          );
        } else if (value['_bsontype'] === 'Code') {
          index = serializeCode(
            buffer,
            key,
            value,
            index,
            checkKeys,
            depth,
            serializeFunctions,
            ignoreUndefined,
            true,
          );
        } else if (value['_bsontype'] === 'Binary') {
          index = serializeBinary(buffer, key, value, index, true);
        } else if (value['_bsontype'] === 'Symbol') {
          index = serializeSymbol(buffer, key, value, index, true);
        } else if (value['_bsontype'] === 'DBRef') {
          index = serializeDBRef(
            buffer,
            key,
            value,
            index,
            depth,
            serializeFunctions,
            true,
          );
        } else if (value['_bsontype'] === 'BSONRegExp') {
          index = serializeBSONRegExp(buffer, key, value, index, true);
        } else if (value['_bsontype'] === 'Int32') {
          index = serializeInt32(buffer, key, value, index, true);
        } else if (
          value['_bsontype'] === 'MinKey' ||
          value['_bsontype'] === 'MaxKey'
        ) {
          index = serializeMinMax(buffer, key, value, index, true);
        } else if (typeof value['_bsontype'] !== 'undefined') {
          throw new TypeError(
            'Unrecognized or invalid _bsontype: ' + value['_bsontype'],
          );
        }
      }
    } else if (object instanceof map_1.Map) {
      var iterator = object.entries();
      var done = false;
      while (!done) {
        var entry = iterator.next();
        done = !!entry.done;
        if (done) continue;
        var key = entry.value[0];
        var value = entry.value[1];
        var type = typeof value;
        if (typeof key === 'string' && !ignoreKeys.has(key)) {
          if (key.match(regexp) != null) {
            throw Error('key ' + key + ' must not contain null bytes');
          }
          if (checkKeys) {
            if (key[0] === '$') {
              throw Error('key ' + key + " must not start with '$'");
            } else if (~key.indexOf('.')) {
              throw Error('key ' + key + " must not contain '.'");
            }
          }
        }
        if (type === 'string') {
          index = serializeString(buffer, key, value, index);
        } else if (type === 'number') {
          index = serializeNumber(buffer, key, value, index);
        } else if (
          type === 'bigint' ||
          utils_1.isBigInt64Array(value) ||
          utils_1.isBigUInt64Array(value)
        ) {
          throw new TypeError('Unsupported type BigInt, please use Decimal128');
        } else if (type === 'boolean') {
          index = serializeBoolean(buffer, key, value, index);
        } else if (value instanceof Date || utils_1.isDate(value)) {
          index = serializeDate(buffer, key, value, index);
        } else if (
          value === null ||
          (value === void 0 && ignoreUndefined === false)
        ) {
          index = serializeNull(buffer, key, value, index);
        } else if (
          value['_bsontype'] === 'ObjectId' ||
          value['_bsontype'] === 'ObjectID'
        ) {
          index = serializeObjectId(buffer, key, value, index);
        } else if (utils_1.isBuffer(value) || utils_1.isUint8Array(value)) {
          index = serializeBuffer(buffer, key, value, index);
        } else if (value instanceof RegExp || isRegExp(value)) {
          index = serializeRegExp(buffer, key, value, index);
        } else if (type === 'object' && value['_bsontype'] == null) {
          index = serializeObject(
            buffer,
            key,
            value,
            index,
            checkKeys,
            depth,
            serializeFunctions,
            ignoreUndefined,
            false,
            path,
          );
        } else if (type === 'object' && value['_bsontype'] === 'Decimal128') {
          index = serializeDecimal128(buffer, key, value, index);
        } else if (
          value['_bsontype'] === 'Long' ||
          value['_bsontype'] === 'Timestamp'
        ) {
          index = serializeLong(buffer, key, value, index);
        } else if (value['_bsontype'] === 'Double') {
          index = serializeDouble(buffer, key, value, index);
        } else if (value['_bsontype'] === 'Code') {
          index = serializeCode(
            buffer,
            key,
            value,
            index,
            checkKeys,
            depth,
            serializeFunctions,
            ignoreUndefined,
          );
        } else if (typeof value === 'function' && serializeFunctions) {
          index = serializeFunction(
            buffer,
            key,
            value,
            index,
            checkKeys,
            depth,
            serializeFunctions,
          );
        } else if (value['_bsontype'] === 'Binary') {
          index = serializeBinary(buffer, key, value, index);
        } else if (value['_bsontype'] === 'Symbol') {
          index = serializeSymbol(buffer, key, value, index);
        } else if (value['_bsontype'] === 'DBRef') {
          index = serializeDBRef(
            buffer,
            key,
            value,
            index,
            depth,
            serializeFunctions,
          );
        } else if (value['_bsontype'] === 'BSONRegExp') {
          index = serializeBSONRegExp(buffer, key, value, index);
        } else if (value['_bsontype'] === 'Int32') {
          index = serializeInt32(buffer, key, value, index);
        } else if (
          value['_bsontype'] === 'MinKey' ||
          value['_bsontype'] === 'MaxKey'
        ) {
          index = serializeMinMax(buffer, key, value, index);
        } else if (typeof value['_bsontype'] !== 'undefined') {
          throw new TypeError(
            'Unrecognized or invalid _bsontype: ' + value['_bsontype'],
          );
        }
      }
    } else {
      if (object.toBSON) {
        if (typeof object.toBSON !== 'function')
          throw new TypeError('toBSON is not a function');
        object = object.toBSON();
        if (object != null && typeof object !== 'object')
          throw new TypeError('toBSON function did not return an object');
      }
      for (var key in object) {
        var value = object[key];
        if (value && value.toBSON) {
          if (typeof value.toBSON !== 'function')
            throw new TypeError('toBSON is not a function');
          value = value.toBSON();
        }
        var type = typeof value;
        if (typeof key === 'string' && !ignoreKeys.has(key)) {
          if (key.match(regexp) != null) {
            throw Error('key ' + key + ' must not contain null bytes');
          }
          if (checkKeys) {
            if (key[0] === '$') {
              throw Error('key ' + key + " must not start with '$'");
            } else if (~key.indexOf('.')) {
              throw Error('key ' + key + " must not contain '.'");
            }
          }
        }
        if (type === 'string') {
          index = serializeString(buffer, key, value, index);
        } else if (type === 'number') {
          index = serializeNumber(buffer, key, value, index);
        } else if (type === 'bigint') {
          throw new TypeError('Unsupported type BigInt, please use Decimal128');
        } else if (type === 'boolean') {
          index = serializeBoolean(buffer, key, value, index);
        } else if (value instanceof Date || utils_1.isDate(value)) {
          index = serializeDate(buffer, key, value, index);
        } else if (value === void 0) {
          if (ignoreUndefined === false)
            index = serializeNull(buffer, key, value, index);
        } else if (value === null) {
          index = serializeNull(buffer, key, value, index);
        } else if (
          value['_bsontype'] === 'ObjectId' ||
          value['_bsontype'] === 'ObjectID'
        ) {
          index = serializeObjectId(buffer, key, value, index);
        } else if (utils_1.isBuffer(value) || utils_1.isUint8Array(value)) {
          index = serializeBuffer(buffer, key, value, index);
        } else if (value instanceof RegExp || isRegExp(value)) {
          index = serializeRegExp(buffer, key, value, index);
        } else if (type === 'object' && value['_bsontype'] == null) {
          index = serializeObject(
            buffer,
            key,
            value,
            index,
            checkKeys,
            depth,
            serializeFunctions,
            ignoreUndefined,
            false,
            path,
          );
        } else if (type === 'object' && value['_bsontype'] === 'Decimal128') {
          index = serializeDecimal128(buffer, key, value, index);
        } else if (
          value['_bsontype'] === 'Long' ||
          value['_bsontype'] === 'Timestamp'
        ) {
          index = serializeLong(buffer, key, value, index);
        } else if (value['_bsontype'] === 'Double') {
          index = serializeDouble(buffer, key, value, index);
        } else if (value['_bsontype'] === 'Code') {
          index = serializeCode(
            buffer,
            key,
            value,
            index,
            checkKeys,
            depth,
            serializeFunctions,
            ignoreUndefined,
          );
        } else if (typeof value === 'function' && serializeFunctions) {
          index = serializeFunction(
            buffer,
            key,
            value,
            index,
            checkKeys,
            depth,
            serializeFunctions,
          );
        } else if (value['_bsontype'] === 'Binary') {
          index = serializeBinary(buffer, key, value, index);
        } else if (value['_bsontype'] === 'Symbol') {
          index = serializeSymbol(buffer, key, value, index);
        } else if (value['_bsontype'] === 'DBRef') {
          index = serializeDBRef(
            buffer,
            key,
            value,
            index,
            depth,
            serializeFunctions,
          );
        } else if (value['_bsontype'] === 'BSONRegExp') {
          index = serializeBSONRegExp(buffer, key, value, index);
        } else if (value['_bsontype'] === 'Int32') {
          index = serializeInt32(buffer, key, value, index);
        } else if (
          value['_bsontype'] === 'MinKey' ||
          value['_bsontype'] === 'MaxKey'
        ) {
          index = serializeMinMax(buffer, key, value, index);
        } else if (typeof value['_bsontype'] !== 'undefined') {
          throw new TypeError(
            'Unrecognized or invalid _bsontype: ' + value['_bsontype'],
          );
        }
      }
    }
    path.pop();
    buffer[index++] = 0;
    var size = index - startingIndex;
    buffer[startingIndex++] = size & 255;
    buffer[startingIndex++] = (size >> 8) & 255;
    buffer[startingIndex++] = (size >> 16) & 255;
    buffer[startingIndex++] = (size >> 24) & 255;
    return index;
  }
  exports2.serializeInto = serializeInto;
});

// node_modules/@cloudbase/node-sdk/node_modules/bson/lib/bson.js
var require_bson = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  exports2.deserializeStream = exports2.calculateObjectSize = exports2.deserialize = exports2.serializeWithBufferAndIndex = exports2.serialize = exports2.setInternalBufferSize = exports2.ObjectID = exports2.Decimal128 = exports2.BSONRegExp = exports2.MaxKey = exports2.MinKey = exports2.Int32 = exports2.Double = exports2.Timestamp = exports2.Long = exports2.ObjectId = exports2.Binary = exports2.DBRef = exports2.BSONSymbol = exports2.Map = exports2.Code = exports2.LongWithoutOverridesClass = exports2.EJSON = exports2.BSON_INT64_MIN = exports2.BSON_INT64_MAX = exports2.BSON_INT32_MIN = exports2.BSON_INT32_MAX = exports2.BSON_DATA_UNDEFINED = exports2.BSON_DATA_TIMESTAMP = exports2.BSON_DATA_SYMBOL = exports2.BSON_DATA_STRING = exports2.BSON_DATA_REGEXP = exports2.BSON_DATA_OID = exports2.BSON_DATA_OBJECT = exports2.BSON_DATA_NUMBER = exports2.BSON_DATA_NULL = exports2.BSON_DATA_MIN_KEY = exports2.BSON_DATA_MAX_KEY = exports2.BSON_DATA_LONG = exports2.BSON_DATA_INT = exports2.BSON_DATA_DECIMAL128 = exports2.BSON_DATA_DBPOINTER = exports2.BSON_DATA_DATE = exports2.BSON_DATA_CODE_W_SCOPE = exports2.BSON_DATA_CODE = exports2.BSON_DATA_BOOLEAN = exports2.BSON_DATA_BINARY = exports2.BSON_DATA_ARRAY = exports2.BSON_BINARY_SUBTYPE_UUID_NEW = exports2.BSON_BINARY_SUBTYPE_UUID = exports2.BSON_BINARY_SUBTYPE_USER_DEFINED = exports2.BSON_BINARY_SUBTYPE_MD5 = exports2.BSON_BINARY_SUBTYPE_FUNCTION = exports2.BSON_BINARY_SUBTYPE_DEFAULT = exports2.BSON_BINARY_SUBTYPE_BYTE_ARRAY = void 0;
  var buffer_1 = require('buffer');
  var binary_1 = require_binary();
  Object.defineProperty(exports2, 'Binary', {
    enumerable: true,
    get: function () {
      return binary_1.Binary;
    },
  });
  var code_1 = require_code2();
  Object.defineProperty(exports2, 'Code', {
    enumerable: true,
    get: function () {
      return code_1.Code;
    },
  });
  var db_ref_1 = require_db_ref();
  Object.defineProperty(exports2, 'DBRef', {
    enumerable: true,
    get: function () {
      return db_ref_1.DBRef;
    },
  });
  var decimal128_1 = require_decimal128();
  Object.defineProperty(exports2, 'Decimal128', {
    enumerable: true,
    get: function () {
      return decimal128_1.Decimal128;
    },
  });
  var double_1 = require_double();
  Object.defineProperty(exports2, 'Double', {
    enumerable: true,
    get: function () {
      return double_1.Double;
    },
  });
  var ensure_buffer_1 = require_ensure_buffer();
  var extended_json_1 = require_extended_json();
  var int_32_1 = require_int_32();
  Object.defineProperty(exports2, 'Int32', {
    enumerable: true,
    get: function () {
      return int_32_1.Int32;
    },
  });
  var long_1 = require_long();
  Object.defineProperty(exports2, 'Long', {
    enumerable: true,
    get: function () {
      return long_1.Long;
    },
  });
  var map_1 = require_map();
  Object.defineProperty(exports2, 'Map', {
    enumerable: true,
    get: function () {
      return map_1.Map;
    },
  });
  var max_key_1 = require_max_key();
  Object.defineProperty(exports2, 'MaxKey', {
    enumerable: true,
    get: function () {
      return max_key_1.MaxKey;
    },
  });
  var min_key_1 = require_min_key();
  Object.defineProperty(exports2, 'MinKey', {
    enumerable: true,
    get: function () {
      return min_key_1.MinKey;
    },
  });
  var objectid_1 = require_objectid();
  Object.defineProperty(exports2, 'ObjectId', {
    enumerable: true,
    get: function () {
      return objectid_1.ObjectId;
    },
  });
  Object.defineProperty(exports2, 'ObjectID', {
    enumerable: true,
    get: function () {
      return objectid_1.ObjectId;
    },
  });
  var calculate_size_1 = require_calculate_size();
  var deserializer_1 = require_deserializer();
  var serializer_1 = require_serializer();
  var regexp_1 = require_regexp();
  Object.defineProperty(exports2, 'BSONRegExp', {
    enumerable: true,
    get: function () {
      return regexp_1.BSONRegExp;
    },
  });
  var symbol_1 = require_symbol();
  Object.defineProperty(exports2, 'BSONSymbol', {
    enumerable: true,
    get: function () {
      return symbol_1.BSONSymbol;
    },
  });
  var timestamp_1 = require_timestamp();
  Object.defineProperty(exports2, 'Timestamp', {
    enumerable: true,
    get: function () {
      return timestamp_1.Timestamp;
    },
  });
  var constants_1 = require_constants();
  Object.defineProperty(exports2, 'BSON_BINARY_SUBTYPE_BYTE_ARRAY', {
    enumerable: true,
    get: function () {
      return constants_1.BSON_BINARY_SUBTYPE_BYTE_ARRAY;
    },
  });
  Object.defineProperty(exports2, 'BSON_BINARY_SUBTYPE_DEFAULT', {
    enumerable: true,
    get: function () {
      return constants_1.BSON_BINARY_SUBTYPE_DEFAULT;
    },
  });
  Object.defineProperty(exports2, 'BSON_BINARY_SUBTYPE_FUNCTION', {
    enumerable: true,
    get: function () {
      return constants_1.BSON_BINARY_SUBTYPE_FUNCTION;
    },
  });
  Object.defineProperty(exports2, 'BSON_BINARY_SUBTYPE_MD5', {
    enumerable: true,
    get: function () {
      return constants_1.BSON_BINARY_SUBTYPE_MD5;
    },
  });
  Object.defineProperty(exports2, 'BSON_BINARY_SUBTYPE_USER_DEFINED', {
    enumerable: true,
    get: function () {
      return constants_1.BSON_BINARY_SUBTYPE_USER_DEFINED;
    },
  });
  Object.defineProperty(exports2, 'BSON_BINARY_SUBTYPE_UUID', {
    enumerable: true,
    get: function () {
      return constants_1.BSON_BINARY_SUBTYPE_UUID;
    },
  });
  Object.defineProperty(exports2, 'BSON_BINARY_SUBTYPE_UUID_NEW', {
    enumerable: true,
    get: function () {
      return constants_1.BSON_BINARY_SUBTYPE_UUID_NEW;
    },
  });
  Object.defineProperty(exports2, 'BSON_DATA_ARRAY', {
    enumerable: true,
    get: function () {
      return constants_1.BSON_DATA_ARRAY;
    },
  });
  Object.defineProperty(exports2, 'BSON_DATA_BINARY', {
    enumerable: true,
    get: function () {
      return constants_1.BSON_DATA_BINARY;
    },
  });
  Object.defineProperty(exports2, 'BSON_DATA_BOOLEAN', {
    enumerable: true,
    get: function () {
      return constants_1.BSON_DATA_BOOLEAN;
    },
  });
  Object.defineProperty(exports2, 'BSON_DATA_CODE', {
    enumerable: true,
    get: function () {
      return constants_1.BSON_DATA_CODE;
    },
  });
  Object.defineProperty(exports2, 'BSON_DATA_CODE_W_SCOPE', {
    enumerable: true,
    get: function () {
      return constants_1.BSON_DATA_CODE_W_SCOPE;
    },
  });
  Object.defineProperty(exports2, 'BSON_DATA_DATE', {
    enumerable: true,
    get: function () {
      return constants_1.BSON_DATA_DATE;
    },
  });
  Object.defineProperty(exports2, 'BSON_DATA_DBPOINTER', {
    enumerable: true,
    get: function () {
      return constants_1.BSON_DATA_DBPOINTER;
    },
  });
  Object.defineProperty(exports2, 'BSON_DATA_DECIMAL128', {
    enumerable: true,
    get: function () {
      return constants_1.BSON_DATA_DECIMAL128;
    },
  });
  Object.defineProperty(exports2, 'BSON_DATA_INT', {
    enumerable: true,
    get: function () {
      return constants_1.BSON_DATA_INT;
    },
  });
  Object.defineProperty(exports2, 'BSON_DATA_LONG', {
    enumerable: true,
    get: function () {
      return constants_1.BSON_DATA_LONG;
    },
  });
  Object.defineProperty(exports2, 'BSON_DATA_MAX_KEY', {
    enumerable: true,
    get: function () {
      return constants_1.BSON_DATA_MAX_KEY;
    },
  });
  Object.defineProperty(exports2, 'BSON_DATA_MIN_KEY', {
    enumerable: true,
    get: function () {
      return constants_1.BSON_DATA_MIN_KEY;
    },
  });
  Object.defineProperty(exports2, 'BSON_DATA_NULL', {
    enumerable: true,
    get: function () {
      return constants_1.BSON_DATA_NULL;
    },
  });
  Object.defineProperty(exports2, 'BSON_DATA_NUMBER', {
    enumerable: true,
    get: function () {
      return constants_1.BSON_DATA_NUMBER;
    },
  });
  Object.defineProperty(exports2, 'BSON_DATA_OBJECT', {
    enumerable: true,
    get: function () {
      return constants_1.BSON_DATA_OBJECT;
    },
  });
  Object.defineProperty(exports2, 'BSON_DATA_OID', {
    enumerable: true,
    get: function () {
      return constants_1.BSON_DATA_OID;
    },
  });
  Object.defineProperty(exports2, 'BSON_DATA_REGEXP', {
    enumerable: true,
    get: function () {
      return constants_1.BSON_DATA_REGEXP;
    },
  });
  Object.defineProperty(exports2, 'BSON_DATA_STRING', {
    enumerable: true,
    get: function () {
      return constants_1.BSON_DATA_STRING;
    },
  });
  Object.defineProperty(exports2, 'BSON_DATA_SYMBOL', {
    enumerable: true,
    get: function () {
      return constants_1.BSON_DATA_SYMBOL;
    },
  });
  Object.defineProperty(exports2, 'BSON_DATA_TIMESTAMP', {
    enumerable: true,
    get: function () {
      return constants_1.BSON_DATA_TIMESTAMP;
    },
  });
  Object.defineProperty(exports2, 'BSON_DATA_UNDEFINED', {
    enumerable: true,
    get: function () {
      return constants_1.BSON_DATA_UNDEFINED;
    },
  });
  Object.defineProperty(exports2, 'BSON_INT32_MAX', {
    enumerable: true,
    get: function () {
      return constants_1.BSON_INT32_MAX;
    },
  });
  Object.defineProperty(exports2, 'BSON_INT32_MIN', {
    enumerable: true,
    get: function () {
      return constants_1.BSON_INT32_MIN;
    },
  });
  Object.defineProperty(exports2, 'BSON_INT64_MAX', {
    enumerable: true,
    get: function () {
      return constants_1.BSON_INT64_MAX;
    },
  });
  Object.defineProperty(exports2, 'BSON_INT64_MIN', {
    enumerable: true,
    get: function () {
      return constants_1.BSON_INT64_MIN;
    },
  });
  var extended_json_2 = require_extended_json();
  Object.defineProperty(exports2, 'EJSON', {
    enumerable: true,
    get: function () {
      return extended_json_2.EJSON;
    },
  });
  var timestamp_2 = require_timestamp();
  Object.defineProperty(exports2, 'LongWithoutOverridesClass', {
    enumerable: true,
    get: function () {
      return timestamp_2.LongWithoutOverridesClass;
    },
  });
  var MAXSIZE = 1024 * 1024 * 17;
  var buffer = buffer_1.Buffer.alloc(MAXSIZE);
  function setInternalBufferSize(size) {
    if (buffer.length < size) {
      buffer = buffer_1.Buffer.alloc(size);
    }
  }
  exports2.setInternalBufferSize = setInternalBufferSize;
  function serialize(object, options) {
    if (options === void 0) {
      options = {};
    }
    var checkKeys =
      typeof options.checkKeys === 'boolean' ? options.checkKeys : false;
    var serializeFunctions =
      typeof options.serializeFunctions === 'boolean'
        ? options.serializeFunctions
        : false;
    var ignoreUndefined =
      typeof options.ignoreUndefined === 'boolean'
        ? options.ignoreUndefined
        : true;
    var minInternalBufferSize =
      typeof options.minInternalBufferSize === 'number'
        ? options.minInternalBufferSize
        : MAXSIZE;
    if (buffer.length < minInternalBufferSize) {
      buffer = buffer_1.Buffer.alloc(minInternalBufferSize);
    }
    var serializationIndex = serializer_1.serializeInto(
      buffer,
      object,
      checkKeys,
      0,
      0,
      serializeFunctions,
      ignoreUndefined,
      [],
    );
    var finishedBuffer = buffer_1.Buffer.alloc(serializationIndex);
    buffer.copy(finishedBuffer, 0, 0, finishedBuffer.length);
    return finishedBuffer;
  }
  exports2.serialize = serialize;
  function serializeWithBufferAndIndex(object, finalBuffer, options) {
    if (options === void 0) {
      options = {};
    }
    var checkKeys =
      typeof options.checkKeys === 'boolean' ? options.checkKeys : false;
    var serializeFunctions =
      typeof options.serializeFunctions === 'boolean'
        ? options.serializeFunctions
        : false;
    var ignoreUndefined =
      typeof options.ignoreUndefined === 'boolean'
        ? options.ignoreUndefined
        : true;
    var startIndex = typeof options.index === 'number' ? options.index : 0;
    var serializationIndex = serializer_1.serializeInto(
      buffer,
      object,
      checkKeys,
      0,
      0,
      serializeFunctions,
      ignoreUndefined,
    );
    buffer.copy(finalBuffer, startIndex, 0, serializationIndex);
    return startIndex + serializationIndex - 1;
  }
  exports2.serializeWithBufferAndIndex = serializeWithBufferAndIndex;
  function deserialize(buffer2, options) {
    if (options === void 0) {
      options = {};
    }
    return deserializer_1.deserialize(
      ensure_buffer_1.ensureBuffer(buffer2),
      options,
    );
  }
  exports2.deserialize = deserialize;
  function calculateObjectSize(object, options) {
    if (options === void 0) {
      options = {};
    }
    options = options || {};
    var serializeFunctions =
      typeof options.serializeFunctions === 'boolean'
        ? options.serializeFunctions
        : false;
    var ignoreUndefined =
      typeof options.ignoreUndefined === 'boolean'
        ? options.ignoreUndefined
        : true;
    return calculate_size_1.calculateObjectSize(
      object,
      serializeFunctions,
      ignoreUndefined,
    );
  }
  exports2.calculateObjectSize = calculateObjectSize;
  function deserializeStream(
    data,
    startIndex,
    numberOfDocuments,
    documents,
    docStartIndex,
    options,
  ) {
    var internalOptions = Object.assign(
      { allowObjectSmallerThanBufferSize: true, index: 0 },
      options,
    );
    var bufferData = ensure_buffer_1.ensureBuffer(data);
    var index = startIndex;
    for (var i = 0; i < numberOfDocuments; i++) {
      var size =
        bufferData[index] |
        (bufferData[index + 1] << 8) |
        (bufferData[index + 2] << 16) |
        (bufferData[index + 3] << 24);
      internalOptions.index = index;
      documents[docStartIndex + i] = deserializer_1.deserialize(
        bufferData,
        internalOptions,
      );
      index = index + size;
    }
    return index;
  }
  exports2.deserializeStream = deserializeStream;
  var BSON = {
    Binary: binary_1.Binary,
    Code: code_1.Code,
    DBRef: db_ref_1.DBRef,
    Decimal128: decimal128_1.Decimal128,
    Double: double_1.Double,
    Int32: int_32_1.Int32,
    Long: long_1.Long,
    Map: map_1.Map,
    MaxKey: max_key_1.MaxKey,
    MinKey: min_key_1.MinKey,
    ObjectId: objectid_1.ObjectId,
    ObjectID: objectid_1.ObjectId,
    BSONRegExp: regexp_1.BSONRegExp,
    BSONSymbol: symbol_1.BSONSymbol,
    Timestamp: timestamp_1.Timestamp,
    EJSON: extended_json_1.EJSON,
    setInternalBufferSize,
    serialize,
    serializeWithBufferAndIndex,
    deserialize,
    calculateObjectSize,
    deserializeStream,
  };
  exports2.default = BSON;
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/utils/symbol.js
var require_symbol2 = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var _symbols = [];
  var __internalMark__ = {};
  var HiddenSymbol = class {
    constructor(target) {
      Object.defineProperties(this, {
        target: {
          enumerable: false,
          writable: false,
          configurable: false,
          value: target,
        },
      });
    }
  };
  var InternalSymbol = class extends HiddenSymbol {
    constructor(target, __mark__) {
      if (__mark__ !== __internalMark__) {
        throw new TypeError(
          'InternalSymbol cannot be constructed with new operator',
        );
      }
      super(target);
    }
    static for(target) {
      for (let i = 0, len = _symbols.length; i < len; i++) {
        if (_symbols[i].target === target) {
          return _symbols[i].instance;
        }
      }
      const symbol = new InternalSymbol(target, __internalMark__);
      _symbols.push({
        target,
        instance: symbol,
      });
      return symbol;
    }
  };
  exports2.InternalSymbol = InternalSymbol;
  exports2.default = InternalSymbol;
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/utils/type.js
var require_type = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var symbol_1 = require_symbol2();
  exports2.getType = (x) =>
    Object.prototype.toString.call(x).slice(8, -1).toLowerCase();
  exports2.isObject = (x) => exports2.getType(x) === 'object';
  exports2.isString = (x) => exports2.getType(x) === 'string';
  exports2.isNumber = (x) => exports2.getType(x) === 'number';
  exports2.isPromise = (x) => exports2.getType(x) === 'promise';
  exports2.isFunction = (x) => typeof x === 'function';
  exports2.isArray = (x) => Array.isArray(x);
  exports2.isDate = (x) => exports2.getType(x) === 'date';
  exports2.isRegExp = (x) => exports2.getType(x) === 'regexp';
  exports2.isInternalObject = (x) =>
    x && x._internalType instanceof symbol_1.InternalSymbol;
  exports2.isPlainObject = (obj) => {
    if (typeof obj !== 'object' || obj === null) return false;
    let proto = obj;
    while (Object.getPrototypeOf(proto) !== null) {
      proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(obj) === proto;
  };
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/utils/utils.js
var require_utils2 = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var bson_1 = require_bson();
  var type_1 = require_type();
  exports2.sleep = (ms = 0) => new Promise((r) => setTimeout(r, ms));
  var counters = {};
  exports2.autoCount = (domain = 'any') => {
    if (!counters[domain]) {
      counters[domain] = 0;
    }
    return counters[domain]++;
  };
  exports2.getReqOpts = (apiOptions) => {
    if (apiOptions.timeout !== void 0) {
      return {
        timeout: apiOptions.timeout,
      };
    }
    return {};
  };
  exports2.filterUndefined = (o) => {
    if (!type_1.isObject(o)) {
      return o;
    }
    for (let key in o) {
      if (o[key] === void 0) {
        delete o[key];
      } else if (type_1.isObject(o[key])) {
        o[key] = exports2.filterUndefined(o[key]);
      }
    }
    return o;
  };
  exports2.stringifyByEJSON = (params) => {
    params = exports2.filterUndefined(params);
    return bson_1.EJSON.stringify(params, { relaxed: false });
  };
  exports2.parseByEJSON = (params) => {
    return bson_1.EJSON.parse(params);
  };
  var TcbError = class extends Error {
    constructor(error) {
      super(error.message);
      this.code = error.code;
      this.message = error.message;
    }
  };
  exports2.TcbError = TcbError;
  exports2.E = (errObj) => {
    return new TcbError(errObj);
  };
  function processReturn(throwOnCode, res) {
    if (throwOnCode === false) {
      return res;
    }
    throw exports2.E(Object.assign({}, res));
  }
  exports2.processReturn = processReturn;
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/helper/symbol.js
var require_symbol3 = __commonJS((exports2) => {
  'use strict';
  function __export(m) {
    for (var p in m) if (!exports2.hasOwnProperty(p)) exports2[p] = m[p];
  }
  Object.defineProperty(exports2, '__esModule', { value: true });
  var symbol_1 = require_symbol2();
  __export(require_symbol2());
  exports2.SYMBOL_UNSET_FIELD_NAME = symbol_1.default.for('UNSET_FIELD_NAME');
  exports2.SYMBOL_UPDATE_COMMAND = symbol_1.default.for('UPDATE_COMMAND');
  exports2.SYMBOL_QUERY_COMMAND = symbol_1.default.for('QUERY_COMMAND');
  exports2.SYMBOL_LOGIC_COMMAND = symbol_1.default.for('LOGIC_COMMAND');
  exports2.SYMBOL_GEO_POINT = symbol_1.default.for('GEO_POINT');
  exports2.SYMBOL_GEO_LINE_STRING = symbol_1.default.for(
    'SYMBOL_GEO_LINE_STRING',
  );
  exports2.SYMBOL_GEO_POLYGON = symbol_1.default.for('SYMBOL_GEO_POLYGON');
  exports2.SYMBOL_GEO_MULTI_POINT = symbol_1.default.for(
    'SYMBOL_GEO_MULTI_POINT',
  );
  exports2.SYMBOL_GEO_MULTI_LINE_STRING = symbol_1.default.for(
    'SYMBOL_GEO_MULTI_LINE_STRING',
  );
  exports2.SYMBOL_GEO_MULTI_POLYGON = symbol_1.default.for(
    'SYMBOL_GEO_MULTI_POLYGON',
  );
  exports2.SYMBOL_SERVER_DATE = symbol_1.default.for('SERVER_DATE');
  exports2.SYMBOL_REGEXP = symbol_1.default.for('REGEXP');
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/validate.js
var require_validate = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var constant_1 = require_constant();
  var util_1 = require_util();
  var code_1 = require_code();
  var utils_1 = require_utils2();
  var type_1 = require_type();
  var symbol_1 = require_symbol3();
  var validOptionsKeys = [
    'limit',
    'offset',
    'projection',
    'order',
    'multiple',
    'timeout',
  ];
  var Validate = class {
    static isGeopoint(point, degree) {
      if (util_1.Util.whichType(degree) !== constant_1.FieldType.Number) {
        throw new Error('Geo Point must be number type');
      }
      const degreeAbs = Math.abs(degree);
      if (point === 'latitude' && degreeAbs > 90) {
        throw new Error('latitude should be a number ranges from -90 to 90');
      } else if (point === 'longitude' && degreeAbs > 180) {
        throw new Error('longitude should be a number ranges from -180 to 180');
      }
      return true;
    }
    static isInteger(param, num) {
      if (!Number.isInteger(num)) {
        throw new Error(param + constant_1.ErrorCode.IntergerError);
      }
      return true;
    }
    static mustBeBoolean(param, bool) {
      if (typeof bool !== 'boolean') {
        throw new Error(param + constant_1.ErrorCode.BooleanError);
      }
      return true;
    }
    static isProjection(param, value) {
      if (type_1.getType(value) !== 'object') {
        throw utils_1.E(
          Object.assign(Object.assign({}, code_1.ERRORS.INVALID_PARAM), {
            message: `${param} projection must be an object`,
          }),
        );
      }
      for (const key in value) {
        const subValue = value[key];
        if (type_1.getType(subValue) === 'number') {
          if (subValue !== 0 && subValue !== 1) {
            throw utils_1.E(
              Object.assign(Object.assign({}, code_1.ERRORS.INVALID_PARAM), {
                message: `if the value in projection is of number, it must be 0 or 1`,
              }),
            );
          }
        } else if (type_1.getType(subValue) === 'object') {
        } else {
          throw utils_1.E(
            Object.assign(Object.assign({}, code_1.ERRORS.INVALID_PARAM), {
              message: 'invalid projection',
            }),
          );
        }
      }
      return true;
    }
    static isOrder(param, value) {
      if (type_1.getType(value) !== 'object') {
        throw utils_1.E(
          Object.assign(Object.assign({}, code_1.ERRORS.INVALID_PARAM), {
            message: `${param} order must be an object`,
          }),
        );
      }
      for (let key in value) {
        const subValue = value[key];
        if (subValue !== 1 && subValue !== -1) {
          throw utils_1.E(
            Object.assign(Object.assign({}, code_1.ERRORS.INVALID_PARAM), {
              message: `order value must be 1 or -1`,
            }),
          );
        }
      }
      return true;
    }
    static isFieldOrder(direction) {
      if (constant_1.OrderDirectionList.indexOf(direction) === -1) {
        throw new Error(constant_1.ErrorCode.DirectionError);
      }
      return true;
    }
    static isFieldPath(path) {
      if (!/^[a-zA-Z0-9-_\.]/.test(path)) {
        throw new Error();
      }
      return true;
    }
    static isOperator(op) {
      if (constant_1.WhereFilterOpList.indexOf(op) === -1) {
        throw new Error(constant_1.ErrorCode.OpStrError);
      }
      return true;
    }
    static isCollName(name) {
      if (!/^[a-zA-Z0-9]([a-zA-Z0-9-_]){1,32}$/.test(name)) {
        throw new Error(constant_1.ErrorCode.CollNameError);
      }
      return true;
    }
    static isDocID(docId) {
      if (!/^([a-fA-F0-9]){24}$/.test(docId)) {
        throw new Error(constant_1.ErrorCode.DocIDError);
      }
      return true;
    }
    static isValidOptions(options = {}) {
      if (type_1.getType(options) !== 'object') {
        throw utils_1.E(
          Object.assign(Object.assign({}, code_1.ERRORS.INVALID_PARAM), {
            message: `options must be an object`,
          }),
        );
      }
      const keys = Object.keys(options);
      for (const index in keys) {
        if (validOptionsKeys.indexOf(keys[index]) < 0) {
          throw utils_1.E(
            Object.assign(Object.assign({}, code_1.ERRORS.INVALID_PARAM), {
              message: `${keys[index]} is invalid options key`,
            }),
          );
        }
      }
      const { limit, offset, projection, order } = options;
      const { multiple } = options;
      if (limit !== void 0) {
        Validate.isInteger('limit', limit);
      }
      if (offset !== void 0) {
        Validate.isInteger('offset', offset);
      }
      if (projection !== void 0) {
        Validate.isProjection('projection', projection);
      }
      if (order !== void 0) {
        Validate.isOrder('order', order);
      }
      if (multiple !== void 0) {
        Validate.mustBeBoolean('multiple', multiple);
      }
      if (options.timeout !== void 0) {
        Validate.isInteger('timeout', options.timeout);
      }
      return true;
    }
    static isCentersPhere(param) {
      if (Array.isArray(param) && param.length === 2) {
        if (
          type_1.getType(param[0]) === 'object' &&
          param[0]._internalType === symbol_1.SYMBOL_GEO_POINT &&
          typeof param[1] === 'number'
        ) {
          return true;
        }
        if (Array.isArray(param[0]) && param[0].length === 2) {
          const longitude = param[0][0];
          const latitude = param[0][1];
          Validate.isGeopoint('longitude', longitude);
          Validate.isGeopoint('latitude', latitude);
          if (typeof param[1] === 'number') {
            return true;
          }
        }
      }
      throw new Error(`${constant_1.ErrorCode.CentersPhereError}`);
    }
  };
  exports2.Validate = Validate;
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/geo/point.js
var require_point = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var validate_1 = require_validate();
  var symbol_1 = require_symbol3();
  var type_1 = require_type();
  var Point = class {
    constructor(longitude, latitude) {
      validate_1.Validate.isGeopoint('longitude', longitude);
      validate_1.Validate.isGeopoint('latitude', latitude);
      this.longitude = longitude;
      this.latitude = latitude;
    }
    parse(key) {
      return {
        [key]: {
          type: 'Point',
          coordinates: [this.longitude, this.latitude],
        },
      };
    }
    toJSON() {
      return {
        type: 'Point',
        coordinates: [this.longitude, this.latitude],
      };
    }
    toReadableString() {
      return `[${this.longitude},${this.latitude}]`;
    }
    static validate(point) {
      return (
        point.type === 'Point' &&
        type_1.isArray(point.coordinates) &&
        validate_1.Validate.isGeopoint('longitude', point.coordinates[0]) &&
        validate_1.Validate.isGeopoint('latitude', point.coordinates[1])
      );
    }
    get _internalType() {
      return symbol_1.SYMBOL_GEO_POINT;
    }
  };
  exports2.Point = Point;
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/geo/lineString.js
var require_lineString = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var symbol_1 = require_symbol3();
  var point_1 = require_point();
  var type_1 = require_type();
  var LineString = class {
    constructor(points) {
      if (!type_1.isArray(points)) {
        throw new TypeError(
          `"points" must be of type Point[]. Received type ${typeof points}`,
        );
      }
      if (points.length < 2) {
        throw new Error('"points" must contain 2 points at least');
      }
      points.forEach((point) => {
        if (!(point instanceof point_1.Point)) {
          throw new TypeError(
            `"points" must be of type Point[]. Received type ${typeof point}[]`,
          );
        }
      });
      this.points = points;
    }
    parse(key) {
      return {
        [key]: {
          type: 'LineString',
          coordinates: this.points.map((point) => point.toJSON().coordinates),
        },
      };
    }
    toJSON() {
      return {
        type: 'LineString',
        coordinates: this.points.map((point) => point.toJSON().coordinates),
      };
    }
    static validate(lineString) {
      if (
        lineString.type !== 'LineString' ||
        !type_1.isArray(lineString.coordinates)
      ) {
        return false;
      }
      for (let point of lineString.coordinates) {
        if (!type_1.isNumber(point[0]) || !type_1.isNumber(point[1])) {
          return false;
        }
      }
      return true;
    }
    static isClosed(lineString) {
      const firstPoint = lineString.points[0];
      const lastPoint = lineString.points[lineString.points.length - 1];
      if (
        firstPoint.latitude === lastPoint.latitude &&
        firstPoint.longitude === lastPoint.longitude
      ) {
        return true;
      }
    }
    get _internalType() {
      return symbol_1.SYMBOL_GEO_LINE_STRING;
    }
  };
  exports2.LineString = LineString;
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/geo/polygon.js
var require_polygon = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var symbol_1 = require_symbol3();
  var type_1 = require_type();
  var lineString_1 = require_lineString();
  var Polygon = class {
    constructor(lines) {
      if (!type_1.isArray(lines)) {
        throw new TypeError(
          `"lines" must be of type LineString[]. Received type ${typeof lines}`,
        );
      }
      if (lines.length === 0) {
        throw new Error('Polygon must contain 1 linestring at least');
      }
      lines.forEach((line) => {
        if (!(line instanceof lineString_1.LineString)) {
          throw new TypeError(
            `"lines" must be of type LineString[]. Received type ${typeof line}[]`,
          );
        }
        if (!lineString_1.LineString.isClosed(line)) {
          throw new Error(
            `LineString ${line.points.map((p) =>
              p.toReadableString(),
            )} is not a closed cycle`,
          );
        }
      });
      this.lines = lines;
    }
    parse(key) {
      return {
        [key]: {
          type: 'Polygon',
          coordinates: this.lines.map((line) => {
            return line.points.map((point) => [
              point.longitude,
              point.latitude,
            ]);
          }),
        },
      };
    }
    toJSON() {
      return {
        type: 'Polygon',
        coordinates: this.lines.map((line) => {
          return line.points.map((point) => [point.longitude, point.latitude]);
        }),
      };
    }
    static validate(polygon) {
      if (polygon.type !== 'Polygon' || !type_1.isArray(polygon.coordinates)) {
        return false;
      }
      for (let line of polygon.coordinates) {
        if (!this.isCloseLineString(line)) {
          return false;
        }
        for (let point of line) {
          if (!type_1.isNumber(point[0]) || !type_1.isNumber(point[1])) {
            return false;
          }
        }
      }
      return true;
    }
    static isCloseLineString(lineString) {
      const firstPoint = lineString[0];
      const lastPoint = lineString[lineString.length - 1];
      if (firstPoint[0] !== lastPoint[0] || firstPoint[1] !== lastPoint[1]) {
        return false;
      }
      return true;
    }
    get _internalType() {
      return symbol_1.SYMBOL_GEO_POLYGON;
    }
  };
  exports2.Polygon = Polygon;
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/geo/multiPoint.js
var require_multiPoint = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var symbol_1 = require_symbol3();
  var point_1 = require_point();
  var type_1 = require_type();
  var MultiPoint = class {
    constructor(points) {
      if (!type_1.isArray(points)) {
        throw new TypeError(
          `"points" must be of type Point[]. Received type ${typeof points}`,
        );
      }
      if (points.length === 0) {
        throw new Error('"points" must contain 1 point at least');
      }
      points.forEach((point) => {
        if (!(point instanceof point_1.Point)) {
          throw new TypeError(
            `"points" must be of type Point[]. Received type ${typeof point}[]`,
          );
        }
      });
      this.points = points;
    }
    parse(key) {
      return {
        [key]: {
          type: 'MultiPoint',
          coordinates: this.points.map((point) => point.toJSON().coordinates),
        },
      };
    }
    toJSON() {
      return {
        type: 'MultiPoint',
        coordinates: this.points.map((point) => point.toJSON().coordinates),
      };
    }
    static validate(multiPoint) {
      if (
        multiPoint.type !== 'MultiPoint' ||
        !type_1.isArray(multiPoint.coordinates)
      ) {
        return false;
      }
      for (let point of multiPoint.coordinates) {
        if (!type_1.isNumber(point[0]) || !type_1.isNumber(point[1])) {
          return false;
        }
      }
      return true;
    }
    get _internalType() {
      return symbol_1.SYMBOL_GEO_MULTI_POINT;
    }
  };
  exports2.MultiPoint = MultiPoint;
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/geo/multiLineString.js
var require_multiLineString = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var symbol_1 = require_symbol3();
  var type_1 = require_type();
  var lineString_1 = require_lineString();
  var MultiLineString = class {
    constructor(lines) {
      if (!type_1.isArray(lines)) {
        throw new TypeError(
          `"lines" must be of type LineString[]. Received type ${typeof lines}`,
        );
      }
      if (lines.length === 0) {
        throw new Error('Polygon must contain 1 linestring at least');
      }
      lines.forEach((line) => {
        if (!(line instanceof lineString_1.LineString)) {
          throw new TypeError(
            `"lines" must be of type LineString[]. Received type ${typeof line}[]`,
          );
        }
      });
      this.lines = lines;
    }
    parse(key) {
      return {
        [key]: {
          type: 'MultiLineString',
          coordinates: this.lines.map((line) => {
            return line.points.map((point) => [
              point.longitude,
              point.latitude,
            ]);
          }),
        },
      };
    }
    toJSON() {
      return {
        type: 'MultiLineString',
        coordinates: this.lines.map((line) => {
          return line.points.map((point) => [point.longitude, point.latitude]);
        }),
      };
    }
    static validate(multiLineString) {
      if (
        multiLineString.type !== 'MultiLineString' ||
        !type_1.isArray(multiLineString.coordinates)
      ) {
        return false;
      }
      for (let line of multiLineString.coordinates) {
        for (let point of line) {
          if (!type_1.isNumber(point[0]) || !type_1.isNumber(point[1])) {
            return false;
          }
        }
      }
      return true;
    }
    get _internalType() {
      return symbol_1.SYMBOL_GEO_MULTI_LINE_STRING;
    }
  };
  exports2.MultiLineString = MultiLineString;
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/geo/multiPolygon.js
var require_multiPolygon = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var symbol_1 = require_symbol3();
  var type_1 = require_type();
  var polygon_1 = require_polygon();
  var MultiPolygon = class {
    constructor(polygons) {
      if (!type_1.isArray(polygons)) {
        throw new TypeError(
          `"polygons" must be of type Polygon[]. Received type ${typeof polygons}`,
        );
      }
      if (polygons.length === 0) {
        throw new Error('MultiPolygon must contain 1 polygon at least');
      }
      for (let polygon of polygons) {
        if (!(polygon instanceof polygon_1.Polygon)) {
          throw new TypeError(
            `"polygon" must be of type Polygon[]. Received type ${typeof polygon}[]`,
          );
        }
      }
      this.polygons = polygons;
    }
    parse(key) {
      return {
        [key]: {
          type: 'MultiPolygon',
          coordinates: this.polygons.map((polygon) => {
            return polygon.lines.map((line) => {
              return line.points.map((point) => [
                point.longitude,
                point.latitude,
              ]);
            });
          }),
        },
      };
    }
    toJSON() {
      return {
        type: 'MultiPolygon',
        coordinates: this.polygons.map((polygon) => {
          return polygon.lines.map((line) => {
            return line.points.map((point) => [
              point.longitude,
              point.latitude,
            ]);
          });
        }),
      };
    }
    static validate(multiPolygon) {
      if (
        multiPolygon.type !== 'MultiPolygon' ||
        !type_1.isArray(multiPolygon.coordinates)
      ) {
        return false;
      }
      for (let polygon of multiPolygon.coordinates) {
        for (let line of polygon) {
          for (let point of line) {
            if (!type_1.isNumber(point[0]) || !type_1.isNumber(point[1])) {
              return false;
            }
          }
        }
      }
      return true;
    }
    get _internalType() {
      return symbol_1.SYMBOL_GEO_MULTI_POLYGON;
    }
  };
  exports2.MultiPolygon = MultiPolygon;
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/geo/index.js
var require_geo = __commonJS((exports2) => {
  'use strict';
  function __export(m) {
    for (var p in m) if (!exports2.hasOwnProperty(p)) exports2[p] = m[p];
  }
  Object.defineProperty(exports2, '__esModule', { value: true });
  __export(require_point());
  __export(require_lineString());
  __export(require_polygon());
  __export(require_multiPoint());
  __export(require_multiLineString());
  __export(require_multiPolygon());
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/commands/update.js
var require_update = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var symbol_1 = require_symbol3();
  var UPDATE_COMMANDS_LITERAL;
  (function (UPDATE_COMMANDS_LITERAL2) {
    UPDATE_COMMANDS_LITERAL2['SET'] = 'set';
    UPDATE_COMMANDS_LITERAL2['REMOVE'] = 'remove';
    UPDATE_COMMANDS_LITERAL2['INC'] = 'inc';
    UPDATE_COMMANDS_LITERAL2['MUL'] = 'mul';
    UPDATE_COMMANDS_LITERAL2['PUSH'] = 'push';
    UPDATE_COMMANDS_LITERAL2['PULL'] = 'pull';
    UPDATE_COMMANDS_LITERAL2['PULL_ALL'] = 'pullAll';
    UPDATE_COMMANDS_LITERAL2['POP'] = 'pop';
    UPDATE_COMMANDS_LITERAL2['SHIFT'] = 'shift';
    UPDATE_COMMANDS_LITERAL2['UNSHIFT'] = 'unshift';
    UPDATE_COMMANDS_LITERAL2['ADD_TO_SET'] = 'addToSet';
    UPDATE_COMMANDS_LITERAL2['BIT'] = 'bit';
    UPDATE_COMMANDS_LITERAL2['RENAME'] = 'rename';
    UPDATE_COMMANDS_LITERAL2['MAX'] = 'max';
    UPDATE_COMMANDS_LITERAL2['MIN'] = 'min';
  })(
    (UPDATE_COMMANDS_LITERAL =
      exports2.UPDATE_COMMANDS_LITERAL ||
      (exports2.UPDATE_COMMANDS_LITERAL = {})),
  );
  var UpdateCommand = class {
    constructor(operator, operands, fieldName) {
      this._internalType = symbol_1.SYMBOL_UPDATE_COMMAND;
      Object.defineProperties(this, {
        _internalType: {
          enumerable: false,
          configurable: false,
        },
      });
      this.operator = operator;
      this.operands = operands;
      this.fieldName = fieldName || symbol_1.SYMBOL_UNSET_FIELD_NAME;
    }
    _setFieldName(fieldName) {
      const command = new UpdateCommand(
        this.operator,
        this.operands,
        fieldName,
      );
      return command;
    }
  };
  exports2.UpdateCommand = UpdateCommand;
  function isUpdateCommand(object) {
    return (
      object &&
      object instanceof UpdateCommand &&
      object._internalType === symbol_1.SYMBOL_UPDATE_COMMAND
    );
  }
  exports2.isUpdateCommand = isUpdateCommand;
  function isKnownUpdateCommand(object) {
    return (
      isUpdateCommand(object) &&
      object.operator.toUpperCase() in UPDATE_COMMANDS_LITERAL
    );
  }
  exports2.isKnownUpdateCommand = isKnownUpdateCommand;
  exports2.default = UpdateCommand;
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/commands/logic.js
var require_logic = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var symbol_1 = require_symbol3();
  var query_1 = require_query();
  exports2.AND = 'and';
  exports2.OR = 'or';
  exports2.NOT = 'not';
  exports2.NOR = 'nor';
  var LOGIC_COMMANDS_LITERAL;
  (function (LOGIC_COMMANDS_LITERAL2) {
    LOGIC_COMMANDS_LITERAL2['AND'] = 'and';
    LOGIC_COMMANDS_LITERAL2['OR'] = 'or';
    LOGIC_COMMANDS_LITERAL2['NOT'] = 'not';
    LOGIC_COMMANDS_LITERAL2['NOR'] = 'nor';
  })(
    (LOGIC_COMMANDS_LITERAL =
      exports2.LOGIC_COMMANDS_LITERAL ||
      (exports2.LOGIC_COMMANDS_LITERAL = {})),
  );
  var LogicCommand = class {
    constructor(operator, operands, fieldName) {
      this._internalType = symbol_1.SYMBOL_LOGIC_COMMAND;
      Object.defineProperties(this, {
        _internalType: {
          enumerable: false,
          configurable: false,
        },
      });
      this.operator = operator;
      this.operands = operands;
      this.fieldName = fieldName || symbol_1.SYMBOL_UNSET_FIELD_NAME;
      if (this.fieldName !== symbol_1.SYMBOL_UNSET_FIELD_NAME) {
        if (Array.isArray(operands)) {
          operands = operands.slice();
          this.operands = operands;
          for (let i = 0, len = operands.length; i < len; i++) {
            const query = operands[i];
            if (isLogicCommand(query) || query_1.isQueryCommand(query)) {
              operands[i] = query._setFieldName(this.fieldName);
            }
          }
        } else {
          const query = operands;
          if (isLogicCommand(query) || query_1.isQueryCommand(query)) {
            operands = query._setFieldName(this.fieldName);
          }
        }
      }
    }
    _setFieldName(fieldName) {
      const operands = this.operands.map((operand) => {
        if (operand instanceof LogicCommand) {
          return operand._setFieldName(fieldName);
        } else {
          return operand;
        }
      });
      const command = new LogicCommand(this.operator, operands, fieldName);
      return command;
    }
    and(...__expressions__) {
      const expressions = Array.isArray(arguments[0])
        ? arguments[0]
        : Array.from(arguments);
      expressions.unshift(this);
      return new LogicCommand(
        LOGIC_COMMANDS_LITERAL.AND,
        expressions,
        this.fieldName,
      );
    }
    or(...__expressions__) {
      const expressions = Array.isArray(arguments[0])
        ? arguments[0]
        : Array.from(arguments);
      expressions.unshift(this);
      return new LogicCommand(
        LOGIC_COMMANDS_LITERAL.OR,
        expressions,
        this.fieldName,
      );
    }
  };
  exports2.LogicCommand = LogicCommand;
  function isLogicCommand(object) {
    return (
      object &&
      object instanceof LogicCommand &&
      object._internalType === symbol_1.SYMBOL_LOGIC_COMMAND
    );
  }
  exports2.isLogicCommand = isLogicCommand;
  function isKnownLogicCommand(object) {
    return (
      isLogicCommand && object.operator.toUpperCase() in LOGIC_COMMANDS_LITERAL
    );
  }
  exports2.isKnownLogicCommand = isKnownLogicCommand;
  exports2.default = LogicCommand;
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/commands/query.js
var require_query = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var logic_1 = require_logic();
  var symbol_1 = require_symbol3();
  var index_1 = require_geo();
  var type_1 = require_type();
  var validate_1 = require_validate();
  exports2.EQ = 'eq';
  exports2.NEQ = 'neq';
  exports2.GT = 'gt';
  exports2.GTE = 'gte';
  exports2.LT = 'lt';
  exports2.LTE = 'lte';
  exports2.IN = 'in';
  exports2.NIN = 'nin';
  exports2.ALL = 'all';
  exports2.ELEM_MATCH = 'elemMatch';
  exports2.EXISTS = 'exists';
  exports2.SIZE = 'size';
  exports2.MOD = 'mod';
  var QUERY_COMMANDS_LITERAL;
  (function (QUERY_COMMANDS_LITERAL2) {
    QUERY_COMMANDS_LITERAL2['EQ'] = 'eq';
    QUERY_COMMANDS_LITERAL2['NEQ'] = 'neq';
    QUERY_COMMANDS_LITERAL2['GT'] = 'gt';
    QUERY_COMMANDS_LITERAL2['GTE'] = 'gte';
    QUERY_COMMANDS_LITERAL2['LT'] = 'lt';
    QUERY_COMMANDS_LITERAL2['LTE'] = 'lte';
    QUERY_COMMANDS_LITERAL2['IN'] = 'in';
    QUERY_COMMANDS_LITERAL2['NIN'] = 'nin';
    QUERY_COMMANDS_LITERAL2['ALL'] = 'all';
    QUERY_COMMANDS_LITERAL2['ELEM_MATCH'] = 'elemMatch';
    QUERY_COMMANDS_LITERAL2['EXISTS'] = 'exists';
    QUERY_COMMANDS_LITERAL2['SIZE'] = 'size';
    QUERY_COMMANDS_LITERAL2['MOD'] = 'mod';
    QUERY_COMMANDS_LITERAL2['GEO_NEAR'] = 'geoNear';
    QUERY_COMMANDS_LITERAL2['GEO_WITHIN'] = 'geoWithin';
    QUERY_COMMANDS_LITERAL2['GEO_INTERSECTS'] = 'geoIntersects';
  })(
    (QUERY_COMMANDS_LITERAL =
      exports2.QUERY_COMMANDS_LITERAL ||
      (exports2.QUERY_COMMANDS_LITERAL = {})),
  );
  var QueryCommand = class extends logic_1.LogicCommand {
    constructor(operator, operands, fieldName) {
      super(operator, operands, fieldName);
      this.operator = operator;
      this._internalType = symbol_1.SYMBOL_QUERY_COMMAND;
    }
    toJSON() {
      switch (this.operator) {
        case QUERY_COMMANDS_LITERAL.IN:
        case QUERY_COMMANDS_LITERAL.NIN:
          return {
            ['$' + this.operator]: this.operands,
          };
        case QUERY_COMMANDS_LITERAL.NEQ:
          return {
            ['$ne']: this.operands[0],
          };
        default:
          return {
            ['$' + this.operator]: this.operands[0],
          };
      }
    }
    _setFieldName(fieldName) {
      const command = new QueryCommand(this.operator, this.operands, fieldName);
      return command;
    }
    eq(val) {
      const command = new QueryCommand(
        QUERY_COMMANDS_LITERAL.EQ,
        [val],
        this.fieldName,
      );
      return this.and(command);
    }
    neq(val) {
      const command = new QueryCommand(
        QUERY_COMMANDS_LITERAL.NEQ,
        [val],
        this.fieldName,
      );
      return this.and(command);
    }
    gt(val) {
      const command = new QueryCommand(
        QUERY_COMMANDS_LITERAL.GT,
        [val],
        this.fieldName,
      );
      return this.and(command);
    }
    gte(val) {
      const command = new QueryCommand(
        QUERY_COMMANDS_LITERAL.GTE,
        [val],
        this.fieldName,
      );
      return this.and(command);
    }
    lt(val) {
      const command = new QueryCommand(
        QUERY_COMMANDS_LITERAL.LT,
        [val],
        this.fieldName,
      );
      return this.and(command);
    }
    lte(val) {
      const command = new QueryCommand(
        QUERY_COMMANDS_LITERAL.LTE,
        [val],
        this.fieldName,
      );
      return this.and(command);
    }
    in(list) {
      const command = new QueryCommand(
        QUERY_COMMANDS_LITERAL.IN,
        list,
        this.fieldName,
      );
      return this.and(command);
    }
    nin(list) {
      const command = new QueryCommand(
        QUERY_COMMANDS_LITERAL.NIN,
        list,
        this.fieldName,
      );
      return this.and(command);
    }
    geoNear(val) {
      if (!(val.geometry instanceof index_1.Point)) {
        throw new TypeError(
          `"geometry" must be of type Point. Received type ${typeof val.geometry}`,
        );
      }
      if (val.maxDistance !== void 0 && !type_1.isNumber(val.maxDistance)) {
        throw new TypeError(
          `"maxDistance" must be of type Number. Received type ${typeof val.maxDistance}`,
        );
      }
      if (val.minDistance !== void 0 && !type_1.isNumber(val.minDistance)) {
        throw new TypeError(
          `"minDistance" must be of type Number. Received type ${typeof val.minDistance}`,
        );
      }
      const command = new QueryCommand(
        QUERY_COMMANDS_LITERAL.GEO_NEAR,
        [val],
        this.fieldName,
      );
      return this.and(command);
    }
    geoWithin(val) {
      if (
        !(val.geometry instanceof index_1.MultiPolygon) &&
        !(val.geometry instanceof index_1.Polygon) &&
        !validate_1.Validate.isCentersPhere(val.centerSphere)
      ) {
        throw new TypeError(
          `"geometry" must be of type Polygon or MultiPolygon. Received type ${typeof val.geometry}`,
        );
      }
      const command = new QueryCommand(
        QUERY_COMMANDS_LITERAL.GEO_WITHIN,
        [val],
        this.fieldName,
      );
      return this.and(command);
    }
    geoIntersects(val) {
      if (
        !(val.geometry instanceof index_1.Point) &&
        !(val.geometry instanceof index_1.LineString) &&
        !(val.geometry instanceof index_1.Polygon) &&
        !(val.geometry instanceof index_1.MultiPoint) &&
        !(val.geometry instanceof index_1.MultiLineString) &&
        !(val.geometry instanceof index_1.MultiPolygon)
      ) {
        throw new TypeError(
          `"geometry" must be of type Point, LineString, Polygon, MultiPoint, MultiLineString or MultiPolygon. Received type ${typeof val.geometry}`,
        );
      }
      const command = new QueryCommand(
        QUERY_COMMANDS_LITERAL.GEO_INTERSECTS,
        [val],
        this.fieldName,
      );
      return this.and(command);
    }
  };
  exports2.QueryCommand = QueryCommand;
  function isQueryCommand(object) {
    return (
      object &&
      object instanceof QueryCommand &&
      object._internalType === symbol_1.SYMBOL_QUERY_COMMAND
    );
  }
  exports2.isQueryCommand = isQueryCommand;
  function isKnownQueryCommand(object) {
    return (
      isQueryCommand(object) &&
      object.operator.toUpperCase() in QUERY_COMMANDS_LITERAL
    );
  }
  exports2.isKnownQueryCommand = isKnownQueryCommand;
  function isComparisonCommand(object) {
    return isQueryCommand(object);
  }
  exports2.isComparisonCommand = isComparisonCommand;
  exports2.default = QueryCommand;
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/operator-map.js
var require_operator_map = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var query_1 = require_query();
  var logic_1 = require_logic();
  var update_1 = require_update();
  exports2.OperatorMap = {};
  for (const key in query_1.QUERY_COMMANDS_LITERAL) {
    exports2.OperatorMap[key] = '$' + key;
  }
  for (const key in logic_1.LOGIC_COMMANDS_LITERAL) {
    exports2.OperatorMap[key] = '$' + key;
  }
  for (const key in update_1.UPDATE_COMMANDS_LITERAL) {
    exports2.OperatorMap[key] = '$' + key;
  }
  exports2.OperatorMap[query_1.QUERY_COMMANDS_LITERAL.NEQ] = '$ne';
  exports2.OperatorMap[update_1.UPDATE_COMMANDS_LITERAL.REMOVE] = '$unset';
  exports2.OperatorMap[update_1.UPDATE_COMMANDS_LITERAL.SHIFT] = '$pop';
  exports2.OperatorMap[update_1.UPDATE_COMMANDS_LITERAL.UNSHIFT] = '$push';
  function operatorToString(operator) {
    return exports2.OperatorMap[operator] || '$' + operator;
  }
  exports2.operatorToString = operatorToString;
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/serverDate/index.js
var require_serverDate = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var symbol_1 = require_symbol3();
  var ServerDate = class {
    constructor({ offset = 0 } = {}) {
      this.offset = offset;
    }
    get _internalType() {
      return symbol_1.SYMBOL_SERVER_DATE;
    }
    parse() {
      return {
        $tcb_server_date: {
          offset: this.offset,
        },
      };
    }
  };
  exports2.ServerDate = ServerDate;
  function ServerDateConstructor(opt) {
    return new ServerDate(opt);
  }
  exports2.ServerDateConstructor = ServerDateConstructor;
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/serializer/datatype.js
var require_datatype = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var symbol_1 = require_symbol3();
  var type_1 = require_type();
  var index_1 = require_geo();
  var index_2 = require_serverDate();
  function serialize(val) {
    return serializeHelper(val, [val]);
  }
  exports2.serialize = serialize;
  function serializeHelper(val, visited) {
    if (type_1.isInternalObject(val)) {
      switch (val._internalType) {
        case symbol_1.SYMBOL_GEO_POINT: {
          return val.toJSON();
        }
        case symbol_1.SYMBOL_SERVER_DATE: {
          return val.parse();
        }
        case symbol_1.SYMBOL_REGEXP: {
          return val.parse();
        }
        default: {
          return val.toJSON ? val.toJSON() : val;
        }
      }
    } else if (type_1.isDate(val)) {
      return val;
    } else if (type_1.isRegExp(val)) {
      return {
        $regularExpression: {
          pattern: val.source,
          options: val.flags,
        },
      };
    } else if (type_1.isArray(val)) {
      return val.map((item) => {
        if (visited.indexOf(item) > -1) {
          throw new Error('Cannot convert circular structure to JSON');
        }
        return serializeHelper(item, [...visited, item]);
      });
    } else if (type_1.isObject(val)) {
      const rawRet = Object.assign({}, val);
      const finalRet = {};
      for (const key in rawRet) {
        if (visited.indexOf(rawRet[key]) > -1) {
          throw new Error('Cannot convert circular structure to JSON');
        }
        if (rawRet[key] !== void 0) {
          finalRet[key] = serializeHelper(rawRet[key], [
            ...visited,
            rawRet[key],
          ]);
        }
      }
      return finalRet;
    } else {
      return val;
    }
  }
  function deserialize(object) {
    const ret = Object.assign({}, object);
    for (const key in ret) {
      switch (key) {
        case '$date': {
          switch (type_1.getType(ret[key])) {
            case 'number': {
              return new Date(ret[key]);
            }
            case 'object': {
              return new index_2.ServerDate(ret[key]);
            }
          }
          break;
        }
        case 'type': {
          switch (ret.type) {
            case 'Point': {
              if (
                type_1.isArray(ret.coordinates) &&
                type_1.isNumber(ret.coordinates[0]) &&
                type_1.isNumber(ret.coordinates[1])
              ) {
                return new index_1.Point(
                  ret.coordinates[0],
                  ret.coordinates[1],
                );
              }
              break;
            }
          }
          break;
        }
      }
    }
    return object;
  }
  exports2.deserialize = deserialize;
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/serializer/common.js
var require_common = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var type_1 = require_type();
  var datatype_1 = require_datatype();
  function flatten(query, shouldPreserverObject, parents, visited) {
    const cloned = Object.assign({}, query);
    for (const key in query) {
      if (/^\$/.test(key)) continue;
      const value = query[key];
      if (value === void 0) {
        delete cloned[key];
        continue;
      }
      if (!value) continue;
      if (type_1.isObject(value) && !shouldPreserverObject(value)) {
        if (visited.indexOf(value) > -1) {
          throw new Error('Cannot convert circular structure to JSON');
        }
        const newParents = [...parents, key];
        const newVisited = [...visited, value];
        const flattenedChild = flatten(
          value,
          shouldPreserverObject,
          newParents,
          newVisited,
        );
        cloned[key] = flattenedChild;
        let hasKeyNotCombined = false;
        for (const childKey in flattenedChild) {
          if (!/^\$/.test(childKey)) {
            cloned[`${key}.${childKey}`] = flattenedChild[childKey];
            delete cloned[key][childKey];
          } else {
            hasKeyNotCombined = true;
          }
        }
        if (!hasKeyNotCombined) {
          delete cloned[key];
        }
      }
    }
    return cloned;
  }
  function flattenQueryObject(query) {
    return flatten(query, isConversionRequired, [], [query]);
  }
  exports2.flattenQueryObject = flattenQueryObject;
  function flattenObject(object) {
    return flatten(object, (_2) => false, [], [object]);
  }
  exports2.flattenObject = flattenObject;
  function mergeConditionAfterEncode(query, condition, key) {
    if (!condition[key]) {
      delete query[key];
    }
    for (const conditionKey in condition) {
      if (query[conditionKey]) {
        if (type_1.isArray(query[conditionKey])) {
          query[conditionKey].push(condition[conditionKey]);
        } else if (type_1.isObject(query[conditionKey])) {
          if (type_1.isObject(condition[conditionKey])) {
            Object.assign(query[conditionKey], condition[conditionKey]);
          } else {
            console.warn(
              `unmergable condition, query is object but condition is ${type_1.getType(
                condition,
              )}, can only overwrite`,
              condition,
              key,
            );
            query[conditionKey] = condition[conditionKey];
          }
        } else {
          console.warn(
            `to-merge query is of type ${type_1.getType(
              query,
            )}, can only overwrite`,
            query,
            condition,
            key,
          );
          query[conditionKey] = condition[conditionKey];
        }
      } else {
        query[conditionKey] = condition[conditionKey];
      }
    }
  }
  exports2.mergeConditionAfterEncode = mergeConditionAfterEncode;
  function isConversionRequired(val) {
    return (
      type_1.isInternalObject(val) || type_1.isDate(val) || type_1.isRegExp(val)
    );
  }
  exports2.isConversionRequired = isConversionRequired;
  function encodeInternalDataType(val) {
    return datatype_1.serialize(val);
  }
  exports2.encodeInternalDataType = encodeInternalDataType;
  function decodeInternalDataType(object) {
    return datatype_1.deserialize(object);
  }
  exports2.decodeInternalDataType = decodeInternalDataType;
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/serializer/update.js
var require_update2 = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var update_1 = require_update();
  var symbol_1 = require_symbol3();
  var type_1 = require_type();
  var operator_map_1 = require_operator_map();
  var common_1 = require_common();
  var utils_1 = require_utils2();
  var UpdateSerializer = class {
    constructor() {}
    static encode(query) {
      const stringifier = new UpdateSerializer();
      return stringifier.encodeUpdate(query);
    }
    static encodeEJSON(query) {
      const stringifier = new UpdateSerializer();
      return utils_1.stringifyByEJSON(stringifier.encodeUpdate(query));
    }
    encodeUpdate(query) {
      if (update_1.isUpdateCommand(query)) {
        return this.encodeUpdateCommand(query);
      } else if (type_1.getType(query) === 'object') {
        return this.encodeUpdateObject(query);
      } else {
        return query;
      }
    }
    encodeUpdateCommand(query) {
      if (query.fieldName === symbol_1.SYMBOL_UNSET_FIELD_NAME) {
        throw new Error(
          'Cannot encode a comparison command with unset field name',
        );
      }
      switch (query.operator) {
        case update_1.UPDATE_COMMANDS_LITERAL.PUSH:
        case update_1.UPDATE_COMMANDS_LITERAL.PULL:
        case update_1.UPDATE_COMMANDS_LITERAL.PULL_ALL:
        case update_1.UPDATE_COMMANDS_LITERAL.POP:
        case update_1.UPDATE_COMMANDS_LITERAL.SHIFT:
        case update_1.UPDATE_COMMANDS_LITERAL.UNSHIFT:
        case update_1.UPDATE_COMMANDS_LITERAL.ADD_TO_SET: {
          return this.encodeArrayUpdateCommand(query);
        }
        default: {
          return this.encodeFieldUpdateCommand(query);
        }
      }
    }
    encodeFieldUpdateCommand(query) {
      const $op = operator_map_1.operatorToString(query.operator);
      switch (query.operator) {
        case update_1.UPDATE_COMMANDS_LITERAL.REMOVE: {
          return {
            [$op]: {
              [query.fieldName]: '',
            },
          };
        }
        default: {
          return {
            [$op]: {
              [query.fieldName]: query.operands[0],
            },
          };
        }
      }
    }
    encodeArrayUpdateCommand(query) {
      const $op = operator_map_1.operatorToString(query.operator);
      switch (query.operator) {
        case update_1.UPDATE_COMMANDS_LITERAL.PUSH: {
          let modifiers;
          if (type_1.isArray(query.operands)) {
            modifiers = {
              $each: query.operands.map(common_1.encodeInternalDataType),
            };
          } else {
            modifiers = query.operands;
          }
          return {
            [$op]: {
              [query.fieldName]: modifiers,
            },
          };
        }
        case update_1.UPDATE_COMMANDS_LITERAL.UNSHIFT: {
          const modifiers = {
            $each: query.operands.map(common_1.encodeInternalDataType),
            $position: 0,
          };
          return {
            [$op]: {
              [query.fieldName]: modifiers,
            },
          };
        }
        case update_1.UPDATE_COMMANDS_LITERAL.POP: {
          return {
            [$op]: {
              [query.fieldName]: 1,
            },
          };
        }
        case update_1.UPDATE_COMMANDS_LITERAL.SHIFT: {
          return {
            [$op]: {
              [query.fieldName]: -1,
            },
          };
        }
        default: {
          return {
            [$op]: {
              [query.fieldName]: common_1.encodeInternalDataType(
                query.operands,
              ),
            },
          };
        }
      }
    }
    encodeUpdateObject(query) {
      const flattened = common_1.flattenQueryObject(query);
      for (const key in flattened) {
        if (/^\$/.test(key)) continue;
        let val = flattened[key];
        if (update_1.isUpdateCommand(val)) {
          flattened[key] = val._setFieldName(key);
          const condition = this.encodeUpdateCommand(flattened[key]);
          common_1.mergeConditionAfterEncode(flattened, condition, key);
        } else {
          flattened[key] = val = common_1.encodeInternalDataType(val);
          const $setCommand = new update_1.UpdateCommand(
            update_1.UPDATE_COMMANDS_LITERAL.SET,
            [val],
            key,
          );
          const condition = this.encodeUpdateCommand($setCommand);
          common_1.mergeConditionAfterEncode(flattened, condition, key);
        }
      }
      return flattened;
    }
  };
  exports2.UpdateSerializer = UpdateSerializer;
});

// node_modules/lodash.set/index.js
var require_lodash = __commonJS((exports2, module2) => {
  var FUNC_ERROR_TEXT = 'Expected a function';
  var HASH_UNDEFINED = '__lodash_hash_undefined__';
  var INFINITY = 1 / 0;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var funcTag = '[object Function]';
  var genTag = '[object GeneratorFunction]';
  var symbolTag = '[object Symbol]';
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
  var reIsPlainProp = /^\w*$/;
  var reLeadingDot = /^\./;
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reEscapeChar = /\\(\\)?/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var freeGlobal =
    typeof global == 'object' && global && global.Object === Object && global;
  var freeSelf =
    typeof self == 'object' && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function('return this')();
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != 'function') {
      try {
        result = !!(value + '');
      } catch (e) {}
    }
    return result;
  }
  var arrayProto = Array.prototype;
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var coreJsData = root['__core-js_shared__'];
  var maskSrcKey = (function () {
    var uid = /[^.]+$/.exec(
      (coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || '',
    );
    return uid ? 'Symbol(src)_1.' + uid : '';
  })();
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp(
    '^' +
      funcToString
        .call(hasOwnProperty)
        .replace(reRegExpChar, '\\$&')
        .replace(
          /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
          '$1.*?',
        ) +
      '$',
  );
  var Symbol2 = root.Symbol;
  var splice = arrayProto.splice;
  var Map2 = getNative(root, 'Map');
  var nativeCreate = getNative(Object, 'create');
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
  var symbolToString = symbolProto ? symbolProto.toString : void 0;
  function Hash(entries) {
    var index = -1,
      length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : void 0;
  }
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
  }
  function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index = -1,
      length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
  }
  function listCacheDelete(key) {
    var data = this.__data__,
      index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    return true;
  }
  function listCacheGet(key) {
    var data = this.__data__,
      index = assocIndexOf(data, key);
    return index < 0 ? void 0 : data[index][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data = this.__data__,
      index = assocIndexOf(data, key);
    if (index < 0) {
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index = -1,
      length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.__data__ = {
      hash: new Hash(),
      map: new (Map2 || ListCache)(),
      string: new Hash(),
    };
  }
  function mapCacheDelete(key) {
    return getMapData(this, key)['delete'](key);
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (
      !(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === void 0 && !(key in object))
    ) {
      object[key] = value;
    }
  }
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern =
      isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function baseSet(object, path, value, customizer) {
    if (!isObject(object)) {
      return object;
    }
    path = isKey(path, object) ? [path] : castPath(path);
    var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;
    while (nested != null && ++index < length) {
      var key = toKey(path[index]),
        newValue = value;
      if (index != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : void 0;
        if (newValue === void 0) {
          newValue = isObject(objValue)
            ? objValue
            : isIndex(path[index + 1])
            ? []
            : {};
        }
      }
      assignValue(nested, key, newValue);
      nested = nested[key];
    }
    return object;
  }
  function baseToString(value) {
    if (typeof value == 'string') {
      return value;
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }
  function castPath(value) {
    return isArray(value) ? value : stringToPath(value);
  }
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key)
      ? data[typeof key == 'string' ? 'string' : 'hash']
      : data.map;
  }
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return (
      !!length &&
      (typeof value == 'number' || reIsUint.test(value)) &&
      value > -1 &&
      value % 1 == 0 &&
      value < length
    );
  }
  function isKey(value, object) {
    if (isArray(value)) {
      return false;
    }
    var type = typeof value;
    if (
      type == 'number' ||
      type == 'symbol' ||
      type == 'boolean' ||
      value == null ||
      isSymbol(value)
    ) {
      return true;
    }
    return (
      reIsPlainProp.test(value) ||
      !reIsDeepProp.test(value) ||
      (object != null && value in Object(object))
    );
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == 'string' ||
      type == 'number' ||
      type == 'symbol' ||
      type == 'boolean'
      ? value !== '__proto__'
      : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  var stringToPath = memoize(function (string) {
    string = toString(string);
    var result = [];
    if (reLeadingDot.test(string)) {
      result.push('');
    }
    string.replace(rePropName, function (match, number, quote, string2) {
      result.push(
        quote ? string2.replace(reEscapeChar, '$1') : number || match,
      );
    });
    return result;
  });
  function toKey(value) {
    if (typeof value == 'string' || isSymbol(value)) {
      return value;
    }
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}
      try {
        return func + '';
      } catch (e) {}
    }
    return '';
  }
  function memoize(func, resolver) {
    if (
      typeof func != 'function' ||
      (resolver && typeof resolver != 'function')
    ) {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function () {
      var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result);
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
  }
  memoize.Cache = MapCache;
  function eq(value, other) {
    return value === other || (value !== value && other !== other);
  }
  var isArray = Array.isArray;
  function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }
  function isSymbol(value) {
    return (
      typeof value == 'symbol' ||
      (isObjectLike(value) && objectToString.call(value) == symbolTag)
    );
  }
  function toString(value) {
    return value == null ? '' : baseToString(value);
  }
  function set(object, path, value) {
    return object == null ? object : baseSet(object, path, value);
  }
  module2.exports = set;
});

// node_modules/lodash.unset/index.js
var require_lodash2 = __commonJS((exports2, module2) => {
  var FUNC_ERROR_TEXT = 'Expected a function';
  var HASH_UNDEFINED = '__lodash_hash_undefined__';
  var INFINITY = 1 / 0;
  var funcTag = '[object Function]';
  var genTag = '[object GeneratorFunction]';
  var symbolTag = '[object Symbol]';
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
  var reIsPlainProp = /^\w*$/;
  var reLeadingDot = /^\./;
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reEscapeChar = /\\(\\)?/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var freeGlobal =
    typeof global == 'object' && global && global.Object === Object && global;
  var freeSelf =
    typeof self == 'object' && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function('return this')();
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != 'function') {
      try {
        result = !!(value + '');
      } catch (e) {}
    }
    return result;
  }
  var arrayProto = Array.prototype;
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var coreJsData = root['__core-js_shared__'];
  var maskSrcKey = (function () {
    var uid = /[^.]+$/.exec(
      (coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || '',
    );
    return uid ? 'Symbol(src)_1.' + uid : '';
  })();
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp(
    '^' +
      funcToString
        .call(hasOwnProperty)
        .replace(reRegExpChar, '\\$&')
        .replace(
          /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
          '$1.*?',
        ) +
      '$',
  );
  var Symbol2 = root.Symbol;
  var splice = arrayProto.splice;
  var Map2 = getNative(root, 'Map');
  var nativeCreate = getNative(Object, 'create');
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
  var symbolToString = symbolProto ? symbolProto.toString : void 0;
  function Hash(entries) {
    var index = -1,
      length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : void 0;
  }
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
  }
  function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index = -1,
      length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
  }
  function listCacheDelete(key) {
    var data = this.__data__,
      index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    return true;
  }
  function listCacheGet(key) {
    var data = this.__data__,
      index = assocIndexOf(data, key);
    return index < 0 ? void 0 : data[index][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data = this.__data__,
      index = assocIndexOf(data, key);
    if (index < 0) {
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index = -1,
      length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.__data__ = {
      hash: new Hash(),
      map: new (Map2 || ListCache)(),
      string: new Hash(),
    };
  }
  function mapCacheDelete(key) {
    return getMapData(this, key)['delete'](key);
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseGet(object, path) {
    path = isKey(path, object) ? [path] : castPath(path);
    var index = 0,
      length = path.length;
    while (object != null && index < length) {
      object = object[toKey(path[index++])];
    }
    return index && index == length ? object : void 0;
  }
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern =
      isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function baseSlice(array, start, end) {
    var index = -1,
      length = array.length;
    if (start < 0) {
      start = -start > length ? 0 : length + start;
    }
    end = end > length ? length : end;
    if (end < 0) {
      end += length;
    }
    length = start > end ? 0 : (end - start) >>> 0;
    start >>>= 0;
    var result = Array(length);
    while (++index < length) {
      result[index] = array[index + start];
    }
    return result;
  }
  function baseToString(value) {
    if (typeof value == 'string') {
      return value;
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }
  function baseUnset(object, path) {
    path = isKey(path, object) ? [path] : castPath(path);
    object = parent(object, path);
    var key = toKey(last(path));
    return (
      !(object != null && hasOwnProperty.call(object, key)) ||
      delete object[key]
    );
  }
  function castPath(value) {
    return isArray(value) ? value : stringToPath(value);
  }
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key)
      ? data[typeof key == 'string' ? 'string' : 'hash']
      : data.map;
  }
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  function isKey(value, object) {
    if (isArray(value)) {
      return false;
    }
    var type = typeof value;
    if (
      type == 'number' ||
      type == 'symbol' ||
      type == 'boolean' ||
      value == null ||
      isSymbol(value)
    ) {
      return true;
    }
    return (
      reIsPlainProp.test(value) ||
      !reIsDeepProp.test(value) ||
      (object != null && value in Object(object))
    );
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == 'string' ||
      type == 'number' ||
      type == 'symbol' ||
      type == 'boolean'
      ? value !== '__proto__'
      : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function parent(object, path) {
    return path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
  }
  var stringToPath = memoize(function (string) {
    string = toString(string);
    var result = [];
    if (reLeadingDot.test(string)) {
      result.push('');
    }
    string.replace(rePropName, function (match, number, quote, string2) {
      result.push(
        quote ? string2.replace(reEscapeChar, '$1') : number || match,
      );
    });
    return result;
  });
  function toKey(value) {
    if (typeof value == 'string' || isSymbol(value)) {
      return value;
    }
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}
      try {
        return func + '';
      } catch (e) {}
    }
    return '';
  }
  function last(array) {
    var length = array ? array.length : 0;
    return length ? array[length - 1] : void 0;
  }
  function memoize(func, resolver) {
    if (
      typeof func != 'function' ||
      (resolver && typeof resolver != 'function')
    ) {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function () {
      var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result);
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
  }
  memoize.Cache = MapCache;
  function eq(value, other) {
    return value === other || (value !== value && other !== other);
  }
  var isArray = Array.isArray;
  function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }
  function isSymbol(value) {
    return (
      typeof value == 'symbol' ||
      (isObjectLike(value) && objectToString.call(value) == symbolTag)
    );
  }
  function toString(value) {
    return value == null ? '' : baseToString(value);
  }
  function unset(object, path) {
    return object == null ? true : baseUnset(object, path);
  }
  module2.exports = unset;
});

// node_modules/lodash.clonedeep/index.js
var require_lodash3 = __commonJS((exports2, module2) => {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = '__lodash_hash_undefined__';
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = '[object Arguments]';
  var arrayTag = '[object Array]';
  var boolTag = '[object Boolean]';
  var dateTag = '[object Date]';
  var errorTag = '[object Error]';
  var funcTag = '[object Function]';
  var genTag = '[object GeneratorFunction]';
  var mapTag = '[object Map]';
  var numberTag = '[object Number]';
  var objectTag = '[object Object]';
  var promiseTag = '[object Promise]';
  var regexpTag = '[object RegExp]';
  var setTag = '[object Set]';
  var stringTag = '[object String]';
  var symbolTag = '[object Symbol]';
  var weakMapTag = '[object WeakMap]';
  var arrayBufferTag = '[object ArrayBuffer]';
  var dataViewTag = '[object DataView]';
  var float32Tag = '[object Float32Array]';
  var float64Tag = '[object Float64Array]';
  var int8Tag = '[object Int8Array]';
  var int16Tag = '[object Int16Array]';
  var int32Tag = '[object Int32Array]';
  var uint8Tag = '[object Uint8Array]';
  var uint8ClampedTag = '[object Uint8ClampedArray]';
  var uint16Tag = '[object Uint16Array]';
  var uint32Tag = '[object Uint32Array]';
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reFlags = /\w*$/;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[
    arrayBufferTag
  ] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[
    dateTag
  ] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[
    int8Tag
  ] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[
    mapTag
  ] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[
    regexpTag
  ] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[
    symbolTag
  ] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[
    uint16Tag
  ] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[
    weakMapTag
  ] = false;
  var freeGlobal =
    typeof global == 'object' && global && global.Object === Object && global;
  var freeSelf =
    typeof self == 'object' && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function('return this')();
  var freeExports =
    typeof exports2 == 'object' && exports2 && !exports2.nodeType && exports2;
  var freeModule =
    freeExports &&
    typeof module2 == 'object' &&
    module2 &&
    !module2.nodeType &&
    module2;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  function addMapEntry(map, pair) {
    map.set(pair[0], pair[1]);
    return map;
  }
  function addSetEntry(set, value) {
    set.add(value);
    return set;
  }
  function arrayEach(array, iteratee) {
    var index = -1,
      length = array ? array.length : 0;
    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }
  function arrayPush(array, values) {
    var index = -1,
      length = values.length,
      offset = array.length;
    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
      length = array ? array.length : 0;
    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }
  function baseTimes(n, iteratee) {
    var index = -1,
      result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != 'function') {
      try {
        result = !!(value + '');
      } catch (e) {}
    }
    return result;
  }
  function mapToArray(map) {
    var index = -1,
      result = Array(map.size);
    map.forEach(function (value, key) {
      result[++index] = [key, value];
    });
    return result;
  }
  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }
  function setToArray(set) {
    var index = -1,
      result = Array(set.size);
    set.forEach(function (value) {
      result[++index] = value;
    });
    return result;
  }
  var arrayProto = Array.prototype;
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var coreJsData = root['__core-js_shared__'];
  var maskSrcKey = (function () {
    var uid = /[^.]+$/.exec(
      (coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || '',
    );
    return uid ? 'Symbol(src)_1.' + uid : '';
  })();
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp(
    '^' +
      funcToString
        .call(hasOwnProperty)
        .replace(reRegExpChar, '\\$&')
        .replace(
          /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
          '$1.*?',
        ) +
      '$',
  );
  var Buffer2 = moduleExports ? root.Buffer : void 0;
  var Symbol2 = root.Symbol;
  var Uint8Array2 = root.Uint8Array;
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  var objectCreate = Object.create;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var splice = arrayProto.splice;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
  var nativeKeys = overArg(Object.keys, Object);
  var DataView = getNative(root, 'DataView');
  var Map2 = getNative(root, 'Map');
  var Promise2 = getNative(root, 'Promise');
  var Set2 = getNative(root, 'Set');
  var WeakMap = getNative(root, 'WeakMap');
  var nativeCreate = getNative(Object, 'create');
  var dataViewCtorString = toSource(DataView);
  var mapCtorString = toSource(Map2);
  var promiseCtorString = toSource(Promise2);
  var setCtorString = toSource(Set2);
  var weakMapCtorString = toSource(WeakMap);
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
  var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function Hash(entries) {
    var index = -1,
      length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : void 0;
  }
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
  }
  function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index = -1,
      length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
  }
  function listCacheDelete(key) {
    var data = this.__data__,
      index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    return true;
  }
  function listCacheGet(key) {
    var data = this.__data__,
      index = assocIndexOf(data, key);
    return index < 0 ? void 0 : data[index][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data = this.__data__,
      index = assocIndexOf(data, key);
    if (index < 0) {
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index = -1,
      length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.__data__ = {
      hash: new Hash(),
      map: new (Map2 || ListCache)(),
      string: new Hash(),
    };
  }
  function mapCacheDelete(key) {
    return getMapData(this, key)['delete'](key);
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function Stack(entries) {
    this.__data__ = new ListCache(entries);
  }
  function stackClear() {
    this.__data__ = new ListCache();
  }
  function stackDelete(key) {
    return this.__data__['delete'](key);
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value) {
    var cache = this.__data__;
    if (cache instanceof ListCache) {
      var pairs = cache.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        return this;
      }
      cache = this.__data__ = new MapCache(pairs);
    }
    cache.set(key, value);
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype['delete'] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value, inherited) {
    var result =
      isArray(value) || isArguments(value)
        ? baseTimes(value.length, String)
        : [];
    var length = result.length,
      skipIndexes = !!length;
    for (var key in value) {
      if (
        (inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))
      ) {
        result.push(key);
      }
    }
    return result;
  }
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (
      !(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === void 0 && !(key in object))
    ) {
      object[key] = value;
    }
  }
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
  }
  function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
    var result;
    if (customizer) {
      result = object
        ? customizer(value, key, object, stack)
        : customizer(value);
    }
    if (result !== void 0) {
      return result;
    }
    if (!isObject(value)) {
      return value;
    }
    var isArr = isArray(value);
    if (isArr) {
      result = initCloneArray(value);
      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;
      if (isBuffer(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
        if (isHostObject(value)) {
          return object ? value : {};
        }
        result = initCloneObject(isFunc ? {} : value);
        if (!isDeep) {
          return copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }
        result = initCloneByTag(value, tag, baseClone, isDeep);
      }
    }
    stack || (stack = new Stack());
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result);
    if (!isArr) {
      var props = isFull ? getAllKeys(value) : keys(value);
    }
    arrayEach(props || value, function (subValue, key2) {
      if (props) {
        key2 = subValue;
        subValue = value[key2];
      }
      assignValue(
        result,
        key2,
        baseClone(subValue, isDeep, isFull, customizer, key2, value, stack),
      );
    });
    return result;
  }
  function baseCreate(proto) {
    return isObject(proto) ? objectCreate(proto) : {};
  }
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  function baseGetTag(value) {
    return objectToString.call(value);
  }
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern =
      isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }
    return result;
  }
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var result = new buffer.constructor(buffer.length);
    buffer.copy(result);
    return result;
  }
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
    return result;
  }
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(
      buffer,
      dataView.byteOffset,
      dataView.byteLength,
    );
  }
  function cloneMap(map, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
    return arrayReduce(array, addMapEntry, new map.constructor());
  }
  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }
  function cloneSet(set, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
    return arrayReduce(array, addSetEntry, new set.constructor());
  }
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep
      ? cloneArrayBuffer(typedArray.buffer)
      : typedArray.buffer;
    return new typedArray.constructor(
      buffer,
      typedArray.byteOffset,
      typedArray.length,
    );
  }
  function copyArray(source, array) {
    var index = -1,
      length = source.length;
    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }
  function copyObject(source, props, object, customizer) {
    object || (object = {});
    var index = -1,
      length = props.length;
    while (++index < length) {
      var key = props[index];
      var newValue = customizer
        ? customizer(object[key], source[key], key, object, source)
        : void 0;
      assignValue(object, key, newValue === void 0 ? source[key] : newValue);
    }
    return object;
  }
  function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
  }
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key)
      ? data[typeof key == 'string' ? 'string' : 'hash']
      : data.map;
  }
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  var getSymbols = nativeGetSymbols
    ? overArg(nativeGetSymbols, Object)
    : stubArray;
  var getTag = baseGetTag;
  if (
    (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map2 && getTag(new Map2()) != mapTag) ||
    (Promise2 && getTag(Promise2.resolve()) != promiseTag) ||
    (Set2 && getTag(new Set2()) != setTag) ||
    (WeakMap && getTag(new WeakMap()) != weakMapTag)
  ) {
    getTag = function (value) {
      var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : void 0,
        ctorString = Ctor ? toSource(Ctor) : void 0;
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  function initCloneArray(array) {
    var length = array.length,
      result = array.constructor(length);
    if (
      length &&
      typeof array[0] == 'string' &&
      hasOwnProperty.call(array, 'index')
    ) {
      result.index = array.index;
      result.input = array.input;
    }
    return result;
  }
  function initCloneObject(object) {
    return typeof object.constructor == 'function' && !isPrototype(object)
      ? baseCreate(getPrototype(object))
      : {};
  }
  function initCloneByTag(object, tag, cloneFunc, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
      case arrayBufferTag:
        return cloneArrayBuffer(object);
      case boolTag:
      case dateTag:
        return new Ctor(+object);
      case dataViewTag:
        return cloneDataView(object, isDeep);
      case float32Tag:
      case float64Tag:
      case int8Tag:
      case int16Tag:
      case int32Tag:
      case uint8Tag:
      case uint8ClampedTag:
      case uint16Tag:
      case uint32Tag:
        return cloneTypedArray(object, isDeep);
      case mapTag:
        return cloneMap(object, isDeep, cloneFunc);
      case numberTag:
      case stringTag:
        return new Ctor(object);
      case regexpTag:
        return cloneRegExp(object);
      case setTag:
        return cloneSet(object, isDeep, cloneFunc);
      case symbolTag:
        return cloneSymbol(object);
    }
  }
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return (
      !!length &&
      (typeof value == 'number' || reIsUint.test(value)) &&
      value > -1 &&
      value % 1 == 0 &&
      value < length
    );
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == 'string' ||
      type == 'number' ||
      type == 'symbol' ||
      type == 'boolean'
      ? value !== '__proto__'
      : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
    return value === proto;
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}
      try {
        return func + '';
      } catch (e) {}
    }
    return '';
  }
  function cloneDeep(value) {
    return baseClone(value, true, true);
  }
  function eq(value, other) {
    return value === other || (value !== value && other !== other);
  }
  function isArguments(value) {
    return (
      isArrayLikeObject(value) &&
      hasOwnProperty.call(value, 'callee') &&
      (!propertyIsEnumerable.call(value, 'callee') ||
        objectToString.call(value) == argsTag)
    );
  }
  var isArray = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  var isBuffer = nativeIsBuffer || stubFalse;
  function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
  }
  function isLength(value) {
    return (
      typeof value == 'number' &&
      value > -1 &&
      value % 1 == 0 &&
      value <= MAX_SAFE_INTEGER
    );
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  function stubArray() {
    return [];
  }
  function stubFalse() {
    return false;
  }
  module2.exports = cloneDeep;
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/realtime/message.js
var require_message = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  function genRequestId(prefix = '') {
    return `${prefix ? `${prefix}_` : ''}${+new Date()}_${Math.random()}`;
  }
  exports2.genRequestId = genRequestId;
  function isInitEventMessage(msg) {
    return msg.msgType === 'INIT_EVENT';
  }
  exports2.isInitEventMessage = isInitEventMessage;
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/config/error.config.js
var require_error_config = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  exports2.ERR_CODE = {
    UNKNOWN_ERROR: 'UNKNOWN_ERROR',
    SDK_DATABASE_REALTIME_LISTENER_INIT_WATCH_FAIL:
      'SDK_DATABASE_REALTIME_LISTENER_INIT_WATCH_FAIL',
    SDK_DATABASE_REALTIME_LISTENER_RECONNECT_WATCH_FAIL:
      'SDK_DATABASE_REALTIME_LISTENER_RECONNECT_WATCH_FAIL',
    SDK_DATABASE_REALTIME_LISTENER_REBUILD_WATCH_FAIL:
      'SDK_DATABASE_REALTIME_LISTENER_REBUILD_WATCH_FAIL',
    SDK_DATABASE_REALTIME_LISTENER_CLOSE_WATCH_FAIL:
      'SDK_DATABASE_REALTIME_LISTENER_CLOSE_WATCH_FAIL',
    SDK_DATABASE_REALTIME_LISTENER_SERVER_ERROR_MSG:
      'SDK_DATABASE_REALTIME_LISTENER_SERVER_ERROR_MSG',
    SDK_DATABASE_REALTIME_LISTENER_RECEIVE_INVALID_SERVER_DATA:
      'SDK_DATABASE_REALTIME_LISTENER_RECEIVE_INVALID_SERVER_DATA',
    SDK_DATABASE_REALTIME_LISTENER_WEBSOCKET_CONNECTION_ERROR:
      'SDK_DATABASE_REALTIME_LISTENER_WEBSOCKET_CONNECTION_ERROR',
    SDK_DATABASE_REALTIME_LISTENER_WEBSOCKET_CONNECTION_CLOSED:
      'SDK_DATABASE_REALTIME_LISTENER_WEBSOCKET_CONNECTION_CLOSED',
    SDK_DATABASE_REALTIME_LISTENER_CHECK_LAST_FAIL:
      'SDK_DATABASE_REALTIME_LISTENER_CHECK_LAST_FAIL',
    SDK_DATABASE_REALTIME_LISTENER_UNEXPECTED_FATAL_ERROR:
      'SDK_DATABASE_REALTIME_LISTENER_UNEXPECTED_FATAL_ERROR',
  };
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/utils/error.js
var require_error = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var type_1 = require_type();
  var error_config_1 = require_error_config();
  var CloudSDKError = class extends Error {
    constructor(options) {
      super(options.errMsg);
      this.errCode = 'UNKNOWN_ERROR';
      Object.defineProperties(this, {
        message: {
          get() {
            return (
              `errCode: ${this.errCode} ${
                error_config_1.ERR_CODE[this.errCode] || ''
              } | errMsg: ` + this.errMsg
            );
          },
          set(msg) {
            this.errMsg = msg;
          },
        },
      });
      this.errCode = options.errCode || 'UNKNOWN_ERROR';
      this.errMsg = options.errMsg;
    }
    get message() {
      return `errCode: ${this.errCode} | errMsg: ` + this.errMsg;
    }
    set message(msg) {
      this.errMsg = msg;
    }
  };
  exports2.CloudSDKError = CloudSDKError;
  function isSDKError(error) {
    return error && error instanceof Error && type_1.isString(error.errMsg);
  }
  exports2.isSDKError = isSDKError;
  exports2.isGenericError = (e) => e.generic;
  var TimeoutError = class extends Error {
    constructor(message) {
      super(message);
      this.type = 'timeout';
      this.payload = null;
      this.generic = true;
    }
  };
  exports2.TimeoutError = TimeoutError;
  exports2.isTimeoutError = (e) => e.type === 'timeout';
  var CancelledError = class extends Error {
    constructor(message) {
      super(message);
      this.type = 'cancelled';
      this.payload = null;
      this.generic = true;
    }
  };
  exports2.CancelledError = CancelledError;
  exports2.isCancelledError = (e) => e.type === 'cancelled';
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/realtime/listener.js
var require_listener = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var RealtimeListener = class {
    constructor(options) {
      this.close = options.close;
      this.onChange = options.onChange;
      this.onError = options.onError;
      if (options.debug) {
        Object.defineProperty(this, 'virtualClient', {
          get: () => {
            return options.virtualClient;
          },
        });
      }
    }
  };
  exports2.RealtimeListener = RealtimeListener;
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/realtime/snapshot.js
var require_snapshot = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var Snapshot = class {
    constructor(options) {
      const { id, docChanges, docs, msgType, type } = options;
      let cachedDocChanges;
      let cachedDocs;
      Object.defineProperties(this, {
        id: {
          get: () => id,
          enumerable: true,
        },
        docChanges: {
          get: () => {
            if (!cachedDocChanges) {
              cachedDocChanges = JSON.parse(JSON.stringify(docChanges));
            }
            return cachedDocChanges;
          },
          enumerable: true,
        },
        docs: {
          get: () => {
            if (!cachedDocs) {
              cachedDocs = JSON.parse(JSON.stringify(docs));
            }
            return cachedDocs;
          },
          enumerable: true,
        },
        msgType: {
          get: () => msgType,
          enumerable: true,
        },
        type: {
          get: () => type,
          enumerable: true,
        },
      });
    }
  };
  exports2.Snapshot = Snapshot;
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/realtime/error.js
var require_error2 = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var RealtimeErrorMessageError = class extends Error {
    constructor(serverErrorMsg) {
      super(
        `Watch Error ${JSON.stringify(serverErrorMsg.msgData)} (requestid: ${
          serverErrorMsg.requestId
        })`,
      );
      this.isRealtimeErrorMessageError = true;
      this.payload = serverErrorMsg;
    }
  };
  exports2.RealtimeErrorMessageError = RealtimeErrorMessageError;
  exports2.isRealtimeErrorMessageError = (e) =>
    e && e.isRealtimeErrorMessageError;
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/realtime/virtual-websocket-client.js
var require_virtual_websocket_client = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var lodash_set_1 = require_lodash();
  var lodash_unset_1 = require_lodash2();
  var lodash_clonedeep_1 = require_lodash3();
  var message_1 = require_message();
  var error_1 = require_error();
  var error_config_1 = require_error_config();
  var utils_1 = require_utils2();
  var listener_1 = require_listener();
  var snapshot_1 = require_snapshot();
  var error_2 = require_error2();
  var WATCH_STATUS;
  (function (WATCH_STATUS2) {
    WATCH_STATUS2['LOGGINGIN'] = 'LOGGINGIN';
    WATCH_STATUS2['INITING'] = 'INITING';
    WATCH_STATUS2['REBUILDING'] = 'REBUILDING';
    WATCH_STATUS2['ACTIVE'] = 'ACTIVE';
    WATCH_STATUS2['ERRORED'] = 'ERRORED';
    WATCH_STATUS2['CLOSING'] = 'CLOSING';
    WATCH_STATUS2['CLOSED'] = 'CLOSED';
    WATCH_STATUS2['PAUSED'] = 'PAUSED';
    WATCH_STATUS2['RESUMING'] = 'RESUMING';
  })(WATCH_STATUS || (WATCH_STATUS = {}));
  var DEFAULT_WAIT_TIME_ON_UNKNOWN_ERROR = 100;
  var DEFAULT_MAX_AUTO_RETRY_ON_ERROR = 2;
  var DEFAULT_MAX_SEND_ACK_AUTO_RETRY_ON_ERROR = 2;
  var DEFAULT_SEND_ACK_DEBOUNCE_TIMEOUT = 10 * 1e3;
  var DEFAULT_INIT_WATCH_TIMEOUT = 10 * 1e3;
  var DEFAULT_REBUILD_WATCH_TIMEOUT = 10 * 1e3;
  var VirtualWebSocketClient = class {
    constructor(options) {
      this.watchStatus = WATCH_STATUS.INITING;
      this._login = async (envId, refresh) => {
        this.watchStatus = WATCH_STATUS.LOGGINGIN;
        const loginResult = await this.login(envId, refresh);
        if (!this.envId) {
          this.envId = loginResult.envId;
        }
        return loginResult;
      };
      this.initWatch = async (forceRefreshLogin) => {
        if (this._initWatchPromise) {
          return this._initWatchPromise;
        }
        this._initWatchPromise = new Promise(async (resolve, reject) => {
          try {
            if (this.watchStatus === WATCH_STATUS.PAUSED) {
              console.log('[realtime] initWatch cancelled on pause');
              return resolve();
            }
            const { envId } = await this._login(this.envId, forceRefreshLogin);
            if (this.watchStatus === WATCH_STATUS.PAUSED) {
              console.log('[realtime] initWatch cancelled on pause');
              return resolve();
            }
            this.watchStatus = WATCH_STATUS.INITING;
            const initWatchMsg = {
              watchId: this.watchId,
              requestId: message_1.genRequestId(),
              msgType: 'INIT_WATCH',
              msgData: {
                envId,
                collName: this.collectionName,
                query: this.query,
                limit: this.limit,
                orderBy: this.orderBy,
              },
            };
            const initEventMsg = await this.send({
              msg: initWatchMsg,
              waitResponse: true,
              skipOnMessage: true,
              timeout: DEFAULT_INIT_WATCH_TIMEOUT,
            });
            const { events, currEvent } = initEventMsg.msgData;
            this.sessionInfo = {
              queryID: initEventMsg.msgData.queryID,
              currentEventId: currEvent - 1,
              currentDocs: [],
            };
            if (events.length > 0) {
              for (const e of events) {
                e.ID = currEvent;
              }
              this.handleServerEvents(initEventMsg);
            } else {
              this.sessionInfo.currentEventId = currEvent;
              const snapshot = new snapshot_1.Snapshot({
                id: currEvent,
                docChanges: [],
                docs: [],
                type: 'init',
              });
              this.listener.onChange(snapshot);
              this.scheduleSendACK();
            }
            this.onWatchStart(this, this.sessionInfo.queryID);
            this.watchStatus = WATCH_STATUS.ACTIVE;
            this._availableRetries.INIT_WATCH = DEFAULT_MAX_AUTO_RETRY_ON_ERROR;
            resolve();
          } catch (e) {
            this.handleWatchEstablishmentError(e, {
              operationName: 'INIT_WATCH',
              resolve,
              reject,
            });
          }
        });
        let success = false;
        try {
          await this._initWatchPromise;
          success = true;
        } finally {
          this._initWatchPromise = void 0;
        }
        console.log(`[realtime] initWatch ${success ? 'success' : 'fail'}`);
      };
      this.rebuildWatch = async (forceRefreshLogin) => {
        if (this._rebuildWatchPromise) {
          return this._rebuildWatchPromise;
        }
        this._rebuildWatchPromise = new Promise(async (resolve, reject) => {
          try {
            if (this.watchStatus === WATCH_STATUS.PAUSED) {
              console.log('[realtime] rebuildWatch cancelled on pause');
              return resolve();
            }
            const { envId } = await this._login(this.envId, forceRefreshLogin);
            if (!this.sessionInfo) {
              throw new Error(
                'can not rebuildWatch without a successful initWatch (lack of sessionInfo)',
              );
            }
            if (this.watchStatus === WATCH_STATUS.PAUSED) {
              console.log('[realtime] rebuildWatch cancelled on pause');
              return resolve();
            }
            this.watchStatus = WATCH_STATUS.REBUILDING;
            const rebuildWatchMsg = {
              watchId: this.watchId,
              requestId: message_1.genRequestId(),
              msgType: 'REBUILD_WATCH',
              msgData: {
                envId,
                collName: this.collectionName,
                queryID: this.sessionInfo.queryID,
                eventID: this.sessionInfo.currentEventId,
              },
            };
            const nextEventMsg = await this.send({
              msg: rebuildWatchMsg,
              waitResponse: true,
              skipOnMessage: false,
              timeout: DEFAULT_REBUILD_WATCH_TIMEOUT,
            });
            this.handleServerEvents(nextEventMsg);
            this.watchStatus = WATCH_STATUS.ACTIVE;
            this._availableRetries.REBUILD_WATCH = DEFAULT_MAX_AUTO_RETRY_ON_ERROR;
            resolve();
          } catch (e) {
            this.handleWatchEstablishmentError(e, {
              operationName: 'REBUILD_WATCH',
              resolve,
              reject,
            });
          }
        });
        let success = false;
        try {
          await this._rebuildWatchPromise;
          success = true;
        } finally {
          this._rebuildWatchPromise = void 0;
        }
        console.log(`[realtime] rebuildWatch ${success ? 'success' : 'fail'}`);
      };
      this.handleWatchEstablishmentError = async (e, options2) => {
        const isInitWatch = options2.operationName === 'INIT_WATCH';
        const abortWatch = () => {
          this.closeWithError(
            new error_1.CloudSDKError({
              errCode: isInitWatch
                ? error_config_1.ERR_CODE
                    .SDK_DATABASE_REALTIME_LISTENER_INIT_WATCH_FAIL
                : error_config_1.ERR_CODE
                    .SDK_DATABASE_REALTIME_LISTENER_REBUILD_WATCH_FAIL,
              errMsg: e,
            }),
          );
          options2.reject(e);
        };
        const retry = (refreshLogin) => {
          if (this.useRetryTicket(options2.operationName)) {
            if (isInitWatch) {
              this._initWatchPromise = void 0;
              options2.resolve(this.initWatch(refreshLogin));
            } else {
              this._rebuildWatchPromise = void 0;
              options2.resolve(this.rebuildWatch(refreshLogin));
            }
          } else {
            abortWatch();
          }
        };
        this.handleCommonError(e, {
          onSignError: () => retry(true),
          onTimeoutError: () => retry(false),
          onNotRetryableError: abortWatch,
          onCancelledError: options2.reject,
          onUnknownError: async () => {
            try {
              const onWSDisconnected = async () => {
                this.pause();
                await this.onceWSConnected();
                retry(true);
              };
              if (!this.isWSConnected()) {
                await onWSDisconnected();
              } else {
                await utils_1.sleep(DEFAULT_WAIT_TIME_ON_UNKNOWN_ERROR);
                if (this.watchStatus === WATCH_STATUS.PAUSED) {
                  options2.reject(
                    new error_1.CancelledError(
                      `${options2.operationName} cancelled due to pause after unknownError`,
                    ),
                  );
                } else if (!this.isWSConnected()) {
                  await onWSDisconnected();
                } else {
                  retry(false);
                }
              }
            } catch (e2) {
              retry(true);
            }
          },
        });
      };
      this.closeWatch = async () => {
        const queryId = this.sessionInfo ? this.sessionInfo.queryID : '';
        if (this.watchStatus !== WATCH_STATUS.ACTIVE) {
          this.watchStatus = WATCH_STATUS.CLOSED;
          this.onWatchClose(this, queryId);
          return;
        }
        try {
          this.watchStatus = WATCH_STATUS.CLOSING;
          const closeWatchMsg = {
            watchId: this.watchId,
            requestId: message_1.genRequestId(),
            msgType: 'CLOSE_WATCH',
            msgData: null,
          };
          await this.send({
            msg: closeWatchMsg,
          });
          this.sessionInfo = void 0;
          this.watchStatus = WATCH_STATUS.CLOSED;
        } catch (e) {
          this.closeWithError(
            new error_1.CloudSDKError({
              errCode:
                error_config_1.ERR_CODE
                  .SDK_DATABASE_REALTIME_LISTENER_CLOSE_WATCH_FAIL,
              errMsg: e,
            }),
          );
        } finally {
          this.onWatchClose(this, queryId);
        }
      };
      this.scheduleSendACK = () => {
        this.clearACKSchedule();
        this._ackTimeoutId = setTimeout(() => {
          if (this._waitExpectedTimeoutId) {
            this.scheduleSendACK();
          } else {
            this.sendACK();
          }
        }, DEFAULT_SEND_ACK_DEBOUNCE_TIMEOUT);
      };
      this.clearACKSchedule = () => {
        if (this._ackTimeoutId) {
          clearTimeout(this._ackTimeoutId);
        }
      };
      this.sendACK = async () => {
        try {
          if (this.watchStatus !== WATCH_STATUS.ACTIVE) {
            this.scheduleSendACK();
            return;
          }
          if (!this.sessionInfo) {
            console.warn(
              '[realtime listener] can not send ack without a successful initWatch (lack of sessionInfo)',
            );
            return;
          }
          const ackMsg = {
            watchId: this.watchId,
            requestId: message_1.genRequestId(),
            msgType: 'CHECK_LAST',
            msgData: {
              queryID: this.sessionInfo.queryID,
              eventID: this.sessionInfo.currentEventId,
            },
          };
          await this.send({
            msg: ackMsg,
          });
          this.scheduleSendACK();
        } catch (e) {
          if (error_2.isRealtimeErrorMessageError(e)) {
            const msg = e.payload;
            switch (msg.msgData.code) {
              case 'CHECK_LOGIN_FAILED':
              case 'SIGN_EXPIRED_ERROR':
              case 'SIGN_INVALID_ERROR':
              case 'SIGN_PARAM_INVALID': {
                this.rebuildWatch();
                return;
              }
              case 'QUERYID_INVALID_ERROR':
              case 'SYS_ERR':
              case 'INVALIID_ENV':
              case 'COLLECTION_PERMISSION_DENIED': {
                this.closeWithError(
                  new error_1.CloudSDKError({
                    errCode:
                      error_config_1.ERR_CODE
                        .SDK_DATABASE_REALTIME_LISTENER_CHECK_LAST_FAIL,
                    errMsg: msg.msgData.code,
                  }),
                );
                return;
              }
              default: {
                break;
              }
            }
          }
          if (
            this._availableRetries.CHECK_LAST &&
            this._availableRetries.CHECK_LAST > 0
          ) {
            this._availableRetries.CHECK_LAST--;
            this.scheduleSendACK();
          } else {
            this.closeWithError(
              new error_1.CloudSDKError({
                errCode:
                  error_config_1.ERR_CODE
                    .SDK_DATABASE_REALTIME_LISTENER_CHECK_LAST_FAIL,
                errMsg: e,
              }),
            );
          }
        }
      };
      this.handleCommonError = (e, options2) => {
        if (error_2.isRealtimeErrorMessageError(e)) {
          const msg = e.payload;
          switch (msg.msgData.code) {
            case 'CHECK_LOGIN_FAILED':
            case 'SIGN_EXPIRED_ERROR':
            case 'SIGN_INVALID_ERROR':
            case 'SIGN_PARAM_INVALID': {
              options2.onSignError(e);
              return;
            }
            case 'QUERYID_INVALID_ERROR':
            case 'SYS_ERR':
            case 'INVALIID_ENV':
            case 'COLLECTION_PERMISSION_DENIED': {
              options2.onNotRetryableError(e);
              return;
            }
            default: {
              options2.onNotRetryableError(e);
              return;
            }
          }
        } else if (error_1.isTimeoutError(e)) {
          options2.onTimeoutError(e);
          return;
        } else if (error_1.isCancelledError(e)) {
          options2.onCancelledError(e);
          return;
        }
        options2.onUnknownError(e);
      };
      this.watchId = `watchid_${+new Date()}_${Math.random()}`;
      this.envId = options.envId;
      this.collectionName = options.collectionName;
      this.query = options.query;
      this.limit = options.limit;
      this.orderBy = options.orderBy;
      this.send = options.send;
      this.login = options.login;
      this.isWSConnected = options.isWSConnected;
      this.onceWSConnected = options.onceWSConnected;
      this.getWaitExpectedTimeoutLength = options.getWaitExpectedTimeoutLength;
      this.onWatchStart = options.onWatchStart;
      this.onWatchClose = options.onWatchClose;
      this.debug = options.debug;
      this._availableRetries = {
        INIT_WATCH: DEFAULT_MAX_AUTO_RETRY_ON_ERROR,
        REBUILD_WATCH: DEFAULT_MAX_AUTO_RETRY_ON_ERROR,
        CHECK_LAST: DEFAULT_MAX_SEND_ACK_AUTO_RETRY_ON_ERROR,
      };
      this.listener = new listener_1.RealtimeListener({
        close: this.closeWatch,
        onChange: options.onChange,
        onError: options.onError,
        debug: this.debug,
        virtualClient: this,
      });
      this.initWatch();
    }
    useRetryTicket(operationName) {
      if (
        this._availableRetries[operationName] &&
        this._availableRetries[operationName] > 0
      ) {
        this._availableRetries[operationName]--;
        console.log(
          `[realtime] ${operationName} use a retry ticket, now only ${this._availableRetries[operationName]} retry left`,
        );
        return true;
      }
      return false;
    }
    async handleServerEvents(msg) {
      try {
        this.scheduleSendACK();
        await this._handleServerEvents(msg);
        this._postHandleServerEventsValidityCheck(msg);
      } catch (e) {
        console.error(
          '[realtime listener] internal non-fatal error: handle server events failed with error: ',
          e,
        );
        throw e;
      }
    }
    async _handleServerEvents(msg) {
      const { requestId } = msg;
      const { events } = msg.msgData;
      const { msgType } = msg;
      if (!events.length || !this.sessionInfo) {
        return;
      }
      const sessionInfo = this.sessionInfo;
      let allChangeEvents;
      try {
        allChangeEvents = events.map(getPublicEvent);
      } catch (e) {
        this.closeWithError(
          new error_1.CloudSDKError({
            errCode:
              error_config_1.ERR_CODE
                .SDK_DATABASE_REALTIME_LISTENER_RECEIVE_INVALID_SERVER_DATA,
            errMsg: e,
          }),
        );
        return;
      }
      let docs = [...sessionInfo.currentDocs];
      let initEncountered = false;
      for (let i = 0, len = allChangeEvents.length; i < len; i++) {
        const change = allChangeEvents[i];
        if (sessionInfo.currentEventId >= change.id) {
          if (
            !allChangeEvents[i - 1] ||
            change.id > allChangeEvents[i - 1].id
          ) {
            console.warn(
              `[realtime] duplicate event received, cur ${sessionInfo.currentEventId} but got ${change.id}`,
            );
          } else {
            console.error(
              `[realtime listener] server non-fatal error: events out of order (the latter event's id is smaller than that of the former) (requestId ${requestId})`,
            );
          }
          continue;
        } else if (sessionInfo.currentEventId === change.id - 1) {
          switch (change.dataType) {
            case 'update': {
              if (!change.doc) {
                switch (change.queueType) {
                  case 'update':
                  case 'dequeue': {
                    const localDoc = docs.find(
                      (doc) => doc._id === change.docId,
                    );
                    if (localDoc) {
                      const doc = lodash_clonedeep_1.default(localDoc);
                      if (change.updatedFields) {
                        for (const fieldPath in change.updatedFields) {
                          lodash_set_1.default(
                            doc,
                            fieldPath,
                            change.updatedFields[fieldPath],
                          );
                        }
                      }
                      if (change.removedFields) {
                        for (const fieldPath of change.removedFields) {
                          lodash_unset_1.default(doc, fieldPath);
                        }
                      }
                      change.doc = doc;
                    } else {
                      console.error(
                        '[realtime listener] internal non-fatal server error: unexpected update dataType event where no doc is associated.',
                      );
                    }
                    break;
                  }
                  case 'enqueue': {
                    const err = new error_1.CloudSDKError({
                      errCode:
                        error_config_1.ERR_CODE
                          .SDK_DATABASE_REALTIME_LISTENER_UNEXPECTED_FATAL_ERROR,
                      errMsg: `HandleServerEvents: full doc is not provided with dataType="update" and queueType="enqueue" (requestId ${msg.requestId})`,
                    });
                    this.closeWithError(err);
                    throw err;
                  }
                  default: {
                    break;
                  }
                }
              }
              break;
            }
            case 'replace': {
              if (!change.doc) {
                const err = new error_1.CloudSDKError({
                  errCode:
                    error_config_1.ERR_CODE
                      .SDK_DATABASE_REALTIME_LISTENER_UNEXPECTED_FATAL_ERROR,
                  errMsg: `HandleServerEvents: full doc is not provided with dataType="replace" (requestId ${msg.requestId})`,
                });
                this.closeWithError(err);
                throw err;
              }
              break;
            }
            case 'remove': {
              const doc = docs.find((doc2) => doc2._id === change.docId);
              if (doc) {
                change.doc = doc;
              } else {
                console.error(
                  '[realtime listener] internal non-fatal server error: unexpected remove event where no doc is associated.',
                );
              }
              break;
            }
            case 'limit': {
              if (!change.doc) {
                switch (change.queueType) {
                  case 'dequeue': {
                    const doc = docs.find((doc2) => doc2._id === change.docId);
                    if (doc) {
                      change.doc = doc;
                    } else {
                      console.error(
                        '[realtime listener] internal non-fatal server error: unexpected limit dataType event where no doc is associated.',
                      );
                    }
                    break;
                  }
                  case 'enqueue': {
                    const err = new error_1.CloudSDKError({
                      errCode:
                        error_config_1.ERR_CODE
                          .SDK_DATABASE_REALTIME_LISTENER_UNEXPECTED_FATAL_ERROR,
                      errMsg: `HandleServerEvents: full doc is not provided with dataType="limit" and queueType="enqueue" (requestId ${msg.requestId})`,
                    });
                    this.closeWithError(err);
                    throw err;
                  }
                  default: {
                    break;
                  }
                }
              }
              break;
            }
          }
          switch (change.queueType) {
            case 'init': {
              if (!initEncountered) {
                initEncountered = true;
                docs = [change.doc];
              } else {
                docs.push(change.doc);
              }
              break;
            }
            case 'enqueue': {
              docs.push(change.doc);
              break;
            }
            case 'dequeue': {
              const ind = docs.findIndex((doc) => doc._id === change.docId);
              if (ind > -1) {
                docs.splice(ind, 1);
              } else {
                console.error(
                  '[realtime listener] internal non-fatal server error: unexpected dequeue event where no doc is associated.',
                );
              }
              break;
            }
            case 'update': {
              const ind = docs.findIndex((doc) => doc._id === change.docId);
              if (ind > -1) {
                docs[ind] = change.doc;
              } else {
                console.error(
                  '[realtime listener] internal non-fatal server error: unexpected queueType update event where no doc is associated.',
                );
              }
              break;
            }
          }
          if (
            i === len - 1 ||
            (allChangeEvents[i + 1] && allChangeEvents[i + 1].id !== change.id)
          ) {
            const docsSnapshot = [...docs];
            const docChanges = allChangeEvents
              .slice(0, i + 1)
              .filter((c) => c.id === change.id);
            this.sessionInfo.currentEventId = change.id;
            this.sessionInfo.currentDocs = docs;
            const snapshot = new snapshot_1.Snapshot({
              id: change.id,
              docChanges,
              docs: docsSnapshot,
              msgType,
            });
            this.listener.onChange(snapshot);
          }
        } else {
          console.warn(
            `[realtime listener] event received is out of order, cur ${this.sessionInfo.currentEventId} but got ${change.id}`,
          );
          await this.rebuildWatch();
          return;
        }
      }
    }
    _postHandleServerEventsValidityCheck(msg) {
      if (!this.sessionInfo) {
        console.error(
          '[realtime listener] internal non-fatal error: sessionInfo lost after server event handling, this should never occur',
        );
        return;
      }
      if (
        this.sessionInfo.expectEventId &&
        this.sessionInfo.currentEventId >= this.sessionInfo.expectEventId
      ) {
        this.clearWaitExpectedEvent();
      }
      if (this.sessionInfo.currentEventId < msg.msgData.currEvent) {
        console.warn(
          '[realtime listener] internal non-fatal error: client eventId does not match with server event id after server event handling',
        );
        return;
      }
    }
    clearWaitExpectedEvent() {
      if (this._waitExpectedTimeoutId) {
        clearTimeout(this._waitExpectedTimeoutId);
        this._waitExpectedTimeoutId = void 0;
      }
    }
    onMessage(msg) {
      switch (this.watchStatus) {
        case WATCH_STATUS.PAUSED: {
          if (msg.msgType !== 'ERROR') {
            return;
          }
          break;
        }
        case WATCH_STATUS.LOGGINGIN:
        case WATCH_STATUS.INITING:
        case WATCH_STATUS.REBUILDING: {
          console.warn(
            `[realtime listener] internal non-fatal error: unexpected message received while ${this.watchStatus}`,
          );
          return;
        }
        case WATCH_STATUS.CLOSED: {
          console.warn(
            '[realtime listener] internal non-fatal error: unexpected message received when the watch has closed',
          );
          return;
        }
        case WATCH_STATUS.ERRORED: {
          console.warn(
            '[realtime listener] internal non-fatal error: unexpected message received when the watch has ended with error',
          );
          return;
        }
      }
      if (!this.sessionInfo) {
        console.warn(
          '[realtime listener] internal non-fatal error: sessionInfo not found while message is received.',
        );
        return;
      }
      this.scheduleSendACK();
      switch (msg.msgType) {
        case 'NEXT_EVENT': {
          console.warn(`nextevent ${msg.msgData.currEvent} ignored`, msg);
          this.handleServerEvents(msg);
          break;
        }
        case 'CHECK_EVENT': {
          if (this.sessionInfo.currentEventId < msg.msgData.currEvent) {
            this.sessionInfo.expectEventId = msg.msgData.currEvent;
            this.clearWaitExpectedEvent();
            this._waitExpectedTimeoutId = setTimeout(() => {
              this.rebuildWatch();
            }, this.getWaitExpectedTimeoutLength());
            console.log(
              `[realtime] waitExpectedTimeoutLength ${this.getWaitExpectedTimeoutLength()}`,
            );
          }
          break;
        }
        case 'ERROR': {
          this.closeWithError(
            new error_1.CloudSDKError({
              errCode:
                error_config_1.ERR_CODE
                  .SDK_DATABASE_REALTIME_LISTENER_SERVER_ERROR_MSG,
              errMsg: `${msg.msgData.code} - ${msg.msgData.message}`,
            }),
          );
          break;
        }
        default: {
          console.warn(
            `[realtime listener] virtual client receive unexpected msg ${msg.msgType}: `,
            msg,
          );
          break;
        }
      }
    }
    closeWithError(error) {
      this.watchStatus = WATCH_STATUS.ERRORED;
      this.clearACKSchedule();
      this.listener.onError(error);
      this.onWatchClose(
        this,
        (this.sessionInfo && this.sessionInfo.queryID) || '',
      );
      console.log(
        `[realtime] client closed (${this.collectionName} ${this.query}) (watchId ${this.watchId})`,
      );
    }
    pause() {
      this.watchStatus = WATCH_STATUS.PAUSED;
      console.log(
        `[realtime] client paused (${this.collectionName} ${this.query}) (watchId ${this.watchId})`,
      );
    }
    async resume() {
      this.watchStatus = WATCH_STATUS.RESUMING;
      console.log(
        `[realtime] client resuming with ${
          this.sessionInfo ? 'REBUILD_WATCH' : 'INIT_WATCH'
        } (${this.collectionName} ${this.query}) (${this.watchId})`,
      );
      try {
        await (this.sessionInfo ? this.rebuildWatch() : this.initWatch());
        console.log(
          `[realtime] client successfully resumed (${this.collectionName} ${this.query}) (${this.watchId})`,
        );
      } catch (e) {
        console.error(
          `[realtime] client resume failed (${this.collectionName} ${this.query}) (${this.watchId})`,
          e,
        );
      }
    }
  };
  exports2.VirtualWebSocketClient = VirtualWebSocketClient;
  function getPublicEvent(event) {
    const e = {
      id: event.ID,
      dataType: event.DataType,
      queueType: event.QueueType,
      docId: event.DocID,
      doc: event.Doc && event.Doc !== '{}' ? JSON.parse(event.Doc) : void 0,
    };
    if (event.DataType === 'update') {
      if (event.UpdatedFields) {
        e.updatedFields = JSON.parse(event.UpdatedFields);
      }
      if (event.removedFields || event.RemovedFields) {
        e.removedFields = JSON.parse(event.removedFields);
      }
    }
    return e;
  }
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/realtime/ws-event.js
var require_ws_event = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var error_1 = require_error();
  var error_config_1 = require_error_config();
  exports2.CLOSE_EVENT_CODE_INFO = {
    1e3: {
      code: 1e3,
      name: 'Normal Closure',
      description:
        'Normal closure; the connection successfully completed whatever purpose for which it was created.',
    },
    1001: {
      code: 1001,
      name: 'Going Away',
      description:
        'The endpoint is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection.',
    },
    1002: {
      code: 1002,
      name: 'Protocol Error',
      description:
        'The endpoint is terminating the connection due to a protocol error.',
    },
    1003: {
      code: 1003,
      name: 'Unsupported Data',
      description:
        'The connection is being terminated because the endpoint received data of a type it cannot accept (for example, a text-only endpoint received binary data).',
    },
    1005: {
      code: 1005,
      name: 'No Status Received',
      description:
        'Indicates that no status code was provided even though one was expected.',
    },
    1006: {
      code: 1006,
      name: 'Abnormal Closure',
      description:
        'Used to indicate that a connection was closed abnormally (that is, with no close frame being sent) when a status code is expected.',
    },
    1007: {
      code: 1007,
      name: 'Invalid frame payload data',
      description:
        'The endpoint is terminating the connection because a message was received that contained inconsistent data (e.g., non-UTF-8 data within a text message).',
    },
    1008: {
      code: 1008,
      name: 'Policy Violation',
      description:
        'The endpoint is terminating the connection because it received a message that violates its policy. This is a generic status code, used when codes 1003 and 1009 are not suitable.',
    },
    1009: {
      code: 1009,
      name: 'Message too big',
      description:
        'The endpoint is terminating the connection because a data frame was received that is too large.',
    },
    1010: {
      code: 1010,
      name: 'Missing Extension',
      description:
        "The client is terminating the connection because it expected the server to negotiate one or more extension, but the server didn't.",
    },
    1011: {
      code: 1011,
      name: 'Internal Error',
      description:
        'The server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request.',
    },
    1012: {
      code: 1012,
      name: 'Service Restart',
      description:
        'The server is terminating the connection because it is restarting.',
    },
    1013: {
      code: 1013,
      name: 'Try Again Later',
      description:
        'The server is terminating the connection due to a temporary condition, e.g. it is overloaded and is casting off some of its clients.',
    },
    1014: {
      code: 1014,
      name: 'Bad Gateway',
      description:
        'The server was acting as a gateway or proxy and received an invalid response from the upstream server. This is similar to 502 HTTP Status Code.',
    },
    1015: {
      code: 1015,
      name: 'TLS Handshake',
      description:
        "Indicates that the connection was closed due to a failure to perform a TLS handshake (e.g., the server certificate can't be verified).",
    },
    3e3: {
      code: 3e3,
      name: 'Reconnect WebSocket',
      description:
        'The client is terminating the connection because it wants to reconnect',
    },
    3001: {
      code: 3001,
      name: 'No Realtime Listeners',
      description:
        'The client is terminating the connection because no more realtime listeners exist',
    },
    3002: {
      code: 3002,
      name: 'Heartbeat Ping Error',
      description:
        'The client is terminating the connection due to its failure in sending heartbeat messages',
    },
    3003: {
      code: 3003,
      name: 'Heartbeat Pong Timeout Error',
      description:
        'The client is terminating the connection because no heartbeat response is received from the server',
    },
    3050: {
      code: 3050,
      name: 'Server Close',
      description:
        'The client is terminating the connection because no heartbeat response is received from the server',
    },
  };
  var CLOSE_EVENT_CODE;
  (function (CLOSE_EVENT_CODE2) {
    CLOSE_EVENT_CODE2[(CLOSE_EVENT_CODE2['NormalClosure'] = 1e3)] =
      'NormalClosure';
    CLOSE_EVENT_CODE2[(CLOSE_EVENT_CODE2['GoingAway'] = 1001)] = 'GoingAway';
    CLOSE_EVENT_CODE2[(CLOSE_EVENT_CODE2['ProtocolError'] = 1002)] =
      'ProtocolError';
    CLOSE_EVENT_CODE2[(CLOSE_EVENT_CODE2['UnsupportedData'] = 1003)] =
      'UnsupportedData';
    CLOSE_EVENT_CODE2[(CLOSE_EVENT_CODE2['NoStatusReceived'] = 1005)] =
      'NoStatusReceived';
    CLOSE_EVENT_CODE2[(CLOSE_EVENT_CODE2['AbnormalClosure'] = 1006)] =
      'AbnormalClosure';
    CLOSE_EVENT_CODE2[(CLOSE_EVENT_CODE2['InvalidFramePayloadData'] = 1007)] =
      'InvalidFramePayloadData';
    CLOSE_EVENT_CODE2[(CLOSE_EVENT_CODE2['PolicyViolation'] = 1008)] =
      'PolicyViolation';
    CLOSE_EVENT_CODE2[(CLOSE_EVENT_CODE2['MessageTooBig'] = 1009)] =
      'MessageTooBig';
    CLOSE_EVENT_CODE2[(CLOSE_EVENT_CODE2['MissingExtension'] = 1010)] =
      'MissingExtension';
    CLOSE_EVENT_CODE2[(CLOSE_EVENT_CODE2['InternalError'] = 1011)] =
      'InternalError';
    CLOSE_EVENT_CODE2[(CLOSE_EVENT_CODE2['ServiceRestart'] = 1012)] =
      'ServiceRestart';
    CLOSE_EVENT_CODE2[(CLOSE_EVENT_CODE2['TryAgainLater'] = 1013)] =
      'TryAgainLater';
    CLOSE_EVENT_CODE2[(CLOSE_EVENT_CODE2['BadGateway'] = 1014)] = 'BadGateway';
    CLOSE_EVENT_CODE2[(CLOSE_EVENT_CODE2['TLSHandshake'] = 1015)] =
      'TLSHandshake';
    CLOSE_EVENT_CODE2[(CLOSE_EVENT_CODE2['ReconnectWebSocket'] = 3e3)] =
      'ReconnectWebSocket';
    CLOSE_EVENT_CODE2[(CLOSE_EVENT_CODE2['NoRealtimeListeners'] = 3001)] =
      'NoRealtimeListeners';
    CLOSE_EVENT_CODE2[(CLOSE_EVENT_CODE2['HeartbeatPingError'] = 3002)] =
      'HeartbeatPingError';
    CLOSE_EVENT_CODE2[(CLOSE_EVENT_CODE2['HeartbeatPongTimeoutError'] = 3003)] =
      'HeartbeatPongTimeoutError';
    CLOSE_EVENT_CODE2[(CLOSE_EVENT_CODE2['NoAuthentication'] = 3050)] =
      'NoAuthentication';
  })(
    (CLOSE_EVENT_CODE =
      exports2.CLOSE_EVENT_CODE || (exports2.CLOSE_EVENT_CODE = {})),
  );
  exports2.getWSCloseError = (code, reason) => {
    const info = exports2.CLOSE_EVENT_CODE_INFO[code];
    const errMsg = !info
      ? `code ${code}`
      : `${info.name}, code ${code}, reason ${reason || info.description}`;
    return new error_1.CloudSDKError({
      errCode:
        error_config_1.ERR_CODE
          .SDK_DATABASE_REALTIME_LISTENER_WEBSOCKET_CONNECTION_CLOSED,
      errMsg,
    });
  };
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/realtime/websocket-client.js
var require_websocket_client = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var virtual_websocket_client_1 = require_virtual_websocket_client();
  var utils_1 = require_utils2();
  var message_1 = require_message();
  var ws_event_1 = require_ws_event();
  var error_1 = require_error();
  var error_2 = require_error2();
  var error_config_1 = require_error_config();
  var __1 = require_commonjs();
  var WS_READY_STATE = {
    CONNECTING: 0,
    OPEN: 1,
    CLOSING: 2,
    CLOSED: 3,
  };
  var MAX_RTT_OBSERVED = 3;
  var DEFAULT_EXPECTED_EVENT_WAIT_TIME = 5e3;
  var DEFAULT_UNTRUSTED_RTT_THRESHOLD = 1e4;
  var DEFAULT_MAX_RECONNECT = 5;
  var DEFAULT_WS_RECONNECT_INTERVAL = 1e4;
  var DEFAULT_PING_FAIL_TOLERANCE = 2;
  var DEFAULT_PONG_MISS_TOLERANCE = 2;
  var DEFAULT_LOGIN_TIMEOUT = 5e3;
  var RealtimeWebSocketClient = class {
    constructor(options) {
      this._virtualWSClient = new Set();
      this._queryIdClientMap = new Map();
      this._watchIdClientMap = new Map();
      this._pingFailed = 0;
      this._pongMissed = 0;
      this._logins = new Map();
      this._wsReadySubsribers = [];
      this._wsResponseWait = new Map();
      this._rttObserved = [];
      this.initWebSocketConnection = async (
        reconnect,
        availableRetries = this._maxReconnect,
      ) => {
        if (reconnect && this._reconnectState) {
          return;
        }
        if (reconnect) {
          this._reconnectState = true;
        }
        if (this._wsInitPromise) {
          return this._wsInitPromise;
        }
        if (reconnect) {
          this.pauseClients();
        }
        this.close(ws_event_1.CLOSE_EVENT_CODE.ReconnectWebSocket);
        this._wsInitPromise = new Promise(async (resolve, reject) => {
          try {
            const wsSign = await this.getWsSign();
            await new Promise((success) => {
              const url = wsSign.wsUrl || 'wss://tcb-ws.tencentcloudapi.com';
              this._ws = __1.Db.wsClass
                ? new __1.Db.wsClass(url)
                : new WebSocket(url);
              success();
            });
            if (this._ws.connect) {
              await this._ws.connect();
            }
            await this.initWebSocketEvent();
            resolve();
            if (reconnect) {
              this.resumeClients();
              this._reconnectState = false;
            }
          } catch (e) {
            console.error('[realtime] initWebSocketConnection connect fail', e);
            if (availableRetries > 0) {
              const isConnected = true;
              this._wsInitPromise = void 0;
              if (isConnected) {
                await utils_1.sleep(this._reconnectInterval);
                if (reconnect) {
                  this._reconnectState = false;
                }
              }
              resolve(
                this.initWebSocketConnection(reconnect, availableRetries - 1),
              );
            } else {
              reject(e);
              if (reconnect) {
                this.closeAllClients(
                  new error_1.CloudSDKError({
                    errCode:
                      error_config_1.ERR_CODE
                        .SDK_DATABASE_REALTIME_LISTENER_RECONNECT_WATCH_FAIL,
                    errMsg: e,
                  }),
                );
              }
            }
          }
        });
        try {
          await this._wsInitPromise;
          this._wsReadySubsribers.forEach(({ resolve }) => resolve());
        } catch (e) {
          this._wsReadySubsribers.forEach(({ reject }) => reject());
        } finally {
          this._wsInitPromise = void 0;
          this._wsReadySubsribers = [];
        }
      };
      this.initWebSocketEvent = () =>
        new Promise((resolve, reject) => {
          if (!this._ws) {
            throw new Error('can not initWebSocketEvent, ws not exists');
          }
          let wsOpened = false;
          this._ws.onopen = (event) => {
            console.warn('[realtime] ws event: open', event);
            wsOpened = true;
            resolve();
          };
          this._ws.onerror = (event) => {
            this._logins = new Map();
            if (!wsOpened) {
              console.error(
                '[realtime] ws open failed with ws event: error',
                event,
              );
              reject(event);
            } else {
              console.error('[realtime] ws event: error', event);
              this.clearHeartbeat();
              this._virtualWSClient.forEach((client) =>
                client.closeWithError(
                  new error_1.CloudSDKError({
                    errCode:
                      error_config_1.ERR_CODE
                        .SDK_DATABASE_REALTIME_LISTENER_WEBSOCKET_CONNECTION_ERROR,
                    errMsg: event,
                  }),
                ),
              );
            }
          };
          this._ws.onclose = (closeEvent) => {
            console.warn('[realtime] ws event: close', closeEvent);
            this._logins = new Map();
            this.clearHeartbeat();
            switch (closeEvent.code) {
              case ws_event_1.CLOSE_EVENT_CODE.ReconnectWebSocket: {
                break;
              }
              case ws_event_1.CLOSE_EVENT_CODE.NoRealtimeListeners: {
                break;
              }
              case ws_event_1.CLOSE_EVENT_CODE.HeartbeatPingError:
              case ws_event_1.CLOSE_EVENT_CODE.HeartbeatPongTimeoutError:
              case ws_event_1.CLOSE_EVENT_CODE.NormalClosure:
              case ws_event_1.CLOSE_EVENT_CODE.AbnormalClosure: {
                if (this._maxReconnect > 0) {
                  this.initWebSocketConnection(true, this._maxReconnect);
                } else {
                  this.closeAllClients(
                    ws_event_1.getWSCloseError(closeEvent.code),
                  );
                }
                break;
              }
              case ws_event_1.CLOSE_EVENT_CODE.NoAuthentication: {
                this.closeAllClients(
                  ws_event_1.getWSCloseError(
                    closeEvent.code,
                    closeEvent.reason,
                  ),
                );
                break;
              }
              default: {
                if (this._maxReconnect > 0) {
                  this.initWebSocketConnection(true, this._maxReconnect);
                } else {
                  this.closeAllClients(
                    ws_event_1.getWSCloseError(closeEvent.code),
                  );
                }
              }
            }
          };
          this._ws.onmessage = (res) => {
            const rawMsg = res.data;
            this.heartbeat();
            let msg;
            try {
              msg = JSON.parse(rawMsg);
            } catch (e) {
              throw new Error(
                `[realtime] onMessage parse res.data error: ${e}`,
              );
            }
            if (msg.msgType === 'ERROR') {
              let virtualWatch = null;
              this._virtualWSClient.forEach((item) => {
                if (item.watchId === msg.watchId) {
                  virtualWatch = item;
                }
              });
              if (virtualWatch) {
                virtualWatch.listener.onError(msg);
              }
            }
            const responseWaitSpec = this._wsResponseWait.get(msg.requestId);
            if (responseWaitSpec) {
              try {
                if (msg.msgType === 'ERROR') {
                  responseWaitSpec.reject(
                    new error_2.RealtimeErrorMessageError(msg),
                  );
                } else {
                  responseWaitSpec.resolve(msg);
                }
              } catch (e) {
                console.error(
                  'ws onMessage responseWaitSpec.resolve(msg) errored:',
                  e,
                );
              } finally {
                this._wsResponseWait.delete(msg.requestId);
              }
              if (responseWaitSpec.skipOnMessage) {
                return;
              }
            }
            if (msg.msgType === 'PONG') {
              if (this._lastPingSendTS) {
                const rtt = Date.now() - this._lastPingSendTS;
                if (rtt > DEFAULT_UNTRUSTED_RTT_THRESHOLD) {
                  console.warn(`[realtime] untrusted rtt observed: ${rtt}`);
                  return;
                }
                if (this._rttObserved.length >= MAX_RTT_OBSERVED) {
                  this._rttObserved.splice(
                    0,
                    this._rttObserved.length - MAX_RTT_OBSERVED + 1,
                  );
                }
                this._rttObserved.push(rtt);
              }
              return;
            }
            let client = msg.watchId && this._watchIdClientMap.get(msg.watchId);
            if (client) {
              client.onMessage(msg);
            } else {
              console.error(
                `[realtime] no realtime listener found responsible for watchId ${msg.watchId}: `,
                msg,
              );
              switch (msg.msgType) {
                case 'INIT_EVENT':
                case 'NEXT_EVENT':
                case 'CHECK_EVENT': {
                  client = this._queryIdClientMap.get(msg.msgData.queryID);
                  if (client) {
                    client.onMessage(msg);
                  }
                  break;
                }
                default: {
                  for (const [, client2] of this._watchIdClientMap) {
                    client2.onMessage(msg);
                    break;
                  }
                }
              }
            }
          };
          this.heartbeat();
        });
      this.isWSConnected = () => {
        return Boolean(this._ws && this._ws.readyState === WS_READY_STATE.OPEN);
      };
      this.onceWSConnected = async () => {
        if (this.isWSConnected()) {
          return;
        }
        if (this._wsInitPromise) {
          return this._wsInitPromise;
        }
        return new Promise((resolve, reject) => {
          this._wsReadySubsribers.push({
            resolve,
            reject,
          });
        });
      };
      this.webLogin = async (envId, refresh) => {
        if (!refresh) {
          if (envId) {
            const loginInfo2 = this._logins.get(envId);
            if (loginInfo2) {
              if (loginInfo2.loggedIn && loginInfo2.loginResult) {
                return loginInfo2.loginResult;
              } else if (loginInfo2.loggingInPromise) {
                return loginInfo2.loggingInPromise;
              }
            }
          } else {
            const emptyEnvLoginInfo = this._logins.get('');
            if (emptyEnvLoginInfo && emptyEnvLoginInfo.loggingInPromise) {
              return emptyEnvLoginInfo.loggingInPromise;
            }
          }
        }
        const promise = new Promise(async (resolve, reject) => {
          try {
            const wsSign = await this.getWsSign();
            const msgData = {
              envId: wsSign.envId || '',
              accessToken: '',
              referrer: 'web',
              sdkVersion: '',
              dataVersion: __1.Db.dataVersion || '',
            };
            const loginMsg = {
              watchId: void 0,
              requestId: message_1.genRequestId(),
              msgType: 'LOGIN',
              msgData,
              exMsgData: {
                runtime: __1.Db.runtime,
                signStr: wsSign.signStr,
                secretVersion: wsSign.secretVersion,
              },
            };
            const loginResMsg = await this.send({
              msg: loginMsg,
              waitResponse: true,
              skipOnMessage: true,
              timeout: DEFAULT_LOGIN_TIMEOUT,
            });
            if (!loginResMsg.msgData.code) {
              resolve({
                envId: wsSign.envId,
              });
            } else {
              reject(
                new Error(
                  `${loginResMsg.msgData.code} ${loginResMsg.msgData.message}`,
                ),
              );
            }
          } catch (e) {
            reject(e);
          }
        });
        let loginInfo = envId && this._logins.get(envId);
        const loginStartTS = Date.now();
        if (loginInfo) {
          loginInfo.loggedIn = false;
          loginInfo.loggingInPromise = promise;
          loginInfo.loginStartTS = loginStartTS;
        } else {
          loginInfo = {
            loggedIn: false,
            loggingInPromise: promise,
            loginStartTS,
          };
          this._logins.set(envId || '', loginInfo);
        }
        try {
          const loginResult = await promise;
          const curLoginInfo = envId && this._logins.get(envId);
          if (
            curLoginInfo &&
            curLoginInfo === loginInfo &&
            curLoginInfo.loginStartTS === loginStartTS
          ) {
            loginInfo.loggedIn = true;
            loginInfo.loggingInPromise = void 0;
            loginInfo.loginStartTS = void 0;
            loginInfo.loginResult = loginResult;
            return loginResult;
          } else if (curLoginInfo) {
            if (curLoginInfo.loggedIn && curLoginInfo.loginResult) {
              return curLoginInfo.loginResult;
            } else if (curLoginInfo.loggingInPromise) {
              return curLoginInfo.loggingInPromise;
            } else {
              throw new Error('ws unexpected login info');
            }
          } else {
            throw new Error('ws login info reset');
          }
        } catch (e) {
          loginInfo.loggedIn = false;
          loginInfo.loggingInPromise = void 0;
          loginInfo.loginStartTS = void 0;
          loginInfo.loginResult = void 0;
          throw e;
        }
      };
      this.getWsSign = async () => {
        if (this._wsSign && this._wsSign.expiredTs > Date.now()) {
          return this._wsSign;
        }
        const expiredTs = Date.now() + 6e4;
        const res = await this._context.appConfig.request.send(
          'auth.wsWebSign',
          { runtime: __1.Db.runtime },
        );
        if (res.code) {
          throw new Error(
            `[tcb-js-sdk] \u83B7\u53D6\u5B9E\u65F6\u6570\u636E\u63A8\u9001\u767B\u5F55\u7968\u636E\u5931\u8D25: ${res.code}`,
          );
        }
        if (res.data) {
          const { signStr, wsUrl, secretVersion, envId } = res.data;
          return {
            signStr,
            wsUrl,
            secretVersion,
            envId,
            expiredTs,
          };
        } else {
          throw new Error(
            '[tcb-js-sdk] \u83B7\u53D6\u5B9E\u65F6\u6570\u636E\u63A8\u9001\u767B\u5F55\u7968\u636E\u5931\u8D25',
          );
        }
      };
      this.getWaitExpectedTimeoutLength = () => {
        if (!this._rttObserved.length) {
          return DEFAULT_EXPECTED_EVENT_WAIT_TIME;
        }
        return (
          (this._rttObserved.reduce((acc, cur) => acc + cur) /
            this._rttObserved.length) *
          1.5
        );
      };
      this.ping = async () => {
        const msg = {
          watchId: void 0,
          requestId: message_1.genRequestId(),
          msgType: 'PING',
          msgData: null,
        };
        await this.send({
          msg,
        });
      };
      this.send = async (opts) =>
        new Promise(async (_resolve, _reject) => {
          let timeoutId;
          let _hasResolved = false;
          let _hasRejected = false;
          const resolve = (value) => {
            _hasResolved = true;
            timeoutId && clearTimeout(timeoutId);
            _resolve(value);
          };
          const reject = (error) => {
            _hasRejected = true;
            timeoutId && clearTimeout(timeoutId);
            _reject(error);
          };
          if (opts.timeout) {
            timeoutId = setTimeout(async () => {
              if (!_hasResolved || !_hasRejected) {
                await utils_1.sleep(0);
                if (!_hasResolved || !_hasRejected) {
                  reject(new error_1.TimeoutError('wsclient.send timedout'));
                }
              }
            }, opts.timeout);
          }
          try {
            if (this._wsInitPromise) {
              await this._wsInitPromise;
            }
            if (!this._ws) {
              reject(
                new Error(
                  'invalid state: ws connection not exists, can not send message',
                ),
              );
              return;
            }
            if (this._ws.readyState !== WS_READY_STATE.OPEN) {
              reject(
                new Error(
                  `ws readyState invalid: ${this._ws.readyState}, can not send message`,
                ),
              );
              return;
            }
            if (opts.waitResponse) {
              this._wsResponseWait.set(opts.msg.requestId, {
                resolve,
                reject,
                skipOnMessage: opts.skipOnMessage,
              });
            }
            try {
              await this._ws.send(JSON.stringify(opts.msg));
              if (!opts.waitResponse) {
                resolve();
              }
            } catch (err) {
              if (err) {
                reject(err);
                if (opts.waitResponse) {
                  this._wsResponseWait.delete(opts.msg.requestId);
                }
              }
            }
          } catch (e) {
            reject(e);
          }
        });
      this.closeAllClients = (error) => {
        this._virtualWSClient.forEach((client) => {
          client.closeWithError(error);
        });
      };
      this.pauseClients = (clients) => {
        (clients || this._virtualWSClient).forEach((client) => {
          client.pause();
        });
      };
      this.resumeClients = (clients) => {
        (clients || this._virtualWSClient).forEach((client) => {
          client.resume();
        });
      };
      this.onWatchStart = (client, queryID) => {
        this._queryIdClientMap.set(queryID, client);
      };
      this.onWatchClose = (client, queryID) => {
        if (queryID) {
          this._queryIdClientMap.delete(queryID);
        }
        this._watchIdClientMap.delete(client.watchId);
        this._virtualWSClient.delete(client);
        if (!this._virtualWSClient.size) {
          this.close(ws_event_1.CLOSE_EVENT_CODE.NoRealtimeListeners);
        }
      };
      this._maxReconnect = options.maxReconnect || DEFAULT_MAX_RECONNECT;
      this._reconnectInterval =
        options.reconnectInterval || DEFAULT_WS_RECONNECT_INTERVAL;
      this._context = options.context;
    }
    heartbeat(immediate) {
      this.clearHeartbeat();
      this._pingTimeoutId = setTimeout(
        async () => {
          try {
            if (!this._ws || this._ws.readyState !== WS_READY_STATE.OPEN) {
              return;
            }
            this._lastPingSendTS = Date.now();
            await this.ping();
            this._pingFailed = 0;
            this._pongTimeoutId = setTimeout(() => {
              console.error('pong timed out');
              if (this._pongMissed < DEFAULT_PONG_MISS_TOLERANCE) {
                this._pongMissed++;
                this.heartbeat(true);
              } else {
                this.initWebSocketConnection(true);
              }
            }, this._context.appConfig.realtimePongWaitTimeout);
          } catch (e) {
            if (this._pingFailed < DEFAULT_PING_FAIL_TOLERANCE) {
              this._pingFailed++;
              this.heartbeat();
            } else {
              this.close(ws_event_1.CLOSE_EVENT_CODE.HeartbeatPingError);
            }
          }
        },
        immediate ? 0 : this._context.appConfig.realtimePingInterval,
      );
    }
    clearHeartbeat() {
      this._pingTimeoutId && clearTimeout(this._pingTimeoutId);
      this._pongTimeoutId && clearTimeout(this._pongTimeoutId);
    }
    close(code) {
      this.clearHeartbeat();
      if (this._ws) {
        this._ws.close(code, ws_event_1.CLOSE_EVENT_CODE_INFO[code].name);
        this._ws = void 0;
      }
    }
    watch(options) {
      if (!this._ws && !this._wsInitPromise) {
        this.initWebSocketConnection(false);
      }
      const virtualClient = new virtual_websocket_client_1.VirtualWebSocketClient(
        Object.assign(Object.assign({}, options), {
          send: this.send,
          login: this.webLogin,
          isWSConnected: this.isWSConnected,
          onceWSConnected: this.onceWSConnected,
          getWaitExpectedTimeoutLength: this.getWaitExpectedTimeoutLength,
          onWatchStart: this.onWatchStart,
          onWatchClose: this.onWatchClose,
          debug: true,
        }),
      );
      this._virtualWSClient.add(virtualClient);
      this._watchIdClientMap.set(virtualClient.watchId, virtualClient);
      return virtualClient.listener;
    }
  };
  exports2.RealtimeWebSocketClient = RealtimeWebSocketClient;
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/document.js
var require_document = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var index_1 = require_commonjs();
  var util_1 = require_util();
  var update_1 = require_update2();
  var datatype_1 = require_datatype();
  var update_2 = require_update();
  var websocket_client_1 = require_websocket_client();
  var constant_1 = require_constant();
  var utils_1 = require_utils2();
  var code_1 = require_code();
  var bson_1 = require_bson();
  var DocumentReference = class {
    constructor(db2, coll, apiOptions, docID, transactionId) {
      this.watch = (options) => {
        if (!index_1.Db.ws) {
          index_1.Db.ws = new websocket_client_1.RealtimeWebSocketClient({
            context: {
              appConfig: {
                docSizeLimit: 1e3,
                realtimePingInterval: 1e4,
                realtimePongWaitTimeout: 5e3,
                request: this.request,
              },
            },
          });
        }
        return index_1.Db.ws.watch(
          Object.assign(Object.assign({}, options), {
            envId: this._db.config.env,
            collectionName: this._coll,
            query: JSON.stringify({
              _id: this.id,
            }),
          }),
        );
      };
      this._db = db2;
      this._coll = coll;
      this.id = docID;
      this._transactionId = transactionId;
      this.request = new index_1.Db.reqClass(this._db.config);
      this._apiOptions = apiOptions;
    }
    async create(data) {
      if (this.id) {
        data['_id'] = this.id;
      }
      let params = {
        collectionName: this._coll,
        data: [utils_1.stringifyByEJSON(datatype_1.serialize(data))],
        transactionId: this._transactionId,
      };
      const res = await this.request.send(
        'database.insertDocument',
        params,
        utils_1.getReqOpts(this._apiOptions),
      );
      if (res.code) {
        return res;
      }
      if (this._transactionId) {
        return {
          inserted: 1,
          ok: 1,
          id: res.data.insertedIds[0],
          requestId: res.requestId,
        };
      }
      return {
        id: res.data.insertedIds[0],
        requestId: res.requestId,
      };
    }
    async set(data) {
      if (!this.id) {
        return utils_1.processReturn(
          this._db.config.throwOnCode,
          Object.assign(Object.assign({}, code_1.ERRORS.INVALID_PARAM), {
            message: 'docId\u4E0D\u80FD\u4E3A\u7A7A',
          }),
        );
      }
      if (!data || typeof data !== 'object') {
        return utils_1.processReturn(
          this._db.config.throwOnCode,
          Object.assign(Object.assign({}, code_1.ERRORS.INVALID_PARAM), {
            message: '\u53C2\u6570\u5FC5\u9700\u662F\u975E\u7A7A\u5BF9\u8C61',
          }),
        );
      }
      if (data.hasOwnProperty('_id')) {
        return utils_1.processReturn(
          this._db.config.throwOnCode,
          Object.assign(Object.assign({}, code_1.ERRORS.INVALID_PARAM), {
            message: '\u4E0D\u80FD\u66F4\u65B0_id\u7684\u503C',
          }),
        );
      }
      let hasOperator = false;
      const checkMixed = (objs) => {
        if (typeof objs === 'object') {
          for (let key in objs) {
            if (objs[key] instanceof update_2.UpdateCommand) {
              hasOperator = true;
            } else if (typeof objs[key] === 'object') {
              checkMixed(objs[key]);
            }
          }
        }
      };
      checkMixed(data);
      if (hasOperator) {
        return utils_1.processReturn(
          this._db.config.throwOnCode,
          Object.assign(
            Object.assign({}, code_1.ERRORS.DATABASE_REQUEST_FAILED),
            { message: 'update operator complicit' },
          ),
        );
      }
      let param = {
        collectionName: this._coll,
        queryType: constant_1.QueryType.DOC,
        data: utils_1.stringifyByEJSON(datatype_1.serialize(data)),
        transactionId: this._transactionId,
        multi: false,
        merge: false,
        upsert: true,
      };
      if (this.id) {
        param['query'] = utils_1.stringifyByEJSON({ _id: this.id });
      }
      const res = await this.request.send(
        'database.modifyDocument',
        param,
        utils_1.getReqOpts(this._apiOptions),
      );
      if (res.code) {
        return res;
      }
      if (this._transactionId) {
        return {
          updated: res.data.updated,
          upserted: [{ _id: res.data.upsert_id }],
          requestId: res.requestId,
        };
      }
      return {
        updated: res.data.updated,
        upsertedId: res.data.upsert_id,
        requestId: res.requestId,
      };
    }
    async update(data) {
      if (!data || typeof data !== 'object') {
        return utils_1.processReturn(
          this._db.config.throwOnCode,
          Object.assign(Object.assign({}, code_1.ERRORS.INVALID_PARAM), {
            message: '\u53C2\u6570\u5FC5\u9700\u662F\u975E\u7A7A\u5BF9\u8C61',
          }),
        );
      }
      if (data.hasOwnProperty('_id')) {
        return utils_1.processReturn(
          this._db.config.throwOnCode,
          Object.assign(Object.assign({}, code_1.ERRORS.INVALID_PARAM), {
            message: '\u4E0D\u80FD\u66F4\u65B0_id\u7684\u503C',
          }),
        );
      }
      const query = utils_1.stringifyByEJSON({ _id: this.id });
      const param = {
        collectionName: this._coll,
        transactionId: this._transactionId,
        data: update_1.UpdateSerializer.encodeEJSON(data),
        query,
        queryType: constant_1.QueryType.DOC,
        multi: false,
        merge: true,
        upsert: false,
      };
      const res = await this.request.send(
        'database.modifyDocument',
        param,
        utils_1.getReqOpts(this._apiOptions),
      );
      if (res.code) {
        return res;
      }
      return {
        updated: res.data.updated,
        requestId: res.requestId,
      };
    }
    async delete() {
      return this.remove();
    }
    async remove() {
      const query = utils_1.stringifyByEJSON({ _id: this.id });
      const param = {
        collectionName: this._coll,
        transactionId: this._transactionId,
        query,
        queryType: constant_1.QueryType.DOC,
        multi: false,
      };
      const res = await this.request.send(
        'database.removeDocument',
        param,
        utils_1.getReqOpts(this._apiOptions),
      );
      if (res.code) {
        return res;
      }
      return {
        deleted: res.data.deleted,
        requestId: res.requestId,
      };
    }
    async get() {
      const query = utils_1.stringifyByEJSON({ _id: this.id });
      const { projection } = this._apiOptions;
      const param = {
        collectionName: this._coll,
        query,
        transactionId: this._transactionId,
        queryType: constant_1.QueryType.DOC,
        multi: false,
      };
      if (projection) {
        param.projection = utils_1.stringifyByEJSON(projection);
      }
      const res = await this.request.send(
        'database.getDocument',
        param,
        utils_1.getReqOpts(this._apiOptions),
      );
      if (res.code) {
        return res;
      }
      const list = res.data.list.map((item) => bson_1.EJSON.parse(item));
      const documents = util_1.Util.formatResDocumentData(list);
      if (this._transactionId) {
        return {
          data: documents[0] || null,
          requestId: res.requestId,
        };
      }
      return {
        data: documents,
        requestId: res.requestId,
        offset: res.data.offset,
        limit: res.data.limit,
      };
    }
    field(projection) {
      let transformProjection = {};
      for (let k in projection) {
        if (typeof projection[k] === 'boolean') {
          transformProjection[k] = projection[k] === true ? 1 : 0;
        }
        if (typeof projection[k] === 'number') {
          transformProjection[k] = projection[k] > 0 ? 1 : 0;
        }
        if (typeof projection[k] === 'object') {
          transformProjection[k] = projection[k];
        }
      }
      let newApiOption = Object.assign({}, this._apiOptions);
      newApiOption.projection = transformProjection;
      return new DocumentReference(
        this._db,
        this._coll,
        newApiOption,
        this.id,
        this._transactionId,
      );
    }
  };
  exports2.DocumentReference = DocumentReference;
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/serializer/query.js
var require_query2 = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var query_1 = require_query();
  var logic_1 = require_logic();
  var symbol_1 = require_symbol3();
  var type_1 = require_type();
  var operator_map_1 = require_operator_map();
  var common_1 = require_common();
  var utils_1 = require_utils2();
  var validate_1 = require_validate();
  var QuerySerializer = class {
    constructor() {}
    static encode(query) {
      const encoder = new QueryEncoder();
      return encoder.encodeQuery(query);
    }
    static encodeEJSON(query) {
      const encoder = new QueryEncoder();
      return utils_1.stringifyByEJSON(encoder.encodeQuery(query));
    }
  };
  exports2.QuerySerializer = QuerySerializer;
  var QueryEncoder = class {
    encodeQuery(query, key) {
      if (common_1.isConversionRequired(query)) {
        if (logic_1.isLogicCommand(query)) {
          return this.encodeLogicCommand(query);
        } else if (query_1.isQueryCommand(query)) {
          return this.encodeQueryCommand(query);
        } else if (type_1.isRegExp(query)) {
          return { [key]: this.encodeRegExp(query) };
        } else if (type_1.isDate(query)) {
          return { [key]: query };
        } else {
          return { [key]: this.encodeQueryObject(query) };
        }
      } else {
        if (type_1.isObject(query)) {
          return this.encodeQueryObject(query);
        } else {
          return query;
        }
      }
    }
    encodeRegExp(query) {
      return {
        $regularExpression: {
          pattern: query.source,
          options: query.flags,
        },
      };
    }
    encodeLogicCommand(query) {
      switch (query.operator) {
        case logic_1.LOGIC_COMMANDS_LITERAL.NOR:
        case logic_1.LOGIC_COMMANDS_LITERAL.AND:
        case logic_1.LOGIC_COMMANDS_LITERAL.OR: {
          const $op = operator_map_1.operatorToString(query.operator);
          const subqueries = query.operands.map((oprand) =>
            this.encodeQuery(oprand, query.fieldName),
          );
          return {
            [$op]: subqueries,
          };
        }
        case logic_1.LOGIC_COMMANDS_LITERAL.NOT: {
          const $op = operator_map_1.operatorToString(query.operator);
          const operatorExpression = query.operands[0];
          if (type_1.isRegExp(operatorExpression)) {
            return {
              [query.fieldName]: {
                [$op]: this.encodeRegExp(operatorExpression),
              },
            };
          } else {
            const subqueries = this.encodeQuery(operatorExpression)[
              query.fieldName
            ];
            return {
              [query.fieldName]: {
                [$op]: subqueries,
              },
            };
          }
        }
        default: {
          const $op = operator_map_1.operatorToString(query.operator);
          if (query.operands.length === 1) {
            const subquery = this.encodeQuery(query.operands[0]);
            return {
              [$op]: subquery,
            };
          } else {
            const subqueries = query.operands.map(this.encodeQuery.bind(this));
            return {
              [$op]: subqueries,
            };
          }
        }
      }
    }
    encodeQueryCommand(query) {
      if (query_1.isComparisonCommand(query)) {
        return this.encodeComparisonCommand(query);
      } else {
        return this.encodeComparisonCommand(query);
      }
    }
    encodeComparisonCommand(query) {
      if (query.fieldName === symbol_1.SYMBOL_UNSET_FIELD_NAME) {
        throw new Error(
          'Cannot encode a comparison command with unset field name',
        );
      }
      const $op = operator_map_1.operatorToString(query.operator);
      switch (query.operator) {
        case query_1.QUERY_COMMANDS_LITERAL.EQ:
        case query_1.QUERY_COMMANDS_LITERAL.NEQ:
        case query_1.QUERY_COMMANDS_LITERAL.LT:
        case query_1.QUERY_COMMANDS_LITERAL.LTE:
        case query_1.QUERY_COMMANDS_LITERAL.GT:
        case query_1.QUERY_COMMANDS_LITERAL.GTE:
        case query_1.QUERY_COMMANDS_LITERAL.ELEM_MATCH:
        case query_1.QUERY_COMMANDS_LITERAL.EXISTS:
        case query_1.QUERY_COMMANDS_LITERAL.SIZE:
        case query_1.QUERY_COMMANDS_LITERAL.MOD: {
          return {
            [query.fieldName]: {
              [$op]: common_1.encodeInternalDataType(query.operands[0]),
            },
          };
        }
        case query_1.QUERY_COMMANDS_LITERAL.IN:
        case query_1.QUERY_COMMANDS_LITERAL.NIN:
        case query_1.QUERY_COMMANDS_LITERAL.ALL: {
          return {
            [query.fieldName]: {
              [$op]: common_1.encodeInternalDataType(query.operands),
            },
          };
        }
        case query_1.QUERY_COMMANDS_LITERAL.GEO_NEAR: {
          const options = query.operands[0];
          return {
            [query.fieldName]: {
              $nearSphere: {
                $geometry: options.geometry.toJSON(),
                $maxDistance: options.maxDistance,
                $minDistance: options.minDistance,
              },
            },
          };
        }
        case query_1.QUERY_COMMANDS_LITERAL.GEO_WITHIN: {
          const options = query.operands[0];
          if (options.centerSphere) {
            validate_1.Validate.isCentersPhere(options.centerSphere);
            const centerSphere = options.centerSphere;
            if (centerSphere[0]._internalType === symbol_1.SYMBOL_GEO_POINT) {
              return {
                [query.fieldName]: {
                  $geoWithin: {
                    $centerSphere: [
                      centerSphere[0].toJSON().coordinates,
                      centerSphere[1],
                    ],
                  },
                },
              };
            }
            return {
              [query.fieldName]: {
                $geoWithin: {
                  $centerSphere: options.centerSphere,
                },
              },
            };
          }
          return {
            [query.fieldName]: {
              $geoWithin: {
                $geometry: options.geometry.toJSON(),
              },
            },
          };
        }
        case query_1.QUERY_COMMANDS_LITERAL.GEO_INTERSECTS: {
          const options = query.operands[0];
          return {
            [query.fieldName]: {
              $geoIntersects: {
                $geometry: options.geometry.toJSON(),
              },
            },
          };
        }
        default: {
          return {
            [query.fieldName]: {
              [$op]: common_1.encodeInternalDataType(query.operands[0]),
            },
          };
        }
      }
    }
    encodeQueryObject(query) {
      const flattened = common_1.flattenQueryObject(query);
      for (const key in flattened) {
        const val = flattened[key];
        if (logic_1.isLogicCommand(val)) {
          flattened[key] = val._setFieldName(key);
          const condition = this.encodeLogicCommand(flattened[key]);
          this.mergeConditionAfterEncode(flattened, condition, key);
        } else if (query_1.isComparisonCommand(val)) {
          flattened[key] = val._setFieldName(key);
          const condition = this.encodeComparisonCommand(flattened[key]);
          this.mergeConditionAfterEncode(flattened, condition, key);
        } else if (common_1.isConversionRequired(val)) {
          flattened[key] = common_1.encodeInternalDataType(val);
        }
      }
      return flattened;
    }
    mergeConditionAfterEncode(query, condition, key) {
      if (!condition[key]) {
        delete query[key];
      }
      for (const conditionKey in condition) {
        if (query[conditionKey]) {
          if (type_1.isArray(query[conditionKey])) {
            query[conditionKey] = query[conditionKey].concat(
              condition[conditionKey],
            );
          } else if (type_1.isObject(query[conditionKey])) {
            if (type_1.isObject(condition[conditionKey])) {
              Object.assign(query, condition);
            } else {
              console.warn(
                `unmergable condition, query is object but condition is ${type_1.getType(
                  condition,
                )}, can only overwrite`,
                condition,
                key,
              );
              query[conditionKey] = condition[conditionKey];
            }
          } else {
            console.warn(
              `to-merge query is of type ${type_1.getType(
                query,
              )}, can only overwrite`,
              query,
              condition,
              key,
            );
            query[conditionKey] = condition[conditionKey];
          }
        } else {
          query[conditionKey] = condition[conditionKey];
        }
      }
    }
  };
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/query.js
var require_query3 = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var constant_1 = require_constant();
  var index_1 = require_commonjs();
  var validate_1 = require_validate();
  var util_1 = require_util();
  var query_1 = require_query2();
  var update_1 = require_update2();
  var websocket_client_1 = require_websocket_client();
  var constant_2 = require_constant();
  var utils_1 = require_utils2();
  var code_1 = require_code();
  var bson_1 = require_bson();
  var Query = class {
    constructor(db2, coll, fieldFilters, apiOptions, transactionId) {
      this.watch = (options) => {
        if (!index_1.Db.ws) {
          index_1.Db.ws = new websocket_client_1.RealtimeWebSocketClient({
            context: {
              appConfig: {
                docSizeLimit: 1e3,
                realtimePingInterval: 1e4,
                realtimePongWaitTimeout: 5e3,
                request: this._request,
              },
            },
          });
        }
        const { limit, order } = this._apiOptions;
        return index_1.Db.ws.watch(
          Object.assign(Object.assign({}, options), {
            envId: this._db.config.env,
            collectionName: this._coll,
            query: JSON.stringify(this._fieldFilters),
            limit,
            orderBy: order
              ? order.reduce((acc, cur) => {
                  acc[cur.field] = cur.direction;
                  return acc;
                }, {})
              : void 0,
          }),
        );
      };
      this._db = db2;
      this._coll = coll;
      this._fieldFilters = fieldFilters;
      this._apiOptions = apiOptions || {};
      this._request = new index_1.Db.reqClass(this._db.config);
      this._transactionId = transactionId;
    }
    async get() {
      const order = this._apiOptions.order;
      let param = {
        collectionName: this._coll,
        queryType: constant_1.QueryType.WHERE,
        transactionId: this._transactionId,
      };
      if (this._fieldFilters) {
        param.query = this._fieldFilters;
      }
      if (order) {
        param.order = utils_1.stringifyByEJSON(order);
      }
      const offset = this._apiOptions.offset;
      if (offset) {
        param.offset = offset;
      }
      const limit = this._apiOptions.limit;
      if (limit) {
        param.limit = limit < 1e3 ? limit : 1e3;
      } else {
        param.limit = 100;
      }
      const projection = this._apiOptions.projection;
      if (projection) {
        param.projection = utils_1.stringifyByEJSON(projection);
      }
      const res = await this._request.send(
        'database.getDocument',
        param,
        utils_1.getReqOpts(this._apiOptions),
      );
      if (res.code) {
        return res;
      }
      const list = res.data.list.map((item) => bson_1.EJSON.parse(item));
      const documents = util_1.Util.formatResDocumentData(list);
      const result = {
        data: documents,
        requestId: res.requestId,
      };
      if (res.limit) result.limit = res.limit;
      if (res.offset) result.offset = res.offset;
      return result;
    }
    async count() {
      let param = {
        collectionName: this._coll,
        queryType: constant_1.QueryType.WHERE,
      };
      if (this._fieldFilters) {
        param.query = this._fieldFilters;
      }
      const res = await this._request.send(
        'database.calculateDocument',
        param,
        utils_1.getReqOpts(this._apiOptions),
      );
      if (res.code) {
        return res;
      }
      return {
        requestId: res.requestId,
        total: res.data.total,
      };
    }
    where(query) {
      if (Object.prototype.toString.call(query).slice(8, -1) !== 'Object') {
        throw Error(constant_2.ErrorCode.QueryParamTypeError);
      }
      const keys = Object.keys(query);
      const checkFlag = keys.some((item) => {
        return query[item] !== void 0;
      });
      if (keys.length && !checkFlag) {
        throw Error(constant_2.ErrorCode.QueryParamValueError);
      }
      return new Query(
        this._db,
        this._coll,
        query_1.QuerySerializer.encodeEJSON(query),
        this._apiOptions,
        this._transactionId,
      );
    }
    options(apiOptions) {
      validate_1.Validate.isValidOptions(apiOptions);
      return new Query(
        this._db,
        this._coll,
        this._fieldFilters,
        apiOptions,
        this._transactionId,
      );
    }
    orderBy(fieldPath, directionStr) {
      validate_1.Validate.isFieldPath(fieldPath);
      validate_1.Validate.isFieldOrder(directionStr);
      const newOrder = {
        [fieldPath]: directionStr === 'desc' ? -1 : 1,
      };
      const order = this._apiOptions.order || {};
      const newApiOption = Object.assign({}, this._apiOptions, {
        order: Object.assign({}, order, newOrder),
      });
      return new Query(
        this._db,
        this._coll,
        this._fieldFilters,
        newApiOption,
        this._transactionId,
      );
    }
    limit(limit) {
      validate_1.Validate.isInteger('limit', limit);
      let newApiOption = Object.assign({}, this._apiOptions);
      newApiOption.limit = limit;
      return new Query(
        this._db,
        this._coll,
        this._fieldFilters,
        newApiOption,
        this._transactionId,
      );
    }
    skip(offset) {
      validate_1.Validate.isInteger('offset', offset);
      let newApiOption = Object.assign({}, this._apiOptions);
      newApiOption.offset = offset;
      return new Query(
        this._db,
        this._coll,
        this._fieldFilters,
        newApiOption,
        this._transactionId,
      );
    }
    async update(data) {
      if (!data || typeof data !== 'object') {
        return utils_1.processReturn(
          this._db.config.throwOnCode,
          Object.assign(Object.assign({}, code_1.ERRORS.INVALID_PARAM), {
            message: '\u53C2\u6570\u5FC5\u9700\u662F\u975E\u7A7A\u5BF9\u8C61',
          }),
        );
      }
      if (data.hasOwnProperty('_id')) {
        return utils_1.processReturn(
          this._db.config.throwOnCode,
          Object.assign(Object.assign({}, code_1.ERRORS.INVALID_PARAM), {
            message: '\u4E0D\u80FD\u66F4\u65B0_id\u7684\u503C',
          }),
        );
      }
      let { multiple } = this._apiOptions;
      const multi = multiple === void 0 ? true : multiple;
      let param = {
        collectionName: this._coll,
        queryType: constant_1.QueryType.WHERE,
        multi,
        merge: true,
        upsert: false,
        data: update_1.UpdateSerializer.encodeEJSON(data),
      };
      if (this._fieldFilters) {
        param.query = this._fieldFilters;
      }
      const res = await this._request.send(
        'database.modifyDocument',
        param,
        utils_1.getReqOpts(this._apiOptions),
      );
      if (res.code) {
        return res;
      }
      return {
        requestId: res.requestId,
        updated: res.data.updated,
        upsertId: res.data.upsert_id,
      };
    }
    field(projection) {
      let transformProjection = {};
      for (let k in projection) {
        if (typeof projection[k] === 'boolean') {
          transformProjection[k] = projection[k] === true ? 1 : 0;
        }
        if (typeof projection[k] === 'number') {
          transformProjection[k] = projection[k] > 0 ? 1 : 0;
        }
        if (typeof projection[k] === 'object') {
          transformProjection[k] = projection[k];
        }
      }
      let newApiOption = Object.assign({}, this._apiOptions);
      newApiOption.projection = transformProjection;
      return new Query(
        this._db,
        this._coll,
        this._fieldFilters,
        newApiOption,
        this._transactionId,
      );
    }
    async remove() {
      const { offset, limit, projection, order } = this._apiOptions;
      if (
        offset !== void 0 ||
        limit !== void 0 ||
        projection !== void 0 ||
        order !== void 0
      ) {
        console.warn(
          '`offset`, `limit`, `projection`, `orderBy` are not supported in remove() operation',
        );
      }
      let { multiple } = this._apiOptions;
      const multi = multiple === void 0 ? true : multiple;
      const param = {
        collectionName: this._coll,
        query: this._fieldFilters,
        queryType: constant_1.QueryType.WHERE,
        multi,
      };
      const res = await this._request.send(
        'database.removeDocument',
        param,
        utils_1.getReqOpts(this._apiOptions),
      );
      if (res.code) {
        return res;
      }
      return {
        requestId: res.requestId,
        deleted: res.data.deleted,
      };
    }
    async updateAndReturn(data) {
      if (!data || typeof data !== 'object') {
        return utils_1.processReturn(
          this._db.config.throwOnCode,
          Object.assign(Object.assign({}, code_1.ERRORS.INVALID_PARAM), {
            message: '\u53C2\u6570\u5FC5\u9700\u662F\u975E\u7A7A\u5BF9\u8C61',
          }),
        );
      }
      if (data.hasOwnProperty('_id')) {
        return utils_1.processReturn(
          this._db.config.throwOnCode,
          Object.assign(Object.assign({}, code_1.ERRORS.INVALID_PARAM), {
            message: '\u4E0D\u80FD\u66F4\u65B0_id\u7684\u503C',
          }),
        );
      }
      let param = {
        collectionName: this._coll,
        queryType: constant_1.QueryType.WHERE,
        data: update_1.UpdateSerializer.encodeEJSON(data),
      };
      if (this._transactionId) {
        param.transactionId = this._transactionId;
      }
      if (this._fieldFilters) {
        param.query = this._fieldFilters;
      }
      const res = await this._request.send(
        'database.modifyAndReturnDoc',
        param,
        utils_1.getReqOpts(this._apiOptions),
      );
      if (res.code) {
        return res;
      }
      return {
        requestId: res.requestId,
        updated: res.data.updated,
        doc: res.data.doc && bson_1.EJSON.parse(res.data.doc),
      };
    }
  };
  exports2.Query = Query;
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/aggregate.js
var require_aggregate = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var index_1 = require_commonjs();
  var bson_1 = require_bson();
  var query_1 = require_query2();
  var utils_1 = require_utils2();
  var type_1 = require_type();
  var Aggregation = class {
    constructor(db2, collectionName) {
      this._stages = [];
      if (db2 && collectionName) {
        this._db = db2;
        this._request = new index_1.Db.reqClass(this._db.config);
        this._collectionName = collectionName;
      }
    }
    async end() {
      if (!this._collectionName || !this._db) {
        throw new Error('Aggregation pipeline cannot send request');
      }
      const result = await this._request.send('database.aggregateDocuments', {
        collectionName: this._collectionName,
        stages: this._stages,
      });
      if (result && result.data && result.data.list) {
        return {
          requestId: result.requestId,
          data: result.data.list.map(bson_1.EJSON.parse),
        };
      }
      return result;
    }
    unwrap() {
      return this._stages;
    }
    done() {
      return this._stages.map(({ stageKey, stageValue }) => {
        return {
          [stageKey]: JSON.parse(stageValue),
        };
      });
    }
    _pipe(stage, param) {
      let transformParam = '';
      if (type_1.getType(param) === 'object') {
        transformParam = utils_1.stringifyByEJSON(param);
      } else {
        transformParam = JSON.stringify(param);
      }
      this._stages.push({
        stageKey: `$${stage}`,
        stageValue: transformParam,
      });
      return this;
    }
    addFields(param) {
      return this._pipe('addFields', param);
    }
    bucket(param) {
      return this._pipe('bucket', param);
    }
    bucketAuto(param) {
      return this._pipe('bucketAuto', param);
    }
    count(param) {
      return this._pipe('count', param);
    }
    geoNear(param) {
      if (param.query) {
        param.query = query_1.QuerySerializer.encode(param.query);
      }
      return this._pipe('geoNear', param);
    }
    group(param) {
      return this._pipe('group', param);
    }
    limit(param) {
      return this._pipe('limit', param);
    }
    match(param) {
      return this._pipe('match', query_1.QuerySerializer.encode(param));
    }
    project(param) {
      return this._pipe('project', param);
    }
    lookup(param) {
      return this._pipe('lookup', param);
    }
    replaceRoot(param) {
      return this._pipe('replaceRoot', param);
    }
    sample(param) {
      return this._pipe('sample', param);
    }
    skip(param) {
      return this._pipe('skip', param);
    }
    sort(param) {
      return this._pipe('sort', param);
    }
    sortByCount(param) {
      return this._pipe('sortByCount', param);
    }
    unwind(param) {
      return this._pipe('unwind', param);
    }
  };
  exports2.default = Aggregation;
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/collection.js
var require_collection = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var document_1 = require_document();
  var query_1 = require_query3();
  var aggregate_1 = require_aggregate();
  var datatype_1 = require_datatype();
  var utils_1 = require_utils2();
  var validate_1 = require_validate();
  var type_1 = require_type();
  var CollectionReference = class extends query_1.Query {
    constructor(db2, coll, apiOptions, transactionId) {
      super(db2, coll, '', apiOptions, transactionId);
      if (transactionId) {
        this._transactionId = transactionId;
      }
    }
    get name() {
      return this._coll;
    }
    doc(docID) {
      if (typeof docID !== 'string' && typeof docID !== 'number') {
        throw new Error(
          'docId\u5FC5\u987B\u4E3A\u5B57\u7B26\u4E32\u6216\u6570\u5B57',
        );
      }
      return new document_1.DocumentReference(
        this._db,
        this._coll,
        this._apiOptions,
        docID,
        this._transactionId,
      );
    }
    async add(data) {
      let transformData = data;
      if (!type_1.isArray(data)) {
        transformData = [data];
      }
      transformData = transformData.map((item) => {
        return utils_1.stringifyByEJSON(datatype_1.serialize(item));
      });
      let params = {
        collectionName: this._coll,
        data: transformData,
      };
      if (this._transactionId) {
        params.transactionId = this._transactionId;
      }
      const res = await this._request.send(
        'database.insertDocument',
        params,
        utils_1.getReqOpts(this._apiOptions),
      );
      if (res.code) {
        return res;
      }
      if (!type_1.isArray(data)) {
        if (this._transactionId) {
          return {
            inserted: 1,
            ok: 1,
            id: res.data.insertedIds[0],
            requestId: res.requestId,
          };
        }
        return {
          id: res.data.insertedIds[0],
          requestId: res.requestId,
        };
      }
      return {
        ids: res.data.insertedIds,
        requestId: res.requestId,
      };
    }
    aggregate() {
      return new aggregate_1.default(this._db, this._coll);
    }
    options(apiOptions) {
      validate_1.Validate.isValidOptions(apiOptions);
      return new CollectionReference(
        this._db,
        this._coll,
        apiOptions,
        this._transactionId,
      );
    }
  };
  exports2.CollectionReference = CollectionReference;
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/command.js
var require_command = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var query_1 = require_query();
  var logic_1 = require_logic();
  var update_1 = require_update();
  var type_1 = require_type();
  var aggregate_1 = require_aggregate();
  exports2.Command = {
    eq(val) {
      return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.EQ, [val]);
    },
    neq(val) {
      return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.NEQ, [
        val,
      ]);
    },
    lt(val) {
      return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.LT, [val]);
    },
    lte(val) {
      return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.LTE, [
        val,
      ]);
    },
    gt(val) {
      return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.GT, [val]);
    },
    gte(val) {
      return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.GTE, [
        val,
      ]);
    },
    in(val) {
      return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.IN, val);
    },
    nin(val) {
      return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.NIN, val);
    },
    all(val) {
      return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.ALL, val);
    },
    elemMatch(val) {
      return new query_1.QueryCommand(
        query_1.QUERY_COMMANDS_LITERAL.ELEM_MATCH,
        [val],
      );
    },
    exists(val) {
      return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.EXISTS, [
        val,
      ]);
    },
    size(val) {
      return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.SIZE, [
        val,
      ]);
    },
    mod(val) {
      return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.MOD, [
        val,
      ]);
    },
    geoNear(val) {
      return new query_1.QueryCommand(query_1.QUERY_COMMANDS_LITERAL.GEO_NEAR, [
        val,
      ]);
    },
    geoWithin(val) {
      return new query_1.QueryCommand(
        query_1.QUERY_COMMANDS_LITERAL.GEO_WITHIN,
        [val],
      );
    },
    geoIntersects(val) {
      return new query_1.QueryCommand(
        query_1.QUERY_COMMANDS_LITERAL.GEO_INTERSECTS,
        [val],
      );
    },
    and(...__expressions__) {
      const expressions = type_1.isArray(arguments[0])
        ? arguments[0]
        : Array.from(arguments);
      return new logic_1.LogicCommand(
        logic_1.LOGIC_COMMANDS_LITERAL.AND,
        expressions,
      );
    },
    nor(...__expressions__) {
      const expressions = type_1.isArray(arguments[0])
        ? arguments[0]
        : Array.from(arguments);
      return new logic_1.LogicCommand(
        logic_1.LOGIC_COMMANDS_LITERAL.NOR,
        expressions,
      );
    },
    or(...__expressions__) {
      const expressions = type_1.isArray(arguments[0])
        ? arguments[0]
        : Array.from(arguments);
      return new logic_1.LogicCommand(
        logic_1.LOGIC_COMMANDS_LITERAL.OR,
        expressions,
      );
    },
    not(...__expressions__) {
      const expressions = type_1.isArray(arguments[0])
        ? arguments[0]
        : Array.from(arguments);
      return new logic_1.LogicCommand(
        logic_1.LOGIC_COMMANDS_LITERAL.NOT,
        expressions,
      );
    },
    set(val) {
      return new update_1.UpdateCommand(update_1.UPDATE_COMMANDS_LITERAL.SET, [
        val,
      ]);
    },
    remove() {
      return new update_1.UpdateCommand(
        update_1.UPDATE_COMMANDS_LITERAL.REMOVE,
        [],
      );
    },
    inc(val) {
      return new update_1.UpdateCommand(update_1.UPDATE_COMMANDS_LITERAL.INC, [
        val,
      ]);
    },
    mul(val) {
      return new update_1.UpdateCommand(update_1.UPDATE_COMMANDS_LITERAL.MUL, [
        val,
      ]);
    },
    push(...args) {
      let values;
      if (type_1.isObject(args[0]) && args[0].hasOwnProperty('each')) {
        values = {};
        const options = args[0];
        if (options.each !== void 0) {
          values['$each'] = options.each;
        }
        if (options.position !== void 0) {
          values['$position'] = options.position;
        }
        if (options.sort !== void 0) {
          values['$sort'] = options.sort;
        }
        if (options.slice !== void 0) {
          values['$slice'] = options.slice;
        }
      } else if (type_1.isArray(args[0])) {
        values = args[0];
      } else {
        values = Array.from(args);
      }
      return new update_1.UpdateCommand(
        update_1.UPDATE_COMMANDS_LITERAL.PUSH,
        values,
      );
    },
    pull(values) {
      return new update_1.UpdateCommand(
        update_1.UPDATE_COMMANDS_LITERAL.PULL,
        values,
      );
    },
    pullAll(values) {
      return new update_1.UpdateCommand(
        update_1.UPDATE_COMMANDS_LITERAL.PULL_ALL,
        values,
      );
    },
    pop() {
      return new update_1.UpdateCommand(
        update_1.UPDATE_COMMANDS_LITERAL.POP,
        [],
      );
    },
    shift() {
      return new update_1.UpdateCommand(
        update_1.UPDATE_COMMANDS_LITERAL.SHIFT,
        [],
      );
    },
    unshift(...__values__) {
      const values = type_1.isArray(arguments[0])
        ? arguments[0]
        : Array.from(arguments);
      return new update_1.UpdateCommand(
        update_1.UPDATE_COMMANDS_LITERAL.UNSHIFT,
        values,
      );
    },
    addToSet(values) {
      return new update_1.UpdateCommand(
        update_1.UPDATE_COMMANDS_LITERAL.ADD_TO_SET,
        values,
      );
    },
    rename(values) {
      return new update_1.UpdateCommand(
        update_1.UPDATE_COMMANDS_LITERAL.RENAME,
        [values],
      );
    },
    bit(values) {
      return new update_1.UpdateCommand(update_1.UPDATE_COMMANDS_LITERAL.BIT, [
        values,
      ]);
    },
    max(values) {
      return new update_1.UpdateCommand(update_1.UPDATE_COMMANDS_LITERAL.MAX, [
        values,
      ]);
    },
    min(values) {
      return new update_1.UpdateCommand(update_1.UPDATE_COMMANDS_LITERAL.MIN, [
        values,
      ]);
    },
    expr(values) {
      return {
        $expr: values,
      };
    },
    jsonSchema(schema) {
      return {
        $jsonSchema: schema,
      };
    },
    text(values) {
      if (type_1.isString(values)) {
        return {
          $search: values.search,
        };
      } else {
        return {
          $search: values.search,
          $language: values.language,
          $caseSensitive: values.caseSensitive,
          $diacriticSensitive: values.diacriticSensitive,
        };
      }
    },
    aggregate: {
      pipeline() {
        return new aggregate_1.default();
      },
      abs: (param) => new AggregationOperator('abs', param),
      add: (param) => new AggregationOperator('add', param),
      ceil: (param) => new AggregationOperator('ceil', param),
      divide: (param) => new AggregationOperator('divide', param),
      exp: (param) => new AggregationOperator('exp', param),
      floor: (param) => new AggregationOperator('floor', param),
      ln: (param) => new AggregationOperator('ln', param),
      log: (param) => new AggregationOperator('log', param),
      log10: (param) => new AggregationOperator('log10', param),
      mod: (param) => new AggregationOperator('mod', param),
      multiply: (param) => new AggregationOperator('multiply', param),
      pow: (param) => new AggregationOperator('pow', param),
      sqrt: (param) => new AggregationOperator('sqrt', param),
      subtract: (param) => new AggregationOperator('subtract', param),
      trunc: (param) => new AggregationOperator('trunc', param),
      arrayElemAt: (param) => new AggregationOperator('arrayElemAt', param),
      arrayToObject: (param) => new AggregationOperator('arrayToObject', param),
      concatArrays: (param) => new AggregationOperator('concatArrays', param),
      filter: (param) => new AggregationOperator('filter', param),
      in: (param) => new AggregationOperator('in', param),
      indexOfArray: (param) => new AggregationOperator('indexOfArray', param),
      isArray: (param) => new AggregationOperator('isArray', param),
      map: (param) => new AggregationOperator('map', param),
      range: (param) => new AggregationOperator('range', param),
      reduce: (param) => new AggregationOperator('reduce', param),
      reverseArray: (param) => new AggregationOperator('reverseArray', param),
      size: (param) => new AggregationOperator('size', param),
      slice: (param) => new AggregationOperator('slice', param),
      zip: (param) => new AggregationOperator('zip', param),
      and: (param) => new AggregationOperator('and', param),
      not: (param) => new AggregationOperator('not', param),
      or: (param) => new AggregationOperator('or', param),
      cmp: (param) => new AggregationOperator('cmp', param),
      eq: (param) => new AggregationOperator('eq', param),
      gt: (param) => new AggregationOperator('gt', param),
      gte: (param) => new AggregationOperator('gte', param),
      lt: (param) => new AggregationOperator('lt', param),
      lte: (param) => new AggregationOperator('lte', param),
      neq: (param) => new AggregationOperator('ne', param),
      cond: (param) => new AggregationOperator('cond', param),
      ifNull: (param) => new AggregationOperator('ifNull', param),
      switch: (param) => new AggregationOperator('switch', param),
      dateFromParts: (param) => new AggregationOperator('dateFromParts', param),
      dateFromString: (param) =>
        new AggregationOperator('dateFromString', param),
      dayOfMonth: (param) => new AggregationOperator('dayOfMonth', param),
      dayOfWeek: (param) => new AggregationOperator('dayOfWeek', param),
      dayOfYear: (param) => new AggregationOperator('dayOfYear', param),
      isoDayOfWeek: (param) => new AggregationOperator('isoDayOfWeek', param),
      isoWeek: (param) => new AggregationOperator('isoWeek', param),
      isoWeekYear: (param) => new AggregationOperator('isoWeekYear', param),
      millisecond: (param) => new AggregationOperator('millisecond', param),
      minute: (param) => new AggregationOperator('minute', param),
      month: (param) => new AggregationOperator('month', param),
      second: (param) => new AggregationOperator('second', param),
      hour: (param) => new AggregationOperator('hour', param),
      week: (param) => new AggregationOperator('week', param),
      year: (param) => new AggregationOperator('year', param),
      literal: (param) => new AggregationOperator('literal', param),
      mergeObjects: (param) => new AggregationOperator('mergeObjects', param),
      objectToArray: (param) => new AggregationOperator('objectToArray', param),
      allElementsTrue: (param) =>
        new AggregationOperator('allElementsTrue', param),
      anyElementTrue: (param) =>
        new AggregationOperator('anyElementTrue', param),
      setDifference: (param) => new AggregationOperator('setDifference', param),
      setEquals: (param) => new AggregationOperator('setEquals', param),
      setIntersection: (param) =>
        new AggregationOperator('setIntersection', param),
      setIsSubset: (param) => new AggregationOperator('setIsSubset', param),
      setUnion: (param) => new AggregationOperator('setUnion', param),
      concat: (param) => new AggregationOperator('concat', param),
      dateToString: (param) => new AggregationOperator('dateToString', param),
      indexOfBytes: (param) => new AggregationOperator('indexOfBytes', param),
      indexOfCP: (param) => new AggregationOperator('indexOfCP', param),
      split: (param) => new AggregationOperator('split', param),
      strLenBytes: (param) => new AggregationOperator('strLenBytes', param),
      strLenCP: (param) => new AggregationOperator('strLenCP', param),
      strcasecmp: (param) => new AggregationOperator('strcasecmp', param),
      substr: (param) => new AggregationOperator('substr', param),
      substrBytes: (param) => new AggregationOperator('substrBytes', param),
      substrCP: (param) => new AggregationOperator('substrCP', param),
      toLower: (param) => new AggregationOperator('toLower', param),
      toUpper: (param) => new AggregationOperator('toUpper', param),
      meta: (param) => new AggregationOperator('meta', param),
      addToSet: (param) => new AggregationOperator('addToSet', param),
      avg: (param) => new AggregationOperator('avg', param),
      first: (param) => new AggregationOperator('first', param),
      last: (param) => new AggregationOperator('last', param),
      max: (param) => new AggregationOperator('max', param),
      min: (param) => new AggregationOperator('min', param),
      push: (param) => new AggregationOperator('push', param),
      stdDevPop: (param) => new AggregationOperator('stdDevPop', param),
      stdDevSamp: (param) => new AggregationOperator('stdDevSamp', param),
      sum: (param) => new AggregationOperator('sum', param),
      let: (param) => new AggregationOperator('let', param),
    },
    project: {
      slice: (param) => new ProjectionOperator('slice', param),
      elemMatch: (param) => new ProjectionOperator('elemMatch', param),
    },
  };
  var AggregationOperator = class {
    constructor(name, param) {
      this['$' + name] = param;
    }
  };
  exports2.AggregationOperator = AggregationOperator;
  var ProjectionOperator = class {
    constructor(name, param) {
      this['$' + name] = param;
    }
  };
  exports2.ProjectionOperator = ProjectionOperator;
  exports2.default = exports2.Command;
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/regexp/index.js
var require_regexp2 = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var symbol_1 = require_symbol3();
  var RegExp2 = class {
    constructor({ regexp, options }) {
      if (!regexp) {
        throw new TypeError('regexp must be a string');
      }
      this.$regularExpression = {
        pattern: regexp || '',
        options: options || '',
      };
    }
    parse() {
      return {
        $regularExpression: {
          pattern: this.$regularExpression.pattern,
          options: this.$regularExpression.options,
        },
      };
    }
    get _internalType() {
      return symbol_1.SYMBOL_REGEXP;
    }
  };
  exports2.RegExp = RegExp2;
  function RegExpConstructor(param) {
    return new RegExp2(param);
  }
  exports2.RegExpConstructor = RegExpConstructor;
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/transaction/index.js
var require_transaction = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var index_1 = require_commonjs();
  var collection_1 = require_collection();
  var code_1 = require_code();
  var START = 'database.startTransaction';
  var COMMIT = 'database.commitTransaction';
  var ABORT = 'database.abortTransaction';
  var Transaction = class {
    constructor(db2) {
      this._db = db2;
      this._request = new index_1.Db.reqClass(this._db.config);
      this.aborted = false;
      this.commited = false;
      this.inited = false;
    }
    async init() {
      const res = await this._request.send(START);
      if (res.code) {
        throw res;
      }
      this.inited = true;
      this._id = res.transactionId;
    }
    collection(collName) {
      if (!collName) {
        throw new Error('Collection name is required');
      }
      return new collection_1.CollectionReference(
        this._db,
        collName,
        {},
        this._id,
      );
    }
    getTransactionId() {
      return this._id;
    }
    getRequestMethod() {
      return this._request;
    }
    async commit() {
      const param = {
        transactionId: this._id,
      };
      const res = await this._request.send(COMMIT, param);
      if (res.code) throw res;
      this.commited = true;
      return res;
    }
    async rollback(customRollbackRes) {
      const param = {
        transactionId: this._id,
      };
      const res = await this._request.send(ABORT, param);
      if (res.code) throw res;
      this.aborted = true;
      this.abortReason = customRollbackRes;
      return res;
    }
  };
  exports2.Transaction = Transaction;
  async function startTransaction() {
    const transaction = new Transaction(this);
    await transaction.init();
    return transaction;
  }
  exports2.startTransaction = startTransaction;
  async function runTransaction(callback, times = 3) {
    let transaction;
    try {
      transaction = new Transaction(this);
      await transaction.init();
      const callbackRes = await callback(transaction);
      if (transaction.aborted === true) {
        throw transaction.abortReason;
      }
      await transaction.commit();
      return callbackRes;
    } catch (error) {
      if (transaction.inited === false) {
        throw error;
      }
      const throwWithRollback = async (error2) => {
        if (!transaction.aborted && !transaction.commited) {
          try {
            await transaction.rollback();
          } catch (err) {}
          throw error2;
        }
        if (transaction.aborted === true) {
          throw transaction.abortReason;
        }
        throw error2;
      };
      if (times <= 0) {
        await throwWithRollback(error);
      }
      if (
        error &&
        error.code === code_1.ERRORS.DATABASE_TRANSACTION_CONFLICT.code
      ) {
        return await runTransaction.bind(this)(callback, --times);
      }
      await throwWithRollback(error);
    }
  }
  exports2.runTransaction = runTransaction;
});

// node_modules/@cloudbase/node-sdk/node_modules/@cloudbase/database/dist/commonjs/index.js
var require_commonjs = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var Geo = require_geo();
  var collection_1 = require_collection();
  var command_1 = require_command();
  var index_1 = require_serverDate();
  var index_2 = require_regexp2();
  var index_3 = require_transaction();
  var query_1 = require_query3();
  exports2.Query = query_1.Query;
  var collection_2 = require_collection();
  exports2.CollectionReference = collection_2.CollectionReference;
  var document_1 = require_document();
  exports2.DocumentReference = document_1.DocumentReference;
  var Db = class {
    constructor(config) {
      this.config = config;
      this.Geo = Geo;
      this.serverDate = index_1.ServerDateConstructor;
      this.command = command_1.Command;
      this.RegExp = index_2.RegExpConstructor;
      this.startTransaction = index_3.startTransaction;
      this.runTransaction = index_3.runTransaction;
    }
    collection(collName) {
      if (!collName) {
        throw new Error('Collection name is required');
      }
      return new collection_1.CollectionReference(this, collName);
    }
    createCollection(collName) {
      let request = new Db.reqClass(this.config);
      const params = {
        collectionName: collName,
      };
      return request.send('database.addCollection', params);
    }
  };
  exports2.Db = Db;
});

// node_modules/@cloudbase/node-sdk/lib/utils/tracing.js
var require_tracing = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var cloudbase_1 = require_cloudbase();
  var seqNum = 0;
  function getSeqNum() {
    return ++seqNum;
  }
  function generateEventId() {
    return Date.now().toString(16) + '_' + getSeqNum().toString(16);
  }
  exports2.generateTracingInfo = () => {
    let {
      TCB_SEQID,
      TCB_TRACELOG,
    } = cloudbase_1.CloudBase.getCloudbaseContext();
    TCB_SEQID = TCB_SEQID || '';
    const eventId = generateEventId();
    const seqId = TCB_SEQID ? `${TCB_SEQID}-${eventId}` : eventId;
    return { eventId, seqId, trace: TCB_TRACELOG };
  };
});

// node_modules/@cloudbase/node-sdk/lib/utils/utils.js
var require_utils3 = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var cloudbase_1 = require_cloudbase();
  var TcbError = class extends Error {
    constructor(error) {
      super(error.message);
      this.code = error.code;
      this.message = error.message;
      this.requestId = error.requestId;
    }
  };
  exports2.TcbError = TcbError;
  exports2.filterValue = function filterValue(o, value) {
    for (let key in o) {
      if (o[key] === value) {
        delete o[key];
      }
    }
  };
  exports2.filterUndefined = function (o) {
    return exports2.filterValue(o, void 0);
  };
  exports2.E = (errObj) => {
    return new TcbError(errObj);
  };
  exports2.checkIsInScf = () => {
    const { TENCENTCLOUD_RUNENV } = cloudbase_1.CloudBase.getCloudbaseContext();
    return TENCENTCLOUD_RUNENV === 'SCF';
  };
  exports2.checkIsInContainer = () => {
    return !!process.env.KUBERNETES_SERVICE_HOST;
  };
  function second() {
    return Math.floor(new Date().getTime() / 1e3);
  }
  exports2.second = second;
  function processReturn(throwOnCode, res) {
    if (throwOnCode === false) {
      return res;
    }
    throw exports2.E(Object.assign({}, res));
  }
  exports2.processReturn = processReturn;
  function getServerInjectUrl() {
    const tcbContextConfig = getTcbContextConfig();
    return tcbContextConfig['URL'] || '';
  }
  exports2.getServerInjectUrl = getServerInjectUrl;
  function getTcbContextConfig() {
    try {
      const { TCB_CONTEXT_CNFG } = cloudbase_1.CloudBase.getCloudbaseContext();
      if (TCB_CONTEXT_CNFG) {
        return JSON.parse(TCB_CONTEXT_CNFG);
      }
      return {};
    } catch (e) {
      console.log('parse context error...');
      return {};
    }
  }
  exports2.getTcbContextConfig = getTcbContextConfig;
  function getWxUrl(config) {
    const protocal = config.isHttp === true ? 'http' : 'https';
    let wxUrl = protocal + '://tcb-open.tencentcloudapi.com/admin';
    if (exports2.checkIsInScf()) {
      wxUrl = 'http://tcb-open.tencentyun.com/admin';
    }
    return wxUrl;
  }
  exports2.getWxUrl = getWxUrl;
  function checkIsInternal() {
    return exports2.checkIsInScf() || exports2.checkIsInContainer();
  }
  exports2.checkIsInternal = checkIsInternal;
});

// node_modules/@cloudbase/node-sdk/lib/const/code.js
var require_code3 = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  exports2.ERROR = {
    INVALID_PARAM: {
      code: 'INVALID_PARAM',
      message: 'invalid param',
    },
    SYS_ERR: {
      code: 'SYS_ERR',
      message: 'system error',
    },
    STORAGE_REQUEST_FAIL: {
      code: 'STORAGE_REQUEST_FAIL',
      message: 'storage request fail',
    },
    STORAGE_FILE_NONEXIST: {
      code: 'STORAGE_FILE_NONEXIST',
      message: 'storage file not exist',
    },
    TCB_CLS_UNOPEN: {
      code: 'TCB_CLS_UNOPEN',
      message:
        '\u9700\u8981\u5148\u5F00\u901A\u65E5\u5FD7\u68C0\u7D22\u529F\u80FD',
    },
    INVALID_CONTEXT: {
      code: 'INVALID_CONTEXT',
      message:
        '\u65E0\u6548\u7684context\u5BF9\u8C61\uFF0C\u8BF7\u4F7F\u7528 \u4E91\u51FD\u6570\u5165\u53E3\u7684context\u53C2\u6570',
    },
  };
});

// node_modules/@cloudbase/node-sdk/lib/const/symbol.js
var require_symbol4 = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  exports2.SYMBOL_CURRENT_ENV = Symbol.for('SYMBOL_CURRENT_ENV');
});

// node_modules/extend/index.js
var require_extend = __commonJS((exports2, module2) => {
  'use strict';
  var hasOwn = Object.prototype.hasOwnProperty;
  var toStr = Object.prototype.toString;
  var defineProperty = Object.defineProperty;
  var gOPD = Object.getOwnPropertyDescriptor;
  var isArray = function isArray2(arr) {
    if (typeof Array.isArray === 'function') {
      return Array.isArray(arr);
    }
    return toStr.call(arr) === '[object Array]';
  };
  var isPlainObject = function isPlainObject2(obj) {
    if (!obj || toStr.call(obj) !== '[object Object]') {
      return false;
    }
    var hasOwnConstructor = hasOwn.call(obj, 'constructor');
    var hasIsPrototypeOf =
      obj.constructor &&
      obj.constructor.prototype &&
      hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
    if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
      return false;
    }
    var key;
    for (key in obj) {
    }
    return typeof key === 'undefined' || hasOwn.call(obj, key);
  };
  var setProperty = function setProperty2(target, options) {
    if (defineProperty && options.name === '__proto__') {
      defineProperty(target, options.name, {
        enumerable: true,
        configurable: true,
        value: options.newValue,
        writable: true,
      });
    } else {
      target[options.name] = options.newValue;
    }
  };
  var getProperty = function getProperty2(obj, name) {
    if (name === '__proto__') {
      if (!hasOwn.call(obj, name)) {
        return void 0;
      } else if (gOPD) {
        return gOPD(obj, name).value;
      }
    }
    return obj[name];
  };
  module2.exports = function extend() {
    var options, name, src, copy, copyIsArray, clone;
    var target = arguments[0];
    var i = 1;
    var length = arguments.length;
    var deep = false;
    if (typeof target === 'boolean') {
      deep = target;
      target = arguments[1] || {};
      i = 2;
    }
    if (
      target == null ||
      (typeof target !== 'object' && typeof target !== 'function')
    ) {
      target = {};
    }
    for (; i < length; ++i) {
      options = arguments[i];
      if (options != null) {
        for (name in options) {
          src = getProperty(target, name);
          copy = getProperty(options, name);
          if (target !== copy) {
            if (
              deep &&
              copy &&
              (isPlainObject(copy) || (copyIsArray = isArray(copy)))
            ) {
              if (copyIsArray) {
                copyIsArray = false;
                clone = src && isArray(src) ? src : [];
              } else {
                clone = src && isPlainObject(src) ? src : {};
              }
              setProperty(target, {
                name,
                newValue: extend(deep, clone, copy),
              });
            } else if (typeof copy !== 'undefined') {
              setProperty(target, { name, newValue: copy });
            }
          }
        }
      }
    }
    return target;
  };
});

// node_modules/psl/data/rules.json
var require_rules = __commonJS((exports2, module2) => {
  module2.exports = [
    'ac',
    'com.ac',
    'edu.ac',
    'gov.ac',
    'net.ac',
    'mil.ac',
    'org.ac',
    'ad',
    'nom.ad',
    'ae',
    'co.ae',
    'net.ae',
    'org.ae',
    'sch.ae',
    'ac.ae',
    'gov.ae',
    'mil.ae',
    'aero',
    'accident-investigation.aero',
    'accident-prevention.aero',
    'aerobatic.aero',
    'aeroclub.aero',
    'aerodrome.aero',
    'agents.aero',
    'aircraft.aero',
    'airline.aero',
    'airport.aero',
    'air-surveillance.aero',
    'airtraffic.aero',
    'air-traffic-control.aero',
    'ambulance.aero',
    'amusement.aero',
    'association.aero',
    'author.aero',
    'ballooning.aero',
    'broker.aero',
    'caa.aero',
    'cargo.aero',
    'catering.aero',
    'certification.aero',
    'championship.aero',
    'charter.aero',
    'civilaviation.aero',
    'club.aero',
    'conference.aero',
    'consultant.aero',
    'consulting.aero',
    'control.aero',
    'council.aero',
    'crew.aero',
    'design.aero',
    'dgca.aero',
    'educator.aero',
    'emergency.aero',
    'engine.aero',
    'engineer.aero',
    'entertainment.aero',
    'equipment.aero',
    'exchange.aero',
    'express.aero',
    'federation.aero',
    'flight.aero',
    'freight.aero',
    'fuel.aero',
    'gliding.aero',
    'government.aero',
    'groundhandling.aero',
    'group.aero',
    'hanggliding.aero',
    'homebuilt.aero',
    'insurance.aero',
    'journal.aero',
    'journalist.aero',
    'leasing.aero',
    'logistics.aero',
    'magazine.aero',
    'maintenance.aero',
    'media.aero',
    'microlight.aero',
    'modelling.aero',
    'navigation.aero',
    'parachuting.aero',
    'paragliding.aero',
    'passenger-association.aero',
    'pilot.aero',
    'press.aero',
    'production.aero',
    'recreation.aero',
    'repbody.aero',
    'res.aero',
    'research.aero',
    'rotorcraft.aero',
    'safety.aero',
    'scientist.aero',
    'services.aero',
    'show.aero',
    'skydiving.aero',
    'software.aero',
    'student.aero',
    'trader.aero',
    'trading.aero',
    'trainer.aero',
    'union.aero',
    'workinggroup.aero',
    'works.aero',
    'af',
    'gov.af',
    'com.af',
    'org.af',
    'net.af',
    'edu.af',
    'ag',
    'com.ag',
    'org.ag',
    'net.ag',
    'co.ag',
    'nom.ag',
    'ai',
    'off.ai',
    'com.ai',
    'net.ai',
    'org.ai',
    'al',
    'com.al',
    'edu.al',
    'gov.al',
    'mil.al',
    'net.al',
    'org.al',
    'am',
    'co.am',
    'com.am',
    'commune.am',
    'net.am',
    'org.am',
    'ao',
    'ed.ao',
    'gv.ao',
    'og.ao',
    'co.ao',
    'pb.ao',
    'it.ao',
    'aq',
    'ar',
    'com.ar',
    'edu.ar',
    'gob.ar',
    'gov.ar',
    'int.ar',
    'mil.ar',
    'musica.ar',
    'net.ar',
    'org.ar',
    'tur.ar',
    'arpa',
    'e164.arpa',
    'in-addr.arpa',
    'ip6.arpa',
    'iris.arpa',
    'uri.arpa',
    'urn.arpa',
    'as',
    'gov.as',
    'asia',
    'at',
    'ac.at',
    'co.at',
    'gv.at',
    'or.at',
    'au',
    'com.au',
    'net.au',
    'org.au',
    'edu.au',
    'gov.au',
    'asn.au',
    'id.au',
    'info.au',
    'conf.au',
    'oz.au',
    'act.au',
    'nsw.au',
    'nt.au',
    'qld.au',
    'sa.au',
    'tas.au',
    'vic.au',
    'wa.au',
    'act.edu.au',
    'catholic.edu.au',
    'nsw.edu.au',
    'nt.edu.au',
    'qld.edu.au',
    'sa.edu.au',
    'tas.edu.au',
    'vic.edu.au',
    'wa.edu.au',
    'qld.gov.au',
    'sa.gov.au',
    'tas.gov.au',
    'vic.gov.au',
    'wa.gov.au',
    'education.tas.edu.au',
    'schools.nsw.edu.au',
    'aw',
    'com.aw',
    'ax',
    'az',
    'com.az',
    'net.az',
    'int.az',
    'gov.az',
    'org.az',
    'edu.az',
    'info.az',
    'pp.az',
    'mil.az',
    'name.az',
    'pro.az',
    'biz.az',
    'ba',
    'com.ba',
    'edu.ba',
    'gov.ba',
    'mil.ba',
    'net.ba',
    'org.ba',
    'bb',
    'biz.bb',
    'co.bb',
    'com.bb',
    'edu.bb',
    'gov.bb',
    'info.bb',
    'net.bb',
    'org.bb',
    'store.bb',
    'tv.bb',
    '*.bd',
    'be',
    'ac.be',
    'bf',
    'gov.bf',
    'bg',
    'a.bg',
    'b.bg',
    'c.bg',
    'd.bg',
    'e.bg',
    'f.bg',
    'g.bg',
    'h.bg',
    'i.bg',
    'j.bg',
    'k.bg',
    'l.bg',
    'm.bg',
    'n.bg',
    'o.bg',
    'p.bg',
    'q.bg',
    'r.bg',
    's.bg',
    't.bg',
    'u.bg',
    'v.bg',
    'w.bg',
    'x.bg',
    'y.bg',
    'z.bg',
    '0.bg',
    '1.bg',
    '2.bg',
    '3.bg',
    '4.bg',
    '5.bg',
    '6.bg',
    '7.bg',
    '8.bg',
    '9.bg',
    'bh',
    'com.bh',
    'edu.bh',
    'net.bh',
    'org.bh',
    'gov.bh',
    'bi',
    'co.bi',
    'com.bi',
    'edu.bi',
    'or.bi',
    'org.bi',
    'biz',
    'bj',
    'asso.bj',
    'barreau.bj',
    'gouv.bj',
    'bm',
    'com.bm',
    'edu.bm',
    'gov.bm',
    'net.bm',
    'org.bm',
    'bn',
    'com.bn',
    'edu.bn',
    'gov.bn',
    'net.bn',
    'org.bn',
    'bo',
    'com.bo',
    'edu.bo',
    'gob.bo',
    'int.bo',
    'org.bo',
    'net.bo',
    'mil.bo',
    'tv.bo',
    'web.bo',
    'academia.bo',
    'agro.bo',
    'arte.bo',
    'blog.bo',
    'bolivia.bo',
    'ciencia.bo',
    'cooperativa.bo',
    'democracia.bo',
    'deporte.bo',
    'ecologia.bo',
    'economia.bo',
    'empresa.bo',
    'indigena.bo',
    'industria.bo',
    'info.bo',
    'medicina.bo',
    'movimiento.bo',
    'musica.bo',
    'natural.bo',
    'nombre.bo',
    'noticias.bo',
    'patria.bo',
    'politica.bo',
    'profesional.bo',
    'plurinacional.bo',
    'pueblo.bo',
    'revista.bo',
    'salud.bo',
    'tecnologia.bo',
    'tksat.bo',
    'transporte.bo',
    'wiki.bo',
    'br',
    '9guacu.br',
    'abc.br',
    'adm.br',
    'adv.br',
    'agr.br',
    'aju.br',
    'am.br',
    'anani.br',
    'aparecida.br',
    'arq.br',
    'art.br',
    'ato.br',
    'b.br',
    'barueri.br',
    'belem.br',
    'bhz.br',
    'bio.br',
    'blog.br',
    'bmd.br',
    'boavista.br',
    'bsb.br',
    'campinagrande.br',
    'campinas.br',
    'caxias.br',
    'cim.br',
    'cng.br',
    'cnt.br',
    'com.br',
    'contagem.br',
    'coop.br',
    'cri.br',
    'cuiaba.br',
    'curitiba.br',
    'def.br',
    'ecn.br',
    'eco.br',
    'edu.br',
    'emp.br',
    'eng.br',
    'esp.br',
    'etc.br',
    'eti.br',
    'far.br',
    'feira.br',
    'flog.br',
    'floripa.br',
    'fm.br',
    'fnd.br',
    'fortal.br',
    'fot.br',
    'foz.br',
    'fst.br',
    'g12.br',
    'ggf.br',
    'goiania.br',
    'gov.br',
    'ac.gov.br',
    'al.gov.br',
    'am.gov.br',
    'ap.gov.br',
    'ba.gov.br',
    'ce.gov.br',
    'df.gov.br',
    'es.gov.br',
    'go.gov.br',
    'ma.gov.br',
    'mg.gov.br',
    'ms.gov.br',
    'mt.gov.br',
    'pa.gov.br',
    'pb.gov.br',
    'pe.gov.br',
    'pi.gov.br',
    'pr.gov.br',
    'rj.gov.br',
    'rn.gov.br',
    'ro.gov.br',
    'rr.gov.br',
    'rs.gov.br',
    'sc.gov.br',
    'se.gov.br',
    'sp.gov.br',
    'to.gov.br',
    'gru.br',
    'imb.br',
    'ind.br',
    'inf.br',
    'jab.br',
    'jampa.br',
    'jdf.br',
    'joinville.br',
    'jor.br',
    'jus.br',
    'leg.br',
    'lel.br',
    'londrina.br',
    'macapa.br',
    'maceio.br',
    'manaus.br',
    'maringa.br',
    'mat.br',
    'med.br',
    'mil.br',
    'morena.br',
    'mp.br',
    'mus.br',
    'natal.br',
    'net.br',
    'niteroi.br',
    '*.nom.br',
    'not.br',
    'ntr.br',
    'odo.br',
    'ong.br',
    'org.br',
    'osasco.br',
    'palmas.br',
    'poa.br',
    'ppg.br',
    'pro.br',
    'psc.br',
    'psi.br',
    'pvh.br',
    'qsl.br',
    'radio.br',
    'rec.br',
    'recife.br',
    'ribeirao.br',
    'rio.br',
    'riobranco.br',
    'riopreto.br',
    'salvador.br',
    'sampa.br',
    'santamaria.br',
    'santoandre.br',
    'saobernardo.br',
    'saogonca.br',
    'sjc.br',
    'slg.br',
    'slz.br',
    'sorocaba.br',
    'srv.br',
    'taxi.br',
    'tc.br',
    'teo.br',
    'the.br',
    'tmp.br',
    'trd.br',
    'tur.br',
    'tv.br',
    'udi.br',
    'vet.br',
    'vix.br',
    'vlog.br',
    'wiki.br',
    'zlg.br',
    'bs',
    'com.bs',
    'net.bs',
    'org.bs',
    'edu.bs',
    'gov.bs',
    'bt',
    'com.bt',
    'edu.bt',
    'gov.bt',
    'net.bt',
    'org.bt',
    'bv',
    'bw',
    'co.bw',
    'org.bw',
    'by',
    'gov.by',
    'mil.by',
    'com.by',
    'of.by',
    'bz',
    'com.bz',
    'net.bz',
    'org.bz',
    'edu.bz',
    'gov.bz',
    'ca',
    'ab.ca',
    'bc.ca',
    'mb.ca',
    'nb.ca',
    'nf.ca',
    'nl.ca',
    'ns.ca',
    'nt.ca',
    'nu.ca',
    'on.ca',
    'pe.ca',
    'qc.ca',
    'sk.ca',
    'yk.ca',
    'gc.ca',
    'cat',
    'cc',
    'cd',
    'gov.cd',
    'cf',
    'cg',
    'ch',
    'ci',
    'org.ci',
    'or.ci',
    'com.ci',
    'co.ci',
    'edu.ci',
    'ed.ci',
    'ac.ci',
    'net.ci',
    'go.ci',
    'asso.ci',
    'a\xE9roport.ci',
    'int.ci',
    'presse.ci',
    'md.ci',
    'gouv.ci',
    '*.ck',
    '!www.ck',
    'cl',
    'aprendemas.cl',
    'co.cl',
    'gob.cl',
    'gov.cl',
    'mil.cl',
    'cm',
    'co.cm',
    'com.cm',
    'gov.cm',
    'net.cm',
    'cn',
    'ac.cn',
    'com.cn',
    'edu.cn',
    'gov.cn',
    'net.cn',
    'org.cn',
    'mil.cn',
    '\u516C\u53F8.cn',
    '\u7F51\u7EDC.cn',
    '\u7DB2\u7D61.cn',
    'ah.cn',
    'bj.cn',
    'cq.cn',
    'fj.cn',
    'gd.cn',
    'gs.cn',
    'gz.cn',
    'gx.cn',
    'ha.cn',
    'hb.cn',
    'he.cn',
    'hi.cn',
    'hl.cn',
    'hn.cn',
    'jl.cn',
    'js.cn',
    'jx.cn',
    'ln.cn',
    'nm.cn',
    'nx.cn',
    'qh.cn',
    'sc.cn',
    'sd.cn',
    'sh.cn',
    'sn.cn',
    'sx.cn',
    'tj.cn',
    'xj.cn',
    'xz.cn',
    'yn.cn',
    'zj.cn',
    'hk.cn',
    'mo.cn',
    'tw.cn',
    'co',
    'arts.co',
    'com.co',
    'edu.co',
    'firm.co',
    'gov.co',
    'info.co',
    'int.co',
    'mil.co',
    'net.co',
    'nom.co',
    'org.co',
    'rec.co',
    'web.co',
    'com',
    'coop',
    'cr',
    'ac.cr',
    'co.cr',
    'ed.cr',
    'fi.cr',
    'go.cr',
    'or.cr',
    'sa.cr',
    'cu',
    'com.cu',
    'edu.cu',
    'org.cu',
    'net.cu',
    'gov.cu',
    'inf.cu',
    'cv',
    'cw',
    'com.cw',
    'edu.cw',
    'net.cw',
    'org.cw',
    'cx',
    'gov.cx',
    'cy',
    'ac.cy',
    'biz.cy',
    'com.cy',
    'ekloges.cy',
    'gov.cy',
    'ltd.cy',
    'name.cy',
    'net.cy',
    'org.cy',
    'parliament.cy',
    'press.cy',
    'pro.cy',
    'tm.cy',
    'cz',
    'de',
    'dj',
    'dk',
    'dm',
    'com.dm',
    'net.dm',
    'org.dm',
    'edu.dm',
    'gov.dm',
    'do',
    'art.do',
    'com.do',
    'edu.do',
    'gob.do',
    'gov.do',
    'mil.do',
    'net.do',
    'org.do',
    'sld.do',
    'web.do',
    'dz',
    'com.dz',
    'org.dz',
    'net.dz',
    'gov.dz',
    'edu.dz',
    'asso.dz',
    'pol.dz',
    'art.dz',
    'ec',
    'com.ec',
    'info.ec',
    'net.ec',
    'fin.ec',
    'k12.ec',
    'med.ec',
    'pro.ec',
    'org.ec',
    'edu.ec',
    'gov.ec',
    'gob.ec',
    'mil.ec',
    'edu',
    'ee',
    'edu.ee',
    'gov.ee',
    'riik.ee',
    'lib.ee',
    'med.ee',
    'com.ee',
    'pri.ee',
    'aip.ee',
    'org.ee',
    'fie.ee',
    'eg',
    'com.eg',
    'edu.eg',
    'eun.eg',
    'gov.eg',
    'mil.eg',
    'name.eg',
    'net.eg',
    'org.eg',
    'sci.eg',
    '*.er',
    'es',
    'com.es',
    'nom.es',
    'org.es',
    'gob.es',
    'edu.es',
    'et',
    'com.et',
    'gov.et',
    'org.et',
    'edu.et',
    'biz.et',
    'name.et',
    'info.et',
    'net.et',
    'eu',
    'fi',
    'aland.fi',
    'fj',
    'ac.fj',
    'biz.fj',
    'com.fj',
    'gov.fj',
    'info.fj',
    'mil.fj',
    'name.fj',
    'net.fj',
    'org.fj',
    'pro.fj',
    '*.fk',
    'fm',
    'fo',
    'fr',
    'asso.fr',
    'com.fr',
    'gouv.fr',
    'nom.fr',
    'prd.fr',
    'tm.fr',
    'aeroport.fr',
    'avocat.fr',
    'avoues.fr',
    'cci.fr',
    'chambagri.fr',
    'chirurgiens-dentistes.fr',
    'experts-comptables.fr',
    'geometre-expert.fr',
    'greta.fr',
    'huissier-justice.fr',
    'medecin.fr',
    'notaires.fr',
    'pharmacien.fr',
    'port.fr',
    'veterinaire.fr',
    'ga',
    'gb',
    'gd',
    'ge',
    'com.ge',
    'edu.ge',
    'gov.ge',
    'org.ge',
    'mil.ge',
    'net.ge',
    'pvt.ge',
    'gf',
    'gg',
    'co.gg',
    'net.gg',
    'org.gg',
    'gh',
    'com.gh',
    'edu.gh',
    'gov.gh',
    'org.gh',
    'mil.gh',
    'gi',
    'com.gi',
    'ltd.gi',
    'gov.gi',
    'mod.gi',
    'edu.gi',
    'org.gi',
    'gl',
    'co.gl',
    'com.gl',
    'edu.gl',
    'net.gl',
    'org.gl',
    'gm',
    'gn',
    'ac.gn',
    'com.gn',
    'edu.gn',
    'gov.gn',
    'org.gn',
    'net.gn',
    'gov',
    'gp',
    'com.gp',
    'net.gp',
    'mobi.gp',
    'edu.gp',
    'org.gp',
    'asso.gp',
    'gq',
    'gr',
    'com.gr',
    'edu.gr',
    'net.gr',
    'org.gr',
    'gov.gr',
    'gs',
    'gt',
    'com.gt',
    'edu.gt',
    'gob.gt',
    'ind.gt',
    'mil.gt',
    'net.gt',
    'org.gt',
    'gu',
    'com.gu',
    'edu.gu',
    'gov.gu',
    'guam.gu',
    'info.gu',
    'net.gu',
    'org.gu',
    'web.gu',
    'gw',
    'gy',
    'co.gy',
    'com.gy',
    'edu.gy',
    'gov.gy',
    'net.gy',
    'org.gy',
    'hk',
    'com.hk',
    'edu.hk',
    'gov.hk',
    'idv.hk',
    'net.hk',
    'org.hk',
    '\u516C\u53F8.hk',
    '\u6559\u80B2.hk',
    '\u654E\u80B2.hk',
    '\u653F\u5E9C.hk',
    '\u500B\u4EBA.hk',
    '\u4E2A\u4EBA.hk',
    '\u7B87\u4EBA.hk',
    '\u7DB2\u7EDC.hk',
    '\u7F51\u7EDC.hk',
    '\u7EC4\u7E54.hk',
    '\u7DB2\u7D61.hk',
    '\u7F51\u7D61.hk',
    '\u7EC4\u7EC7.hk',
    '\u7D44\u7E54.hk',
    '\u7D44\u7EC7.hk',
    'hm',
    'hn',
    'com.hn',
    'edu.hn',
    'org.hn',
    'net.hn',
    'mil.hn',
    'gob.hn',
    'hr',
    'iz.hr',
    'from.hr',
    'name.hr',
    'com.hr',
    'ht',
    'com.ht',
    'shop.ht',
    'firm.ht',
    'info.ht',
    'adult.ht',
    'net.ht',
    'pro.ht',
    'org.ht',
    'med.ht',
    'art.ht',
    'coop.ht',
    'pol.ht',
    'asso.ht',
    'edu.ht',
    'rel.ht',
    'gouv.ht',
    'perso.ht',
    'hu',
    'co.hu',
    'info.hu',
    'org.hu',
    'priv.hu',
    'sport.hu',
    'tm.hu',
    '2000.hu',
    'agrar.hu',
    'bolt.hu',
    'casino.hu',
    'city.hu',
    'erotica.hu',
    'erotika.hu',
    'film.hu',
    'forum.hu',
    'games.hu',
    'hotel.hu',
    'ingatlan.hu',
    'jogasz.hu',
    'konyvelo.hu',
    'lakas.hu',
    'media.hu',
    'news.hu',
    'reklam.hu',
    'sex.hu',
    'shop.hu',
    'suli.hu',
    'szex.hu',
    'tozsde.hu',
    'utazas.hu',
    'video.hu',
    'id',
    'ac.id',
    'biz.id',
    'co.id',
    'desa.id',
    'go.id',
    'mil.id',
    'my.id',
    'net.id',
    'or.id',
    'ponpes.id',
    'sch.id',
    'web.id',
    'ie',
    'gov.ie',
    'il',
    'ac.il',
    'co.il',
    'gov.il',
    'idf.il',
    'k12.il',
    'muni.il',
    'net.il',
    'org.il',
    'im',
    'ac.im',
    'co.im',
    'com.im',
    'ltd.co.im',
    'net.im',
    'org.im',
    'plc.co.im',
    'tt.im',
    'tv.im',
    'in',
    'co.in',
    'firm.in',
    'net.in',
    'org.in',
    'gen.in',
    'ind.in',
    'nic.in',
    'ac.in',
    'edu.in',
    'res.in',
    'gov.in',
    'mil.in',
    'info',
    'int',
    'eu.int',
    'io',
    'com.io',
    'iq',
    'gov.iq',
    'edu.iq',
    'mil.iq',
    'com.iq',
    'org.iq',
    'net.iq',
    'ir',
    'ac.ir',
    'co.ir',
    'gov.ir',
    'id.ir',
    'net.ir',
    'org.ir',
    'sch.ir',
    '\u0627\u06CC\u0631\u0627\u0646.ir',
    '\u0627\u064A\u0631\u0627\u0646.ir',
    'is',
    'net.is',
    'com.is',
    'edu.is',
    'gov.is',
    'org.is',
    'int.is',
    'it',
    'gov.it',
    'edu.it',
    'abr.it',
    'abruzzo.it',
    'aosta-valley.it',
    'aostavalley.it',
    'bas.it',
    'basilicata.it',
    'cal.it',
    'calabria.it',
    'cam.it',
    'campania.it',
    'emilia-romagna.it',
    'emiliaromagna.it',
    'emr.it',
    'friuli-v-giulia.it',
    'friuli-ve-giulia.it',
    'friuli-vegiulia.it',
    'friuli-venezia-giulia.it',
    'friuli-veneziagiulia.it',
    'friuli-vgiulia.it',
    'friuliv-giulia.it',
    'friulive-giulia.it',
    'friulivegiulia.it',
    'friulivenezia-giulia.it',
    'friuliveneziagiulia.it',
    'friulivgiulia.it',
    'fvg.it',
    'laz.it',
    'lazio.it',
    'lig.it',
    'liguria.it',
    'lom.it',
    'lombardia.it',
    'lombardy.it',
    'lucania.it',
    'mar.it',
    'marche.it',
    'mol.it',
    'molise.it',
    'piedmont.it',
    'piemonte.it',
    'pmn.it',
    'pug.it',
    'puglia.it',
    'sar.it',
    'sardegna.it',
    'sardinia.it',
    'sic.it',
    'sicilia.it',
    'sicily.it',
    'taa.it',
    'tos.it',
    'toscana.it',
    'trentin-sud-tirol.it',
    'trentin-s\xFCd-tirol.it',
    'trentin-sudtirol.it',
    'trentin-s\xFCdtirol.it',
    'trentin-sued-tirol.it',
    'trentin-suedtirol.it',
    'trentino-a-adige.it',
    'trentino-aadige.it',
    'trentino-alto-adige.it',
    'trentino-altoadige.it',
    'trentino-s-tirol.it',
    'trentino-stirol.it',
    'trentino-sud-tirol.it',
    'trentino-s\xFCd-tirol.it',
    'trentino-sudtirol.it',
    'trentino-s\xFCdtirol.it',
    'trentino-sued-tirol.it',
    'trentino-suedtirol.it',
    'trentino.it',
    'trentinoa-adige.it',
    'trentinoaadige.it',
    'trentinoalto-adige.it',
    'trentinoaltoadige.it',
    'trentinos-tirol.it',
    'trentinostirol.it',
    'trentinosud-tirol.it',
    'trentinos\xFCd-tirol.it',
    'trentinosudtirol.it',
    'trentinos\xFCdtirol.it',
    'trentinosued-tirol.it',
    'trentinosuedtirol.it',
    'trentinsud-tirol.it',
    'trentins\xFCd-tirol.it',
    'trentinsudtirol.it',
    'trentins\xFCdtirol.it',
    'trentinsued-tirol.it',
    'trentinsuedtirol.it',
    'tuscany.it',
    'umb.it',
    'umbria.it',
    'val-d-aosta.it',
    'val-daosta.it',
    'vald-aosta.it',
    'valdaosta.it',
    'valle-aosta.it',
    'valle-d-aosta.it',
    'valle-daosta.it',
    'valleaosta.it',
    'valled-aosta.it',
    'valledaosta.it',
    'vallee-aoste.it',
    'vall\xE9e-aoste.it',
    'vallee-d-aoste.it',
    'vall\xE9e-d-aoste.it',
    'valleeaoste.it',
    'vall\xE9eaoste.it',
    'valleedaoste.it',
    'vall\xE9edaoste.it',
    'vao.it',
    'vda.it',
    'ven.it',
    'veneto.it',
    'ag.it',
    'agrigento.it',
    'al.it',
    'alessandria.it',
    'alto-adige.it',
    'altoadige.it',
    'an.it',
    'ancona.it',
    'andria-barletta-trani.it',
    'andria-trani-barletta.it',
    'andriabarlettatrani.it',
    'andriatranibarletta.it',
    'ao.it',
    'aosta.it',
    'aoste.it',
    'ap.it',
    'aq.it',
    'aquila.it',
    'ar.it',
    'arezzo.it',
    'ascoli-piceno.it',
    'ascolipiceno.it',
    'asti.it',
    'at.it',
    'av.it',
    'avellino.it',
    'ba.it',
    'balsan-sudtirol.it',
    'balsan-s\xFCdtirol.it',
    'balsan-suedtirol.it',
    'balsan.it',
    'bari.it',
    'barletta-trani-andria.it',
    'barlettatraniandria.it',
    'belluno.it',
    'benevento.it',
    'bergamo.it',
    'bg.it',
    'bi.it',
    'biella.it',
    'bl.it',
    'bn.it',
    'bo.it',
    'bologna.it',
    'bolzano-altoadige.it',
    'bolzano.it',
    'bozen-sudtirol.it',
    'bozen-s\xFCdtirol.it',
    'bozen-suedtirol.it',
    'bozen.it',
    'br.it',
    'brescia.it',
    'brindisi.it',
    'bs.it',
    'bt.it',
    'bulsan-sudtirol.it',
    'bulsan-s\xFCdtirol.it',
    'bulsan-suedtirol.it',
    'bulsan.it',
    'bz.it',
    'ca.it',
    'cagliari.it',
    'caltanissetta.it',
    'campidano-medio.it',
    'campidanomedio.it',
    'campobasso.it',
    'carbonia-iglesias.it',
    'carboniaiglesias.it',
    'carrara-massa.it',
    'carraramassa.it',
    'caserta.it',
    'catania.it',
    'catanzaro.it',
    'cb.it',
    'ce.it',
    'cesena-forli.it',
    'cesena-forl\xEC.it',
    'cesenaforli.it',
    'cesenaforl\xEC.it',
    'ch.it',
    'chieti.it',
    'ci.it',
    'cl.it',
    'cn.it',
    'co.it',
    'como.it',
    'cosenza.it',
    'cr.it',
    'cremona.it',
    'crotone.it',
    'cs.it',
    'ct.it',
    'cuneo.it',
    'cz.it',
    'dell-ogliastra.it',
    'dellogliastra.it',
    'en.it',
    'enna.it',
    'fc.it',
    'fe.it',
    'fermo.it',
    'ferrara.it',
    'fg.it',
    'fi.it',
    'firenze.it',
    'florence.it',
    'fm.it',
    'foggia.it',
    'forli-cesena.it',
    'forl\xEC-cesena.it',
    'forlicesena.it',
    'forl\xECcesena.it',
    'fr.it',
    'frosinone.it',
    'ge.it',
    'genoa.it',
    'genova.it',
    'go.it',
    'gorizia.it',
    'gr.it',
    'grosseto.it',
    'iglesias-carbonia.it',
    'iglesiascarbonia.it',
    'im.it',
    'imperia.it',
    'is.it',
    'isernia.it',
    'kr.it',
    'la-spezia.it',
    'laquila.it',
    'laspezia.it',
    'latina.it',
    'lc.it',
    'le.it',
    'lecce.it',
    'lecco.it',
    'li.it',
    'livorno.it',
    'lo.it',
    'lodi.it',
    'lt.it',
    'lu.it',
    'lucca.it',
    'macerata.it',
    'mantova.it',
    'massa-carrara.it',
    'massacarrara.it',
    'matera.it',
    'mb.it',
    'mc.it',
    'me.it',
    'medio-campidano.it',
    'mediocampidano.it',
    'messina.it',
    'mi.it',
    'milan.it',
    'milano.it',
    'mn.it',
    'mo.it',
    'modena.it',
    'monza-brianza.it',
    'monza-e-della-brianza.it',
    'monza.it',
    'monzabrianza.it',
    'monzaebrianza.it',
    'monzaedellabrianza.it',
    'ms.it',
    'mt.it',
    'na.it',
    'naples.it',
    'napoli.it',
    'no.it',
    'novara.it',
    'nu.it',
    'nuoro.it',
    'og.it',
    'ogliastra.it',
    'olbia-tempio.it',
    'olbiatempio.it',
    'or.it',
    'oristano.it',
    'ot.it',
    'pa.it',
    'padova.it',
    'padua.it',
    'palermo.it',
    'parma.it',
    'pavia.it',
    'pc.it',
    'pd.it',
    'pe.it',
    'perugia.it',
    'pesaro-urbino.it',
    'pesarourbino.it',
    'pescara.it',
    'pg.it',
    'pi.it',
    'piacenza.it',
    'pisa.it',
    'pistoia.it',
    'pn.it',
    'po.it',
    'pordenone.it',
    'potenza.it',
    'pr.it',
    'prato.it',
    'pt.it',
    'pu.it',
    'pv.it',
    'pz.it',
    'ra.it',
    'ragusa.it',
    'ravenna.it',
    'rc.it',
    're.it',
    'reggio-calabria.it',
    'reggio-emilia.it',
    'reggiocalabria.it',
    'reggioemilia.it',
    'rg.it',
    'ri.it',
    'rieti.it',
    'rimini.it',
    'rm.it',
    'rn.it',
    'ro.it',
    'roma.it',
    'rome.it',
    'rovigo.it',
    'sa.it',
    'salerno.it',
    'sassari.it',
    'savona.it',
    'si.it',
    'siena.it',
    'siracusa.it',
    'so.it',
    'sondrio.it',
    'sp.it',
    'sr.it',
    'ss.it',
    'suedtirol.it',
    's\xFCdtirol.it',
    'sv.it',
    'ta.it',
    'taranto.it',
    'te.it',
    'tempio-olbia.it',
    'tempioolbia.it',
    'teramo.it',
    'terni.it',
    'tn.it',
    'to.it',
    'torino.it',
    'tp.it',
    'tr.it',
    'trani-andria-barletta.it',
    'trani-barletta-andria.it',
    'traniandriabarletta.it',
    'tranibarlettaandria.it',
    'trapani.it',
    'trento.it',
    'treviso.it',
    'trieste.it',
    'ts.it',
    'turin.it',
    'tv.it',
    'ud.it',
    'udine.it',
    'urbino-pesaro.it',
    'urbinopesaro.it',
    'va.it',
    'varese.it',
    'vb.it',
    'vc.it',
    've.it',
    'venezia.it',
    'venice.it',
    'verbania.it',
    'vercelli.it',
    'verona.it',
    'vi.it',
    'vibo-valentia.it',
    'vibovalentia.it',
    'vicenza.it',
    'viterbo.it',
    'vr.it',
    'vs.it',
    'vt.it',
    'vv.it',
    'je',
    'co.je',
    'net.je',
    'org.je',
    '*.jm',
    'jo',
    'com.jo',
    'org.jo',
    'net.jo',
    'edu.jo',
    'sch.jo',
    'gov.jo',
    'mil.jo',
    'name.jo',
    'jobs',
    'jp',
    'ac.jp',
    'ad.jp',
    'co.jp',
    'ed.jp',
    'go.jp',
    'gr.jp',
    'lg.jp',
    'ne.jp',
    'or.jp',
    'aichi.jp',
    'akita.jp',
    'aomori.jp',
    'chiba.jp',
    'ehime.jp',
    'fukui.jp',
    'fukuoka.jp',
    'fukushima.jp',
    'gifu.jp',
    'gunma.jp',
    'hiroshima.jp',
    'hokkaido.jp',
    'hyogo.jp',
    'ibaraki.jp',
    'ishikawa.jp',
    'iwate.jp',
    'kagawa.jp',
    'kagoshima.jp',
    'kanagawa.jp',
    'kochi.jp',
    'kumamoto.jp',
    'kyoto.jp',
    'mie.jp',
    'miyagi.jp',
    'miyazaki.jp',
    'nagano.jp',
    'nagasaki.jp',
    'nara.jp',
    'niigata.jp',
    'oita.jp',
    'okayama.jp',
    'okinawa.jp',
    'osaka.jp',
    'saga.jp',
    'saitama.jp',
    'shiga.jp',
    'shimane.jp',
    'shizuoka.jp',
    'tochigi.jp',
    'tokushima.jp',
    'tokyo.jp',
    'tottori.jp',
    'toyama.jp',
    'wakayama.jp',
    'yamagata.jp',
    'yamaguchi.jp',
    'yamanashi.jp',
    '\u6803\u6728.jp',
    '\u611B\u77E5.jp',
    '\u611B\u5A9B.jp',
    '\u5175\u5EAB.jp',
    '\u718A\u672C.jp',
    '\u8328\u57CE.jp',
    '\u5317\u6D77\u9053.jp',
    '\u5343\u8449.jp',
    '\u548C\u6B4C\u5C71.jp',
    '\u9577\u5D0E.jp',
    '\u9577\u91CE.jp',
    '\u65B0\u6F5F.jp',
    '\u9752\u68EE.jp',
    '\u9759\u5CA1.jp',
    '\u6771\u4EAC.jp',
    '\u77F3\u5DDD.jp',
    '\u57FC\u7389.jp',
    '\u4E09\u91CD.jp',
    '\u4EAC\u90FD.jp',
    '\u4F50\u8CC0.jp',
    '\u5927\u5206.jp',
    '\u5927\u962A.jp',
    '\u5948\u826F.jp',
    '\u5BAE\u57CE.jp',
    '\u5BAE\u5D0E.jp',
    '\u5BCC\u5C71.jp',
    '\u5C71\u53E3.jp',
    '\u5C71\u5F62.jp',
    '\u5C71\u68A8.jp',
    '\u5CA9\u624B.jp',
    '\u5C90\u961C.jp',
    '\u5CA1\u5C71.jp',
    '\u5CF6\u6839.jp',
    '\u5E83\u5CF6.jp',
    '\u5FB3\u5CF6.jp',
    '\u6C96\u7E04.jp',
    '\u6ECB\u8CC0.jp',
    '\u795E\u5948\u5DDD.jp',
    '\u798F\u4E95.jp',
    '\u798F\u5CA1.jp',
    '\u798F\u5CF6.jp',
    '\u79CB\u7530.jp',
    '\u7FA4\u99AC.jp',
    '\u9999\u5DDD.jp',
    '\u9AD8\u77E5.jp',
    '\u9CE5\u53D6.jp',
    '\u9E7F\u5150\u5CF6.jp',
    '*.kawasaki.jp',
    '*.kitakyushu.jp',
    '*.kobe.jp',
    '*.nagoya.jp',
    '*.sapporo.jp',
    '*.sendai.jp',
    '*.yokohama.jp',
    '!city.kawasaki.jp',
    '!city.kitakyushu.jp',
    '!city.kobe.jp',
    '!city.nagoya.jp',
    '!city.sapporo.jp',
    '!city.sendai.jp',
    '!city.yokohama.jp',
    'aisai.aichi.jp',
    'ama.aichi.jp',
    'anjo.aichi.jp',
    'asuke.aichi.jp',
    'chiryu.aichi.jp',
    'chita.aichi.jp',
    'fuso.aichi.jp',
    'gamagori.aichi.jp',
    'handa.aichi.jp',
    'hazu.aichi.jp',
    'hekinan.aichi.jp',
    'higashiura.aichi.jp',
    'ichinomiya.aichi.jp',
    'inazawa.aichi.jp',
    'inuyama.aichi.jp',
    'isshiki.aichi.jp',
    'iwakura.aichi.jp',
    'kanie.aichi.jp',
    'kariya.aichi.jp',
    'kasugai.aichi.jp',
    'kira.aichi.jp',
    'kiyosu.aichi.jp',
    'komaki.aichi.jp',
    'konan.aichi.jp',
    'kota.aichi.jp',
    'mihama.aichi.jp',
    'miyoshi.aichi.jp',
    'nishio.aichi.jp',
    'nisshin.aichi.jp',
    'obu.aichi.jp',
    'oguchi.aichi.jp',
    'oharu.aichi.jp',
    'okazaki.aichi.jp',
    'owariasahi.aichi.jp',
    'seto.aichi.jp',
    'shikatsu.aichi.jp',
    'shinshiro.aichi.jp',
    'shitara.aichi.jp',
    'tahara.aichi.jp',
    'takahama.aichi.jp',
    'tobishima.aichi.jp',
    'toei.aichi.jp',
    'togo.aichi.jp',
    'tokai.aichi.jp',
    'tokoname.aichi.jp',
    'toyoake.aichi.jp',
    'toyohashi.aichi.jp',
    'toyokawa.aichi.jp',
    'toyone.aichi.jp',
    'toyota.aichi.jp',
    'tsushima.aichi.jp',
    'yatomi.aichi.jp',
    'akita.akita.jp',
    'daisen.akita.jp',
    'fujisato.akita.jp',
    'gojome.akita.jp',
    'hachirogata.akita.jp',
    'happou.akita.jp',
    'higashinaruse.akita.jp',
    'honjo.akita.jp',
    'honjyo.akita.jp',
    'ikawa.akita.jp',
    'kamikoani.akita.jp',
    'kamioka.akita.jp',
    'katagami.akita.jp',
    'kazuno.akita.jp',
    'kitaakita.akita.jp',
    'kosaka.akita.jp',
    'kyowa.akita.jp',
    'misato.akita.jp',
    'mitane.akita.jp',
    'moriyoshi.akita.jp',
    'nikaho.akita.jp',
    'noshiro.akita.jp',
    'odate.akita.jp',
    'oga.akita.jp',
    'ogata.akita.jp',
    'semboku.akita.jp',
    'yokote.akita.jp',
    'yurihonjo.akita.jp',
    'aomori.aomori.jp',
    'gonohe.aomori.jp',
    'hachinohe.aomori.jp',
    'hashikami.aomori.jp',
    'hiranai.aomori.jp',
    'hirosaki.aomori.jp',
    'itayanagi.aomori.jp',
    'kuroishi.aomori.jp',
    'misawa.aomori.jp',
    'mutsu.aomori.jp',
    'nakadomari.aomori.jp',
    'noheji.aomori.jp',
    'oirase.aomori.jp',
    'owani.aomori.jp',
    'rokunohe.aomori.jp',
    'sannohe.aomori.jp',
    'shichinohe.aomori.jp',
    'shingo.aomori.jp',
    'takko.aomori.jp',
    'towada.aomori.jp',
    'tsugaru.aomori.jp',
    'tsuruta.aomori.jp',
    'abiko.chiba.jp',
    'asahi.chiba.jp',
    'chonan.chiba.jp',
    'chosei.chiba.jp',
    'choshi.chiba.jp',
    'chuo.chiba.jp',
    'funabashi.chiba.jp',
    'futtsu.chiba.jp',
    'hanamigawa.chiba.jp',
    'ichihara.chiba.jp',
    'ichikawa.chiba.jp',
    'ichinomiya.chiba.jp',
    'inzai.chiba.jp',
    'isumi.chiba.jp',
    'kamagaya.chiba.jp',
    'kamogawa.chiba.jp',
    'kashiwa.chiba.jp',
    'katori.chiba.jp',
    'katsuura.chiba.jp',
    'kimitsu.chiba.jp',
    'kisarazu.chiba.jp',
    'kozaki.chiba.jp',
    'kujukuri.chiba.jp',
    'kyonan.chiba.jp',
    'matsudo.chiba.jp',
    'midori.chiba.jp',
    'mihama.chiba.jp',
    'minamiboso.chiba.jp',
    'mobara.chiba.jp',
    'mutsuzawa.chiba.jp',
    'nagara.chiba.jp',
    'nagareyama.chiba.jp',
    'narashino.chiba.jp',
    'narita.chiba.jp',
    'noda.chiba.jp',
    'oamishirasato.chiba.jp',
    'omigawa.chiba.jp',
    'onjuku.chiba.jp',
    'otaki.chiba.jp',
    'sakae.chiba.jp',
    'sakura.chiba.jp',
    'shimofusa.chiba.jp',
    'shirako.chiba.jp',
    'shiroi.chiba.jp',
    'shisui.chiba.jp',
    'sodegaura.chiba.jp',
    'sosa.chiba.jp',
    'tako.chiba.jp',
    'tateyama.chiba.jp',
    'togane.chiba.jp',
    'tohnosho.chiba.jp',
    'tomisato.chiba.jp',
    'urayasu.chiba.jp',
    'yachimata.chiba.jp',
    'yachiyo.chiba.jp',
    'yokaichiba.chiba.jp',
    'yokoshibahikari.chiba.jp',
    'yotsukaido.chiba.jp',
    'ainan.ehime.jp',
    'honai.ehime.jp',
    'ikata.ehime.jp',
    'imabari.ehime.jp',
    'iyo.ehime.jp',
    'kamijima.ehime.jp',
    'kihoku.ehime.jp',
    'kumakogen.ehime.jp',
    'masaki.ehime.jp',
    'matsuno.ehime.jp',
    'matsuyama.ehime.jp',
    'namikata.ehime.jp',
    'niihama.ehime.jp',
    'ozu.ehime.jp',
    'saijo.ehime.jp',
    'seiyo.ehime.jp',
    'shikokuchuo.ehime.jp',
    'tobe.ehime.jp',
    'toon.ehime.jp',
    'uchiko.ehime.jp',
    'uwajima.ehime.jp',
    'yawatahama.ehime.jp',
    'echizen.fukui.jp',
    'eiheiji.fukui.jp',
    'fukui.fukui.jp',
    'ikeda.fukui.jp',
    'katsuyama.fukui.jp',
    'mihama.fukui.jp',
    'minamiechizen.fukui.jp',
    'obama.fukui.jp',
    'ohi.fukui.jp',
    'ono.fukui.jp',
    'sabae.fukui.jp',
    'sakai.fukui.jp',
    'takahama.fukui.jp',
    'tsuruga.fukui.jp',
    'wakasa.fukui.jp',
    'ashiya.fukuoka.jp',
    'buzen.fukuoka.jp',
    'chikugo.fukuoka.jp',
    'chikuho.fukuoka.jp',
    'chikujo.fukuoka.jp',
    'chikushino.fukuoka.jp',
    'chikuzen.fukuoka.jp',
    'chuo.fukuoka.jp',
    'dazaifu.fukuoka.jp',
    'fukuchi.fukuoka.jp',
    'hakata.fukuoka.jp',
    'higashi.fukuoka.jp',
    'hirokawa.fukuoka.jp',
    'hisayama.fukuoka.jp',
    'iizuka.fukuoka.jp',
    'inatsuki.fukuoka.jp',
    'kaho.fukuoka.jp',
    'kasuga.fukuoka.jp',
    'kasuya.fukuoka.jp',
    'kawara.fukuoka.jp',
    'keisen.fukuoka.jp',
    'koga.fukuoka.jp',
    'kurate.fukuoka.jp',
    'kurogi.fukuoka.jp',
    'kurume.fukuoka.jp',
    'minami.fukuoka.jp',
    'miyako.fukuoka.jp',
    'miyama.fukuoka.jp',
    'miyawaka.fukuoka.jp',
    'mizumaki.fukuoka.jp',
    'munakata.fukuoka.jp',
    'nakagawa.fukuoka.jp',
    'nakama.fukuoka.jp',
    'nishi.fukuoka.jp',
    'nogata.fukuoka.jp',
    'ogori.fukuoka.jp',
    'okagaki.fukuoka.jp',
    'okawa.fukuoka.jp',
    'oki.fukuoka.jp',
    'omuta.fukuoka.jp',
    'onga.fukuoka.jp',
    'onojo.fukuoka.jp',
    'oto.fukuoka.jp',
    'saigawa.fukuoka.jp',
    'sasaguri.fukuoka.jp',
    'shingu.fukuoka.jp',
    'shinyoshitomi.fukuoka.jp',
    'shonai.fukuoka.jp',
    'soeda.fukuoka.jp',
    'sue.fukuoka.jp',
    'tachiarai.fukuoka.jp',
    'tagawa.fukuoka.jp',
    'takata.fukuoka.jp',
    'toho.fukuoka.jp',
    'toyotsu.fukuoka.jp',
    'tsuiki.fukuoka.jp',
    'ukiha.fukuoka.jp',
    'umi.fukuoka.jp',
    'usui.fukuoka.jp',
    'yamada.fukuoka.jp',
    'yame.fukuoka.jp',
    'yanagawa.fukuoka.jp',
    'yukuhashi.fukuoka.jp',
    'aizubange.fukushima.jp',
    'aizumisato.fukushima.jp',
    'aizuwakamatsu.fukushima.jp',
    'asakawa.fukushima.jp',
    'bandai.fukushima.jp',
    'date.fukushima.jp',
    'fukushima.fukushima.jp',
    'furudono.fukushima.jp',
    'futaba.fukushima.jp',
    'hanawa.fukushima.jp',
    'higashi.fukushima.jp',
    'hirata.fukushima.jp',
    'hirono.fukushima.jp',
    'iitate.fukushima.jp',
    'inawashiro.fukushima.jp',
    'ishikawa.fukushima.jp',
    'iwaki.fukushima.jp',
    'izumizaki.fukushima.jp',
    'kagamiishi.fukushima.jp',
    'kaneyama.fukushima.jp',
    'kawamata.fukushima.jp',
    'kitakata.fukushima.jp',
    'kitashiobara.fukushima.jp',
    'koori.fukushima.jp',
    'koriyama.fukushima.jp',
    'kunimi.fukushima.jp',
    'miharu.fukushima.jp',
    'mishima.fukushima.jp',
    'namie.fukushima.jp',
    'nango.fukushima.jp',
    'nishiaizu.fukushima.jp',
    'nishigo.fukushima.jp',
    'okuma.fukushima.jp',
    'omotego.fukushima.jp',
    'ono.fukushima.jp',
    'otama.fukushima.jp',
    'samegawa.fukushima.jp',
    'shimogo.fukushima.jp',
    'shirakawa.fukushima.jp',
    'showa.fukushima.jp',
    'soma.fukushima.jp',
    'sukagawa.fukushima.jp',
    'taishin.fukushima.jp',
    'tamakawa.fukushima.jp',
    'tanagura.fukushima.jp',
    'tenei.fukushima.jp',
    'yabuki.fukushima.jp',
    'yamato.fukushima.jp',
    'yamatsuri.fukushima.jp',
    'yanaizu.fukushima.jp',
    'yugawa.fukushima.jp',
    'anpachi.gifu.jp',
    'ena.gifu.jp',
    'gifu.gifu.jp',
    'ginan.gifu.jp',
    'godo.gifu.jp',
    'gujo.gifu.jp',
    'hashima.gifu.jp',
    'hichiso.gifu.jp',
    'hida.gifu.jp',
    'higashishirakawa.gifu.jp',
    'ibigawa.gifu.jp',
    'ikeda.gifu.jp',
    'kakamigahara.gifu.jp',
    'kani.gifu.jp',
    'kasahara.gifu.jp',
    'kasamatsu.gifu.jp',
    'kawaue.gifu.jp',
    'kitagata.gifu.jp',
    'mino.gifu.jp',
    'minokamo.gifu.jp',
    'mitake.gifu.jp',
    'mizunami.gifu.jp',
    'motosu.gifu.jp',
    'nakatsugawa.gifu.jp',
    'ogaki.gifu.jp',
    'sakahogi.gifu.jp',
    'seki.gifu.jp',
    'sekigahara.gifu.jp',
    'shirakawa.gifu.jp',
    'tajimi.gifu.jp',
    'takayama.gifu.jp',
    'tarui.gifu.jp',
    'toki.gifu.jp',
    'tomika.gifu.jp',
    'wanouchi.gifu.jp',
    'yamagata.gifu.jp',
    'yaotsu.gifu.jp',
    'yoro.gifu.jp',
    'annaka.gunma.jp',
    'chiyoda.gunma.jp',
    'fujioka.gunma.jp',
    'higashiagatsuma.gunma.jp',
    'isesaki.gunma.jp',
    'itakura.gunma.jp',
    'kanna.gunma.jp',
    'kanra.gunma.jp',
    'katashina.gunma.jp',
    'kawaba.gunma.jp',
    'kiryu.gunma.jp',
    'kusatsu.gunma.jp',
    'maebashi.gunma.jp',
    'meiwa.gunma.jp',
    'midori.gunma.jp',
    'minakami.gunma.jp',
    'naganohara.gunma.jp',
    'nakanojo.gunma.jp',
    'nanmoku.gunma.jp',
    'numata.gunma.jp',
    'oizumi.gunma.jp',
    'ora.gunma.jp',
    'ota.gunma.jp',
    'shibukawa.gunma.jp',
    'shimonita.gunma.jp',
    'shinto.gunma.jp',
    'showa.gunma.jp',
    'takasaki.gunma.jp',
    'takayama.gunma.jp',
    'tamamura.gunma.jp',
    'tatebayashi.gunma.jp',
    'tomioka.gunma.jp',
    'tsukiyono.gunma.jp',
    'tsumagoi.gunma.jp',
    'ueno.gunma.jp',
    'yoshioka.gunma.jp',
    'asaminami.hiroshima.jp',
    'daiwa.hiroshima.jp',
    'etajima.hiroshima.jp',
    'fuchu.hiroshima.jp',
    'fukuyama.hiroshima.jp',
    'hatsukaichi.hiroshima.jp',
    'higashihiroshima.hiroshima.jp',
    'hongo.hiroshima.jp',
    'jinsekikogen.hiroshima.jp',
    'kaita.hiroshima.jp',
    'kui.hiroshima.jp',
    'kumano.hiroshima.jp',
    'kure.hiroshima.jp',
    'mihara.hiroshima.jp',
    'miyoshi.hiroshima.jp',
    'naka.hiroshima.jp',
    'onomichi.hiroshima.jp',
    'osakikamijima.hiroshima.jp',
    'otake.hiroshima.jp',
    'saka.hiroshima.jp',
    'sera.hiroshima.jp',
    'seranishi.hiroshima.jp',
    'shinichi.hiroshima.jp',
    'shobara.hiroshima.jp',
    'takehara.hiroshima.jp',
    'abashiri.hokkaido.jp',
    'abira.hokkaido.jp',
    'aibetsu.hokkaido.jp',
    'akabira.hokkaido.jp',
    'akkeshi.hokkaido.jp',
    'asahikawa.hokkaido.jp',
    'ashibetsu.hokkaido.jp',
    'ashoro.hokkaido.jp',
    'assabu.hokkaido.jp',
    'atsuma.hokkaido.jp',
    'bibai.hokkaido.jp',
    'biei.hokkaido.jp',
    'bifuka.hokkaido.jp',
    'bihoro.hokkaido.jp',
    'biratori.hokkaido.jp',
    'chippubetsu.hokkaido.jp',
    'chitose.hokkaido.jp',
    'date.hokkaido.jp',
    'ebetsu.hokkaido.jp',
    'embetsu.hokkaido.jp',
    'eniwa.hokkaido.jp',
    'erimo.hokkaido.jp',
    'esan.hokkaido.jp',
    'esashi.hokkaido.jp',
    'fukagawa.hokkaido.jp',
    'fukushima.hokkaido.jp',
    'furano.hokkaido.jp',
    'furubira.hokkaido.jp',
    'haboro.hokkaido.jp',
    'hakodate.hokkaido.jp',
    'hamatonbetsu.hokkaido.jp',
    'hidaka.hokkaido.jp',
    'higashikagura.hokkaido.jp',
    'higashikawa.hokkaido.jp',
    'hiroo.hokkaido.jp',
    'hokuryu.hokkaido.jp',
    'hokuto.hokkaido.jp',
    'honbetsu.hokkaido.jp',
    'horokanai.hokkaido.jp',
    'horonobe.hokkaido.jp',
    'ikeda.hokkaido.jp',
    'imakane.hokkaido.jp',
    'ishikari.hokkaido.jp',
    'iwamizawa.hokkaido.jp',
    'iwanai.hokkaido.jp',
    'kamifurano.hokkaido.jp',
    'kamikawa.hokkaido.jp',
    'kamishihoro.hokkaido.jp',
    'kamisunagawa.hokkaido.jp',
    'kamoenai.hokkaido.jp',
    'kayabe.hokkaido.jp',
    'kembuchi.hokkaido.jp',
    'kikonai.hokkaido.jp',
    'kimobetsu.hokkaido.jp',
    'kitahiroshima.hokkaido.jp',
    'kitami.hokkaido.jp',
    'kiyosato.hokkaido.jp',
    'koshimizu.hokkaido.jp',
    'kunneppu.hokkaido.jp',
    'kuriyama.hokkaido.jp',
    'kuromatsunai.hokkaido.jp',
    'kushiro.hokkaido.jp',
    'kutchan.hokkaido.jp',
    'kyowa.hokkaido.jp',
    'mashike.hokkaido.jp',
    'matsumae.hokkaido.jp',
    'mikasa.hokkaido.jp',
    'minamifurano.hokkaido.jp',
    'mombetsu.hokkaido.jp',
    'moseushi.hokkaido.jp',
    'mukawa.hokkaido.jp',
    'muroran.hokkaido.jp',
    'naie.hokkaido.jp',
    'nakagawa.hokkaido.jp',
    'nakasatsunai.hokkaido.jp',
    'nakatombetsu.hokkaido.jp',
    'nanae.hokkaido.jp',
    'nanporo.hokkaido.jp',
    'nayoro.hokkaido.jp',
    'nemuro.hokkaido.jp',
    'niikappu.hokkaido.jp',
    'niki.hokkaido.jp',
    'nishiokoppe.hokkaido.jp',
    'noboribetsu.hokkaido.jp',
    'numata.hokkaido.jp',
    'obihiro.hokkaido.jp',
    'obira.hokkaido.jp',
    'oketo.hokkaido.jp',
    'okoppe.hokkaido.jp',
    'otaru.hokkaido.jp',
    'otobe.hokkaido.jp',
    'otofuke.hokkaido.jp',
    'otoineppu.hokkaido.jp',
    'oumu.hokkaido.jp',
    'ozora.hokkaido.jp',
    'pippu.hokkaido.jp',
    'rankoshi.hokkaido.jp',
    'rebun.hokkaido.jp',
    'rikubetsu.hokkaido.jp',
    'rishiri.hokkaido.jp',
    'rishirifuji.hokkaido.jp',
    'saroma.hokkaido.jp',
    'sarufutsu.hokkaido.jp',
    'shakotan.hokkaido.jp',
    'shari.hokkaido.jp',
    'shibecha.hokkaido.jp',
    'shibetsu.hokkaido.jp',
    'shikabe.hokkaido.jp',
    'shikaoi.hokkaido.jp',
    'shimamaki.hokkaido.jp',
    'shimizu.hokkaido.jp',
    'shimokawa.hokkaido.jp',
    'shinshinotsu.hokkaido.jp',
    'shintoku.hokkaido.jp',
    'shiranuka.hokkaido.jp',
    'shiraoi.hokkaido.jp',
    'shiriuchi.hokkaido.jp',
    'sobetsu.hokkaido.jp',
    'sunagawa.hokkaido.jp',
    'taiki.hokkaido.jp',
    'takasu.hokkaido.jp',
    'takikawa.hokkaido.jp',
    'takinoue.hokkaido.jp',
    'teshikaga.hokkaido.jp',
    'tobetsu.hokkaido.jp',
    'tohma.hokkaido.jp',
    'tomakomai.hokkaido.jp',
    'tomari.hokkaido.jp',
    'toya.hokkaido.jp',
    'toyako.hokkaido.jp',
    'toyotomi.hokkaido.jp',
    'toyoura.hokkaido.jp',
    'tsubetsu.hokkaido.jp',
    'tsukigata.hokkaido.jp',
    'urakawa.hokkaido.jp',
    'urausu.hokkaido.jp',
    'uryu.hokkaido.jp',
    'utashinai.hokkaido.jp',
    'wakkanai.hokkaido.jp',
    'wassamu.hokkaido.jp',
    'yakumo.hokkaido.jp',
    'yoichi.hokkaido.jp',
    'aioi.hyogo.jp',
    'akashi.hyogo.jp',
    'ako.hyogo.jp',
    'amagasaki.hyogo.jp',
    'aogaki.hyogo.jp',
    'asago.hyogo.jp',
    'ashiya.hyogo.jp',
    'awaji.hyogo.jp',
    'fukusaki.hyogo.jp',
    'goshiki.hyogo.jp',
    'harima.hyogo.jp',
    'himeji.hyogo.jp',
    'ichikawa.hyogo.jp',
    'inagawa.hyogo.jp',
    'itami.hyogo.jp',
    'kakogawa.hyogo.jp',
    'kamigori.hyogo.jp',
    'kamikawa.hyogo.jp',
    'kasai.hyogo.jp',
    'kasuga.hyogo.jp',
    'kawanishi.hyogo.jp',
    'miki.hyogo.jp',
    'minamiawaji.hyogo.jp',
    'nishinomiya.hyogo.jp',
    'nishiwaki.hyogo.jp',
    'ono.hyogo.jp',
    'sanda.hyogo.jp',
    'sannan.hyogo.jp',
    'sasayama.hyogo.jp',
    'sayo.hyogo.jp',
    'shingu.hyogo.jp',
    'shinonsen.hyogo.jp',
    'shiso.hyogo.jp',
    'sumoto.hyogo.jp',
    'taishi.hyogo.jp',
    'taka.hyogo.jp',
    'takarazuka.hyogo.jp',
    'takasago.hyogo.jp',
    'takino.hyogo.jp',
    'tamba.hyogo.jp',
    'tatsuno.hyogo.jp',
    'toyooka.hyogo.jp',
    'yabu.hyogo.jp',
    'yashiro.hyogo.jp',
    'yoka.hyogo.jp',
    'yokawa.hyogo.jp',
    'ami.ibaraki.jp',
    'asahi.ibaraki.jp',
    'bando.ibaraki.jp',
    'chikusei.ibaraki.jp',
    'daigo.ibaraki.jp',
    'fujishiro.ibaraki.jp',
    'hitachi.ibaraki.jp',
    'hitachinaka.ibaraki.jp',
    'hitachiomiya.ibaraki.jp',
    'hitachiota.ibaraki.jp',
    'ibaraki.ibaraki.jp',
    'ina.ibaraki.jp',
    'inashiki.ibaraki.jp',
    'itako.ibaraki.jp',
    'iwama.ibaraki.jp',
    'joso.ibaraki.jp',
    'kamisu.ibaraki.jp',
    'kasama.ibaraki.jp',
    'kashima.ibaraki.jp',
    'kasumigaura.ibaraki.jp',
    'koga.ibaraki.jp',
    'miho.ibaraki.jp',
    'mito.ibaraki.jp',
    'moriya.ibaraki.jp',
    'naka.ibaraki.jp',
    'namegata.ibaraki.jp',
    'oarai.ibaraki.jp',
    'ogawa.ibaraki.jp',
    'omitama.ibaraki.jp',
    'ryugasaki.ibaraki.jp',
    'sakai.ibaraki.jp',
    'sakuragawa.ibaraki.jp',
    'shimodate.ibaraki.jp',
    'shimotsuma.ibaraki.jp',
    'shirosato.ibaraki.jp',
    'sowa.ibaraki.jp',
    'suifu.ibaraki.jp',
    'takahagi.ibaraki.jp',
    'tamatsukuri.ibaraki.jp',
    'tokai.ibaraki.jp',
    'tomobe.ibaraki.jp',
    'tone.ibaraki.jp',
    'toride.ibaraki.jp',
    'tsuchiura.ibaraki.jp',
    'tsukuba.ibaraki.jp',
    'uchihara.ibaraki.jp',
    'ushiku.ibaraki.jp',
    'yachiyo.ibaraki.jp',
    'yamagata.ibaraki.jp',
    'yawara.ibaraki.jp',
    'yuki.ibaraki.jp',
    'anamizu.ishikawa.jp',
    'hakui.ishikawa.jp',
    'hakusan.ishikawa.jp',
    'kaga.ishikawa.jp',
    'kahoku.ishikawa.jp',
    'kanazawa.ishikawa.jp',
    'kawakita.ishikawa.jp',
    'komatsu.ishikawa.jp',
    'nakanoto.ishikawa.jp',
    'nanao.ishikawa.jp',
    'nomi.ishikawa.jp',
    'nonoichi.ishikawa.jp',
    'noto.ishikawa.jp',
    'shika.ishikawa.jp',
    'suzu.ishikawa.jp',
    'tsubata.ishikawa.jp',
    'tsurugi.ishikawa.jp',
    'uchinada.ishikawa.jp',
    'wajima.ishikawa.jp',
    'fudai.iwate.jp',
    'fujisawa.iwate.jp',
    'hanamaki.iwate.jp',
    'hiraizumi.iwate.jp',
    'hirono.iwate.jp',
    'ichinohe.iwate.jp',
    'ichinoseki.iwate.jp',
    'iwaizumi.iwate.jp',
    'iwate.iwate.jp',
    'joboji.iwate.jp',
    'kamaishi.iwate.jp',
    'kanegasaki.iwate.jp',
    'karumai.iwate.jp',
    'kawai.iwate.jp',
    'kitakami.iwate.jp',
    'kuji.iwate.jp',
    'kunohe.iwate.jp',
    'kuzumaki.iwate.jp',
    'miyako.iwate.jp',
    'mizusawa.iwate.jp',
    'morioka.iwate.jp',
    'ninohe.iwate.jp',
    'noda.iwate.jp',
    'ofunato.iwate.jp',
    'oshu.iwate.jp',
    'otsuchi.iwate.jp',
    'rikuzentakata.iwate.jp',
    'shiwa.iwate.jp',
    'shizukuishi.iwate.jp',
    'sumita.iwate.jp',
    'tanohata.iwate.jp',
    'tono.iwate.jp',
    'yahaba.iwate.jp',
    'yamada.iwate.jp',
    'ayagawa.kagawa.jp',
    'higashikagawa.kagawa.jp',
    'kanonji.kagawa.jp',
    'kotohira.kagawa.jp',
    'manno.kagawa.jp',
    'marugame.kagawa.jp',
    'mitoyo.kagawa.jp',
    'naoshima.kagawa.jp',
    'sanuki.kagawa.jp',
    'tadotsu.kagawa.jp',
    'takamatsu.kagawa.jp',
    'tonosho.kagawa.jp',
    'uchinomi.kagawa.jp',
    'utazu.kagawa.jp',
    'zentsuji.kagawa.jp',
    'akune.kagoshima.jp',
    'amami.kagoshima.jp',
    'hioki.kagoshima.jp',
    'isa.kagoshima.jp',
    'isen.kagoshima.jp',
    'izumi.kagoshima.jp',
    'kagoshima.kagoshima.jp',
    'kanoya.kagoshima.jp',
    'kawanabe.kagoshima.jp',
    'kinko.kagoshima.jp',
    'kouyama.kagoshima.jp',
    'makurazaki.kagoshima.jp',
    'matsumoto.kagoshima.jp',
    'minamitane.kagoshima.jp',
    'nakatane.kagoshima.jp',
    'nishinoomote.kagoshima.jp',
    'satsumasendai.kagoshima.jp',
    'soo.kagoshima.jp',
    'tarumizu.kagoshima.jp',
    'yusui.kagoshima.jp',
    'aikawa.kanagawa.jp',
    'atsugi.kanagawa.jp',
    'ayase.kanagawa.jp',
    'chigasaki.kanagawa.jp',
    'ebina.kanagawa.jp',
    'fujisawa.kanagawa.jp',
    'hadano.kanagawa.jp',
    'hakone.kanagawa.jp',
    'hiratsuka.kanagawa.jp',
    'isehara.kanagawa.jp',
    'kaisei.kanagawa.jp',
    'kamakura.kanagawa.jp',
    'kiyokawa.kanagawa.jp',
    'matsuda.kanagawa.jp',
    'minamiashigara.kanagawa.jp',
    'miura.kanagawa.jp',
    'nakai.kanagawa.jp',
    'ninomiya.kanagawa.jp',
    'odawara.kanagawa.jp',
    'oi.kanagawa.jp',
    'oiso.kanagawa.jp',
    'sagamihara.kanagawa.jp',
    'samukawa.kanagawa.jp',
    'tsukui.kanagawa.jp',
    'yamakita.kanagawa.jp',
    'yamato.kanagawa.jp',
    'yokosuka.kanagawa.jp',
    'yugawara.kanagawa.jp',
    'zama.kanagawa.jp',
    'zushi.kanagawa.jp',
    'aki.kochi.jp',
    'geisei.kochi.jp',
    'hidaka.kochi.jp',
    'higashitsuno.kochi.jp',
    'ino.kochi.jp',
    'kagami.kochi.jp',
    'kami.kochi.jp',
    'kitagawa.kochi.jp',
    'kochi.kochi.jp',
    'mihara.kochi.jp',
    'motoyama.kochi.jp',
    'muroto.kochi.jp',
    'nahari.kochi.jp',
    'nakamura.kochi.jp',
    'nankoku.kochi.jp',
    'nishitosa.kochi.jp',
    'niyodogawa.kochi.jp',
    'ochi.kochi.jp',
    'okawa.kochi.jp',
    'otoyo.kochi.jp',
    'otsuki.kochi.jp',
    'sakawa.kochi.jp',
    'sukumo.kochi.jp',
    'susaki.kochi.jp',
    'tosa.kochi.jp',
    'tosashimizu.kochi.jp',
    'toyo.kochi.jp',
    'tsuno.kochi.jp',
    'umaji.kochi.jp',
    'yasuda.kochi.jp',
    'yusuhara.kochi.jp',
    'amakusa.kumamoto.jp',
    'arao.kumamoto.jp',
    'aso.kumamoto.jp',
    'choyo.kumamoto.jp',
    'gyokuto.kumamoto.jp',
    'kamiamakusa.kumamoto.jp',
    'kikuchi.kumamoto.jp',
    'kumamoto.kumamoto.jp',
    'mashiki.kumamoto.jp',
    'mifune.kumamoto.jp',
    'minamata.kumamoto.jp',
    'minamioguni.kumamoto.jp',
    'nagasu.kumamoto.jp',
    'nishihara.kumamoto.jp',
    'oguni.kumamoto.jp',
    'ozu.kumamoto.jp',
    'sumoto.kumamoto.jp',
    'takamori.kumamoto.jp',
    'uki.kumamoto.jp',
    'uto.kumamoto.jp',
    'yamaga.kumamoto.jp',
    'yamato.kumamoto.jp',
    'yatsushiro.kumamoto.jp',
    'ayabe.kyoto.jp',
    'fukuchiyama.kyoto.jp',
    'higashiyama.kyoto.jp',
    'ide.kyoto.jp',
    'ine.kyoto.jp',
    'joyo.kyoto.jp',
    'kameoka.kyoto.jp',
    'kamo.kyoto.jp',
    'kita.kyoto.jp',
    'kizu.kyoto.jp',
    'kumiyama.kyoto.jp',
    'kyotamba.kyoto.jp',
    'kyotanabe.kyoto.jp',
    'kyotango.kyoto.jp',
    'maizuru.kyoto.jp',
    'minami.kyoto.jp',
    'minamiyamashiro.kyoto.jp',
    'miyazu.kyoto.jp',
    'muko.kyoto.jp',
    'nagaokakyo.kyoto.jp',
    'nakagyo.kyoto.jp',
    'nantan.kyoto.jp',
    'oyamazaki.kyoto.jp',
    'sakyo.kyoto.jp',
    'seika.kyoto.jp',
    'tanabe.kyoto.jp',
    'uji.kyoto.jp',
    'ujitawara.kyoto.jp',
    'wazuka.kyoto.jp',
    'yamashina.kyoto.jp',
    'yawata.kyoto.jp',
    'asahi.mie.jp',
    'inabe.mie.jp',
    'ise.mie.jp',
    'kameyama.mie.jp',
    'kawagoe.mie.jp',
    'kiho.mie.jp',
    'kisosaki.mie.jp',
    'kiwa.mie.jp',
    'komono.mie.jp',
    'kumano.mie.jp',
    'kuwana.mie.jp',
    'matsusaka.mie.jp',
    'meiwa.mie.jp',
    'mihama.mie.jp',
    'minamiise.mie.jp',
    'misugi.mie.jp',
    'miyama.mie.jp',
    'nabari.mie.jp',
    'shima.mie.jp',
    'suzuka.mie.jp',
    'tado.mie.jp',
    'taiki.mie.jp',
    'taki.mie.jp',
    'tamaki.mie.jp',
    'toba.mie.jp',
    'tsu.mie.jp',
    'udono.mie.jp',
    'ureshino.mie.jp',
    'watarai.mie.jp',
    'yokkaichi.mie.jp',
    'furukawa.miyagi.jp',
    'higashimatsushima.miyagi.jp',
    'ishinomaki.miyagi.jp',
    'iwanuma.miyagi.jp',
    'kakuda.miyagi.jp',
    'kami.miyagi.jp',
    'kawasaki.miyagi.jp',
    'marumori.miyagi.jp',
    'matsushima.miyagi.jp',
    'minamisanriku.miyagi.jp',
    'misato.miyagi.jp',
    'murata.miyagi.jp',
    'natori.miyagi.jp',
    'ogawara.miyagi.jp',
    'ohira.miyagi.jp',
    'onagawa.miyagi.jp',
    'osaki.miyagi.jp',
    'rifu.miyagi.jp',
    'semine.miyagi.jp',
    'shibata.miyagi.jp',
    'shichikashuku.miyagi.jp',
    'shikama.miyagi.jp',
    'shiogama.miyagi.jp',
    'shiroishi.miyagi.jp',
    'tagajo.miyagi.jp',
    'taiwa.miyagi.jp',
    'tome.miyagi.jp',
    'tomiya.miyagi.jp',
    'wakuya.miyagi.jp',
    'watari.miyagi.jp',
    'yamamoto.miyagi.jp',
    'zao.miyagi.jp',
    'aya.miyazaki.jp',
    'ebino.miyazaki.jp',
    'gokase.miyazaki.jp',
    'hyuga.miyazaki.jp',
    'kadogawa.miyazaki.jp',
    'kawaminami.miyazaki.jp',
    'kijo.miyazaki.jp',
    'kitagawa.miyazaki.jp',
    'kitakata.miyazaki.jp',
    'kitaura.miyazaki.jp',
    'kobayashi.miyazaki.jp',
    'kunitomi.miyazaki.jp',
    'kushima.miyazaki.jp',
    'mimata.miyazaki.jp',
    'miyakonojo.miyazaki.jp',
    'miyazaki.miyazaki.jp',
    'morotsuka.miyazaki.jp',
    'nichinan.miyazaki.jp',
    'nishimera.miyazaki.jp',
    'nobeoka.miyazaki.jp',
    'saito.miyazaki.jp',
    'shiiba.miyazaki.jp',
    'shintomi.miyazaki.jp',
    'takaharu.miyazaki.jp',
    'takanabe.miyazaki.jp',
    'takazaki.miyazaki.jp',
    'tsuno.miyazaki.jp',
    'achi.nagano.jp',
    'agematsu.nagano.jp',
    'anan.nagano.jp',
    'aoki.nagano.jp',
    'asahi.nagano.jp',
    'azumino.nagano.jp',
    'chikuhoku.nagano.jp',
    'chikuma.nagano.jp',
    'chino.nagano.jp',
    'fujimi.nagano.jp',
    'hakuba.nagano.jp',
    'hara.nagano.jp',
    'hiraya.nagano.jp',
    'iida.nagano.jp',
    'iijima.nagano.jp',
    'iiyama.nagano.jp',
    'iizuna.nagano.jp',
    'ikeda.nagano.jp',
    'ikusaka.nagano.jp',
    'ina.nagano.jp',
    'karuizawa.nagano.jp',
    'kawakami.nagano.jp',
    'kiso.nagano.jp',
    'kisofukushima.nagano.jp',
    'kitaaiki.nagano.jp',
    'komagane.nagano.jp',
    'komoro.nagano.jp',
    'matsukawa.nagano.jp',
    'matsumoto.nagano.jp',
    'miasa.nagano.jp',
    'minamiaiki.nagano.jp',
    'minamimaki.nagano.jp',
    'minamiminowa.nagano.jp',
    'minowa.nagano.jp',
    'miyada.nagano.jp',
    'miyota.nagano.jp',
    'mochizuki.nagano.jp',
    'nagano.nagano.jp',
    'nagawa.nagano.jp',
    'nagiso.nagano.jp',
    'nakagawa.nagano.jp',
    'nakano.nagano.jp',
    'nozawaonsen.nagano.jp',
    'obuse.nagano.jp',
    'ogawa.nagano.jp',
    'okaya.nagano.jp',
    'omachi.nagano.jp',
    'omi.nagano.jp',
    'ookuwa.nagano.jp',
    'ooshika.nagano.jp',
    'otaki.nagano.jp',
    'otari.nagano.jp',
    'sakae.nagano.jp',
    'sakaki.nagano.jp',
    'saku.nagano.jp',
    'sakuho.nagano.jp',
    'shimosuwa.nagano.jp',
    'shinanomachi.nagano.jp',
    'shiojiri.nagano.jp',
    'suwa.nagano.jp',
    'suzaka.nagano.jp',
    'takagi.nagano.jp',
    'takamori.nagano.jp',
    'takayama.nagano.jp',
    'tateshina.nagano.jp',
    'tatsuno.nagano.jp',
    'togakushi.nagano.jp',
    'togura.nagano.jp',
    'tomi.nagano.jp',
    'ueda.nagano.jp',
    'wada.nagano.jp',
    'yamagata.nagano.jp',
    'yamanouchi.nagano.jp',
    'yasaka.nagano.jp',
    'yasuoka.nagano.jp',
    'chijiwa.nagasaki.jp',
    'futsu.nagasaki.jp',
    'goto.nagasaki.jp',
    'hasami.nagasaki.jp',
    'hirado.nagasaki.jp',
    'iki.nagasaki.jp',
    'isahaya.nagasaki.jp',
    'kawatana.nagasaki.jp',
    'kuchinotsu.nagasaki.jp',
    'matsuura.nagasaki.jp',
    'nagasaki.nagasaki.jp',
    'obama.nagasaki.jp',
    'omura.nagasaki.jp',
    'oseto.nagasaki.jp',
    'saikai.nagasaki.jp',
    'sasebo.nagasaki.jp',
    'seihi.nagasaki.jp',
    'shimabara.nagasaki.jp',
    'shinkamigoto.nagasaki.jp',
    'togitsu.nagasaki.jp',
    'tsushima.nagasaki.jp',
    'unzen.nagasaki.jp',
    'ando.nara.jp',
    'gose.nara.jp',
    'heguri.nara.jp',
    'higashiyoshino.nara.jp',
    'ikaruga.nara.jp',
    'ikoma.nara.jp',
    'kamikitayama.nara.jp',
    'kanmaki.nara.jp',
    'kashiba.nara.jp',
    'kashihara.nara.jp',
    'katsuragi.nara.jp',
    'kawai.nara.jp',
    'kawakami.nara.jp',
    'kawanishi.nara.jp',
    'koryo.nara.jp',
    'kurotaki.nara.jp',
    'mitsue.nara.jp',
    'miyake.nara.jp',
    'nara.nara.jp',
    'nosegawa.nara.jp',
    'oji.nara.jp',
    'ouda.nara.jp',
    'oyodo.nara.jp',
    'sakurai.nara.jp',
    'sango.nara.jp',
    'shimoichi.nara.jp',
    'shimokitayama.nara.jp',
    'shinjo.nara.jp',
    'soni.nara.jp',
    'takatori.nara.jp',
    'tawaramoto.nara.jp',
    'tenkawa.nara.jp',
    'tenri.nara.jp',
    'uda.nara.jp',
    'yamatokoriyama.nara.jp',
    'yamatotakada.nara.jp',
    'yamazoe.nara.jp',
    'yoshino.nara.jp',
    'aga.niigata.jp',
    'agano.niigata.jp',
    'gosen.niigata.jp',
    'itoigawa.niigata.jp',
    'izumozaki.niigata.jp',
    'joetsu.niigata.jp',
    'kamo.niigata.jp',
    'kariwa.niigata.jp',
    'kashiwazaki.niigata.jp',
    'minamiuonuma.niigata.jp',
    'mitsuke.niigata.jp',
    'muika.niigata.jp',
    'murakami.niigata.jp',
    'myoko.niigata.jp',
    'nagaoka.niigata.jp',
    'niigata.niigata.jp',
    'ojiya.niigata.jp',
    'omi.niigata.jp',
    'sado.niigata.jp',
    'sanjo.niigata.jp',
    'seiro.niigata.jp',
    'seirou.niigata.jp',
    'sekikawa.niigata.jp',
    'shibata.niigata.jp',
    'tagami.niigata.jp',
    'tainai.niigata.jp',
    'tochio.niigata.jp',
    'tokamachi.niigata.jp',
    'tsubame.niigata.jp',
    'tsunan.niigata.jp',
    'uonuma.niigata.jp',
    'yahiko.niigata.jp',
    'yoita.niigata.jp',
    'yuzawa.niigata.jp',
    'beppu.oita.jp',
    'bungoono.oita.jp',
    'bungotakada.oita.jp',
    'hasama.oita.jp',
    'hiji.oita.jp',
    'himeshima.oita.jp',
    'hita.oita.jp',
    'kamitsue.oita.jp',
    'kokonoe.oita.jp',
    'kuju.oita.jp',
    'kunisaki.oita.jp',
    'kusu.oita.jp',
    'oita.oita.jp',
    'saiki.oita.jp',
    'taketa.oita.jp',
    'tsukumi.oita.jp',
    'usa.oita.jp',
    'usuki.oita.jp',
    'yufu.oita.jp',
    'akaiwa.okayama.jp',
    'asakuchi.okayama.jp',
    'bizen.okayama.jp',
    'hayashima.okayama.jp',
    'ibara.okayama.jp',
    'kagamino.okayama.jp',
    'kasaoka.okayama.jp',
    'kibichuo.okayama.jp',
    'kumenan.okayama.jp',
    'kurashiki.okayama.jp',
    'maniwa.okayama.jp',
    'misaki.okayama.jp',
    'nagi.okayama.jp',
    'niimi.okayama.jp',
    'nishiawakura.okayama.jp',
    'okayama.okayama.jp',
    'satosho.okayama.jp',
    'setouchi.okayama.jp',
    'shinjo.okayama.jp',
    'shoo.okayama.jp',
    'soja.okayama.jp',
    'takahashi.okayama.jp',
    'tamano.okayama.jp',
    'tsuyama.okayama.jp',
    'wake.okayama.jp',
    'yakage.okayama.jp',
    'aguni.okinawa.jp',
    'ginowan.okinawa.jp',
    'ginoza.okinawa.jp',
    'gushikami.okinawa.jp',
    'haebaru.okinawa.jp',
    'higashi.okinawa.jp',
    'hirara.okinawa.jp',
    'iheya.okinawa.jp',
    'ishigaki.okinawa.jp',
    'ishikawa.okinawa.jp',
    'itoman.okinawa.jp',
    'izena.okinawa.jp',
    'kadena.okinawa.jp',
    'kin.okinawa.jp',
    'kitadaito.okinawa.jp',
    'kitanakagusuku.okinawa.jp',
    'kumejima.okinawa.jp',
    'kunigami.okinawa.jp',
    'minamidaito.okinawa.jp',
    'motobu.okinawa.jp',
    'nago.okinawa.jp',
    'naha.okinawa.jp',
    'nakagusuku.okinawa.jp',
    'nakijin.okinawa.jp',
    'nanjo.okinawa.jp',
    'nishihara.okinawa.jp',
    'ogimi.okinawa.jp',
    'okinawa.okinawa.jp',
    'onna.okinawa.jp',
    'shimoji.okinawa.jp',
    'taketomi.okinawa.jp',
    'tarama.okinawa.jp',
    'tokashiki.okinawa.jp',
    'tomigusuku.okinawa.jp',
    'tonaki.okinawa.jp',
    'urasoe.okinawa.jp',
    'uruma.okinawa.jp',
    'yaese.okinawa.jp',
    'yomitan.okinawa.jp',
    'yonabaru.okinawa.jp',
    'yonaguni.okinawa.jp',
    'zamami.okinawa.jp',
    'abeno.osaka.jp',
    'chihayaakasaka.osaka.jp',
    'chuo.osaka.jp',
    'daito.osaka.jp',
    'fujiidera.osaka.jp',
    'habikino.osaka.jp',
    'hannan.osaka.jp',
    'higashiosaka.osaka.jp',
    'higashisumiyoshi.osaka.jp',
    'higashiyodogawa.osaka.jp',
    'hirakata.osaka.jp',
    'ibaraki.osaka.jp',
    'ikeda.osaka.jp',
    'izumi.osaka.jp',
    'izumiotsu.osaka.jp',
    'izumisano.osaka.jp',
    'kadoma.osaka.jp',
    'kaizuka.osaka.jp',
    'kanan.osaka.jp',
    'kashiwara.osaka.jp',
    'katano.osaka.jp',
    'kawachinagano.osaka.jp',
    'kishiwada.osaka.jp',
    'kita.osaka.jp',
    'kumatori.osaka.jp',
    'matsubara.osaka.jp',
    'minato.osaka.jp',
    'minoh.osaka.jp',
    'misaki.osaka.jp',
    'moriguchi.osaka.jp',
    'neyagawa.osaka.jp',
    'nishi.osaka.jp',
    'nose.osaka.jp',
    'osakasayama.osaka.jp',
    'sakai.osaka.jp',
    'sayama.osaka.jp',
    'sennan.osaka.jp',
    'settsu.osaka.jp',
    'shijonawate.osaka.jp',
    'shimamoto.osaka.jp',
    'suita.osaka.jp',
    'tadaoka.osaka.jp',
    'taishi.osaka.jp',
    'tajiri.osaka.jp',
    'takaishi.osaka.jp',
    'takatsuki.osaka.jp',
    'tondabayashi.osaka.jp',
    'toyonaka.osaka.jp',
    'toyono.osaka.jp',
    'yao.osaka.jp',
    'ariake.saga.jp',
    'arita.saga.jp',
    'fukudomi.saga.jp',
    'genkai.saga.jp',
    'hamatama.saga.jp',
    'hizen.saga.jp',
    'imari.saga.jp',
    'kamimine.saga.jp',
    'kanzaki.saga.jp',
    'karatsu.saga.jp',
    'kashima.saga.jp',
    'kitagata.saga.jp',
    'kitahata.saga.jp',
    'kiyama.saga.jp',
    'kouhoku.saga.jp',
    'kyuragi.saga.jp',
    'nishiarita.saga.jp',
    'ogi.saga.jp',
    'omachi.saga.jp',
    'ouchi.saga.jp',
    'saga.saga.jp',
    'shiroishi.saga.jp',
    'taku.saga.jp',
    'tara.saga.jp',
    'tosu.saga.jp',
    'yoshinogari.saga.jp',
    'arakawa.saitama.jp',
    'asaka.saitama.jp',
    'chichibu.saitama.jp',
    'fujimi.saitama.jp',
    'fujimino.saitama.jp',
    'fukaya.saitama.jp',
    'hanno.saitama.jp',
    'hanyu.saitama.jp',
    'hasuda.saitama.jp',
    'hatogaya.saitama.jp',
    'hatoyama.saitama.jp',
    'hidaka.saitama.jp',
    'higashichichibu.saitama.jp',
    'higashimatsuyama.saitama.jp',
    'honjo.saitama.jp',
    'ina.saitama.jp',
    'iruma.saitama.jp',
    'iwatsuki.saitama.jp',
    'kamiizumi.saitama.jp',
    'kamikawa.saitama.jp',
    'kamisato.saitama.jp',
    'kasukabe.saitama.jp',
    'kawagoe.saitama.jp',
    'kawaguchi.saitama.jp',
    'kawajima.saitama.jp',
    'kazo.saitama.jp',
    'kitamoto.saitama.jp',
    'koshigaya.saitama.jp',
    'kounosu.saitama.jp',
    'kuki.saitama.jp',
    'kumagaya.saitama.jp',
    'matsubushi.saitama.jp',
    'minano.saitama.jp',
    'misato.saitama.jp',
    'miyashiro.saitama.jp',
    'miyoshi.saitama.jp',
    'moroyama.saitama.jp',
    'nagatoro.saitama.jp',
    'namegawa.saitama.jp',
    'niiza.saitama.jp',
    'ogano.saitama.jp',
    'ogawa.saitama.jp',
    'ogose.saitama.jp',
    'okegawa.saitama.jp',
    'omiya.saitama.jp',
    'otaki.saitama.jp',
    'ranzan.saitama.jp',
    'ryokami.saitama.jp',
    'saitama.saitama.jp',
    'sakado.saitama.jp',
    'satte.saitama.jp',
    'sayama.saitama.jp',
    'shiki.saitama.jp',
    'shiraoka.saitama.jp',
    'soka.saitama.jp',
    'sugito.saitama.jp',
    'toda.saitama.jp',
    'tokigawa.saitama.jp',
    'tokorozawa.saitama.jp',
    'tsurugashima.saitama.jp',
    'urawa.saitama.jp',
    'warabi.saitama.jp',
    'yashio.saitama.jp',
    'yokoze.saitama.jp',
    'yono.saitama.jp',
    'yorii.saitama.jp',
    'yoshida.saitama.jp',
    'yoshikawa.saitama.jp',
    'yoshimi.saitama.jp',
    'aisho.shiga.jp',
    'gamo.shiga.jp',
    'higashiomi.shiga.jp',
    'hikone.shiga.jp',
    'koka.shiga.jp',
    'konan.shiga.jp',
    'kosei.shiga.jp',
    'koto.shiga.jp',
    'kusatsu.shiga.jp',
    'maibara.shiga.jp',
    'moriyama.shiga.jp',
    'nagahama.shiga.jp',
    'nishiazai.shiga.jp',
    'notogawa.shiga.jp',
    'omihachiman.shiga.jp',
    'otsu.shiga.jp',
    'ritto.shiga.jp',
    'ryuoh.shiga.jp',
    'takashima.shiga.jp',
    'takatsuki.shiga.jp',
    'torahime.shiga.jp',
    'toyosato.shiga.jp',
    'yasu.shiga.jp',
    'akagi.shimane.jp',
    'ama.shimane.jp',
    'gotsu.shimane.jp',
    'hamada.shimane.jp',
    'higashiizumo.shimane.jp',
    'hikawa.shimane.jp',
    'hikimi.shimane.jp',
    'izumo.shimane.jp',
    'kakinoki.shimane.jp',
    'masuda.shimane.jp',
    'matsue.shimane.jp',
    'misato.shimane.jp',
    'nishinoshima.shimane.jp',
    'ohda.shimane.jp',
    'okinoshima.shimane.jp',
    'okuizumo.shimane.jp',
    'shimane.shimane.jp',
    'tamayu.shimane.jp',
    'tsuwano.shimane.jp',
    'unnan.shimane.jp',
    'yakumo.shimane.jp',
    'yasugi.shimane.jp',
    'yatsuka.shimane.jp',
    'arai.shizuoka.jp',
    'atami.shizuoka.jp',
    'fuji.shizuoka.jp',
    'fujieda.shizuoka.jp',
    'fujikawa.shizuoka.jp',
    'fujinomiya.shizuoka.jp',
    'fukuroi.shizuoka.jp',
    'gotemba.shizuoka.jp',
    'haibara.shizuoka.jp',
    'hamamatsu.shizuoka.jp',
    'higashiizu.shizuoka.jp',
    'ito.shizuoka.jp',
    'iwata.shizuoka.jp',
    'izu.shizuoka.jp',
    'izunokuni.shizuoka.jp',
    'kakegawa.shizuoka.jp',
    'kannami.shizuoka.jp',
    'kawanehon.shizuoka.jp',
    'kawazu.shizuoka.jp',
    'kikugawa.shizuoka.jp',
    'kosai.shizuoka.jp',
    'makinohara.shizuoka.jp',
    'matsuzaki.shizuoka.jp',
    'minamiizu.shizuoka.jp',
    'mishima.shizuoka.jp',
    'morimachi.shizuoka.jp',
    'nishiizu.shizuoka.jp',
    'numazu.shizuoka.jp',
    'omaezaki.shizuoka.jp',
    'shimada.shizuoka.jp',
    'shimizu.shizuoka.jp',
    'shimoda.shizuoka.jp',
    'shizuoka.shizuoka.jp',
    'susono.shizuoka.jp',
    'yaizu.shizuoka.jp',
    'yoshida.shizuoka.jp',
    'ashikaga.tochigi.jp',
    'bato.tochigi.jp',
    'haga.tochigi.jp',
    'ichikai.tochigi.jp',
    'iwafune.tochigi.jp',
    'kaminokawa.tochigi.jp',
    'kanuma.tochigi.jp',
    'karasuyama.tochigi.jp',
    'kuroiso.tochigi.jp',
    'mashiko.tochigi.jp',
    'mibu.tochigi.jp',
    'moka.tochigi.jp',
    'motegi.tochigi.jp',
    'nasu.tochigi.jp',
    'nasushiobara.tochigi.jp',
    'nikko.tochigi.jp',
    'nishikata.tochigi.jp',
    'nogi.tochigi.jp',
    'ohira.tochigi.jp',
    'ohtawara.tochigi.jp',
    'oyama.tochigi.jp',
    'sakura.tochigi.jp',
    'sano.tochigi.jp',
    'shimotsuke.tochigi.jp',
    'shioya.tochigi.jp',
    'takanezawa.tochigi.jp',
    'tochigi.tochigi.jp',
    'tsuga.tochigi.jp',
    'ujiie.tochigi.jp',
    'utsunomiya.tochigi.jp',
    'yaita.tochigi.jp',
    'aizumi.tokushima.jp',
    'anan.tokushima.jp',
    'ichiba.tokushima.jp',
    'itano.tokushima.jp',
    'kainan.tokushima.jp',
    'komatsushima.tokushima.jp',
    'matsushige.tokushima.jp',
    'mima.tokushima.jp',
    'minami.tokushima.jp',
    'miyoshi.tokushima.jp',
    'mugi.tokushima.jp',
    'nakagawa.tokushima.jp',
    'naruto.tokushima.jp',
    'sanagochi.tokushima.jp',
    'shishikui.tokushima.jp',
    'tokushima.tokushima.jp',
    'wajiki.tokushima.jp',
    'adachi.tokyo.jp',
    'akiruno.tokyo.jp',
    'akishima.tokyo.jp',
    'aogashima.tokyo.jp',
    'arakawa.tokyo.jp',
    'bunkyo.tokyo.jp',
    'chiyoda.tokyo.jp',
    'chofu.tokyo.jp',
    'chuo.tokyo.jp',
    'edogawa.tokyo.jp',
    'fuchu.tokyo.jp',
    'fussa.tokyo.jp',
    'hachijo.tokyo.jp',
    'hachioji.tokyo.jp',
    'hamura.tokyo.jp',
    'higashikurume.tokyo.jp',
    'higashimurayama.tokyo.jp',
    'higashiyamato.tokyo.jp',
    'hino.tokyo.jp',
    'hinode.tokyo.jp',
    'hinohara.tokyo.jp',
    'inagi.tokyo.jp',
    'itabashi.tokyo.jp',
    'katsushika.tokyo.jp',
    'kita.tokyo.jp',
    'kiyose.tokyo.jp',
    'kodaira.tokyo.jp',
    'koganei.tokyo.jp',
    'kokubunji.tokyo.jp',
    'komae.tokyo.jp',
    'koto.tokyo.jp',
    'kouzushima.tokyo.jp',
    'kunitachi.tokyo.jp',
    'machida.tokyo.jp',
    'meguro.tokyo.jp',
    'minato.tokyo.jp',
    'mitaka.tokyo.jp',
    'mizuho.tokyo.jp',
    'musashimurayama.tokyo.jp',
    'musashino.tokyo.jp',
    'nakano.tokyo.jp',
    'nerima.tokyo.jp',
    'ogasawara.tokyo.jp',
    'okutama.tokyo.jp',
    'ome.tokyo.jp',
    'oshima.tokyo.jp',
    'ota.tokyo.jp',
    'setagaya.tokyo.jp',
    'shibuya.tokyo.jp',
    'shinagawa.tokyo.jp',
    'shinjuku.tokyo.jp',
    'suginami.tokyo.jp',
    'sumida.tokyo.jp',
    'tachikawa.tokyo.jp',
    'taito.tokyo.jp',
    'tama.tokyo.jp',
    'toshima.tokyo.jp',
    'chizu.tottori.jp',
    'hino.tottori.jp',
    'kawahara.tottori.jp',
    'koge.tottori.jp',
    'kotoura.tottori.jp',
    'misasa.tottori.jp',
    'nanbu.tottori.jp',
    'nichinan.tottori.jp',
    'sakaiminato.tottori.jp',
    'tottori.tottori.jp',
    'wakasa.tottori.jp',
    'yazu.tottori.jp',
    'yonago.tottori.jp',
    'asahi.toyama.jp',
    'fuchu.toyama.jp',
    'fukumitsu.toyama.jp',
    'funahashi.toyama.jp',
    'himi.toyama.jp',
    'imizu.toyama.jp',
    'inami.toyama.jp',
    'johana.toyama.jp',
    'kamiichi.toyama.jp',
    'kurobe.toyama.jp',
    'nakaniikawa.toyama.jp',
    'namerikawa.toyama.jp',
    'nanto.toyama.jp',
    'nyuzen.toyama.jp',
    'oyabe.toyama.jp',
    'taira.toyama.jp',
    'takaoka.toyama.jp',
    'tateyama.toyama.jp',
    'toga.toyama.jp',
    'tonami.toyama.jp',
    'toyama.toyama.jp',
    'unazuki.toyama.jp',
    'uozu.toyama.jp',
    'yamada.toyama.jp',
    'arida.wakayama.jp',
    'aridagawa.wakayama.jp',
    'gobo.wakayama.jp',
    'hashimoto.wakayama.jp',
    'hidaka.wakayama.jp',
    'hirogawa.wakayama.jp',
    'inami.wakayama.jp',
    'iwade.wakayama.jp',
    'kainan.wakayama.jp',
    'kamitonda.wakayama.jp',
    'katsuragi.wakayama.jp',
    'kimino.wakayama.jp',
    'kinokawa.wakayama.jp',
    'kitayama.wakayama.jp',
    'koya.wakayama.jp',
    'koza.wakayama.jp',
    'kozagawa.wakayama.jp',
    'kudoyama.wakayama.jp',
    'kushimoto.wakayama.jp',
    'mihama.wakayama.jp',
    'misato.wakayama.jp',
    'nachikatsuura.wakayama.jp',
    'shingu.wakayama.jp',
    'shirahama.wakayama.jp',
    'taiji.wakayama.jp',
    'tanabe.wakayama.jp',
    'wakayama.wakayama.jp',
    'yuasa.wakayama.jp',
    'yura.wakayama.jp',
    'asahi.yamagata.jp',
    'funagata.yamagata.jp',
    'higashine.yamagata.jp',
    'iide.yamagata.jp',
    'kahoku.yamagata.jp',
    'kaminoyama.yamagata.jp',
    'kaneyama.yamagata.jp',
    'kawanishi.yamagata.jp',
    'mamurogawa.yamagata.jp',
    'mikawa.yamagata.jp',
    'murayama.yamagata.jp',
    'nagai.yamagata.jp',
    'nakayama.yamagata.jp',
    'nanyo.yamagata.jp',
    'nishikawa.yamagata.jp',
    'obanazawa.yamagata.jp',
    'oe.yamagata.jp',
    'oguni.yamagata.jp',
    'ohkura.yamagata.jp',
    'oishida.yamagata.jp',
    'sagae.yamagata.jp',
    'sakata.yamagata.jp',
    'sakegawa.yamagata.jp',
    'shinjo.yamagata.jp',
    'shirataka.yamagata.jp',
    'shonai.yamagata.jp',
    'takahata.yamagata.jp',
    'tendo.yamagata.jp',
    'tozawa.yamagata.jp',
    'tsuruoka.yamagata.jp',
    'yamagata.yamagata.jp',
    'yamanobe.yamagata.jp',
    'yonezawa.yamagata.jp',
    'yuza.yamagata.jp',
    'abu.yamaguchi.jp',
    'hagi.yamaguchi.jp',
    'hikari.yamaguchi.jp',
    'hofu.yamaguchi.jp',
    'iwakuni.yamaguchi.jp',
    'kudamatsu.yamaguchi.jp',
    'mitou.yamaguchi.jp',
    'nagato.yamaguchi.jp',
    'oshima.yamaguchi.jp',
    'shimonoseki.yamaguchi.jp',
    'shunan.yamaguchi.jp',
    'tabuse.yamaguchi.jp',
    'tokuyama.yamaguchi.jp',
    'toyota.yamaguchi.jp',
    'ube.yamaguchi.jp',
    'yuu.yamaguchi.jp',
    'chuo.yamanashi.jp',
    'doshi.yamanashi.jp',
    'fuefuki.yamanashi.jp',
    'fujikawa.yamanashi.jp',
    'fujikawaguchiko.yamanashi.jp',
    'fujiyoshida.yamanashi.jp',
    'hayakawa.yamanashi.jp',
    'hokuto.yamanashi.jp',
    'ichikawamisato.yamanashi.jp',
    'kai.yamanashi.jp',
    'kofu.yamanashi.jp',
    'koshu.yamanashi.jp',
    'kosuge.yamanashi.jp',
    'minami-alps.yamanashi.jp',
    'minobu.yamanashi.jp',
    'nakamichi.yamanashi.jp',
    'nanbu.yamanashi.jp',
    'narusawa.yamanashi.jp',
    'nirasaki.yamanashi.jp',
    'nishikatsura.yamanashi.jp',
    'oshino.yamanashi.jp',
    'otsuki.yamanashi.jp',
    'showa.yamanashi.jp',
    'tabayama.yamanashi.jp',
    'tsuru.yamanashi.jp',
    'uenohara.yamanashi.jp',
    'yamanakako.yamanashi.jp',
    'yamanashi.yamanashi.jp',
    'ke',
    'ac.ke',
    'co.ke',
    'go.ke',
    'info.ke',
    'me.ke',
    'mobi.ke',
    'ne.ke',
    'or.ke',
    'sc.ke',
    'kg',
    'org.kg',
    'net.kg',
    'com.kg',
    'edu.kg',
    'gov.kg',
    'mil.kg',
    '*.kh',
    'ki',
    'edu.ki',
    'biz.ki',
    'net.ki',
    'org.ki',
    'gov.ki',
    'info.ki',
    'com.ki',
    'km',
    'org.km',
    'nom.km',
    'gov.km',
    'prd.km',
    'tm.km',
    'edu.km',
    'mil.km',
    'ass.km',
    'com.km',
    'coop.km',
    'asso.km',
    'presse.km',
    'medecin.km',
    'notaires.km',
    'pharmaciens.km',
    'veterinaire.km',
    'gouv.km',
    'kn',
    'net.kn',
    'org.kn',
    'edu.kn',
    'gov.kn',
    'kp',
    'com.kp',
    'edu.kp',
    'gov.kp',
    'org.kp',
    'rep.kp',
    'tra.kp',
    'kr',
    'ac.kr',
    'co.kr',
    'es.kr',
    'go.kr',
    'hs.kr',
    'kg.kr',
    'mil.kr',
    'ms.kr',
    'ne.kr',
    'or.kr',
    'pe.kr',
    're.kr',
    'sc.kr',
    'busan.kr',
    'chungbuk.kr',
    'chungnam.kr',
    'daegu.kr',
    'daejeon.kr',
    'gangwon.kr',
    'gwangju.kr',
    'gyeongbuk.kr',
    'gyeonggi.kr',
    'gyeongnam.kr',
    'incheon.kr',
    'jeju.kr',
    'jeonbuk.kr',
    'jeonnam.kr',
    'seoul.kr',
    'ulsan.kr',
    'kw',
    'com.kw',
    'edu.kw',
    'emb.kw',
    'gov.kw',
    'ind.kw',
    'net.kw',
    'org.kw',
    'ky',
    'edu.ky',
    'gov.ky',
    'com.ky',
    'org.ky',
    'net.ky',
    'kz',
    'org.kz',
    'edu.kz',
    'net.kz',
    'gov.kz',
    'mil.kz',
    'com.kz',
    'la',
    'int.la',
    'net.la',
    'info.la',
    'edu.la',
    'gov.la',
    'per.la',
    'com.la',
    'org.la',
    'lb',
    'com.lb',
    'edu.lb',
    'gov.lb',
    'net.lb',
    'org.lb',
    'lc',
    'com.lc',
    'net.lc',
    'co.lc',
    'org.lc',
    'edu.lc',
    'gov.lc',
    'li',
    'lk',
    'gov.lk',
    'sch.lk',
    'net.lk',
    'int.lk',
    'com.lk',
    'org.lk',
    'edu.lk',
    'ngo.lk',
    'soc.lk',
    'web.lk',
    'ltd.lk',
    'assn.lk',
    'grp.lk',
    'hotel.lk',
    'ac.lk',
    'lr',
    'com.lr',
    'edu.lr',
    'gov.lr',
    'org.lr',
    'net.lr',
    'ls',
    'ac.ls',
    'biz.ls',
    'co.ls',
    'edu.ls',
    'gov.ls',
    'info.ls',
    'net.ls',
    'org.ls',
    'sc.ls',
    'lt',
    'gov.lt',
    'lu',
    'lv',
    'com.lv',
    'edu.lv',
    'gov.lv',
    'org.lv',
    'mil.lv',
    'id.lv',
    'net.lv',
    'asn.lv',
    'conf.lv',
    'ly',
    'com.ly',
    'net.ly',
    'gov.ly',
    'plc.ly',
    'edu.ly',
    'sch.ly',
    'med.ly',
    'org.ly',
    'id.ly',
    'ma',
    'co.ma',
    'net.ma',
    'gov.ma',
    'org.ma',
    'ac.ma',
    'press.ma',
    'mc',
    'tm.mc',
    'asso.mc',
    'md',
    'me',
    'co.me',
    'net.me',
    'org.me',
    'edu.me',
    'ac.me',
    'gov.me',
    'its.me',
    'priv.me',
    'mg',
    'org.mg',
    'nom.mg',
    'gov.mg',
    'prd.mg',
    'tm.mg',
    'edu.mg',
    'mil.mg',
    'com.mg',
    'co.mg',
    'mh',
    'mil',
    'mk',
    'com.mk',
    'org.mk',
    'net.mk',
    'edu.mk',
    'gov.mk',
    'inf.mk',
    'name.mk',
    'ml',
    'com.ml',
    'edu.ml',
    'gouv.ml',
    'gov.ml',
    'net.ml',
    'org.ml',
    'presse.ml',
    '*.mm',
    'mn',
    'gov.mn',
    'edu.mn',
    'org.mn',
    'mo',
    'com.mo',
    'net.mo',
    'org.mo',
    'edu.mo',
    'gov.mo',
    'mobi',
    'mp',
    'mq',
    'mr',
    'gov.mr',
    'ms',
    'com.ms',
    'edu.ms',
    'gov.ms',
    'net.ms',
    'org.ms',
    'mt',
    'com.mt',
    'edu.mt',
    'net.mt',
    'org.mt',
    'mu',
    'com.mu',
    'net.mu',
    'org.mu',
    'gov.mu',
    'ac.mu',
    'co.mu',
    'or.mu',
    'museum',
    'academy.museum',
    'agriculture.museum',
    'air.museum',
    'airguard.museum',
    'alabama.museum',
    'alaska.museum',
    'amber.museum',
    'ambulance.museum',
    'american.museum',
    'americana.museum',
    'americanantiques.museum',
    'americanart.museum',
    'amsterdam.museum',
    'and.museum',
    'annefrank.museum',
    'anthro.museum',
    'anthropology.museum',
    'antiques.museum',
    'aquarium.museum',
    'arboretum.museum',
    'archaeological.museum',
    'archaeology.museum',
    'architecture.museum',
    'art.museum',
    'artanddesign.museum',
    'artcenter.museum',
    'artdeco.museum',
    'arteducation.museum',
    'artgallery.museum',
    'arts.museum',
    'artsandcrafts.museum',
    'asmatart.museum',
    'assassination.museum',
    'assisi.museum',
    'association.museum',
    'astronomy.museum',
    'atlanta.museum',
    'austin.museum',
    'australia.museum',
    'automotive.museum',
    'aviation.museum',
    'axis.museum',
    'badajoz.museum',
    'baghdad.museum',
    'bahn.museum',
    'bale.museum',
    'baltimore.museum',
    'barcelona.museum',
    'baseball.museum',
    'basel.museum',
    'baths.museum',
    'bauern.museum',
    'beauxarts.museum',
    'beeldengeluid.museum',
    'bellevue.museum',
    'bergbau.museum',
    'berkeley.museum',
    'berlin.museum',
    'bern.museum',
    'bible.museum',
    'bilbao.museum',
    'bill.museum',
    'birdart.museum',
    'birthplace.museum',
    'bonn.museum',
    'boston.museum',
    'botanical.museum',
    'botanicalgarden.museum',
    'botanicgarden.museum',
    'botany.museum',
    'brandywinevalley.museum',
    'brasil.museum',
    'bristol.museum',
    'british.museum',
    'britishcolumbia.museum',
    'broadcast.museum',
    'brunel.museum',
    'brussel.museum',
    'brussels.museum',
    'bruxelles.museum',
    'building.museum',
    'burghof.museum',
    'bus.museum',
    'bushey.museum',
    'cadaques.museum',
    'california.museum',
    'cambridge.museum',
    'can.museum',
    'canada.museum',
    'capebreton.museum',
    'carrier.museum',
    'cartoonart.museum',
    'casadelamoneda.museum',
    'castle.museum',
    'castres.museum',
    'celtic.museum',
    'center.museum',
    'chattanooga.museum',
    'cheltenham.museum',
    'chesapeakebay.museum',
    'chicago.museum',
    'children.museum',
    'childrens.museum',
    'childrensgarden.museum',
    'chiropractic.museum',
    'chocolate.museum',
    'christiansburg.museum',
    'cincinnati.museum',
    'cinema.museum',
    'circus.museum',
    'civilisation.museum',
    'civilization.museum',
    'civilwar.museum',
    'clinton.museum',
    'clock.museum',
    'coal.museum',
    'coastaldefence.museum',
    'cody.museum',
    'coldwar.museum',
    'collection.museum',
    'colonialwilliamsburg.museum',
    'coloradoplateau.museum',
    'columbia.museum',
    'columbus.museum',
    'communication.museum',
    'communications.museum',
    'community.museum',
    'computer.museum',
    'computerhistory.museum',
    'comunica\xE7\xF5es.museum',
    'contemporary.museum',
    'contemporaryart.museum',
    'convent.museum',
    'copenhagen.museum',
    'corporation.museum',
    'correios-e-telecomunica\xE7\xF5es.museum',
    'corvette.museum',
    'costume.museum',
    'countryestate.museum',
    'county.museum',
    'crafts.museum',
    'cranbrook.museum',
    'creation.museum',
    'cultural.museum',
    'culturalcenter.museum',
    'culture.museum',
    'cyber.museum',
    'cymru.museum',
    'dali.museum',
    'dallas.museum',
    'database.museum',
    'ddr.museum',
    'decorativearts.museum',
    'delaware.museum',
    'delmenhorst.museum',
    'denmark.museum',
    'depot.museum',
    'design.museum',
    'detroit.museum',
    'dinosaur.museum',
    'discovery.museum',
    'dolls.museum',
    'donostia.museum',
    'durham.museum',
    'eastafrica.museum',
    'eastcoast.museum',
    'education.museum',
    'educational.museum',
    'egyptian.museum',
    'eisenbahn.museum',
    'elburg.museum',
    'elvendrell.museum',
    'embroidery.museum',
    'encyclopedic.museum',
    'england.museum',
    'entomology.museum',
    'environment.museum',
    'environmentalconservation.museum',
    'epilepsy.museum',
    'essex.museum',
    'estate.museum',
    'ethnology.museum',
    'exeter.museum',
    'exhibition.museum',
    'family.museum',
    'farm.museum',
    'farmequipment.museum',
    'farmers.museum',
    'farmstead.museum',
    'field.museum',
    'figueres.museum',
    'filatelia.museum',
    'film.museum',
    'fineart.museum',
    'finearts.museum',
    'finland.museum',
    'flanders.museum',
    'florida.museum',
    'force.museum',
    'fortmissoula.museum',
    'fortworth.museum',
    'foundation.museum',
    'francaise.museum',
    'frankfurt.museum',
    'franziskaner.museum',
    'freemasonry.museum',
    'freiburg.museum',
    'fribourg.museum',
    'frog.museum',
    'fundacio.museum',
    'furniture.museum',
    'gallery.museum',
    'garden.museum',
    'gateway.museum',
    'geelvinck.museum',
    'gemological.museum',
    'geology.museum',
    'georgia.museum',
    'giessen.museum',
    'glas.museum',
    'glass.museum',
    'gorge.museum',
    'grandrapids.museum',
    'graz.museum',
    'guernsey.museum',
    'halloffame.museum',
    'hamburg.museum',
    'handson.museum',
    'harvestcelebration.museum',
    'hawaii.museum',
    'health.museum',
    'heimatunduhren.museum',
    'hellas.museum',
    'helsinki.museum',
    'hembygdsforbund.museum',
    'heritage.museum',
    'histoire.museum',
    'historical.museum',
    'historicalsociety.museum',
    'historichouses.museum',
    'historisch.museum',
    'historisches.museum',
    'history.museum',
    'historyofscience.museum',
    'horology.museum',
    'house.museum',
    'humanities.museum',
    'illustration.museum',
    'imageandsound.museum',
    'indian.museum',
    'indiana.museum',
    'indianapolis.museum',
    'indianmarket.museum',
    'intelligence.museum',
    'interactive.museum',
    'iraq.museum',
    'iron.museum',
    'isleofman.museum',
    'jamison.museum',
    'jefferson.museum',
    'jerusalem.museum',
    'jewelry.museum',
    'jewish.museum',
    'jewishart.museum',
    'jfk.museum',
    'journalism.museum',
    'judaica.museum',
    'judygarland.museum',
    'juedisches.museum',
    'juif.museum',
    'karate.museum',
    'karikatur.museum',
    'kids.museum',
    'koebenhavn.museum',
    'koeln.museum',
    'kunst.museum',
    'kunstsammlung.museum',
    'kunstunddesign.museum',
    'labor.museum',
    'labour.museum',
    'lajolla.museum',
    'lancashire.museum',
    'landes.museum',
    'lans.museum',
    'l\xE4ns.museum',
    'larsson.museum',
    'lewismiller.museum',
    'lincoln.museum',
    'linz.museum',
    'living.museum',
    'livinghistory.museum',
    'localhistory.museum',
    'london.museum',
    'losangeles.museum',
    'louvre.museum',
    'loyalist.museum',
    'lucerne.museum',
    'luxembourg.museum',
    'luzern.museum',
    'mad.museum',
    'madrid.museum',
    'mallorca.museum',
    'manchester.museum',
    'mansion.museum',
    'mansions.museum',
    'manx.museum',
    'marburg.museum',
    'maritime.museum',
    'maritimo.museum',
    'maryland.museum',
    'marylhurst.museum',
    'media.museum',
    'medical.museum',
    'medizinhistorisches.museum',
    'meeres.museum',
    'memorial.museum',
    'mesaverde.museum',
    'michigan.museum',
    'midatlantic.museum',
    'military.museum',
    'mill.museum',
    'miners.museum',
    'mining.museum',
    'minnesota.museum',
    'missile.museum',
    'missoula.museum',
    'modern.museum',
    'moma.museum',
    'money.museum',
    'monmouth.museum',
    'monticello.museum',
    'montreal.museum',
    'moscow.museum',
    'motorcycle.museum',
    'muenchen.museum',
    'muenster.museum',
    'mulhouse.museum',
    'muncie.museum',
    'museet.museum',
    'museumcenter.museum',
    'museumvereniging.museum',
    'music.museum',
    'national.museum',
    'nationalfirearms.museum',
    'nationalheritage.museum',
    'nativeamerican.museum',
    'naturalhistory.museum',
    'naturalhistorymuseum.museum',
    'naturalsciences.museum',
    'nature.museum',
    'naturhistorisches.museum',
    'natuurwetenschappen.museum',
    'naumburg.museum',
    'naval.museum',
    'nebraska.museum',
    'neues.museum',
    'newhampshire.museum',
    'newjersey.museum',
    'newmexico.museum',
    'newport.museum',
    'newspaper.museum',
    'newyork.museum',
    'niepce.museum',
    'norfolk.museum',
    'north.museum',
    'nrw.museum',
    'nyc.museum',
    'nyny.museum',
    'oceanographic.museum',
    'oceanographique.museum',
    'omaha.museum',
    'online.museum',
    'ontario.museum',
    'openair.museum',
    'oregon.museum',
    'oregontrail.museum',
    'otago.museum',
    'oxford.museum',
    'pacific.museum',
    'paderborn.museum',
    'palace.museum',
    'paleo.museum',
    'palmsprings.museum',
    'panama.museum',
    'paris.museum',
    'pasadena.museum',
    'pharmacy.museum',
    'philadelphia.museum',
    'philadelphiaarea.museum',
    'philately.museum',
    'phoenix.museum',
    'photography.museum',
    'pilots.museum',
    'pittsburgh.museum',
    'planetarium.museum',
    'plantation.museum',
    'plants.museum',
    'plaza.museum',
    'portal.museum',
    'portland.museum',
    'portlligat.museum',
    'posts-and-telecommunications.museum',
    'preservation.museum',
    'presidio.museum',
    'press.museum',
    'project.museum',
    'public.museum',
    'pubol.museum',
    'quebec.museum',
    'railroad.museum',
    'railway.museum',
    'research.museum',
    'resistance.museum',
    'riodejaneiro.museum',
    'rochester.museum',
    'rockart.museum',
    'roma.museum',
    'russia.museum',
    'saintlouis.museum',
    'salem.museum',
    'salvadordali.museum',
    'salzburg.museum',
    'sandiego.museum',
    'sanfrancisco.museum',
    'santabarbara.museum',
    'santacruz.museum',
    'santafe.museum',
    'saskatchewan.museum',
    'satx.museum',
    'savannahga.museum',
    'schlesisches.museum',
    'schoenbrunn.museum',
    'schokoladen.museum',
    'school.museum',
    'schweiz.museum',
    'science.museum',
    'scienceandhistory.museum',
    'scienceandindustry.museum',
    'sciencecenter.museum',
    'sciencecenters.museum',
    'science-fiction.museum',
    'sciencehistory.museum',
    'sciences.museum',
    'sciencesnaturelles.museum',
    'scotland.museum',
    'seaport.museum',
    'settlement.museum',
    'settlers.museum',
    'shell.museum',
    'sherbrooke.museum',
    'sibenik.museum',
    'silk.museum',
    'ski.museum',
    'skole.museum',
    'society.museum',
    'sologne.museum',
    'soundandvision.museum',
    'southcarolina.museum',
    'southwest.museum',
    'space.museum',
    'spy.museum',
    'square.museum',
    'stadt.museum',
    'stalbans.museum',
    'starnberg.museum',
    'state.museum',
    'stateofdelaware.museum',
    'station.museum',
    'steam.museum',
    'steiermark.museum',
    'stjohn.museum',
    'stockholm.museum',
    'stpetersburg.museum',
    'stuttgart.museum',
    'suisse.museum',
    'surgeonshall.museum',
    'surrey.museum',
    'svizzera.museum',
    'sweden.museum',
    'sydney.museum',
    'tank.museum',
    'tcm.museum',
    'technology.museum',
    'telekommunikation.museum',
    'television.museum',
    'texas.museum',
    'textile.museum',
    'theater.museum',
    'time.museum',
    'timekeeping.museum',
    'topology.museum',
    'torino.museum',
    'touch.museum',
    'town.museum',
    'transport.museum',
    'tree.museum',
    'trolley.museum',
    'trust.museum',
    'trustee.museum',
    'uhren.museum',
    'ulm.museum',
    'undersea.museum',
    'university.museum',
    'usa.museum',
    'usantiques.museum',
    'usarts.museum',
    'uscountryestate.museum',
    'usculture.museum',
    'usdecorativearts.museum',
    'usgarden.museum',
    'ushistory.museum',
    'ushuaia.museum',
    'uslivinghistory.museum',
    'utah.museum',
    'uvic.museum',
    'valley.museum',
    'vantaa.museum',
    'versailles.museum',
    'viking.museum',
    'village.museum',
    'virginia.museum',
    'virtual.museum',
    'virtuel.museum',
    'vlaanderen.museum',
    'volkenkunde.museum',
    'wales.museum',
    'wallonie.museum',
    'war.museum',
    'washingtondc.museum',
    'watchandclock.museum',
    'watch-and-clock.museum',
    'western.museum',
    'westfalen.museum',
    'whaling.museum',
    'wildlife.museum',
    'williamsburg.museum',
    'windmill.museum',
    'workshop.museum',
    'york.museum',
    'yorkshire.museum',
    'yosemite.museum',
    'youth.museum',
    'zoological.museum',
    'zoology.museum',
    '\u05D9\u05E8\u05D5\u05E9\u05DC\u05D9\u05DD.museum',
    '\u0438\u043A\u043E\u043C.museum',
    'mv',
    'aero.mv',
    'biz.mv',
    'com.mv',
    'coop.mv',
    'edu.mv',
    'gov.mv',
    'info.mv',
    'int.mv',
    'mil.mv',
    'museum.mv',
    'name.mv',
    'net.mv',
    'org.mv',
    'pro.mv',
    'mw',
    'ac.mw',
    'biz.mw',
    'co.mw',
    'com.mw',
    'coop.mw',
    'edu.mw',
    'gov.mw',
    'int.mw',
    'museum.mw',
    'net.mw',
    'org.mw',
    'mx',
    'com.mx',
    'org.mx',
    'gob.mx',
    'edu.mx',
    'net.mx',
    'my',
    'com.my',
    'net.my',
    'org.my',
    'gov.my',
    'edu.my',
    'mil.my',
    'name.my',
    'mz',
    'ac.mz',
    'adv.mz',
    'co.mz',
    'edu.mz',
    'gov.mz',
    'mil.mz',
    'net.mz',
    'org.mz',
    'na',
    'info.na',
    'pro.na',
    'name.na',
    'school.na',
    'or.na',
    'dr.na',
    'us.na',
    'mx.na',
    'ca.na',
    'in.na',
    'cc.na',
    'tv.na',
    'ws.na',
    'mobi.na',
    'co.na',
    'com.na',
    'org.na',
    'name',
    'nc',
    'asso.nc',
    'nom.nc',
    'ne',
    'net',
    'nf',
    'com.nf',
    'net.nf',
    'per.nf',
    'rec.nf',
    'web.nf',
    'arts.nf',
    'firm.nf',
    'info.nf',
    'other.nf',
    'store.nf',
    'ng',
    'com.ng',
    'edu.ng',
    'gov.ng',
    'i.ng',
    'mil.ng',
    'mobi.ng',
    'name.ng',
    'net.ng',
    'org.ng',
    'sch.ng',
    'ni',
    'ac.ni',
    'biz.ni',
    'co.ni',
    'com.ni',
    'edu.ni',
    'gob.ni',
    'in.ni',
    'info.ni',
    'int.ni',
    'mil.ni',
    'net.ni',
    'nom.ni',
    'org.ni',
    'web.ni',
    'nl',
    'no',
    'fhs.no',
    'vgs.no',
    'fylkesbibl.no',
    'folkebibl.no',
    'museum.no',
    'idrett.no',
    'priv.no',
    'mil.no',
    'stat.no',
    'dep.no',
    'kommune.no',
    'herad.no',
    'aa.no',
    'ah.no',
    'bu.no',
    'fm.no',
    'hl.no',
    'hm.no',
    'jan-mayen.no',
    'mr.no',
    'nl.no',
    'nt.no',
    'of.no',
    'ol.no',
    'oslo.no',
    'rl.no',
    'sf.no',
    'st.no',
    'svalbard.no',
    'tm.no',
    'tr.no',
    'va.no',
    'vf.no',
    'gs.aa.no',
    'gs.ah.no',
    'gs.bu.no',
    'gs.fm.no',
    'gs.hl.no',
    'gs.hm.no',
    'gs.jan-mayen.no',
    'gs.mr.no',
    'gs.nl.no',
    'gs.nt.no',
    'gs.of.no',
    'gs.ol.no',
    'gs.oslo.no',
    'gs.rl.no',
    'gs.sf.no',
    'gs.st.no',
    'gs.svalbard.no',
    'gs.tm.no',
    'gs.tr.no',
    'gs.va.no',
    'gs.vf.no',
    'akrehamn.no',
    '\xE5krehamn.no',
    'algard.no',
    '\xE5lg\xE5rd.no',
    'arna.no',
    'brumunddal.no',
    'bryne.no',
    'bronnoysund.no',
    'br\xF8nn\xF8ysund.no',
    'drobak.no',
    'dr\xF8bak.no',
    'egersund.no',
    'fetsund.no',
    'floro.no',
    'flor\xF8.no',
    'fredrikstad.no',
    'hokksund.no',
    'honefoss.no',
    'h\xF8nefoss.no',
    'jessheim.no',
    'jorpeland.no',
    'j\xF8rpeland.no',
    'kirkenes.no',
    'kopervik.no',
    'krokstadelva.no',
    'langevag.no',
    'langev\xE5g.no',
    'leirvik.no',
    'mjondalen.no',
    'mj\xF8ndalen.no',
    'mo-i-rana.no',
    'mosjoen.no',
    'mosj\xF8en.no',
    'nesoddtangen.no',
    'orkanger.no',
    'osoyro.no',
    'os\xF8yro.no',
    'raholt.no',
    'r\xE5holt.no',
    'sandnessjoen.no',
    'sandnessj\xF8en.no',
    'skedsmokorset.no',
    'slattum.no',
    'spjelkavik.no',
    'stathelle.no',
    'stavern.no',
    'stjordalshalsen.no',
    'stj\xF8rdalshalsen.no',
    'tananger.no',
    'tranby.no',
    'vossevangen.no',
    'afjord.no',
    '\xE5fjord.no',
    'agdenes.no',
    'al.no',
    '\xE5l.no',
    'alesund.no',
    '\xE5lesund.no',
    'alstahaug.no',
    'alta.no',
    '\xE1lt\xE1.no',
    'alaheadju.no',
    '\xE1laheadju.no',
    'alvdal.no',
    'amli.no',
    '\xE5mli.no',
    'amot.no',
    '\xE5mot.no',
    'andebu.no',
    'andoy.no',
    'and\xF8y.no',
    'andasuolo.no',
    'ardal.no',
    '\xE5rdal.no',
    'aremark.no',
    'arendal.no',
    '\xE5s.no',
    'aseral.no',
    '\xE5seral.no',
    'asker.no',
    'askim.no',
    'askvoll.no',
    'askoy.no',
    'ask\xF8y.no',
    'asnes.no',
    '\xE5snes.no',
    'audnedaln.no',
    'aukra.no',
    'aure.no',
    'aurland.no',
    'aurskog-holand.no',
    'aurskog-h\xF8land.no',
    'austevoll.no',
    'austrheim.no',
    'averoy.no',
    'aver\xF8y.no',
    'balestrand.no',
    'ballangen.no',
    'balat.no',
    'b\xE1l\xE1t.no',
    'balsfjord.no',
    'bahccavuotna.no',
    'b\xE1hccavuotna.no',
    'bamble.no',
    'bardu.no',
    'beardu.no',
    'beiarn.no',
    'bajddar.no',
    'b\xE1jddar.no',
    'baidar.no',
    'b\xE1id\xE1r.no',
    'berg.no',
    'bergen.no',
    'berlevag.no',
    'berlev\xE5g.no',
    'bearalvahki.no',
    'bearalv\xE1hki.no',
    'bindal.no',
    'birkenes.no',
    'bjarkoy.no',
    'bjark\xF8y.no',
    'bjerkreim.no',
    'bjugn.no',
    'bodo.no',
    'bod\xF8.no',
    'badaddja.no',
    'b\xE5d\xE5ddj\xE5.no',
    'budejju.no',
    'bokn.no',
    'bremanger.no',
    'bronnoy.no',
    'br\xF8nn\xF8y.no',
    'bygland.no',
    'bykle.no',
    'barum.no',
    'b\xE6rum.no',
    'bo.telemark.no',
    'b\xF8.telemark.no',
    'bo.nordland.no',
    'b\xF8.nordland.no',
    'bievat.no',
    'biev\xE1t.no',
    'bomlo.no',
    'b\xF8mlo.no',
    'batsfjord.no',
    'b\xE5tsfjord.no',
    'bahcavuotna.no',
    'b\xE1hcavuotna.no',
    'dovre.no',
    'drammen.no',
    'drangedal.no',
    'dyroy.no',
    'dyr\xF8y.no',
    'donna.no',
    'd\xF8nna.no',
    'eid.no',
    'eidfjord.no',
    'eidsberg.no',
    'eidskog.no',
    'eidsvoll.no',
    'eigersund.no',
    'elverum.no',
    'enebakk.no',
    'engerdal.no',
    'etne.no',
    'etnedal.no',
    'evenes.no',
    'evenassi.no',
    'even\xE1\u0161\u0161i.no',
    'evje-og-hornnes.no',
    'farsund.no',
    'fauske.no',
    'fuossko.no',
    'fuoisku.no',
    'fedje.no',
    'fet.no',
    'finnoy.no',
    'finn\xF8y.no',
    'fitjar.no',
    'fjaler.no',
    'fjell.no',
    'flakstad.no',
    'flatanger.no',
    'flekkefjord.no',
    'flesberg.no',
    'flora.no',
    'fla.no',
    'fl\xE5.no',
    'folldal.no',
    'forsand.no',
    'fosnes.no',
    'frei.no',
    'frogn.no',
    'froland.no',
    'frosta.no',
    'frana.no',
    'fr\xE6na.no',
    'froya.no',
    'fr\xF8ya.no',
    'fusa.no',
    'fyresdal.no',
    'forde.no',
    'f\xF8rde.no',
    'gamvik.no',
    'gangaviika.no',
    'g\xE1\u014Bgaviika.no',
    'gaular.no',
    'gausdal.no',
    'gildeskal.no',
    'gildesk\xE5l.no',
    'giske.no',
    'gjemnes.no',
    'gjerdrum.no',
    'gjerstad.no',
    'gjesdal.no',
    'gjovik.no',
    'gj\xF8vik.no',
    'gloppen.no',
    'gol.no',
    'gran.no',
    'grane.no',
    'granvin.no',
    'gratangen.no',
    'grimstad.no',
    'grong.no',
    'kraanghke.no',
    'kr\xE5anghke.no',
    'grue.no',
    'gulen.no',
    'hadsel.no',
    'halden.no',
    'halsa.no',
    'hamar.no',
    'hamaroy.no',
    'habmer.no',
    'h\xE1bmer.no',
    'hapmir.no',
    'h\xE1pmir.no',
    'hammerfest.no',
    'hammarfeasta.no',
    'h\xE1mm\xE1rfeasta.no',
    'haram.no',
    'hareid.no',
    'harstad.no',
    'hasvik.no',
    'aknoluokta.no',
    '\xE1k\u014Boluokta.no',
    'hattfjelldal.no',
    'aarborte.no',
    'haugesund.no',
    'hemne.no',
    'hemnes.no',
    'hemsedal.no',
    'heroy.more-og-romsdal.no',
    'her\xF8y.m\xF8re-og-romsdal.no',
    'heroy.nordland.no',
    'her\xF8y.nordland.no',
    'hitra.no',
    'hjartdal.no',
    'hjelmeland.no',
    'hobol.no',
    'hob\xF8l.no',
    'hof.no',
    'hol.no',
    'hole.no',
    'holmestrand.no',
    'holtalen.no',
    'holt\xE5len.no',
    'hornindal.no',
    'horten.no',
    'hurdal.no',
    'hurum.no',
    'hvaler.no',
    'hyllestad.no',
    'hagebostad.no',
    'h\xE6gebostad.no',
    'hoyanger.no',
    'h\xF8yanger.no',
    'hoylandet.no',
    'h\xF8ylandet.no',
    'ha.no',
    'h\xE5.no',
    'ibestad.no',
    'inderoy.no',
    'inder\xF8y.no',
    'iveland.no',
    'jevnaker.no',
    'jondal.no',
    'jolster.no',
    'j\xF8lster.no',
    'karasjok.no',
    'karasjohka.no',
    'k\xE1r\xE1\u0161johka.no',
    'karlsoy.no',
    'galsa.no',
    'g\xE1ls\xE1.no',
    'karmoy.no',
    'karm\xF8y.no',
    'kautokeino.no',
    'guovdageaidnu.no',
    'klepp.no',
    'klabu.no',
    'kl\xE6bu.no',
    'kongsberg.no',
    'kongsvinger.no',
    'kragero.no',
    'krager\xF8.no',
    'kristiansand.no',
    'kristiansund.no',
    'krodsherad.no',
    'kr\xF8dsherad.no',
    'kvalsund.no',
    'rahkkeravju.no',
    'r\xE1hkker\xE1vju.no',
    'kvam.no',
    'kvinesdal.no',
    'kvinnherad.no',
    'kviteseid.no',
    'kvitsoy.no',
    'kvits\xF8y.no',
    'kvafjord.no',
    'kv\xE6fjord.no',
    'giehtavuoatna.no',
    'kvanangen.no',
    'kv\xE6nangen.no',
    'navuotna.no',
    'n\xE1vuotna.no',
    'kafjord.no',
    'k\xE5fjord.no',
    'gaivuotna.no',
    'g\xE1ivuotna.no',
    'larvik.no',
    'lavangen.no',
    'lavagis.no',
    'loabat.no',
    'loab\xE1t.no',
    'lebesby.no',
    'davvesiida.no',
    'leikanger.no',
    'leirfjord.no',
    'leka.no',
    'leksvik.no',
    'lenvik.no',
    'leangaviika.no',
    'lea\u014Bgaviika.no',
    'lesja.no',
    'levanger.no',
    'lier.no',
    'lierne.no',
    'lillehammer.no',
    'lillesand.no',
    'lindesnes.no',
    'lindas.no',
    'lind\xE5s.no',
    'lom.no',
    'loppa.no',
    'lahppi.no',
    'l\xE1hppi.no',
    'lund.no',
    'lunner.no',
    'luroy.no',
    'lur\xF8y.no',
    'luster.no',
    'lyngdal.no',
    'lyngen.no',
    'ivgu.no',
    'lardal.no',
    'lerdal.no',
    'l\xE6rdal.no',
    'lodingen.no',
    'l\xF8dingen.no',
    'lorenskog.no',
    'l\xF8renskog.no',
    'loten.no',
    'l\xF8ten.no',
    'malvik.no',
    'masoy.no',
    'm\xE5s\xF8y.no',
    'muosat.no',
    'muos\xE1t.no',
    'mandal.no',
    'marker.no',
    'marnardal.no',
    'masfjorden.no',
    'meland.no',
    'meldal.no',
    'melhus.no',
    'meloy.no',
    'mel\xF8y.no',
    'meraker.no',
    'mer\xE5ker.no',
    'moareke.no',
    'mo\xE5reke.no',
    'midsund.no',
    'midtre-gauldal.no',
    'modalen.no',
    'modum.no',
    'molde.no',
    'moskenes.no',
    'moss.no',
    'mosvik.no',
    'malselv.no',
    'm\xE5lselv.no',
    'malatvuopmi.no',
    'm\xE1latvuopmi.no',
    'namdalseid.no',
    'aejrie.no',
    'namsos.no',
    'namsskogan.no',
    'naamesjevuemie.no',
    'n\xE5\xE5mesjevuemie.no',
    'laakesvuemie.no',
    'nannestad.no',
    'narvik.no',
    'narviika.no',
    'naustdal.no',
    'nedre-eiker.no',
    'nes.akershus.no',
    'nes.buskerud.no',
    'nesna.no',
    'nesodden.no',
    'nesseby.no',
    'unjarga.no',
    'unj\xE1rga.no',
    'nesset.no',
    'nissedal.no',
    'nittedal.no',
    'nord-aurdal.no',
    'nord-fron.no',
    'nord-odal.no',
    'norddal.no',
    'nordkapp.no',
    'davvenjarga.no',
    'davvenj\xE1rga.no',
    'nordre-land.no',
    'nordreisa.no',
    'raisa.no',
    'r\xE1isa.no',
    'nore-og-uvdal.no',
    'notodden.no',
    'naroy.no',
    'n\xE6r\xF8y.no',
    'notteroy.no',
    'n\xF8tter\xF8y.no',
    'odda.no',
    'oksnes.no',
    '\xF8ksnes.no',
    'oppdal.no',
    'oppegard.no',
    'oppeg\xE5rd.no',
    'orkdal.no',
    'orland.no',
    '\xF8rland.no',
    'orskog.no',
    '\xF8rskog.no',
    'orsta.no',
    '\xF8rsta.no',
    'os.hedmark.no',
    'os.hordaland.no',
    'osen.no',
    'osteroy.no',
    'oster\xF8y.no',
    'ostre-toten.no',
    '\xF8stre-toten.no',
    'overhalla.no',
    'ovre-eiker.no',
    '\xF8vre-eiker.no',
    'oyer.no',
    '\xF8yer.no',
    'oygarden.no',
    '\xF8ygarden.no',
    'oystre-slidre.no',
    '\xF8ystre-slidre.no',
    'porsanger.no',
    'porsangu.no',
    'pors\xE1\u014Bgu.no',
    'porsgrunn.no',
    'radoy.no',
    'rad\xF8y.no',
    'rakkestad.no',
    'rana.no',
    'ruovat.no',
    'randaberg.no',
    'rauma.no',
    'rendalen.no',
    'rennebu.no',
    'rennesoy.no',
    'rennes\xF8y.no',
    'rindal.no',
    'ringebu.no',
    'ringerike.no',
    'ringsaker.no',
    'rissa.no',
    'risor.no',
    'ris\xF8r.no',
    'roan.no',
    'rollag.no',
    'rygge.no',
    'ralingen.no',
    'r\xE6lingen.no',
    'rodoy.no',
    'r\xF8d\xF8y.no',
    'romskog.no',
    'r\xF8mskog.no',
    'roros.no',
    'r\xF8ros.no',
    'rost.no',
    'r\xF8st.no',
    'royken.no',
    'r\xF8yken.no',
    'royrvik.no',
    'r\xF8yrvik.no',
    'rade.no',
    'r\xE5de.no',
    'salangen.no',
    'siellak.no',
    'saltdal.no',
    'salat.no',
    's\xE1l\xE1t.no',
    's\xE1lat.no',
    'samnanger.no',
    'sande.more-og-romsdal.no',
    'sande.m\xF8re-og-romsdal.no',
    'sande.vestfold.no',
    'sandefjord.no',
    'sandnes.no',
    'sandoy.no',
    'sand\xF8y.no',
    'sarpsborg.no',
    'sauda.no',
    'sauherad.no',
    'sel.no',
    'selbu.no',
    'selje.no',
    'seljord.no',
    'sigdal.no',
    'siljan.no',
    'sirdal.no',
    'skaun.no',
    'skedsmo.no',
    'ski.no',
    'skien.no',
    'skiptvet.no',
    'skjervoy.no',
    'skjerv\xF8y.no',
    'skierva.no',
    'skierv\xE1.no',
    'skjak.no',
    'skj\xE5k.no',
    'skodje.no',
    'skanland.no',
    'sk\xE5nland.no',
    'skanit.no',
    'sk\xE1nit.no',
    'smola.no',
    'sm\xF8la.no',
    'snillfjord.no',
    'snasa.no',
    'sn\xE5sa.no',
    'snoasa.no',
    'snaase.no',
    'sn\xE5ase.no',
    'sogndal.no',
    'sokndal.no',
    'sola.no',
    'solund.no',
    'songdalen.no',
    'sortland.no',
    'spydeberg.no',
    'stange.no',
    'stavanger.no',
    'steigen.no',
    'steinkjer.no',
    'stjordal.no',
    'stj\xF8rdal.no',
    'stokke.no',
    'stor-elvdal.no',
    'stord.no',
    'stordal.no',
    'storfjord.no',
    'omasvuotna.no',
    'strand.no',
    'stranda.no',
    'stryn.no',
    'sula.no',
    'suldal.no',
    'sund.no',
    'sunndal.no',
    'surnadal.no',
    'sveio.no',
    'svelvik.no',
    'sykkylven.no',
    'sogne.no',
    's\xF8gne.no',
    'somna.no',
    's\xF8mna.no',
    'sondre-land.no',
    's\xF8ndre-land.no',
    'sor-aurdal.no',
    's\xF8r-aurdal.no',
    'sor-fron.no',
    's\xF8r-fron.no',
    'sor-odal.no',
    's\xF8r-odal.no',
    'sor-varanger.no',
    's\xF8r-varanger.no',
    'matta-varjjat.no',
    'm\xE1tta-v\xE1rjjat.no',
    'sorfold.no',
    's\xF8rfold.no',
    'sorreisa.no',
    's\xF8rreisa.no',
    'sorum.no',
    's\xF8rum.no',
    'tana.no',
    'deatnu.no',
    'time.no',
    'tingvoll.no',
    'tinn.no',
    'tjeldsund.no',
    'dielddanuorri.no',
    'tjome.no',
    'tj\xF8me.no',
    'tokke.no',
    'tolga.no',
    'torsken.no',
    'tranoy.no',
    'tran\xF8y.no',
    'tromso.no',
    'troms\xF8.no',
    'tromsa.no',
    'romsa.no',
    'trondheim.no',
    'troandin.no',
    'trysil.no',
    'trana.no',
    'tr\xE6na.no',
    'trogstad.no',
    'tr\xF8gstad.no',
    'tvedestrand.no',
    'tydal.no',
    'tynset.no',
    'tysfjord.no',
    'divtasvuodna.no',
    'divttasvuotna.no',
    'tysnes.no',
    'tysvar.no',
    'tysv\xE6r.no',
    'tonsberg.no',
    't\xF8nsberg.no',
    'ullensaker.no',
    'ullensvang.no',
    'ulvik.no',
    'utsira.no',
    'vadso.no',
    'vads\xF8.no',
    'cahcesuolo.no',
    '\u010D\xE1hcesuolo.no',
    'vaksdal.no',
    'valle.no',
    'vang.no',
    'vanylven.no',
    'vardo.no',
    'vard\xF8.no',
    'varggat.no',
    'v\xE1rgg\xE1t.no',
    'vefsn.no',
    'vaapste.no',
    'vega.no',
    'vegarshei.no',
    'veg\xE5rshei.no',
    'vennesla.no',
    'verdal.no',
    'verran.no',
    'vestby.no',
    'vestnes.no',
    'vestre-slidre.no',
    'vestre-toten.no',
    'vestvagoy.no',
    'vestv\xE5g\xF8y.no',
    'vevelstad.no',
    'vik.no',
    'vikna.no',
    'vindafjord.no',
    'volda.no',
    'voss.no',
    'varoy.no',
    'v\xE6r\xF8y.no',
    'vagan.no',
    'v\xE5gan.no',
    'voagat.no',
    'vagsoy.no',
    'v\xE5gs\xF8y.no',
    'vaga.no',
    'v\xE5g\xE5.no',
    'valer.ostfold.no',
    'v\xE5ler.\xF8stfold.no',
    'valer.hedmark.no',
    'v\xE5ler.hedmark.no',
    '*.np',
    'nr',
    'biz.nr',
    'info.nr',
    'gov.nr',
    'edu.nr',
    'org.nr',
    'net.nr',
    'com.nr',
    'nu',
    'nz',
    'ac.nz',
    'co.nz',
    'cri.nz',
    'geek.nz',
    'gen.nz',
    'govt.nz',
    'health.nz',
    'iwi.nz',
    'kiwi.nz',
    'maori.nz',
    'mil.nz',
    'm\u0101ori.nz',
    'net.nz',
    'org.nz',
    'parliament.nz',
    'school.nz',
    'om',
    'co.om',
    'com.om',
    'edu.om',
    'gov.om',
    'med.om',
    'museum.om',
    'net.om',
    'org.om',
    'pro.om',
    'onion',
    'org',
    'pa',
    'ac.pa',
    'gob.pa',
    'com.pa',
    'org.pa',
    'sld.pa',
    'edu.pa',
    'net.pa',
    'ing.pa',
    'abo.pa',
    'med.pa',
    'nom.pa',
    'pe',
    'edu.pe',
    'gob.pe',
    'nom.pe',
    'mil.pe',
    'org.pe',
    'com.pe',
    'net.pe',
    'pf',
    'com.pf',
    'org.pf',
    'edu.pf',
    '*.pg',
    'ph',
    'com.ph',
    'net.ph',
    'org.ph',
    'gov.ph',
    'edu.ph',
    'ngo.ph',
    'mil.ph',
    'i.ph',
    'pk',
    'com.pk',
    'net.pk',
    'edu.pk',
    'org.pk',
    'fam.pk',
    'biz.pk',
    'web.pk',
    'gov.pk',
    'gob.pk',
    'gok.pk',
    'gon.pk',
    'gop.pk',
    'gos.pk',
    'info.pk',
    'pl',
    'com.pl',
    'net.pl',
    'org.pl',
    'aid.pl',
    'agro.pl',
    'atm.pl',
    'auto.pl',
    'biz.pl',
    'edu.pl',
    'gmina.pl',
    'gsm.pl',
    'info.pl',
    'mail.pl',
    'miasta.pl',
    'media.pl',
    'mil.pl',
    'nieruchomosci.pl',
    'nom.pl',
    'pc.pl',
    'powiat.pl',
    'priv.pl',
    'realestate.pl',
    'rel.pl',
    'sex.pl',
    'shop.pl',
    'sklep.pl',
    'sos.pl',
    'szkola.pl',
    'targi.pl',
    'tm.pl',
    'tourism.pl',
    'travel.pl',
    'turystyka.pl',
    'gov.pl',
    'ap.gov.pl',
    'ic.gov.pl',
    'is.gov.pl',
    'us.gov.pl',
    'kmpsp.gov.pl',
    'kppsp.gov.pl',
    'kwpsp.gov.pl',
    'psp.gov.pl',
    'wskr.gov.pl',
    'kwp.gov.pl',
    'mw.gov.pl',
    'ug.gov.pl',
    'um.gov.pl',
    'umig.gov.pl',
    'ugim.gov.pl',
    'upow.gov.pl',
    'uw.gov.pl',
    'starostwo.gov.pl',
    'pa.gov.pl',
    'po.gov.pl',
    'psse.gov.pl',
    'pup.gov.pl',
    'rzgw.gov.pl',
    'sa.gov.pl',
    'so.gov.pl',
    'sr.gov.pl',
    'wsa.gov.pl',
    'sko.gov.pl',
    'uzs.gov.pl',
    'wiih.gov.pl',
    'winb.gov.pl',
    'pinb.gov.pl',
    'wios.gov.pl',
    'witd.gov.pl',
    'wzmiuw.gov.pl',
    'piw.gov.pl',
    'wiw.gov.pl',
    'griw.gov.pl',
    'wif.gov.pl',
    'oum.gov.pl',
    'sdn.gov.pl',
    'zp.gov.pl',
    'uppo.gov.pl',
    'mup.gov.pl',
    'wuoz.gov.pl',
    'konsulat.gov.pl',
    'oirm.gov.pl',
    'augustow.pl',
    'babia-gora.pl',
    'bedzin.pl',
    'beskidy.pl',
    'bialowieza.pl',
    'bialystok.pl',
    'bielawa.pl',
    'bieszczady.pl',
    'boleslawiec.pl',
    'bydgoszcz.pl',
    'bytom.pl',
    'cieszyn.pl',
    'czeladz.pl',
    'czest.pl',
    'dlugoleka.pl',
    'elblag.pl',
    'elk.pl',
    'glogow.pl',
    'gniezno.pl',
    'gorlice.pl',
    'grajewo.pl',
    'ilawa.pl',
    'jaworzno.pl',
    'jelenia-gora.pl',
    'jgora.pl',
    'kalisz.pl',
    'kazimierz-dolny.pl',
    'karpacz.pl',
    'kartuzy.pl',
    'kaszuby.pl',
    'katowice.pl',
    'kepno.pl',
    'ketrzyn.pl',
    'klodzko.pl',
    'kobierzyce.pl',
    'kolobrzeg.pl',
    'konin.pl',
    'konskowola.pl',
    'kutno.pl',
    'lapy.pl',
    'lebork.pl',
    'legnica.pl',
    'lezajsk.pl',
    'limanowa.pl',
    'lomza.pl',
    'lowicz.pl',
    'lubin.pl',
    'lukow.pl',
    'malbork.pl',
    'malopolska.pl',
    'mazowsze.pl',
    'mazury.pl',
    'mielec.pl',
    'mielno.pl',
    'mragowo.pl',
    'naklo.pl',
    'nowaruda.pl',
    'nysa.pl',
    'olawa.pl',
    'olecko.pl',
    'olkusz.pl',
    'olsztyn.pl',
    'opoczno.pl',
    'opole.pl',
    'ostroda.pl',
    'ostroleka.pl',
    'ostrowiec.pl',
    'ostrowwlkp.pl',
    'pila.pl',
    'pisz.pl',
    'podhale.pl',
    'podlasie.pl',
    'polkowice.pl',
    'pomorze.pl',
    'pomorskie.pl',
    'prochowice.pl',
    'pruszkow.pl',
    'przeworsk.pl',
    'pulawy.pl',
    'radom.pl',
    'rawa-maz.pl',
    'rybnik.pl',
    'rzeszow.pl',
    'sanok.pl',
    'sejny.pl',
    'slask.pl',
    'slupsk.pl',
    'sosnowiec.pl',
    'stalowa-wola.pl',
    'skoczow.pl',
    'starachowice.pl',
    'stargard.pl',
    'suwalki.pl',
    'swidnica.pl',
    'swiebodzin.pl',
    'swinoujscie.pl',
    'szczecin.pl',
    'szczytno.pl',
    'tarnobrzeg.pl',
    'tgory.pl',
    'turek.pl',
    'tychy.pl',
    'ustka.pl',
    'walbrzych.pl',
    'warmia.pl',
    'warszawa.pl',
    'waw.pl',
    'wegrow.pl',
    'wielun.pl',
    'wlocl.pl',
    'wloclawek.pl',
    'wodzislaw.pl',
    'wolomin.pl',
    'wroclaw.pl',
    'zachpomor.pl',
    'zagan.pl',
    'zarow.pl',
    'zgora.pl',
    'zgorzelec.pl',
    'pm',
    'pn',
    'gov.pn',
    'co.pn',
    'org.pn',
    'edu.pn',
    'net.pn',
    'post',
    'pr',
    'com.pr',
    'net.pr',
    'org.pr',
    'gov.pr',
    'edu.pr',
    'isla.pr',
    'pro.pr',
    'biz.pr',
    'info.pr',
    'name.pr',
    'est.pr',
    'prof.pr',
    'ac.pr',
    'pro',
    'aaa.pro',
    'aca.pro',
    'acct.pro',
    'avocat.pro',
    'bar.pro',
    'cpa.pro',
    'eng.pro',
    'jur.pro',
    'law.pro',
    'med.pro',
    'recht.pro',
    'ps',
    'edu.ps',
    'gov.ps',
    'sec.ps',
    'plo.ps',
    'com.ps',
    'org.ps',
    'net.ps',
    'pt',
    'net.pt',
    'gov.pt',
    'org.pt',
    'edu.pt',
    'int.pt',
    'publ.pt',
    'com.pt',
    'nome.pt',
    'pw',
    'co.pw',
    'ne.pw',
    'or.pw',
    'ed.pw',
    'go.pw',
    'belau.pw',
    'py',
    'com.py',
    'coop.py',
    'edu.py',
    'gov.py',
    'mil.py',
    'net.py',
    'org.py',
    'qa',
    'com.qa',
    'edu.qa',
    'gov.qa',
    'mil.qa',
    'name.qa',
    'net.qa',
    'org.qa',
    'sch.qa',
    're',
    'asso.re',
    'com.re',
    'nom.re',
    'ro',
    'arts.ro',
    'com.ro',
    'firm.ro',
    'info.ro',
    'nom.ro',
    'nt.ro',
    'org.ro',
    'rec.ro',
    'store.ro',
    'tm.ro',
    'www.ro',
    'rs',
    'ac.rs',
    'co.rs',
    'edu.rs',
    'gov.rs',
    'in.rs',
    'org.rs',
    'ru',
    'rw',
    'ac.rw',
    'co.rw',
    'coop.rw',
    'gov.rw',
    'mil.rw',
    'net.rw',
    'org.rw',
    'sa',
    'com.sa',
    'net.sa',
    'org.sa',
    'gov.sa',
    'med.sa',
    'pub.sa',
    'edu.sa',
    'sch.sa',
    'sb',
    'com.sb',
    'edu.sb',
    'gov.sb',
    'net.sb',
    'org.sb',
    'sc',
    'com.sc',
    'gov.sc',
    'net.sc',
    'org.sc',
    'edu.sc',
    'sd',
    'com.sd',
    'net.sd',
    'org.sd',
    'edu.sd',
    'med.sd',
    'tv.sd',
    'gov.sd',
    'info.sd',
    'se',
    'a.se',
    'ac.se',
    'b.se',
    'bd.se',
    'brand.se',
    'c.se',
    'd.se',
    'e.se',
    'f.se',
    'fh.se',
    'fhsk.se',
    'fhv.se',
    'g.se',
    'h.se',
    'i.se',
    'k.se',
    'komforb.se',
    'kommunalforbund.se',
    'komvux.se',
    'l.se',
    'lanbib.se',
    'm.se',
    'n.se',
    'naturbruksgymn.se',
    'o.se',
    'org.se',
    'p.se',
    'parti.se',
    'pp.se',
    'press.se',
    'r.se',
    's.se',
    't.se',
    'tm.se',
    'u.se',
    'w.se',
    'x.se',
    'y.se',
    'z.se',
    'sg',
    'com.sg',
    'net.sg',
    'org.sg',
    'gov.sg',
    'edu.sg',
    'per.sg',
    'sh',
    'com.sh',
    'net.sh',
    'gov.sh',
    'org.sh',
    'mil.sh',
    'si',
    'sj',
    'sk',
    'sl',
    'com.sl',
    'net.sl',
    'edu.sl',
    'gov.sl',
    'org.sl',
    'sm',
    'sn',
    'art.sn',
    'com.sn',
    'edu.sn',
    'gouv.sn',
    'org.sn',
    'perso.sn',
    'univ.sn',
    'so',
    'com.so',
    'edu.so',
    'gov.so',
    'me.so',
    'net.so',
    'org.so',
    'sr',
    'ss',
    'biz.ss',
    'com.ss',
    'edu.ss',
    'gov.ss',
    'net.ss',
    'org.ss',
    'st',
    'co.st',
    'com.st',
    'consulado.st',
    'edu.st',
    'embaixada.st',
    'gov.st',
    'mil.st',
    'net.st',
    'org.st',
    'principe.st',
    'saotome.st',
    'store.st',
    'su',
    'sv',
    'com.sv',
    'edu.sv',
    'gob.sv',
    'org.sv',
    'red.sv',
    'sx',
    'gov.sx',
    'sy',
    'edu.sy',
    'gov.sy',
    'net.sy',
    'mil.sy',
    'com.sy',
    'org.sy',
    'sz',
    'co.sz',
    'ac.sz',
    'org.sz',
    'tc',
    'td',
    'tel',
    'tf',
    'tg',
    'th',
    'ac.th',
    'co.th',
    'go.th',
    'in.th',
    'mi.th',
    'net.th',
    'or.th',
    'tj',
    'ac.tj',
    'biz.tj',
    'co.tj',
    'com.tj',
    'edu.tj',
    'go.tj',
    'gov.tj',
    'int.tj',
    'mil.tj',
    'name.tj',
    'net.tj',
    'nic.tj',
    'org.tj',
    'test.tj',
    'web.tj',
    'tk',
    'tl',
    'gov.tl',
    'tm',
    'com.tm',
    'co.tm',
    'org.tm',
    'net.tm',
    'nom.tm',
    'gov.tm',
    'mil.tm',
    'edu.tm',
    'tn',
    'com.tn',
    'ens.tn',
    'fin.tn',
    'gov.tn',
    'ind.tn',
    'intl.tn',
    'nat.tn',
    'net.tn',
    'org.tn',
    'info.tn',
    'perso.tn',
    'tourism.tn',
    'edunet.tn',
    'rnrt.tn',
    'rns.tn',
    'rnu.tn',
    'mincom.tn',
    'agrinet.tn',
    'defense.tn',
    'turen.tn',
    'to',
    'com.to',
    'gov.to',
    'net.to',
    'org.to',
    'edu.to',
    'mil.to',
    'tr',
    'av.tr',
    'bbs.tr',
    'bel.tr',
    'biz.tr',
    'com.tr',
    'dr.tr',
    'edu.tr',
    'gen.tr',
    'gov.tr',
    'info.tr',
    'mil.tr',
    'k12.tr',
    'kep.tr',
    'name.tr',
    'net.tr',
    'org.tr',
    'pol.tr',
    'tel.tr',
    'tsk.tr',
    'tv.tr',
    'web.tr',
    'nc.tr',
    'gov.nc.tr',
    'tt',
    'co.tt',
    'com.tt',
    'org.tt',
    'net.tt',
    'biz.tt',
    'info.tt',
    'pro.tt',
    'int.tt',
    'coop.tt',
    'jobs.tt',
    'mobi.tt',
    'travel.tt',
    'museum.tt',
    'aero.tt',
    'name.tt',
    'gov.tt',
    'edu.tt',
    'tv',
    'tw',
    'edu.tw',
    'gov.tw',
    'mil.tw',
    'com.tw',
    'net.tw',
    'org.tw',
    'idv.tw',
    'game.tw',
    'ebiz.tw',
    'club.tw',
    '\u7DB2\u8DEF.tw',
    '\u7D44\u7E54.tw',
    '\u5546\u696D.tw',
    'tz',
    'ac.tz',
    'co.tz',
    'go.tz',
    'hotel.tz',
    'info.tz',
    'me.tz',
    'mil.tz',
    'mobi.tz',
    'ne.tz',
    'or.tz',
    'sc.tz',
    'tv.tz',
    'ua',
    'com.ua',
    'edu.ua',
    'gov.ua',
    'in.ua',
    'net.ua',
    'org.ua',
    'cherkassy.ua',
    'cherkasy.ua',
    'chernigov.ua',
    'chernihiv.ua',
    'chernivtsi.ua',
    'chernovtsy.ua',
    'ck.ua',
    'cn.ua',
    'cr.ua',
    'crimea.ua',
    'cv.ua',
    'dn.ua',
    'dnepropetrovsk.ua',
    'dnipropetrovsk.ua',
    'dominic.ua',
    'donetsk.ua',
    'dp.ua',
    'if.ua',
    'ivano-frankivsk.ua',
    'kh.ua',
    'kharkiv.ua',
    'kharkov.ua',
    'kherson.ua',
    'khmelnitskiy.ua',
    'khmelnytskyi.ua',
    'kiev.ua',
    'kirovograd.ua',
    'km.ua',
    'kr.ua',
    'krym.ua',
    'ks.ua',
    'kv.ua',
    'kyiv.ua',
    'lg.ua',
    'lt.ua',
    'lugansk.ua',
    'lutsk.ua',
    'lv.ua',
    'lviv.ua',
    'mk.ua',
    'mykolaiv.ua',
    'nikolaev.ua',
    'od.ua',
    'odesa.ua',
    'odessa.ua',
    'pl.ua',
    'poltava.ua',
    'rivne.ua',
    'rovno.ua',
    'rv.ua',
    'sb.ua',
    'sebastopol.ua',
    'sevastopol.ua',
    'sm.ua',
    'sumy.ua',
    'te.ua',
    'ternopil.ua',
    'uz.ua',
    'uzhgorod.ua',
    'vinnica.ua',
    'vinnytsia.ua',
    'vn.ua',
    'volyn.ua',
    'yalta.ua',
    'zaporizhzhe.ua',
    'zaporizhzhia.ua',
    'zhitomir.ua',
    'zhytomyr.ua',
    'zp.ua',
    'zt.ua',
    'ug',
    'co.ug',
    'or.ug',
    'ac.ug',
    'sc.ug',
    'go.ug',
    'ne.ug',
    'com.ug',
    'org.ug',
    'uk',
    'ac.uk',
    'co.uk',
    'gov.uk',
    'ltd.uk',
    'me.uk',
    'net.uk',
    'nhs.uk',
    'org.uk',
    'plc.uk',
    'police.uk',
    '*.sch.uk',
    'us',
    'dni.us',
    'fed.us',
    'isa.us',
    'kids.us',
    'nsn.us',
    'ak.us',
    'al.us',
    'ar.us',
    'as.us',
    'az.us',
    'ca.us',
    'co.us',
    'ct.us',
    'dc.us',
    'de.us',
    'fl.us',
    'ga.us',
    'gu.us',
    'hi.us',
    'ia.us',
    'id.us',
    'il.us',
    'in.us',
    'ks.us',
    'ky.us',
    'la.us',
    'ma.us',
    'md.us',
    'me.us',
    'mi.us',
    'mn.us',
    'mo.us',
    'ms.us',
    'mt.us',
    'nc.us',
    'nd.us',
    'ne.us',
    'nh.us',
    'nj.us',
    'nm.us',
    'nv.us',
    'ny.us',
    'oh.us',
    'ok.us',
    'or.us',
    'pa.us',
    'pr.us',
    'ri.us',
    'sc.us',
    'sd.us',
    'tn.us',
    'tx.us',
    'ut.us',
    'vi.us',
    'vt.us',
    'va.us',
    'wa.us',
    'wi.us',
    'wv.us',
    'wy.us',
    'k12.ak.us',
    'k12.al.us',
    'k12.ar.us',
    'k12.as.us',
    'k12.az.us',
    'k12.ca.us',
    'k12.co.us',
    'k12.ct.us',
    'k12.dc.us',
    'k12.de.us',
    'k12.fl.us',
    'k12.ga.us',
    'k12.gu.us',
    'k12.ia.us',
    'k12.id.us',
    'k12.il.us',
    'k12.in.us',
    'k12.ks.us',
    'k12.ky.us',
    'k12.la.us',
    'k12.ma.us',
    'k12.md.us',
    'k12.me.us',
    'k12.mi.us',
    'k12.mn.us',
    'k12.mo.us',
    'k12.ms.us',
    'k12.mt.us',
    'k12.nc.us',
    'k12.ne.us',
    'k12.nh.us',
    'k12.nj.us',
    'k12.nm.us',
    'k12.nv.us',
    'k12.ny.us',
    'k12.oh.us',
    'k12.ok.us',
    'k12.or.us',
    'k12.pa.us',
    'k12.pr.us',
    'k12.ri.us',
    'k12.sc.us',
    'k12.tn.us',
    'k12.tx.us',
    'k12.ut.us',
    'k12.vi.us',
    'k12.vt.us',
    'k12.va.us',
    'k12.wa.us',
    'k12.wi.us',
    'k12.wy.us',
    'cc.ak.us',
    'cc.al.us',
    'cc.ar.us',
    'cc.as.us',
    'cc.az.us',
    'cc.ca.us',
    'cc.co.us',
    'cc.ct.us',
    'cc.dc.us',
    'cc.de.us',
    'cc.fl.us',
    'cc.ga.us',
    'cc.gu.us',
    'cc.hi.us',
    'cc.ia.us',
    'cc.id.us',
    'cc.il.us',
    'cc.in.us',
    'cc.ks.us',
    'cc.ky.us',
    'cc.la.us',
    'cc.ma.us',
    'cc.md.us',
    'cc.me.us',
    'cc.mi.us',
    'cc.mn.us',
    'cc.mo.us',
    'cc.ms.us',
    'cc.mt.us',
    'cc.nc.us',
    'cc.nd.us',
    'cc.ne.us',
    'cc.nh.us',
    'cc.nj.us',
    'cc.nm.us',
    'cc.nv.us',
    'cc.ny.us',
    'cc.oh.us',
    'cc.ok.us',
    'cc.or.us',
    'cc.pa.us',
    'cc.pr.us',
    'cc.ri.us',
    'cc.sc.us',
    'cc.sd.us',
    'cc.tn.us',
    'cc.tx.us',
    'cc.ut.us',
    'cc.vi.us',
    'cc.vt.us',
    'cc.va.us',
    'cc.wa.us',
    'cc.wi.us',
    'cc.wv.us',
    'cc.wy.us',
    'lib.ak.us',
    'lib.al.us',
    'lib.ar.us',
    'lib.as.us',
    'lib.az.us',
    'lib.ca.us',
    'lib.co.us',
    'lib.ct.us',
    'lib.dc.us',
    'lib.fl.us',
    'lib.ga.us',
    'lib.gu.us',
    'lib.hi.us',
    'lib.ia.us',
    'lib.id.us',
    'lib.il.us',
    'lib.in.us',
    'lib.ks.us',
    'lib.ky.us',
    'lib.la.us',
    'lib.ma.us',
    'lib.md.us',
    'lib.me.us',
    'lib.mi.us',
    'lib.mn.us',
    'lib.mo.us',
    'lib.ms.us',
    'lib.mt.us',
    'lib.nc.us',
    'lib.nd.us',
    'lib.ne.us',
    'lib.nh.us',
    'lib.nj.us',
    'lib.nm.us',
    'lib.nv.us',
    'lib.ny.us',
    'lib.oh.us',
    'lib.ok.us',
    'lib.or.us',
    'lib.pa.us',
    'lib.pr.us',
    'lib.ri.us',
    'lib.sc.us',
    'lib.sd.us',
    'lib.tn.us',
    'lib.tx.us',
    'lib.ut.us',
    'lib.vi.us',
    'lib.vt.us',
    'lib.va.us',
    'lib.wa.us',
    'lib.wi.us',
    'lib.wy.us',
    'pvt.k12.ma.us',
    'chtr.k12.ma.us',
    'paroch.k12.ma.us',
    'ann-arbor.mi.us',
    'cog.mi.us',
    'dst.mi.us',
    'eaton.mi.us',
    'gen.mi.us',
    'mus.mi.us',
    'tec.mi.us',
    'washtenaw.mi.us',
    'uy',
    'com.uy',
    'edu.uy',
    'gub.uy',
    'mil.uy',
    'net.uy',
    'org.uy',
    'uz',
    'co.uz',
    'com.uz',
    'net.uz',
    'org.uz',
    'va',
    'vc',
    'com.vc',
    'net.vc',
    'org.vc',
    'gov.vc',
    'mil.vc',
    'edu.vc',
    've',
    'arts.ve',
    'co.ve',
    'com.ve',
    'e12.ve',
    'edu.ve',
    'firm.ve',
    'gob.ve',
    'gov.ve',
    'info.ve',
    'int.ve',
    'mil.ve',
    'net.ve',
    'org.ve',
    'rec.ve',
    'store.ve',
    'tec.ve',
    'web.ve',
    'vg',
    'vi',
    'co.vi',
    'com.vi',
    'k12.vi',
    'net.vi',
    'org.vi',
    'vn',
    'com.vn',
    'net.vn',
    'org.vn',
    'edu.vn',
    'gov.vn',
    'int.vn',
    'ac.vn',
    'biz.vn',
    'info.vn',
    'name.vn',
    'pro.vn',
    'health.vn',
    'vu',
    'com.vu',
    'edu.vu',
    'net.vu',
    'org.vu',
    'wf',
    'ws',
    'com.ws',
    'net.ws',
    'org.ws',
    'gov.ws',
    'edu.ws',
    'yt',
    '\u0627\u0645\u0627\u0631\u0627\u062A',
    '\u0570\u0561\u0575',
    '\u09AC\u09BE\u0982\u09B2\u09BE',
    '\u0431\u0433',
    '\u0431\u0435\u043B',
    '\u4E2D\u56FD',
    '\u4E2D\u570B',
    '\u0627\u0644\u062C\u0632\u0627\u0626\u0631',
    '\u0645\u0635\u0631',
    '\u0435\u044E',
    '\u03B5\u03C5',
    '\u0645\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u0627',
    '\u10D2\u10D4',
    '\u03B5\u03BB',
    '\u9999\u6E2F',
    '\u516C\u53F8.\u9999\u6E2F',
    '\u6559\u80B2.\u9999\u6E2F',
    '\u653F\u5E9C.\u9999\u6E2F',
    '\u500B\u4EBA.\u9999\u6E2F',
    '\u7DB2\u7D61.\u9999\u6E2F',
    '\u7D44\u7E54.\u9999\u6E2F',
    '\u0CAD\u0CBE\u0CB0\u0CA4',
    '\u0B2D\u0B3E\u0B30\u0B24',
    '\u09AD\u09BE\u09F0\u09A4',
    '\u092D\u093E\u0930\u0924\u092E\u094D',
    '\u092D\u093E\u0930\u094B\u0924',
    '\u0680\u0627\u0631\u062A',
    '\u0D2D\u0D3E\u0D30\u0D24\u0D02',
    '\u092D\u093E\u0930\u0924',
    '\u0628\u0627\u0631\u062A',
    '\u0628\u06BE\u0627\u0631\u062A',
    '\u0C2D\u0C3E\u0C30\u0C24\u0C4D',
    '\u0AAD\u0ABE\u0AB0\u0AA4',
    '\u0A2D\u0A3E\u0A30\u0A24',
    '\u09AD\u09BE\u09B0\u09A4',
    '\u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE',
    '\u0627\u06CC\u0631\u0627\u0646',
    '\u0627\u064A\u0631\u0627\u0646',
    '\u0639\u0631\u0627\u0642',
    '\u0627\u0644\u0627\u0631\u062F\u0646',
    '\uD55C\uAD6D',
    '\u049B\u0430\u0437',
    '\u0DBD\u0D82\u0D9A\u0DCF',
    '\u0B87\u0BB2\u0B99\u0BCD\u0B95\u0BC8',
    '\u0627\u0644\u0645\u063A\u0631\u0628',
    '\u043C\u043A\u0434',
    '\u043C\u043E\u043D',
    '\u6FB3\u9580',
    '\u6FB3\u95E8',
    '\u0645\u0644\u064A\u0633\u064A\u0627',
    '\u0639\u0645\u0627\u0646',
    '\u067E\u0627\u06A9\u0633\u062A\u0627\u0646',
    '\u067E\u0627\u0643\u0633\u062A\u0627\u0646',
    '\u0641\u0644\u0633\u0637\u064A\u0646',
    '\u0441\u0440\u0431',
    '\u043F\u0440.\u0441\u0440\u0431',
    '\u043E\u0440\u0433.\u0441\u0440\u0431',
    '\u043E\u0431\u0440.\u0441\u0440\u0431',
    '\u043E\u0434.\u0441\u0440\u0431',
    '\u0443\u043F\u0440.\u0441\u0440\u0431',
    '\u0430\u043A.\u0441\u0440\u0431',
    '\u0440\u0444',
    '\u0642\u0637\u0631',
    '\u0627\u0644\u0633\u0639\u0648\u062F\u064A\u0629',
    '\u0627\u0644\u0633\u0639\u0648\u062F\u06CC\u0629',
    '\u0627\u0644\u0633\u0639\u0648\u062F\u06CC\u06C3',
    '\u0627\u0644\u0633\u0639\u0648\u062F\u064A\u0647',
    '\u0633\u0648\u062F\u0627\u0646',
    '\u65B0\u52A0\u5761',
    '\u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD',
    '\u0633\u0648\u0631\u064A\u0629',
    '\u0633\u0648\u0631\u064A\u0627',
    '\u0E44\u0E17\u0E22',
    '\u0E28\u0E36\u0E01\u0E29\u0E32.\u0E44\u0E17\u0E22',
    '\u0E18\u0E38\u0E23\u0E01\u0E34\u0E08.\u0E44\u0E17\u0E22',
    '\u0E23\u0E31\u0E10\u0E1A\u0E32\u0E25.\u0E44\u0E17\u0E22',
    '\u0E17\u0E2B\u0E32\u0E23.\u0E44\u0E17\u0E22',
    '\u0E40\u0E19\u0E47\u0E15.\u0E44\u0E17\u0E22',
    '\u0E2D\u0E07\u0E04\u0E4C\u0E01\u0E23.\u0E44\u0E17\u0E22',
    '\u062A\u0648\u0646\u0633',
    '\u53F0\u7063',
    '\u53F0\u6E7E',
    '\u81FA\u7063',
    '\u0443\u043A\u0440',
    '\u0627\u0644\u064A\u0645\u0646',
    'xxx',
    '*.ye',
    'ac.za',
    'agric.za',
    'alt.za',
    'co.za',
    'edu.za',
    'gov.za',
    'grondar.za',
    'law.za',
    'mil.za',
    'net.za',
    'ngo.za',
    'nic.za',
    'nis.za',
    'nom.za',
    'org.za',
    'school.za',
    'tm.za',
    'web.za',
    'zm',
    'ac.zm',
    'biz.zm',
    'co.zm',
    'com.zm',
    'edu.zm',
    'gov.zm',
    'info.zm',
    'mil.zm',
    'net.zm',
    'org.zm',
    'sch.zm',
    'zw',
    'ac.zw',
    'co.zw',
    'gov.zw',
    'mil.zw',
    'org.zw',
    'aaa',
    'aarp',
    'abarth',
    'abb',
    'abbott',
    'abbvie',
    'abc',
    'able',
    'abogado',
    'abudhabi',
    'academy',
    'accenture',
    'accountant',
    'accountants',
    'aco',
    'actor',
    'adac',
    'ads',
    'adult',
    'aeg',
    'aetna',
    'afamilycompany',
    'afl',
    'africa',
    'agakhan',
    'agency',
    'aig',
    'aigo',
    'airbus',
    'airforce',
    'airtel',
    'akdn',
    'alfaromeo',
    'alibaba',
    'alipay',
    'allfinanz',
    'allstate',
    'ally',
    'alsace',
    'alstom',
    'amazon',
    'americanexpress',
    'americanfamily',
    'amex',
    'amfam',
    'amica',
    'amsterdam',
    'analytics',
    'android',
    'anquan',
    'anz',
    'aol',
    'apartments',
    'app',
    'apple',
    'aquarelle',
    'arab',
    'aramco',
    'archi',
    'army',
    'art',
    'arte',
    'asda',
    'associates',
    'athleta',
    'attorney',
    'auction',
    'audi',
    'audible',
    'audio',
    'auspost',
    'author',
    'auto',
    'autos',
    'avianca',
    'aws',
    'axa',
    'azure',
    'baby',
    'baidu',
    'banamex',
    'bananarepublic',
    'band',
    'bank',
    'bar',
    'barcelona',
    'barclaycard',
    'barclays',
    'barefoot',
    'bargains',
    'baseball',
    'basketball',
    'bauhaus',
    'bayern',
    'bbc',
    'bbt',
    'bbva',
    'bcg',
    'bcn',
    'beats',
    'beauty',
    'beer',
    'bentley',
    'berlin',
    'best',
    'bestbuy',
    'bet',
    'bharti',
    'bible',
    'bid',
    'bike',
    'bing',
    'bingo',
    'bio',
    'black',
    'blackfriday',
    'blockbuster',
    'blog',
    'bloomberg',
    'blue',
    'bms',
    'bmw',
    'bnpparibas',
    'boats',
    'boehringer',
    'bofa',
    'bom',
    'bond',
    'boo',
    'book',
    'booking',
    'bosch',
    'bostik',
    'boston',
    'bot',
    'boutique',
    'box',
    'bradesco',
    'bridgestone',
    'broadway',
    'broker',
    'brother',
    'brussels',
    'budapest',
    'bugatti',
    'build',
    'builders',
    'business',
    'buy',
    'buzz',
    'bzh',
    'cab',
    'cafe',
    'cal',
    'call',
    'calvinklein',
    'cam',
    'camera',
    'camp',
    'cancerresearch',
    'canon',
    'capetown',
    'capital',
    'capitalone',
    'car',
    'caravan',
    'cards',
    'care',
    'career',
    'careers',
    'cars',
    'casa',
    'case',
    'caseih',
    'cash',
    'casino',
    'catering',
    'catholic',
    'cba',
    'cbn',
    'cbre',
    'cbs',
    'ceb',
    'center',
    'ceo',
    'cern',
    'cfa',
    'cfd',
    'chanel',
    'channel',
    'charity',
    'chase',
    'chat',
    'cheap',
    'chintai',
    'christmas',
    'chrome',
    'church',
    'cipriani',
    'circle',
    'cisco',
    'citadel',
    'citi',
    'citic',
    'city',
    'cityeats',
    'claims',
    'cleaning',
    'click',
    'clinic',
    'clinique',
    'clothing',
    'cloud',
    'club',
    'clubmed',
    'coach',
    'codes',
    'coffee',
    'college',
    'cologne',
    'comcast',
    'commbank',
    'community',
    'company',
    'compare',
    'computer',
    'comsec',
    'condos',
    'construction',
    'consulting',
    'contact',
    'contractors',
    'cooking',
    'cookingchannel',
    'cool',
    'corsica',
    'country',
    'coupon',
    'coupons',
    'courses',
    'cpa',
    'credit',
    'creditcard',
    'creditunion',
    'cricket',
    'crown',
    'crs',
    'cruise',
    'cruises',
    'csc',
    'cuisinella',
    'cymru',
    'cyou',
    'dabur',
    'dad',
    'dance',
    'data',
    'date',
    'dating',
    'datsun',
    'day',
    'dclk',
    'dds',
    'deal',
    'dealer',
    'deals',
    'degree',
    'delivery',
    'dell',
    'deloitte',
    'delta',
    'democrat',
    'dental',
    'dentist',
    'desi',
    'design',
    'dev',
    'dhl',
    'diamonds',
    'diet',
    'digital',
    'direct',
    'directory',
    'discount',
    'discover',
    'dish',
    'diy',
    'dnp',
    'docs',
    'doctor',
    'dog',
    'domains',
    'dot',
    'download',
    'drive',
    'dtv',
    'dubai',
    'duck',
    'dunlop',
    'dupont',
    'durban',
    'dvag',
    'dvr',
    'earth',
    'eat',
    'eco',
    'edeka',
    'education',
    'email',
    'emerck',
    'energy',
    'engineer',
    'engineering',
    'enterprises',
    'epson',
    'equipment',
    'ericsson',
    'erni',
    'esq',
    'estate',
    'esurance',
    'etisalat',
    'eurovision',
    'eus',
    'events',
    'exchange',
    'expert',
    'exposed',
    'express',
    'extraspace',
    'fage',
    'fail',
    'fairwinds',
    'faith',
    'family',
    'fan',
    'fans',
    'farm',
    'farmers',
    'fashion',
    'fast',
    'fedex',
    'feedback',
    'ferrari',
    'ferrero',
    'fiat',
    'fidelity',
    'fido',
    'film',
    'final',
    'finance',
    'financial',
    'fire',
    'firestone',
    'firmdale',
    'fish',
    'fishing',
    'fit',
    'fitness',
    'flickr',
    'flights',
    'flir',
    'florist',
    'flowers',
    'fly',
    'foo',
    'food',
    'foodnetwork',
    'football',
    'ford',
    'forex',
    'forsale',
    'forum',
    'foundation',
    'fox',
    'free',
    'fresenius',
    'frl',
    'frogans',
    'frontdoor',
    'frontier',
    'ftr',
    'fujitsu',
    'fujixerox',
    'fun',
    'fund',
    'furniture',
    'futbol',
    'fyi',
    'gal',
    'gallery',
    'gallo',
    'gallup',
    'game',
    'games',
    'gap',
    'garden',
    'gay',
    'gbiz',
    'gdn',
    'gea',
    'gent',
    'genting',
    'george',
    'ggee',
    'gift',
    'gifts',
    'gives',
    'giving',
    'glade',
    'glass',
    'gle',
    'global',
    'globo',
    'gmail',
    'gmbh',
    'gmo',
    'gmx',
    'godaddy',
    'gold',
    'goldpoint',
    'golf',
    'goo',
    'goodyear',
    'goog',
    'google',
    'gop',
    'got',
    'grainger',
    'graphics',
    'gratis',
    'green',
    'gripe',
    'grocery',
    'group',
    'guardian',
    'gucci',
    'guge',
    'guide',
    'guitars',
    'guru',
    'hair',
    'hamburg',
    'hangout',
    'haus',
    'hbo',
    'hdfc',
    'hdfcbank',
    'health',
    'healthcare',
    'help',
    'helsinki',
    'here',
    'hermes',
    'hgtv',
    'hiphop',
    'hisamitsu',
    'hitachi',
    'hiv',
    'hkt',
    'hockey',
    'holdings',
    'holiday',
    'homedepot',
    'homegoods',
    'homes',
    'homesense',
    'honda',
    'horse',
    'hospital',
    'host',
    'hosting',
    'hot',
    'hoteles',
    'hotels',
    'hotmail',
    'house',
    'how',
    'hsbc',
    'hughes',
    'hyatt',
    'hyundai',
    'ibm',
    'icbc',
    'ice',
    'icu',
    'ieee',
    'ifm',
    'ikano',
    'imamat',
    'imdb',
    'immo',
    'immobilien',
    'inc',
    'industries',
    'infiniti',
    'ing',
    'ink',
    'institute',
    'insurance',
    'insure',
    'intel',
    'international',
    'intuit',
    'investments',
    'ipiranga',
    'irish',
    'ismaili',
    'ist',
    'istanbul',
    'itau',
    'itv',
    'iveco',
    'jaguar',
    'java',
    'jcb',
    'jcp',
    'jeep',
    'jetzt',
    'jewelry',
    'jio',
    'jll',
    'jmp',
    'jnj',
    'joburg',
    'jot',
    'joy',
    'jpmorgan',
    'jprs',
    'juegos',
    'juniper',
    'kaufen',
    'kddi',
    'kerryhotels',
    'kerrylogistics',
    'kerryproperties',
    'kfh',
    'kia',
    'kim',
    'kinder',
    'kindle',
    'kitchen',
    'kiwi',
    'koeln',
    'komatsu',
    'kosher',
    'kpmg',
    'kpn',
    'krd',
    'kred',
    'kuokgroup',
    'kyoto',
    'lacaixa',
    'lamborghini',
    'lamer',
    'lancaster',
    'lancia',
    'land',
    'landrover',
    'lanxess',
    'lasalle',
    'lat',
    'latino',
    'latrobe',
    'law',
    'lawyer',
    'lds',
    'lease',
    'leclerc',
    'lefrak',
    'legal',
    'lego',
    'lexus',
    'lgbt',
    'lidl',
    'life',
    'lifeinsurance',
    'lifestyle',
    'lighting',
    'like',
    'lilly',
    'limited',
    'limo',
    'lincoln',
    'linde',
    'link',
    'lipsy',
    'live',
    'living',
    'lixil',
    'llc',
    'llp',
    'loan',
    'loans',
    'locker',
    'locus',
    'loft',
    'lol',
    'london',
    'lotte',
    'lotto',
    'love',
    'lpl',
    'lplfinancial',
    'ltd',
    'ltda',
    'lundbeck',
    'lupin',
    'luxe',
    'luxury',
    'macys',
    'madrid',
    'maif',
    'maison',
    'makeup',
    'man',
    'management',
    'mango',
    'map',
    'market',
    'marketing',
    'markets',
    'marriott',
    'marshalls',
    'maserati',
    'mattel',
    'mba',
    'mckinsey',
    'med',
    'media',
    'meet',
    'melbourne',
    'meme',
    'memorial',
    'men',
    'menu',
    'merckmsd',
    'metlife',
    'miami',
    'microsoft',
    'mini',
    'mint',
    'mit',
    'mitsubishi',
    'mlb',
    'mls',
    'mma',
    'mobile',
    'moda',
    'moe',
    'moi',
    'mom',
    'monash',
    'money',
    'monster',
    'mormon',
    'mortgage',
    'moscow',
    'moto',
    'motorcycles',
    'mov',
    'movie',
    'msd',
    'mtn',
    'mtr',
    'mutual',
    'nab',
    'nadex',
    'nagoya',
    'nationwide',
    'natura',
    'navy',
    'nba',
    'nec',
    'netbank',
    'netflix',
    'network',
    'neustar',
    'new',
    'newholland',
    'news',
    'next',
    'nextdirect',
    'nexus',
    'nfl',
    'ngo',
    'nhk',
    'nico',
    'nike',
    'nikon',
    'ninja',
    'nissan',
    'nissay',
    'nokia',
    'northwesternmutual',
    'norton',
    'now',
    'nowruz',
    'nowtv',
    'nra',
    'nrw',
    'ntt',
    'nyc',
    'obi',
    'observer',
    'off',
    'office',
    'okinawa',
    'olayan',
    'olayangroup',
    'oldnavy',
    'ollo',
    'omega',
    'one',
    'ong',
    'onl',
    'online',
    'onyourside',
    'ooo',
    'open',
    'oracle',
    'orange',
    'organic',
    'origins',
    'osaka',
    'otsuka',
    'ott',
    'ovh',
    'page',
    'panasonic',
    'paris',
    'pars',
    'partners',
    'parts',
    'party',
    'passagens',
    'pay',
    'pccw',
    'pet',
    'pfizer',
    'pharmacy',
    'phd',
    'philips',
    'phone',
    'photo',
    'photography',
    'photos',
    'physio',
    'pics',
    'pictet',
    'pictures',
    'pid',
    'pin',
    'ping',
    'pink',
    'pioneer',
    'pizza',
    'place',
    'play',
    'playstation',
    'plumbing',
    'plus',
    'pnc',
    'pohl',
    'poker',
    'politie',
    'porn',
    'pramerica',
    'praxi',
    'press',
    'prime',
    'prod',
    'productions',
    'prof',
    'progressive',
    'promo',
    'properties',
    'property',
    'protection',
    'pru',
    'prudential',
    'pub',
    'pwc',
    'qpon',
    'quebec',
    'quest',
    'qvc',
    'racing',
    'radio',
    'raid',
    'read',
    'realestate',
    'realtor',
    'realty',
    'recipes',
    'red',
    'redstone',
    'redumbrella',
    'rehab',
    'reise',
    'reisen',
    'reit',
    'reliance',
    'ren',
    'rent',
    'rentals',
    'repair',
    'report',
    'republican',
    'rest',
    'restaurant',
    'review',
    'reviews',
    'rexroth',
    'rich',
    'richardli',
    'ricoh',
    'rightathome',
    'ril',
    'rio',
    'rip',
    'rmit',
    'rocher',
    'rocks',
    'rodeo',
    'rogers',
    'room',
    'rsvp',
    'rugby',
    'ruhr',
    'run',
    'rwe',
    'ryukyu',
    'saarland',
    'safe',
    'safety',
    'sakura',
    'sale',
    'salon',
    'samsclub',
    'samsung',
    'sandvik',
    'sandvikcoromant',
    'sanofi',
    'sap',
    'sarl',
    'sas',
    'save',
    'saxo',
    'sbi',
    'sbs',
    'sca',
    'scb',
    'schaeffler',
    'schmidt',
    'scholarships',
    'school',
    'schule',
    'schwarz',
    'science',
    'scjohnson',
    'scor',
    'scot',
    'search',
    'seat',
    'secure',
    'security',
    'seek',
    'select',
    'sener',
    'services',
    'ses',
    'seven',
    'sew',
    'sex',
    'sexy',
    'sfr',
    'shangrila',
    'sharp',
    'shaw',
    'shell',
    'shia',
    'shiksha',
    'shoes',
    'shop',
    'shopping',
    'shouji',
    'show',
    'showtime',
    'shriram',
    'silk',
    'sina',
    'singles',
    'site',
    'ski',
    'skin',
    'sky',
    'skype',
    'sling',
    'smart',
    'smile',
    'sncf',
    'soccer',
    'social',
    'softbank',
    'software',
    'sohu',
    'solar',
    'solutions',
    'song',
    'sony',
    'soy',
    'spa',
    'space',
    'sport',
    'spot',
    'spreadbetting',
    'srl',
    'stada',
    'staples',
    'star',
    'statebank',
    'statefarm',
    'stc',
    'stcgroup',
    'stockholm',
    'storage',
    'store',
    'stream',
    'studio',
    'study',
    'style',
    'sucks',
    'supplies',
    'supply',
    'support',
    'surf',
    'surgery',
    'suzuki',
    'swatch',
    'swiftcover',
    'swiss',
    'sydney',
    'symantec',
    'systems',
    'tab',
    'taipei',
    'talk',
    'taobao',
    'target',
    'tatamotors',
    'tatar',
    'tattoo',
    'tax',
    'taxi',
    'tci',
    'tdk',
    'team',
    'tech',
    'technology',
    'temasek',
    'tennis',
    'teva',
    'thd',
    'theater',
    'theatre',
    'tiaa',
    'tickets',
    'tienda',
    'tiffany',
    'tips',
    'tires',
    'tirol',
    'tjmaxx',
    'tjx',
    'tkmaxx',
    'tmall',
    'today',
    'tokyo',
    'tools',
    'top',
    'toray',
    'toshiba',
    'total',
    'tours',
    'town',
    'toyota',
    'toys',
    'trade',
    'trading',
    'training',
    'travel',
    'travelchannel',
    'travelers',
    'travelersinsurance',
    'trust',
    'trv',
    'tube',
    'tui',
    'tunes',
    'tushu',
    'tvs',
    'ubank',
    'ubs',
    'unicom',
    'university',
    'uno',
    'uol',
    'ups',
    'vacations',
    'vana',
    'vanguard',
    'vegas',
    'ventures',
    'verisign',
    'versicherung',
    'vet',
    'viajes',
    'video',
    'vig',
    'viking',
    'villas',
    'vin',
    'vip',
    'virgin',
    'visa',
    'vision',
    'viva',
    'vivo',
    'vlaanderen',
    'vodka',
    'volkswagen',
    'volvo',
    'vote',
    'voting',
    'voto',
    'voyage',
    'vuelos',
    'wales',
    'walmart',
    'walter',
    'wang',
    'wanggou',
    'watch',
    'watches',
    'weather',
    'weatherchannel',
    'webcam',
    'weber',
    'website',
    'wed',
    'wedding',
    'weibo',
    'weir',
    'whoswho',
    'wien',
    'wiki',
    'williamhill',
    'win',
    'windows',
    'wine',
    'winners',
    'wme',
    'wolterskluwer',
    'woodside',
    'work',
    'works',
    'world',
    'wow',
    'wtc',
    'wtf',
    'xbox',
    'xerox',
    'xfinity',
    'xihuan',
    'xin',
    '\u0915\u0949\u092E',
    '\u30BB\u30FC\u30EB',
    '\u4F5B\u5C71',
    '\u6148\u5584',
    '\u96C6\u56E2',
    '\u5728\u7EBF',
    '\u5927\u4F17\u6C7D\u8F66',
    '\u70B9\u770B',
    '\u0E04\u0E2D\u0E21',
    '\u516B\u5366',
    '\u0645\u0648\u0642\u0639',
    '\u516C\u76CA',
    '\u516C\u53F8',
    '\u9999\u683C\u91CC\u62C9',
    '\u7F51\u7AD9',
    '\u79FB\u52A8',
    '\u6211\u7231\u4F60',
    '\u043C\u043E\u0441\u043A\u0432\u0430',
    '\u043A\u0430\u0442\u043E\u043B\u0438\u043A',
    '\u043E\u043D\u043B\u0430\u0439\u043D',
    '\u0441\u0430\u0439\u0442',
    '\u8054\u901A',
    '\u05E7\u05D5\u05DD',
    '\u65F6\u5C1A',
    '\u5FAE\u535A',
    '\u6DE1\u9A6C\u9521',
    '\u30D5\u30A1\u30C3\u30B7\u30E7\u30F3',
    '\u043E\u0440\u0433',
    '\u0928\u0947\u091F',
    '\u30B9\u30C8\u30A2',
    '\u30A2\u30DE\u30BE\u30F3',
    '\uC0BC\uC131',
    '\u5546\u6807',
    '\u5546\u5E97',
    '\u5546\u57CE',
    '\u0434\u0435\u0442\u0438',
    '\u30DD\u30A4\u30F3\u30C8',
    '\u65B0\u95FB',
    '\u5DE5\u884C',
    '\u5BB6\u96FB',
    '\u0643\u0648\u0645',
    '\u4E2D\u6587\u7F51',
    '\u4E2D\u4FE1',
    '\u5A31\u4E50',
    '\u8C37\u6B4C',
    '\u96FB\u8A0A\u76C8\u79D1',
    '\u8D2D\u7269',
    '\u30AF\u30E9\u30A6\u30C9',
    '\u901A\u8CA9',
    '\u7F51\u5E97',
    '\u0938\u0902\u0917\u0920\u0928',
    '\u9910\u5385',
    '\u7F51\u7EDC',
    '\u043A\u043E\u043C',
    '\u4E9A\u9A6C\u900A',
    '\u8BFA\u57FA\u4E9A',
    '\u98DF\u54C1',
    '\u98DE\u5229\u6D66',
    '\u624B\u8868',
    '\u624B\u673A',
    '\u0627\u0631\u0627\u0645\u0643\u0648',
    '\u0627\u0644\u0639\u0644\u064A\u0627\u0646',
    '\u0627\u062A\u0635\u0627\u0644\u0627\u062A',
    '\u0628\u0627\u0632\u0627\u0631',
    '\u0627\u0628\u0648\u0638\u0628\u064A',
    '\u0643\u0627\u062B\u0648\u0644\u064A\u0643',
    '\u0647\u0645\u0631\u0627\u0647',
    '\uB2F7\uCEF4',
    '\u653F\u5E9C',
    '\u0634\u0628\u0643\u0629',
    '\u0628\u064A\u062A\u0643',
    '\u0639\u0631\u0628',
    '\u673A\u6784',
    '\u7EC4\u7EC7\u673A\u6784',
    '\u5065\u5EB7',
    '\u62DB\u8058',
    '\u0440\u0443\u0441',
    '\u73E0\u5B9D',
    '\u5927\u62FF',
    '\u307F\u3093\u306A',
    '\u30B0\u30FC\u30B0\u30EB',
    '\u4E16\u754C',
    '\u66F8\u7C4D',
    '\u7F51\u5740',
    '\uB2F7\uB137',
    '\u30B3\u30E0',
    '\u5929\u4E3B\u6559',
    '\u6E38\u620F',
    'verm\xF6gensberater',
    'verm\xF6gensberatung',
    '\u4F01\u4E1A',
    '\u4FE1\u606F',
    '\u5609\u91CC\u5927\u9152\u5E97',
    '\u5609\u91CC',
    '\u5E7F\u4E1C',
    '\u653F\u52A1',
    'xyz',
    'yachts',
    'yahoo',
    'yamaxun',
    'yandex',
    'yodobashi',
    'yoga',
    'yokohama',
    'you',
    'youtube',
    'yun',
    'zappos',
    'zara',
    'zero',
    'zip',
    'zone',
    'zuerich',
    'cc.ua',
    'inf.ua',
    'ltd.ua',
    'adobeaemcloud.com',
    'adobeaemcloud.net',
    '*.dev.adobeaemcloud.com',
    'beep.pl',
    'barsy.ca',
    '*.compute.estate',
    '*.alces.network',
    'altervista.org',
    'alwaysdata.net',
    'cloudfront.net',
    '*.compute.amazonaws.com',
    '*.compute-1.amazonaws.com',
    '*.compute.amazonaws.com.cn',
    'us-east-1.amazonaws.com',
    'cn-north-1.eb.amazonaws.com.cn',
    'cn-northwest-1.eb.amazonaws.com.cn',
    'elasticbeanstalk.com',
    'ap-northeast-1.elasticbeanstalk.com',
    'ap-northeast-2.elasticbeanstalk.com',
    'ap-northeast-3.elasticbeanstalk.com',
    'ap-south-1.elasticbeanstalk.com',
    'ap-southeast-1.elasticbeanstalk.com',
    'ap-southeast-2.elasticbeanstalk.com',
    'ca-central-1.elasticbeanstalk.com',
    'eu-central-1.elasticbeanstalk.com',
    'eu-west-1.elasticbeanstalk.com',
    'eu-west-2.elasticbeanstalk.com',
    'eu-west-3.elasticbeanstalk.com',
    'sa-east-1.elasticbeanstalk.com',
    'us-east-1.elasticbeanstalk.com',
    'us-east-2.elasticbeanstalk.com',
    'us-gov-west-1.elasticbeanstalk.com',
    'us-west-1.elasticbeanstalk.com',
    'us-west-2.elasticbeanstalk.com',
    '*.elb.amazonaws.com',
    '*.elb.amazonaws.com.cn',
    's3.amazonaws.com',
    's3-ap-northeast-1.amazonaws.com',
    's3-ap-northeast-2.amazonaws.com',
    's3-ap-south-1.amazonaws.com',
    's3-ap-southeast-1.amazonaws.com',
    's3-ap-southeast-2.amazonaws.com',
    's3-ca-central-1.amazonaws.com',
    's3-eu-central-1.amazonaws.com',
    's3-eu-west-1.amazonaws.com',
    's3-eu-west-2.amazonaws.com',
    's3-eu-west-3.amazonaws.com',
    's3-external-1.amazonaws.com',
    's3-fips-us-gov-west-1.amazonaws.com',
    's3-sa-east-1.amazonaws.com',
    's3-us-gov-west-1.amazonaws.com',
    's3-us-east-2.amazonaws.com',
    's3-us-west-1.amazonaws.com',
    's3-us-west-2.amazonaws.com',
    's3.ap-northeast-2.amazonaws.com',
    's3.ap-south-1.amazonaws.com',
    's3.cn-north-1.amazonaws.com.cn',
    's3.ca-central-1.amazonaws.com',
    's3.eu-central-1.amazonaws.com',
    's3.eu-west-2.amazonaws.com',
    's3.eu-west-3.amazonaws.com',
    's3.us-east-2.amazonaws.com',
    's3.dualstack.ap-northeast-1.amazonaws.com',
    's3.dualstack.ap-northeast-2.amazonaws.com',
    's3.dualstack.ap-south-1.amazonaws.com',
    's3.dualstack.ap-southeast-1.amazonaws.com',
    's3.dualstack.ap-southeast-2.amazonaws.com',
    's3.dualstack.ca-central-1.amazonaws.com',
    's3.dualstack.eu-central-1.amazonaws.com',
    's3.dualstack.eu-west-1.amazonaws.com',
    's3.dualstack.eu-west-2.amazonaws.com',
    's3.dualstack.eu-west-3.amazonaws.com',
    's3.dualstack.sa-east-1.amazonaws.com',
    's3.dualstack.us-east-1.amazonaws.com',
    's3.dualstack.us-east-2.amazonaws.com',
    's3-website-us-east-1.amazonaws.com',
    's3-website-us-west-1.amazonaws.com',
    's3-website-us-west-2.amazonaws.com',
    's3-website-ap-northeast-1.amazonaws.com',
    's3-website-ap-southeast-1.amazonaws.com',
    's3-website-ap-southeast-2.amazonaws.com',
    's3-website-eu-west-1.amazonaws.com',
    's3-website-sa-east-1.amazonaws.com',
    's3-website.ap-northeast-2.amazonaws.com',
    's3-website.ap-south-1.amazonaws.com',
    's3-website.ca-central-1.amazonaws.com',
    's3-website.eu-central-1.amazonaws.com',
    's3-website.eu-west-2.amazonaws.com',
    's3-website.eu-west-3.amazonaws.com',
    's3-website.us-east-2.amazonaws.com',
    'amsw.nl',
    't3l3p0rt.net',
    'tele.amune.org',
    'apigee.io',
    'on-aptible.com',
    'user.aseinet.ne.jp',
    'gv.vc',
    'd.gv.vc',
    'user.party.eus',
    'pimienta.org',
    'poivron.org',
    'potager.org',
    'sweetpepper.org',
    'myasustor.com',
    'myfritz.net',
    '*.awdev.ca',
    '*.advisor.ws',
    'b-data.io',
    'backplaneapp.io',
    'balena-devices.com',
    'app.banzaicloud.io',
    'betainabox.com',
    'bnr.la',
    'blackbaudcdn.net',
    'boomla.net',
    'boxfuse.io',
    'square7.ch',
    'bplaced.com',
    'bplaced.de',
    'square7.de',
    'bplaced.net',
    'square7.net',
    'browsersafetymark.io',
    'uk0.bigv.io',
    'dh.bytemark.co.uk',
    'vm.bytemark.co.uk',
    'mycd.eu',
    'carrd.co',
    'crd.co',
    'uwu.ai',
    'ae.org',
    'ar.com',
    'br.com',
    'cn.com',
    'com.de',
    'com.se',
    'de.com',
    'eu.com',
    'gb.com',
    'gb.net',
    'hu.com',
    'hu.net',
    'jp.net',
    'jpn.com',
    'kr.com',
    'mex.com',
    'no.com',
    'qc.com',
    'ru.com',
    'sa.com',
    'se.net',
    'uk.com',
    'uk.net',
    'us.com',
    'uy.com',
    'za.bz',
    'za.com',
    'africa.com',
    'gr.com',
    'in.net',
    'us.org',
    'co.com',
    'c.la',
    'certmgr.org',
    'xenapponazure.com',
    'discourse.group',
    'discourse.team',
    'virtueeldomein.nl',
    'cleverapps.io',
    '*.lcl.dev',
    '*.stg.dev',
    'c66.me',
    'cloud66.ws',
    'cloud66.zone',
    'jdevcloud.com',
    'wpdevcloud.com',
    'cloudaccess.host',
    'freesite.host',
    'cloudaccess.net',
    'cloudcontrolled.com',
    'cloudcontrolapp.com',
    'cloudera.site',
    'trycloudflare.com',
    'workers.dev',
    'wnext.app',
    'co.ca',
    '*.otap.co',
    'co.cz',
    'c.cdn77.org',
    'cdn77-ssl.net',
    'r.cdn77.net',
    'rsc.cdn77.org',
    'ssl.origin.cdn77-secure.org',
    'cloudns.asia',
    'cloudns.biz',
    'cloudns.club',
    'cloudns.cc',
    'cloudns.eu',
    'cloudns.in',
    'cloudns.info',
    'cloudns.org',
    'cloudns.pro',
    'cloudns.pw',
    'cloudns.us',
    'cloudeity.net',
    'cnpy.gdn',
    'co.nl',
    'co.no',
    'webhosting.be',
    'hosting-cluster.nl',
    'ac.ru',
    'edu.ru',
    'gov.ru',
    'int.ru',
    'mil.ru',
    'test.ru',
    'dyn.cosidns.de',
    'dynamisches-dns.de',
    'dnsupdater.de',
    'internet-dns.de',
    'l-o-g-i-n.de',
    'dynamic-dns.info',
    'feste-ip.net',
    'knx-server.net',
    'static-access.net',
    'realm.cz',
    '*.cryptonomic.net',
    'cupcake.is',
    '*.customer-oci.com',
    '*.oci.customer-oci.com',
    '*.ocp.customer-oci.com',
    '*.ocs.customer-oci.com',
    'cyon.link',
    'cyon.site',
    'daplie.me',
    'localhost.daplie.me',
    'dattolocal.com',
    'dattorelay.com',
    'dattoweb.com',
    'mydatto.com',
    'dattolocal.net',
    'mydatto.net',
    'biz.dk',
    'co.dk',
    'firm.dk',
    'reg.dk',
    'store.dk',
    '*.dapps.earth',
    '*.bzz.dapps.earth',
    'builtwithdark.com',
    'edgestack.me',
    'debian.net',
    'dedyn.io',
    'dnshome.de',
    'online.th',
    'shop.th',
    'drayddns.com',
    'dreamhosters.com',
    'mydrobo.com',
    'drud.io',
    'drud.us',
    'duckdns.org',
    'dy.fi',
    'tunk.org',
    'dyndns-at-home.com',
    'dyndns-at-work.com',
    'dyndns-blog.com',
    'dyndns-free.com',
    'dyndns-home.com',
    'dyndns-ip.com',
    'dyndns-mail.com',
    'dyndns-office.com',
    'dyndns-pics.com',
    'dyndns-remote.com',
    'dyndns-server.com',
    'dyndns-web.com',
    'dyndns-wiki.com',
    'dyndns-work.com',
    'dyndns.biz',
    'dyndns.info',
    'dyndns.org',
    'dyndns.tv',
    'at-band-camp.net',
    'ath.cx',
    'barrel-of-knowledge.info',
    'barrell-of-knowledge.info',
    'better-than.tv',
    'blogdns.com',
    'blogdns.net',
    'blogdns.org',
    'blogsite.org',
    'boldlygoingnowhere.org',
    'broke-it.net',
    'buyshouses.net',
    'cechire.com',
    'dnsalias.com',
    'dnsalias.net',
    'dnsalias.org',
    'dnsdojo.com',
    'dnsdojo.net',
    'dnsdojo.org',
    'does-it.net',
    'doesntexist.com',
    'doesntexist.org',
    'dontexist.com',
    'dontexist.net',
    'dontexist.org',
    'doomdns.com',
    'doomdns.org',
    'dvrdns.org',
    'dyn-o-saur.com',
    'dynalias.com',
    'dynalias.net',
    'dynalias.org',
    'dynathome.net',
    'dyndns.ws',
    'endofinternet.net',
    'endofinternet.org',
    'endoftheinternet.org',
    'est-a-la-maison.com',
    'est-a-la-masion.com',
    'est-le-patron.com',
    'est-mon-blogueur.com',
    'for-better.biz',
    'for-more.biz',
    'for-our.info',
    'for-some.biz',
    'for-the.biz',
    'forgot.her.name',
    'forgot.his.name',
    'from-ak.com',
    'from-al.com',
    'from-ar.com',
    'from-az.net',
    'from-ca.com',
    'from-co.net',
    'from-ct.com',
    'from-dc.com',
    'from-de.com',
    'from-fl.com',
    'from-ga.com',
    'from-hi.com',
    'from-ia.com',
    'from-id.com',
    'from-il.com',
    'from-in.com',
    'from-ks.com',
    'from-ky.com',
    'from-la.net',
    'from-ma.com',
    'from-md.com',
    'from-me.org',
    'from-mi.com',
    'from-mn.com',
    'from-mo.com',
    'from-ms.com',
    'from-mt.com',
    'from-nc.com',
    'from-nd.com',
    'from-ne.com',
    'from-nh.com',
    'from-nj.com',
    'from-nm.com',
    'from-nv.com',
    'from-ny.net',
    'from-oh.com',
    'from-ok.com',
    'from-or.com',
    'from-pa.com',
    'from-pr.com',
    'from-ri.com',
    'from-sc.com',
    'from-sd.com',
    'from-tn.com',
    'from-tx.com',
    'from-ut.com',
    'from-va.com',
    'from-vt.com',
    'from-wa.com',
    'from-wi.com',
    'from-wv.com',
    'from-wy.com',
    'ftpaccess.cc',
    'fuettertdasnetz.de',
    'game-host.org',
    'game-server.cc',
    'getmyip.com',
    'gets-it.net',
    'go.dyndns.org',
    'gotdns.com',
    'gotdns.org',
    'groks-the.info',
    'groks-this.info',
    'ham-radio-op.net',
    'here-for-more.info',
    'hobby-site.com',
    'hobby-site.org',
    'home.dyndns.org',
    'homedns.org',
    'homeftp.net',
    'homeftp.org',
    'homeip.net',
    'homelinux.com',
    'homelinux.net',
    'homelinux.org',
    'homeunix.com',
    'homeunix.net',
    'homeunix.org',
    'iamallama.com',
    'in-the-band.net',
    'is-a-anarchist.com',
    'is-a-blogger.com',
    'is-a-bookkeeper.com',
    'is-a-bruinsfan.org',
    'is-a-bulls-fan.com',
    'is-a-candidate.org',
    'is-a-caterer.com',
    'is-a-celticsfan.org',
    'is-a-chef.com',
    'is-a-chef.net',
    'is-a-chef.org',
    'is-a-conservative.com',
    'is-a-cpa.com',
    'is-a-cubicle-slave.com',
    'is-a-democrat.com',
    'is-a-designer.com',
    'is-a-doctor.com',
    'is-a-financialadvisor.com',
    'is-a-geek.com',
    'is-a-geek.net',
    'is-a-geek.org',
    'is-a-green.com',
    'is-a-guru.com',
    'is-a-hard-worker.com',
    'is-a-hunter.com',
    'is-a-knight.org',
    'is-a-landscaper.com',
    'is-a-lawyer.com',
    'is-a-liberal.com',
    'is-a-libertarian.com',
    'is-a-linux-user.org',
    'is-a-llama.com',
    'is-a-musician.com',
    'is-a-nascarfan.com',
    'is-a-nurse.com',
    'is-a-painter.com',
    'is-a-patsfan.org',
    'is-a-personaltrainer.com',
    'is-a-photographer.com',
    'is-a-player.com',
    'is-a-republican.com',
    'is-a-rockstar.com',
    'is-a-socialist.com',
    'is-a-soxfan.org',
    'is-a-student.com',
    'is-a-teacher.com',
    'is-a-techie.com',
    'is-a-therapist.com',
    'is-an-accountant.com',
    'is-an-actor.com',
    'is-an-actress.com',
    'is-an-anarchist.com',
    'is-an-artist.com',
    'is-an-engineer.com',
    'is-an-entertainer.com',
    'is-by.us',
    'is-certified.com',
    'is-found.org',
    'is-gone.com',
    'is-into-anime.com',
    'is-into-cars.com',
    'is-into-cartoons.com',
    'is-into-games.com',
    'is-leet.com',
    'is-lost.org',
    'is-not-certified.com',
    'is-saved.org',
    'is-slick.com',
    'is-uberleet.com',
    'is-very-bad.org',
    'is-very-evil.org',
    'is-very-good.org',
    'is-very-nice.org',
    'is-very-sweet.org',
    'is-with-theband.com',
    'isa-geek.com',
    'isa-geek.net',
    'isa-geek.org',
    'isa-hockeynut.com',
    'issmarterthanyou.com',
    'isteingeek.de',
    'istmein.de',
    'kicks-ass.net',
    'kicks-ass.org',
    'knowsitall.info',
    'land-4-sale.us',
    'lebtimnetz.de',
    'leitungsen.de',
    'likes-pie.com',
    'likescandy.com',
    'merseine.nu',
    'mine.nu',
    'misconfused.org',
    'mypets.ws',
    'myphotos.cc',
    'neat-url.com',
    'office-on-the.net',
    'on-the-web.tv',
    'podzone.net',
    'podzone.org',
    'readmyblog.org',
    'saves-the-whales.com',
    'scrapper-site.net',
    'scrapping.cc',
    'selfip.biz',
    'selfip.com',
    'selfip.info',
    'selfip.net',
    'selfip.org',
    'sells-for-less.com',
    'sells-for-u.com',
    'sells-it.net',
    'sellsyourhome.org',
    'servebbs.com',
    'servebbs.net',
    'servebbs.org',
    'serveftp.net',
    'serveftp.org',
    'servegame.org',
    'shacknet.nu',
    'simple-url.com',
    'space-to-rent.com',
    'stuff-4-sale.org',
    'stuff-4-sale.us',
    'teaches-yoga.com',
    'thruhere.net',
    'traeumtgerade.de',
    'webhop.biz',
    'webhop.info',
    'webhop.net',
    'webhop.org',
    'worse-than.tv',
    'writesthisblog.com',
    'ddnss.de',
    'dyn.ddnss.de',
    'dyndns.ddnss.de',
    'dyndns1.de',
    'dyn-ip24.de',
    'home-webserver.de',
    'dyn.home-webserver.de',
    'myhome-server.de',
    'ddnss.org',
    'definima.net',
    'definima.io',
    'bci.dnstrace.pro',
    'ddnsfree.com',
    'ddnsgeek.com',
    'giize.com',
    'gleeze.com',
    'kozow.com',
    'loseyourip.com',
    'ooguy.com',
    'theworkpc.com',
    'casacam.net',
    'dynu.net',
    'accesscam.org',
    'camdvr.org',
    'freeddns.org',
    'mywire.org',
    'webredirect.org',
    'myddns.rocks',
    'blogsite.xyz',
    'dynv6.net',
    'e4.cz',
    'en-root.fr',
    'mytuleap.com',
    'onred.one',
    'staging.onred.one',
    'enonic.io',
    'customer.enonic.io',
    'eu.org',
    'al.eu.org',
    'asso.eu.org',
    'at.eu.org',
    'au.eu.org',
    'be.eu.org',
    'bg.eu.org',
    'ca.eu.org',
    'cd.eu.org',
    'ch.eu.org',
    'cn.eu.org',
    'cy.eu.org',
    'cz.eu.org',
    'de.eu.org',
    'dk.eu.org',
    'edu.eu.org',
    'ee.eu.org',
    'es.eu.org',
    'fi.eu.org',
    'fr.eu.org',
    'gr.eu.org',
    'hr.eu.org',
    'hu.eu.org',
    'ie.eu.org',
    'il.eu.org',
    'in.eu.org',
    'int.eu.org',
    'is.eu.org',
    'it.eu.org',
    'jp.eu.org',
    'kr.eu.org',
    'lt.eu.org',
    'lu.eu.org',
    'lv.eu.org',
    'mc.eu.org',
    'me.eu.org',
    'mk.eu.org',
    'mt.eu.org',
    'my.eu.org',
    'net.eu.org',
    'ng.eu.org',
    'nl.eu.org',
    'no.eu.org',
    'nz.eu.org',
    'paris.eu.org',
    'pl.eu.org',
    'pt.eu.org',
    'q-a.eu.org',
    'ro.eu.org',
    'ru.eu.org',
    'se.eu.org',
    'si.eu.org',
    'sk.eu.org',
    'tr.eu.org',
    'uk.eu.org',
    'us.eu.org',
    'eu-1.evennode.com',
    'eu-2.evennode.com',
    'eu-3.evennode.com',
    'eu-4.evennode.com',
    'us-1.evennode.com',
    'us-2.evennode.com',
    'us-3.evennode.com',
    'us-4.evennode.com',
    'twmail.cc',
    'twmail.net',
    'twmail.org',
    'mymailer.com.tw',
    'url.tw',
    'apps.fbsbx.com',
    'ru.net',
    'adygeya.ru',
    'bashkiria.ru',
    'bir.ru',
    'cbg.ru',
    'com.ru',
    'dagestan.ru',
    'grozny.ru',
    'kalmykia.ru',
    'kustanai.ru',
    'marine.ru',
    'mordovia.ru',
    'msk.ru',
    'mytis.ru',
    'nalchik.ru',
    'nov.ru',
    'pyatigorsk.ru',
    'spb.ru',
    'vladikavkaz.ru',
    'vladimir.ru',
    'abkhazia.su',
    'adygeya.su',
    'aktyubinsk.su',
    'arkhangelsk.su',
    'armenia.su',
    'ashgabad.su',
    'azerbaijan.su',
    'balashov.su',
    'bashkiria.su',
    'bryansk.su',
    'bukhara.su',
    'chimkent.su',
    'dagestan.su',
    'east-kazakhstan.su',
    'exnet.su',
    'georgia.su',
    'grozny.su',
    'ivanovo.su',
    'jambyl.su',
    'kalmykia.su',
    'kaluga.su',
    'karacol.su',
    'karaganda.su',
    'karelia.su',
    'khakassia.su',
    'krasnodar.su',
    'kurgan.su',
    'kustanai.su',
    'lenug.su',
    'mangyshlak.su',
    'mordovia.su',
    'msk.su',
    'murmansk.su',
    'nalchik.su',
    'navoi.su',
    'north-kazakhstan.su',
    'nov.su',
    'obninsk.su',
    'penza.su',
    'pokrovsk.su',
    'sochi.su',
    'spb.su',
    'tashkent.su',
    'termez.su',
    'togliatti.su',
    'troitsk.su',
    'tselinograd.su',
    'tula.su',
    'tuva.su',
    'vladikavkaz.su',
    'vladimir.su',
    'vologda.su',
    'channelsdvr.net',
    'u.channelsdvr.net',
    'fastly-terrarium.com',
    'fastlylb.net',
    'map.fastlylb.net',
    'freetls.fastly.net',
    'map.fastly.net',
    'a.prod.fastly.net',
    'global.prod.fastly.net',
    'a.ssl.fastly.net',
    'b.ssl.fastly.net',
    'global.ssl.fastly.net',
    'fastpanel.direct',
    'fastvps-server.com',
    'fhapp.xyz',
    'fedorainfracloud.org',
    'fedorapeople.org',
    'cloud.fedoraproject.org',
    'app.os.fedoraproject.org',
    'app.os.stg.fedoraproject.org',
    'mydobiss.com',
    'filegear.me',
    'filegear-au.me',
    'filegear-de.me',
    'filegear-gb.me',
    'filegear-ie.me',
    'filegear-jp.me',
    'filegear-sg.me',
    'firebaseapp.com',
    'flynnhub.com',
    'flynnhosting.net',
    '0e.vc',
    'freebox-os.com',
    'freeboxos.com',
    'fbx-os.fr',
    'fbxos.fr',
    'freebox-os.fr',
    'freeboxos.fr',
    'freedesktop.org',
    '*.futurecms.at',
    '*.ex.futurecms.at',
    '*.in.futurecms.at',
    'futurehosting.at',
    'futuremailing.at',
    '*.ex.ortsinfo.at',
    '*.kunden.ortsinfo.at',
    '*.statics.cloud',
    'service.gov.uk',
    'gehirn.ne.jp',
    'usercontent.jp',
    'gentapps.com',
    'lab.ms',
    'github.io',
    'githubusercontent.com',
    'gitlab.io',
    'glitch.me',
    'lolipop.io',
    'cloudapps.digital',
    'london.cloudapps.digital',
    'homeoffice.gov.uk',
    'ro.im',
    'shop.ro',
    'goip.de',
    'run.app',
    'a.run.app',
    'web.app',
    '*.0emm.com',
    'appspot.com',
    '*.r.appspot.com',
    'blogspot.ae',
    'blogspot.al',
    'blogspot.am',
    'blogspot.ba',
    'blogspot.be',
    'blogspot.bg',
    'blogspot.bj',
    'blogspot.ca',
    'blogspot.cf',
    'blogspot.ch',
    'blogspot.cl',
    'blogspot.co.at',
    'blogspot.co.id',
    'blogspot.co.il',
    'blogspot.co.ke',
    'blogspot.co.nz',
    'blogspot.co.uk',
    'blogspot.co.za',
    'blogspot.com',
    'blogspot.com.ar',
    'blogspot.com.au',
    'blogspot.com.br',
    'blogspot.com.by',
    'blogspot.com.co',
    'blogspot.com.cy',
    'blogspot.com.ee',
    'blogspot.com.eg',
    'blogspot.com.es',
    'blogspot.com.mt',
    'blogspot.com.ng',
    'blogspot.com.tr',
    'blogspot.com.uy',
    'blogspot.cv',
    'blogspot.cz',
    'blogspot.de',
    'blogspot.dk',
    'blogspot.fi',
    'blogspot.fr',
    'blogspot.gr',
    'blogspot.hk',
    'blogspot.hr',
    'blogspot.hu',
    'blogspot.ie',
    'blogspot.in',
    'blogspot.is',
    'blogspot.it',
    'blogspot.jp',
    'blogspot.kr',
    'blogspot.li',
    'blogspot.lt',
    'blogspot.lu',
    'blogspot.md',
    'blogspot.mk',
    'blogspot.mr',
    'blogspot.mx',
    'blogspot.my',
    'blogspot.nl',
    'blogspot.no',
    'blogspot.pe',
    'blogspot.pt',
    'blogspot.qa',
    'blogspot.re',
    'blogspot.ro',
    'blogspot.rs',
    'blogspot.ru',
    'blogspot.se',
    'blogspot.sg',
    'blogspot.si',
    'blogspot.sk',
    'blogspot.sn',
    'blogspot.td',
    'blogspot.tw',
    'blogspot.ug',
    'blogspot.vn',
    'cloudfunctions.net',
    'cloud.goog',
    'codespot.com',
    'googleapis.com',
    'googlecode.com',
    'pagespeedmobilizer.com',
    'publishproxy.com',
    'withgoogle.com',
    'withyoutube.com',
    'awsmppl.com',
    'fin.ci',
    'free.hr',
    'caa.li',
    'ua.rs',
    'conf.se',
    'hs.zone',
    'hs.run',
    'hashbang.sh',
    'hasura.app',
    'hasura-app.io',
    'hepforge.org',
    'herokuapp.com',
    'herokussl.com',
    'myravendb.com',
    'ravendb.community',
    'ravendb.me',
    'development.run',
    'ravendb.run',
    'bpl.biz',
    'orx.biz',
    'ng.city',
    'biz.gl',
    'ng.ink',
    'col.ng',
    'firm.ng',
    'gen.ng',
    'ltd.ng',
    'ngo.ng',
    'ng.school',
    'sch.so',
    'h\xE4kkinen.fi',
    '*.moonscale.io',
    'moonscale.net',
    'iki.fi',
    'dyn-berlin.de',
    'in-berlin.de',
    'in-brb.de',
    'in-butter.de',
    'in-dsl.de',
    'in-dsl.net',
    'in-dsl.org',
    'in-vpn.de',
    'in-vpn.net',
    'in-vpn.org',
    'biz.at',
    'info.at',
    'info.cx',
    'ac.leg.br',
    'al.leg.br',
    'am.leg.br',
    'ap.leg.br',
    'ba.leg.br',
    'ce.leg.br',
    'df.leg.br',
    'es.leg.br',
    'go.leg.br',
    'ma.leg.br',
    'mg.leg.br',
    'ms.leg.br',
    'mt.leg.br',
    'pa.leg.br',
    'pb.leg.br',
    'pe.leg.br',
    'pi.leg.br',
    'pr.leg.br',
    'rj.leg.br',
    'rn.leg.br',
    'ro.leg.br',
    'rr.leg.br',
    'rs.leg.br',
    'sc.leg.br',
    'se.leg.br',
    'sp.leg.br',
    'to.leg.br',
    'pixolino.com',
    'ipifony.net',
    'mein-iserv.de',
    'test-iserv.de',
    'iserv.dev',
    'iobb.net',
    'myjino.ru',
    '*.hosting.myjino.ru',
    '*.landing.myjino.ru',
    '*.spectrum.myjino.ru',
    '*.vps.myjino.ru',
    '*.triton.zone',
    '*.cns.joyent.com',
    'js.org',
    'kaas.gg',
    'khplay.nl',
    'keymachine.de',
    'kinghost.net',
    'uni5.net',
    'knightpoint.systems',
    'oya.to',
    'co.krd',
    'edu.krd',
    'git-repos.de',
    'lcube-server.de',
    'svn-repos.de',
    'leadpages.co',
    'lpages.co',
    'lpusercontent.com',
    'lelux.site',
    'co.business',
    'co.education',
    'co.events',
    'co.financial',
    'co.network',
    'co.place',
    'co.technology',
    'app.lmpm.com',
    'linkitools.space',
    'linkyard.cloud',
    'linkyard-cloud.ch',
    'members.linode.com',
    'nodebalancer.linode.com',
    'we.bs',
    'loginline.app',
    'loginline.dev',
    'loginline.io',
    'loginline.services',
    'loginline.site',
    'krasnik.pl',
    'leczna.pl',
    'lubartow.pl',
    'lublin.pl',
    'poniatowa.pl',
    'swidnik.pl',
    'uklugs.org',
    'glug.org.uk',
    'lug.org.uk',
    'lugs.org.uk',
    'barsy.bg',
    'barsy.co.uk',
    'barsyonline.co.uk',
    'barsycenter.com',
    'barsyonline.com',
    'barsy.club',
    'barsy.de',
    'barsy.eu',
    'barsy.in',
    'barsy.info',
    'barsy.io',
    'barsy.me',
    'barsy.menu',
    'barsy.mobi',
    'barsy.net',
    'barsy.online',
    'barsy.org',
    'barsy.pro',
    'barsy.pub',
    'barsy.shop',
    'barsy.site',
    'barsy.support',
    'barsy.uk',
    '*.magentosite.cloud',
    'mayfirst.info',
    'mayfirst.org',
    'hb.cldmail.ru',
    'miniserver.com',
    'memset.net',
    'cloud.metacentrum.cz',
    'custom.metacentrum.cz',
    'flt.cloud.muni.cz',
    'usr.cloud.muni.cz',
    'meteorapp.com',
    'eu.meteorapp.com',
    'co.pl',
    'azurecontainer.io',
    'azurewebsites.net',
    'azure-mobile.net',
    'cloudapp.net',
    'mozilla-iot.org',
    'bmoattachments.org',
    'net.ru',
    'org.ru',
    'pp.ru',
    'ui.nabu.casa',
    'pony.club',
    'of.fashion',
    'on.fashion',
    'of.football',
    'in.london',
    'of.london',
    'for.men',
    'and.mom',
    'for.mom',
    'for.one',
    'for.sale',
    'of.work',
    'to.work',
    'nctu.me',
    'bitballoon.com',
    'netlify.com',
    '4u.com',
    'ngrok.io',
    'nh-serv.co.uk',
    'nfshost.com',
    'dnsking.ch',
    'mypi.co',
    'n4t.co',
    '001www.com',
    'ddnslive.com',
    'myiphost.com',
    'forumz.info',
    '16-b.it',
    '32-b.it',
    '64-b.it',
    'soundcast.me',
    'tcp4.me',
    'dnsup.net',
    'hicam.net',
    'now-dns.net',
    'ownip.net',
    'vpndns.net',
    'dynserv.org',
    'now-dns.org',
    'x443.pw',
    'now-dns.top',
    'ntdll.top',
    'freeddns.us',
    'crafting.xyz',
    'zapto.xyz',
    'nsupdate.info',
    'nerdpol.ovh',
    'blogsyte.com',
    'brasilia.me',
    'cable-modem.org',
    'ciscofreak.com',
    'collegefan.org',
    'couchpotatofries.org',
    'damnserver.com',
    'ddns.me',
    'ditchyourip.com',
    'dnsfor.me',
    'dnsiskinky.com',
    'dvrcam.info',
    'dynns.com',
    'eating-organic.net',
    'fantasyleague.cc',
    'geekgalaxy.com',
    'golffan.us',
    'health-carereform.com',
    'homesecuritymac.com',
    'homesecuritypc.com',
    'hopto.me',
    'ilovecollege.info',
    'loginto.me',
    'mlbfan.org',
    'mmafan.biz',
    'myactivedirectory.com',
    'mydissent.net',
    'myeffect.net',
    'mymediapc.net',
    'mypsx.net',
    'mysecuritycamera.com',
    'mysecuritycamera.net',
    'mysecuritycamera.org',
    'net-freaks.com',
    'nflfan.org',
    'nhlfan.net',
    'no-ip.ca',
    'no-ip.co.uk',
    'no-ip.net',
    'noip.us',
    'onthewifi.com',
    'pgafan.net',
    'point2this.com',
    'pointto.us',
    'privatizehealthinsurance.net',
    'quicksytes.com',
    'read-books.org',
    'securitytactics.com',
    'serveexchange.com',
    'servehumour.com',
    'servep2p.com',
    'servesarcasm.com',
    'stufftoread.com',
    'ufcfan.org',
    'unusualperson.com',
    'workisboring.com',
    '3utilities.com',
    'bounceme.net',
    'ddns.net',
    'ddnsking.com',
    'gotdns.ch',
    'hopto.org',
    'myftp.biz',
    'myftp.org',
    'myvnc.com',
    'no-ip.biz',
    'no-ip.info',
    'no-ip.org',
    'noip.me',
    'redirectme.net',
    'servebeer.com',
    'serveblog.net',
    'servecounterstrike.com',
    'serveftp.com',
    'servegame.com',
    'servehalflife.com',
    'servehttp.com',
    'serveirc.com',
    'serveminecraft.net',
    'servemp3.com',
    'servepics.com',
    'servequake.com',
    'sytes.net',
    'webhop.me',
    'zapto.org',
    'stage.nodeart.io',
    'nodum.co',
    'nodum.io',
    'pcloud.host',
    'nyc.mn',
    'nom.ae',
    'nom.af',
    'nom.ai',
    'nom.al',
    'nym.by',
    'nom.bz',
    'nym.bz',
    'nom.cl',
    'nym.ec',
    'nom.gd',
    'nom.ge',
    'nom.gl',
    'nym.gr',
    'nom.gt',
    'nym.gy',
    'nym.hk',
    'nom.hn',
    'nym.ie',
    'nom.im',
    'nom.ke',
    'nym.kz',
    'nym.la',
    'nym.lc',
    'nom.li',
    'nym.li',
    'nym.lt',
    'nym.lu',
    'nom.lv',
    'nym.me',
    'nom.mk',
    'nym.mn',
    'nym.mx',
    'nom.nu',
    'nym.nz',
    'nym.pe',
    'nym.pt',
    'nom.pw',
    'nom.qa',
    'nym.ro',
    'nom.rs',
    'nom.si',
    'nym.sk',
    'nom.st',
    'nym.su',
    'nym.sx',
    'nom.tj',
    'nym.tw',
    'nom.ug',
    'nom.uy',
    'nom.vc',
    'nom.vg',
    'static.observableusercontent.com',
    'cya.gg',
    'cloudycluster.net',
    'nid.io',
    'opencraft.hosting',
    'operaunite.com',
    'skygearapp.com',
    'outsystemscloud.com',
    'ownprovider.com',
    'own.pm',
    'ox.rs',
    'oy.lc',
    'pgfog.com',
    'pagefrontapp.com',
    'art.pl',
    'gliwice.pl',
    'krakow.pl',
    'poznan.pl',
    'wroc.pl',
    'zakopane.pl',
    'pantheonsite.io',
    'gotpantheon.com',
    'mypep.link',
    'perspecta.cloud',
    'on-web.fr',
    '*.platform.sh',
    '*.platformsh.site',
    'dyn53.io',
    'co.bn',
    'xen.prgmr.com',
    'priv.at',
    'prvcy.page',
    '*.dweb.link',
    'protonet.io',
    'chirurgiens-dentistes-en-france.fr',
    'byen.site',
    'pubtls.org',
    'qualifioapp.com',
    'qbuser.com',
    'instantcloud.cn',
    'ras.ru',
    'qa2.com',
    'qcx.io',
    '*.sys.qcx.io',
    'dev-myqnapcloud.com',
    'alpha-myqnapcloud.com',
    'myqnapcloud.com',
    '*.quipelements.com',
    'vapor.cloud',
    'vaporcloud.io',
    'rackmaze.com',
    'rackmaze.net',
    '*.on-k3s.io',
    '*.on-rancher.cloud',
    '*.on-rio.io',
    'readthedocs.io',
    'rhcloud.com',
    'app.render.com',
    'onrender.com',
    'repl.co',
    'repl.run',
    'resindevice.io',
    'devices.resinstaging.io',
    'hzc.io',
    'wellbeingzone.eu',
    'ptplus.fit',
    'wellbeingzone.co.uk',
    'git-pages.rit.edu',
    'sandcats.io',
    'logoip.de',
    'logoip.com',
    'schokokeks.net',
    'gov.scot',
    'scrysec.com',
    'firewall-gateway.com',
    'firewall-gateway.de',
    'my-gateway.de',
    'my-router.de',
    'spdns.de',
    'spdns.eu',
    'firewall-gateway.net',
    'my-firewall.org',
    'myfirewall.org',
    'spdns.org',
    'senseering.net',
    'biz.ua',
    'co.ua',
    'pp.ua',
    'shiftedit.io',
    'myshopblocks.com',
    'shopitsite.com',
    'mo-siemens.io',
    '1kapp.com',
    'appchizi.com',
    'applinzi.com',
    'sinaapp.com',
    'vipsinaapp.com',
    'siteleaf.net',
    'bounty-full.com',
    'alpha.bounty-full.com',
    'beta.bounty-full.com',
    'stackhero-network.com',
    'static.land',
    'dev.static.land',
    'sites.static.land',
    'apps.lair.io',
    '*.stolos.io',
    'spacekit.io',
    'customer.speedpartner.de',
    'api.stdlib.com',
    'storj.farm',
    'utwente.io',
    'soc.srcf.net',
    'user.srcf.net',
    'temp-dns.com',
    'applicationcloud.io',
    'scapp.io',
    '*.s5y.io',
    '*.sensiosite.cloud',
    'syncloud.it',
    'diskstation.me',
    'dscloud.biz',
    'dscloud.me',
    'dscloud.mobi',
    'dsmynas.com',
    'dsmynas.net',
    'dsmynas.org',
    'familyds.com',
    'familyds.net',
    'familyds.org',
    'i234.me',
    'myds.me',
    'synology.me',
    'vpnplus.to',
    'direct.quickconnect.to',
    'taifun-dns.de',
    'gda.pl',
    'gdansk.pl',
    'gdynia.pl',
    'med.pl',
    'sopot.pl',
    'edugit.org',
    'telebit.app',
    'telebit.io',
    '*.telebit.xyz',
    'gwiddle.co.uk',
    'thingdustdata.com',
    'cust.dev.thingdust.io',
    'cust.disrec.thingdust.io',
    'cust.prod.thingdust.io',
    'cust.testing.thingdust.io',
    'arvo.network',
    'azimuth.network',
    'bloxcms.com',
    'townnews-staging.com',
    '12hp.at',
    '2ix.at',
    '4lima.at',
    'lima-city.at',
    '12hp.ch',
    '2ix.ch',
    '4lima.ch',
    'lima-city.ch',
    'trafficplex.cloud',
    'de.cool',
    '12hp.de',
    '2ix.de',
    '4lima.de',
    'lima-city.de',
    '1337.pictures',
    'clan.rip',
    'lima-city.rocks',
    'webspace.rocks',
    'lima.zone',
    '*.transurl.be',
    '*.transurl.eu',
    '*.transurl.nl',
    'tuxfamily.org',
    'dd-dns.de',
    'diskstation.eu',
    'diskstation.org',
    'dray-dns.de',
    'draydns.de',
    'dyn-vpn.de',
    'dynvpn.de',
    'mein-vigor.de',
    'my-vigor.de',
    'my-wan.de',
    'syno-ds.de',
    'synology-diskstation.de',
    'synology-ds.de',
    'uber.space',
    '*.uberspace.de',
    'hk.com',
    'hk.org',
    'ltd.hk',
    'inc.hk',
    'virtualuser.de',
    'virtual-user.de',
    'urown.cloud',
    'dnsupdate.info',
    'lib.de.us',
    '2038.io',
    'router.management',
    'v-info.info',
    'voorloper.cloud',
    'v.ua',
    'wafflecell.com',
    '*.webhare.dev',
    'wedeploy.io',
    'wedeploy.me',
    'wedeploy.sh',
    'remotewd.com',
    'wmflabs.org',
    'myforum.community',
    'community-pro.de',
    'diskussionsbereich.de',
    'community-pro.net',
    'meinforum.net',
    'half.host',
    'xnbay.com',
    'u2.xnbay.com',
    'u2-local.xnbay.com',
    'cistron.nl',
    'demon.nl',
    'xs4all.space',
    'yandexcloud.net',
    'storage.yandexcloud.net',
    'website.yandexcloud.net',
    'official.academy',
    'yolasite.com',
    'ybo.faith',
    'yombo.me',
    'homelink.one',
    'ybo.party',
    'ybo.review',
    'ybo.science',
    'ybo.trade',
    'nohost.me',
    'noho.st',
    'za.net',
    'za.org',
    'now.sh',
    'bss.design',
    'basicserver.io',
    'virtualserver.io',
    'enterprisecloud.nu',
  ];
});

// node_modules/psl/index.js
var require_psl = __commonJS((exports2) => {
  'use strict';
  var Punycode = require('punycode');
  var internals = {};
  internals.rules = require_rules().map(function (rule) {
    return {
      rule,
      suffix: rule.replace(/^(\*\.|\!)/, ''),
      punySuffix: -1,
      wildcard: rule.charAt(0) === '*',
      exception: rule.charAt(0) === '!',
    };
  });
  internals.endsWith = function (str, suffix) {
    return str.indexOf(suffix, str.length - suffix.length) !== -1;
  };
  internals.findRule = function (domain) {
    var punyDomain = Punycode.toASCII(domain);
    return internals.rules.reduce(function (memo, rule) {
      if (rule.punySuffix === -1) {
        rule.punySuffix = Punycode.toASCII(rule.suffix);
      }
      if (
        !internals.endsWith(punyDomain, '.' + rule.punySuffix) &&
        punyDomain !== rule.punySuffix
      ) {
        return memo;
      }
      return rule;
    }, null);
  };
  exports2.errorCodes = {
    DOMAIN_TOO_SHORT: 'Domain name too short.',
    DOMAIN_TOO_LONG:
      'Domain name too long. It should be no more than 255 chars.',
    LABEL_STARTS_WITH_DASH: 'Domain name label can not start with a dash.',
    LABEL_ENDS_WITH_DASH: 'Domain name label can not end with a dash.',
    LABEL_TOO_LONG: 'Domain name label should be at most 63 chars long.',
    LABEL_TOO_SHORT: 'Domain name label should be at least 1 character long.',
    LABEL_INVALID_CHARS:
      'Domain name label can only contain alphanumeric characters or dashes.',
  };
  internals.validate = function (input) {
    var ascii = Punycode.toASCII(input);
    if (ascii.length < 1) {
      return 'DOMAIN_TOO_SHORT';
    }
    if (ascii.length > 255) {
      return 'DOMAIN_TOO_LONG';
    }
    var labels = ascii.split('.');
    var label;
    for (var i = 0; i < labels.length; ++i) {
      label = labels[i];
      if (!label.length) {
        return 'LABEL_TOO_SHORT';
      }
      if (label.length > 63) {
        return 'LABEL_TOO_LONG';
      }
      if (label.charAt(0) === '-') {
        return 'LABEL_STARTS_WITH_DASH';
      }
      if (label.charAt(label.length - 1) === '-') {
        return 'LABEL_ENDS_WITH_DASH';
      }
      if (!/^[a-z0-9\-]+$/.test(label)) {
        return 'LABEL_INVALID_CHARS';
      }
    }
  };
  exports2.parse = function (input) {
    if (typeof input !== 'string') {
      throw new TypeError('Domain name must be a string.');
    }
    var domain = input.slice(0).toLowerCase();
    if (domain.charAt(domain.length - 1) === '.') {
      domain = domain.slice(0, domain.length - 1);
    }
    var error = internals.validate(domain);
    if (error) {
      return {
        input,
        error: {
          message: exports2.errorCodes[error],
          code: error,
        },
      };
    }
    var parsed = {
      input,
      tld: null,
      sld: null,
      domain: null,
      subdomain: null,
      listed: false,
    };
    var domainParts = domain.split('.');
    if (domainParts[domainParts.length - 1] === 'local') {
      return parsed;
    }
    var handlePunycode = function () {
      if (!/xn--/.test(domain)) {
        return parsed;
      }
      if (parsed.domain) {
        parsed.domain = Punycode.toASCII(parsed.domain);
      }
      if (parsed.subdomain) {
        parsed.subdomain = Punycode.toASCII(parsed.subdomain);
      }
      return parsed;
    };
    var rule = internals.findRule(domain);
    if (!rule) {
      if (domainParts.length < 2) {
        return parsed;
      }
      parsed.tld = domainParts.pop();
      parsed.sld = domainParts.pop();
      parsed.domain = [parsed.sld, parsed.tld].join('.');
      if (domainParts.length) {
        parsed.subdomain = domainParts.pop();
      }
      return handlePunycode();
    }
    parsed.listed = true;
    var tldParts = rule.suffix.split('.');
    var privateParts = domainParts.slice(
      0,
      domainParts.length - tldParts.length,
    );
    if (rule.exception) {
      privateParts.push(tldParts.shift());
    }
    parsed.tld = tldParts.join('.');
    if (!privateParts.length) {
      return handlePunycode();
    }
    if (rule.wildcard) {
      tldParts.unshift(privateParts.pop());
      parsed.tld = tldParts.join('.');
    }
    if (!privateParts.length) {
      return handlePunycode();
    }
    parsed.sld = privateParts.pop();
    parsed.domain = [parsed.sld, parsed.tld].join('.');
    if (privateParts.length) {
      parsed.subdomain = privateParts.join('.');
    }
    return handlePunycode();
  };
  exports2.get = function (domain) {
    if (!domain) {
      return null;
    }
    return exports2.parse(domain).domain || null;
  };
  exports2.isValid = function (domain) {
    var parsed = exports2.parse(domain);
    return Boolean(parsed.domain && parsed.listed);
  };
});

// node_modules/tough-cookie/lib/pubsuffix-psl.js
var require_pubsuffix_psl = __commonJS((exports2) => {
  /*!
   * Copyright (c) 2018, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   */
  'use strict';
  var psl = require_psl();
  function getPublicSuffix(domain) {
    return psl.get(domain);
  }
  exports2.getPublicSuffix = getPublicSuffix;
});

// node_modules/tough-cookie/lib/store.js
var require_store = __commonJS((exports2) => {
  /*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   */
  'use strict';
  function Store() {}
  exports2.Store = Store;
  Store.prototype.synchronous = false;
  Store.prototype.findCookie = function (domain, path, key, cb) {
    throw new Error('findCookie is not implemented');
  };
  Store.prototype.findCookies = function (domain, path, cb) {
    throw new Error('findCookies is not implemented');
  };
  Store.prototype.putCookie = function (cookie, cb) {
    throw new Error('putCookie is not implemented');
  };
  Store.prototype.updateCookie = function (oldCookie, newCookie, cb) {
    throw new Error('updateCookie is not implemented');
  };
  Store.prototype.removeCookie = function (domain, path, key, cb) {
    throw new Error('removeCookie is not implemented');
  };
  Store.prototype.removeCookies = function (domain, path, cb) {
    throw new Error('removeCookies is not implemented');
  };
  Store.prototype.removeAllCookies = function (cb) {
    throw new Error('removeAllCookies is not implemented');
  };
  Store.prototype.getAllCookies = function (cb) {
    throw new Error(
      'getAllCookies is not implemented (therefore jar cannot be serialized)',
    );
  };
});

// node_modules/tough-cookie/lib/permuteDomain.js
var require_permuteDomain = __commonJS((exports2) => {
  /*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   */
  'use strict';
  var pubsuffix = require_pubsuffix_psl();
  function permuteDomain(domain) {
    var pubSuf = pubsuffix.getPublicSuffix(domain);
    if (!pubSuf) {
      return null;
    }
    if (pubSuf == domain) {
      return [domain];
    }
    var prefix = domain.slice(0, -(pubSuf.length + 1));
    var parts = prefix.split('.').reverse();
    var cur = pubSuf;
    var permutations = [cur];
    while (parts.length) {
      cur = parts.shift() + '.' + cur;
      permutations.push(cur);
    }
    return permutations;
  }
  exports2.permuteDomain = permuteDomain;
});

// node_modules/tough-cookie/lib/pathMatch.js
var require_pathMatch = __commonJS((exports2) => {
  /*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   */
  'use strict';
  function pathMatch(reqPath, cookiePath) {
    if (cookiePath === reqPath) {
      return true;
    }
    var idx = reqPath.indexOf(cookiePath);
    if (idx === 0) {
      if (cookiePath.substr(-1) === '/') {
        return true;
      }
      if (reqPath.substr(cookiePath.length, 1) === '/') {
        return true;
      }
    }
    return false;
  }
  exports2.pathMatch = pathMatch;
});

// node_modules/tough-cookie/lib/memstore.js
var require_memstore = __commonJS((exports2) => {
  /*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   */
  'use strict';
  var Store = require_store().Store;
  var permuteDomain = require_permuteDomain().permuteDomain;
  var pathMatch = require_pathMatch().pathMatch;
  var util = require('util');
  function MemoryCookieStore() {
    Store.call(this);
    this.idx = {};
  }
  util.inherits(MemoryCookieStore, Store);
  exports2.MemoryCookieStore = MemoryCookieStore;
  MemoryCookieStore.prototype.idx = null;
  MemoryCookieStore.prototype.synchronous = true;
  MemoryCookieStore.prototype.inspect = function () {
    return '{ idx: ' + util.inspect(this.idx, false, 2) + ' }';
  };
  if (util.inspect.custom) {
    MemoryCookieStore.prototype[util.inspect.custom] =
      MemoryCookieStore.prototype.inspect;
  }
  MemoryCookieStore.prototype.findCookie = function (domain, path, key, cb) {
    if (!this.idx[domain]) {
      return cb(null, void 0);
    }
    if (!this.idx[domain][path]) {
      return cb(null, void 0);
    }
    return cb(null, this.idx[domain][path][key] || null);
  };
  MemoryCookieStore.prototype.findCookies = function (domain, path, cb) {
    var results = [];
    if (!domain) {
      return cb(null, []);
    }
    var pathMatcher;
    if (!path) {
      pathMatcher = function matchAll(domainIndex) {
        for (var curPath in domainIndex) {
          var pathIndex = domainIndex[curPath];
          for (var key in pathIndex) {
            results.push(pathIndex[key]);
          }
        }
      };
    } else {
      pathMatcher = function matchRFC(domainIndex) {
        Object.keys(domainIndex).forEach(function (cookiePath) {
          if (pathMatch(path, cookiePath)) {
            var pathIndex = domainIndex[cookiePath];
            for (var key in pathIndex) {
              results.push(pathIndex[key]);
            }
          }
        });
      };
    }
    var domains = permuteDomain(domain) || [domain];
    var idx = this.idx;
    domains.forEach(function (curDomain) {
      var domainIndex = idx[curDomain];
      if (!domainIndex) {
        return;
      }
      pathMatcher(domainIndex);
    });
    cb(null, results);
  };
  MemoryCookieStore.prototype.putCookie = function (cookie, cb) {
    if (!this.idx[cookie.domain]) {
      this.idx[cookie.domain] = {};
    }
    if (!this.idx[cookie.domain][cookie.path]) {
      this.idx[cookie.domain][cookie.path] = {};
    }
    this.idx[cookie.domain][cookie.path][cookie.key] = cookie;
    cb(null);
  };
  MemoryCookieStore.prototype.updateCookie = function (
    oldCookie,
    newCookie,
    cb,
  ) {
    this.putCookie(newCookie, cb);
  };
  MemoryCookieStore.prototype.removeCookie = function (domain, path, key, cb) {
    if (
      this.idx[domain] &&
      this.idx[domain][path] &&
      this.idx[domain][path][key]
    ) {
      delete this.idx[domain][path][key];
    }
    cb(null);
  };
  MemoryCookieStore.prototype.removeCookies = function (domain, path, cb) {
    if (this.idx[domain]) {
      if (path) {
        delete this.idx[domain][path];
      } else {
        delete this.idx[domain];
      }
    }
    return cb(null);
  };
  MemoryCookieStore.prototype.removeAllCookies = function (cb) {
    this.idx = {};
    return cb(null);
  };
  MemoryCookieStore.prototype.getAllCookies = function (cb) {
    var cookies = [];
    var idx = this.idx;
    var domains = Object.keys(idx);
    domains.forEach(function (domain) {
      var paths = Object.keys(idx[domain]);
      paths.forEach(function (path) {
        var keys = Object.keys(idx[domain][path]);
        keys.forEach(function (key) {
          if (key !== null) {
            cookies.push(idx[domain][path][key]);
          }
        });
      });
    });
    cookies.sort(function (a, b) {
      return (a.creationIndex || 0) - (b.creationIndex || 0);
    });
    cb(null, cookies);
  };
});

// node_modules/tough-cookie/lib/version.js
var require_version = __commonJS((exports2, module2) => {
  module2.exports = '2.5.0';
});

// node_modules/tough-cookie/lib/cookie.js
var require_cookie = __commonJS((exports2) => {
  /*!
   * Copyright (c) 2015, Salesforce.com, Inc.
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice,
   * this list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   * this list of conditions and the following disclaimer in the documentation
   * and/or other materials provided with the distribution.
   *
   * 3. Neither the name of Salesforce.com nor the names of its contributors may
   * be used to endorse or promote products derived from this software without
   * specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   * POSSIBILITY OF SUCH DAMAGE.
   */
  'use strict';
  var net = require('net');
  var urlParse = require('url').parse;
  var util = require('util');
  var pubsuffix = require_pubsuffix_psl();
  var Store = require_store().Store;
  var MemoryCookieStore = require_memstore().MemoryCookieStore;
  var pathMatch = require_pathMatch().pathMatch;
  var VERSION = require_version();
  var punycode;
  try {
    punycode = require('punycode');
  } catch (e) {
    console.warn(
      "tough-cookie: can't load punycode; won't use punycode for domain normalization",
    );
  }
  var COOKIE_OCTETS = /^[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]+$/;
  var CONTROL_CHARS = /[\x00-\x1F]/;
  var TERMINATORS = ['\n', '\r', '\0'];
  var PATH_VALUE = /[\x20-\x3A\x3C-\x7E]+/;
  var DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/;
  var MONTH_TO_NUM = {
    jan: 0,
    feb: 1,
    mar: 2,
    apr: 3,
    may: 4,
    jun: 5,
    jul: 6,
    aug: 7,
    sep: 8,
    oct: 9,
    nov: 10,
    dec: 11,
  };
  var NUM_TO_MONTH = [
    'Jan',
    'Feb',
    'Mar',
    'Apr',
    'May',
    'Jun',
    'Jul',
    'Aug',
    'Sep',
    'Oct',
    'Nov',
    'Dec',
  ];
  var NUM_TO_DAY = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
  var MAX_TIME = 2147483647e3;
  var MIN_TIME = 0;
  function parseDigits(token, minDigits, maxDigits, trailingOK) {
    var count = 0;
    while (count < token.length) {
      var c = token.charCodeAt(count);
      if (c <= 47 || c >= 58) {
        break;
      }
      count++;
    }
    if (count < minDigits || count > maxDigits) {
      return null;
    }
    if (!trailingOK && count != token.length) {
      return null;
    }
    return parseInt(token.substr(0, count), 10);
  }
  function parseTime(token) {
    var parts = token.split(':');
    var result = [0, 0, 0];
    if (parts.length !== 3) {
      return null;
    }
    for (var i = 0; i < 3; i++) {
      var trailingOK = i == 2;
      var num = parseDigits(parts[i], 1, 2, trailingOK);
      if (num === null) {
        return null;
      }
      result[i] = num;
    }
    return result;
  }
  function parseMonth(token) {
    token = String(token).substr(0, 3).toLowerCase();
    var num = MONTH_TO_NUM[token];
    return num >= 0 ? num : null;
  }
  function parseDate(str) {
    if (!str) {
      return;
    }
    var tokens = str.split(DATE_DELIM);
    if (!tokens) {
      return;
    }
    var hour = null;
    var minute = null;
    var second = null;
    var dayOfMonth = null;
    var month = null;
    var year = null;
    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i].trim();
      if (!token.length) {
        continue;
      }
      var result;
      if (second === null) {
        result = parseTime(token);
        if (result) {
          hour = result[0];
          minute = result[1];
          second = result[2];
          continue;
        }
      }
      if (dayOfMonth === null) {
        result = parseDigits(token, 1, 2, true);
        if (result !== null) {
          dayOfMonth = result;
          continue;
        }
      }
      if (month === null) {
        result = parseMonth(token);
        if (result !== null) {
          month = result;
          continue;
        }
      }
      if (year === null) {
        result = parseDigits(token, 2, 4, true);
        if (result !== null) {
          year = result;
          if (year >= 70 && year <= 99) {
            year += 1900;
          } else if (year >= 0 && year <= 69) {
            year += 2e3;
          }
        }
      }
    }
    if (
      dayOfMonth === null ||
      month === null ||
      year === null ||
      second === null ||
      dayOfMonth < 1 ||
      dayOfMonth > 31 ||
      year < 1601 ||
      hour > 23 ||
      minute > 59 ||
      second > 59
    ) {
      return;
    }
    return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));
  }
  function formatDate(date) {
    var d = date.getUTCDate();
    d = d >= 10 ? d : '0' + d;
    var h = date.getUTCHours();
    h = h >= 10 ? h : '0' + h;
    var m = date.getUTCMinutes();
    m = m >= 10 ? m : '0' + m;
    var s = date.getUTCSeconds();
    s = s >= 10 ? s : '0' + s;
    return (
      NUM_TO_DAY[date.getUTCDay()] +
      ', ' +
      d +
      ' ' +
      NUM_TO_MONTH[date.getUTCMonth()] +
      ' ' +
      date.getUTCFullYear() +
      ' ' +
      h +
      ':' +
      m +
      ':' +
      s +
      ' GMT'
    );
  }
  function canonicalDomain(str) {
    if (str == null) {
      return null;
    }
    str = str.trim().replace(/^\./, '');
    if (punycode && /[^\u0001-\u007f]/.test(str)) {
      str = punycode.toASCII(str);
    }
    return str.toLowerCase();
  }
  function domainMatch(str, domStr, canonicalize) {
    if (str == null || domStr == null) {
      return null;
    }
    if (canonicalize !== false) {
      str = canonicalDomain(str);
      domStr = canonicalDomain(domStr);
    }
    if (str == domStr) {
      return true;
    }
    if (net.isIP(str)) {
      return false;
    }
    var idx = str.indexOf(domStr);
    if (idx <= 0) {
      return false;
    }
    if (str.length !== domStr.length + idx) {
      return false;
    }
    if (str.substr(idx - 1, 1) !== '.') {
      return false;
    }
    return true;
  }
  function defaultPath(path) {
    if (!path || path.substr(0, 1) !== '/') {
      return '/';
    }
    if (path === '/') {
      return path;
    }
    var rightSlash = path.lastIndexOf('/');
    if (rightSlash === 0) {
      return '/';
    }
    return path.slice(0, rightSlash);
  }
  function trimTerminator(str) {
    for (var t = 0; t < TERMINATORS.length; t++) {
      var terminatorIdx = str.indexOf(TERMINATORS[t]);
      if (terminatorIdx !== -1) {
        str = str.substr(0, terminatorIdx);
      }
    }
    return str;
  }
  function parseCookiePair(cookiePair, looseMode) {
    cookiePair = trimTerminator(cookiePair);
    var firstEq = cookiePair.indexOf('=');
    if (looseMode) {
      if (firstEq === 0) {
        cookiePair = cookiePair.substr(1);
        firstEq = cookiePair.indexOf('=');
      }
    } else {
      if (firstEq <= 0) {
        return;
      }
    }
    var cookieName, cookieValue;
    if (firstEq <= 0) {
      cookieName = '';
      cookieValue = cookiePair.trim();
    } else {
      cookieName = cookiePair.substr(0, firstEq).trim();
      cookieValue = cookiePair.substr(firstEq + 1).trim();
    }
    if (CONTROL_CHARS.test(cookieName) || CONTROL_CHARS.test(cookieValue)) {
      return;
    }
    var c = new Cookie();
    c.key = cookieName;
    c.value = cookieValue;
    return c;
  }
  function parse(str, options) {
    if (!options || typeof options !== 'object') {
      options = {};
    }
    str = str.trim();
    var firstSemi = str.indexOf(';');
    var cookiePair = firstSemi === -1 ? str : str.substr(0, firstSemi);
    var c = parseCookiePair(cookiePair, !!options.loose);
    if (!c) {
      return;
    }
    if (firstSemi === -1) {
      return c;
    }
    var unparsed = str.slice(firstSemi + 1).trim();
    if (unparsed.length === 0) {
      return c;
    }
    var cookie_avs = unparsed.split(';');
    while (cookie_avs.length) {
      var av = cookie_avs.shift().trim();
      if (av.length === 0) {
        continue;
      }
      var av_sep = av.indexOf('=');
      var av_key, av_value;
      if (av_sep === -1) {
        av_key = av;
        av_value = null;
      } else {
        av_key = av.substr(0, av_sep);
        av_value = av.substr(av_sep + 1);
      }
      av_key = av_key.trim().toLowerCase();
      if (av_value) {
        av_value = av_value.trim();
      }
      switch (av_key) {
        case 'expires':
          if (av_value) {
            var exp = parseDate(av_value);
            if (exp) {
              c.expires = exp;
            }
          }
          break;
        case 'max-age':
          if (av_value) {
            if (/^-?[0-9]+$/.test(av_value)) {
              var delta = parseInt(av_value, 10);
              c.setMaxAge(delta);
            }
          }
          break;
        case 'domain':
          if (av_value) {
            var domain = av_value.trim().replace(/^\./, '');
            if (domain) {
              c.domain = domain.toLowerCase();
            }
          }
          break;
        case 'path':
          c.path = av_value && av_value[0] === '/' ? av_value : null;
          break;
        case 'secure':
          c.secure = true;
          break;
        case 'httponly':
          c.httpOnly = true;
          break;
        default:
          c.extensions = c.extensions || [];
          c.extensions.push(av);
          break;
      }
    }
    return c;
  }
  function jsonParse(str) {
    var obj;
    try {
      obj = JSON.parse(str);
    } catch (e) {
      return e;
    }
    return obj;
  }
  function fromJSON(str) {
    if (!str) {
      return null;
    }
    var obj;
    if (typeof str === 'string') {
      obj = jsonParse(str);
      if (obj instanceof Error) {
        return null;
      }
    } else {
      obj = str;
    }
    var c = new Cookie();
    for (var i = 0; i < Cookie.serializableProperties.length; i++) {
      var prop = Cookie.serializableProperties[i];
      if (obj[prop] === void 0 || obj[prop] === Cookie.prototype[prop]) {
        continue;
      }
      if (
        prop === 'expires' ||
        prop === 'creation' ||
        prop === 'lastAccessed'
      ) {
        if (obj[prop] === null) {
          c[prop] = null;
        } else {
          c[prop] = obj[prop] == 'Infinity' ? 'Infinity' : new Date(obj[prop]);
        }
      } else {
        c[prop] = obj[prop];
      }
    }
    return c;
  }
  function cookieCompare(a, b) {
    var cmp = 0;
    var aPathLen = a.path ? a.path.length : 0;
    var bPathLen = b.path ? b.path.length : 0;
    cmp = bPathLen - aPathLen;
    if (cmp !== 0) {
      return cmp;
    }
    var aTime = a.creation ? a.creation.getTime() : MAX_TIME;
    var bTime = b.creation ? b.creation.getTime() : MAX_TIME;
    cmp = aTime - bTime;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = a.creationIndex - b.creationIndex;
    return cmp;
  }
  function permutePath(path) {
    if (path === '/') {
      return ['/'];
    }
    if (path.lastIndexOf('/') === path.length - 1) {
      path = path.substr(0, path.length - 1);
    }
    var permutations = [path];
    while (path.length > 1) {
      var lindex = path.lastIndexOf('/');
      if (lindex === 0) {
        break;
      }
      path = path.substr(0, lindex);
      permutations.push(path);
    }
    permutations.push('/');
    return permutations;
  }
  function getCookieContext(url) {
    if (url instanceof Object) {
      return url;
    }
    try {
      url = decodeURI(url);
    } catch (err) {}
    return urlParse(url);
  }
  function Cookie(options) {
    options = options || {};
    Object.keys(options).forEach(function (prop) {
      if (
        Cookie.prototype.hasOwnProperty(prop) &&
        Cookie.prototype[prop] !== options[prop] &&
        prop.substr(0, 1) !== '_'
      ) {
        this[prop] = options[prop];
      }
    }, this);
    this.creation = this.creation || new Date();
    Object.defineProperty(this, 'creationIndex', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: ++Cookie.cookiesCreated,
    });
  }
  Cookie.cookiesCreated = 0;
  Cookie.parse = parse;
  Cookie.fromJSON = fromJSON;
  Cookie.prototype.key = '';
  Cookie.prototype.value = '';
  Cookie.prototype.expires = 'Infinity';
  Cookie.prototype.maxAge = null;
  Cookie.prototype.domain = null;
  Cookie.prototype.path = null;
  Cookie.prototype.secure = false;
  Cookie.prototype.httpOnly = false;
  Cookie.prototype.extensions = null;
  Cookie.prototype.hostOnly = null;
  Cookie.prototype.pathIsDefault = null;
  Cookie.prototype.creation = null;
  Cookie.prototype.lastAccessed = null;
  Object.defineProperty(Cookie.prototype, 'creationIndex', {
    configurable: true,
    enumerable: false,
    writable: true,
    value: 0,
  });
  Cookie.serializableProperties = Object.keys(Cookie.prototype).filter(
    function (prop) {
      return !(
        Cookie.prototype[prop] instanceof Function ||
        prop === 'creationIndex' ||
        prop.substr(0, 1) === '_'
      );
    },
  );
  Cookie.prototype.inspect = function inspect() {
    var now2 = Date.now();
    return (
      'Cookie="' +
      this.toString() +
      '; hostOnly=' +
      (this.hostOnly != null ? this.hostOnly : '?') +
      '; aAge=' +
      (this.lastAccessed ? now2 - this.lastAccessed.getTime() + 'ms' : '?') +
      '; cAge=' +
      (this.creation ? now2 - this.creation.getTime() + 'ms' : '?') +
      '"'
    );
  };
  if (util.inspect.custom) {
    Cookie.prototype[util.inspect.custom] = Cookie.prototype.inspect;
  }
  Cookie.prototype.toJSON = function () {
    var obj = {};
    var props = Cookie.serializableProperties;
    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      if (this[prop] === Cookie.prototype[prop]) {
        continue;
      }
      if (
        prop === 'expires' ||
        prop === 'creation' ||
        prop === 'lastAccessed'
      ) {
        if (this[prop] === null) {
          obj[prop] = null;
        } else {
          obj[prop] =
            this[prop] == 'Infinity' ? 'Infinity' : this[prop].toISOString();
        }
      } else if (prop === 'maxAge') {
        if (this[prop] !== null) {
          obj[prop] =
            this[prop] == Infinity || this[prop] == -Infinity
              ? this[prop].toString()
              : this[prop];
        }
      } else {
        if (this[prop] !== Cookie.prototype[prop]) {
          obj[prop] = this[prop];
        }
      }
    }
    return obj;
  };
  Cookie.prototype.clone = function () {
    return fromJSON(this.toJSON());
  };
  Cookie.prototype.validate = function validate() {
    if (!COOKIE_OCTETS.test(this.value)) {
      return false;
    }
    if (
      this.expires != Infinity &&
      !(this.expires instanceof Date) &&
      !parseDate(this.expires)
    ) {
      return false;
    }
    if (this.maxAge != null && this.maxAge <= 0) {
      return false;
    }
    if (this.path != null && !PATH_VALUE.test(this.path)) {
      return false;
    }
    var cdomain = this.cdomain();
    if (cdomain) {
      if (cdomain.match(/\.$/)) {
        return false;
      }
      var suffix = pubsuffix.getPublicSuffix(cdomain);
      if (suffix == null) {
        return false;
      }
    }
    return true;
  };
  Cookie.prototype.setExpires = function setExpires(exp) {
    if (exp instanceof Date) {
      this.expires = exp;
    } else {
      this.expires = parseDate(exp) || 'Infinity';
    }
  };
  Cookie.prototype.setMaxAge = function setMaxAge(age) {
    if (age === Infinity || age === -Infinity) {
      this.maxAge = age.toString();
    } else {
      this.maxAge = age;
    }
  };
  Cookie.prototype.cookieString = function cookieString() {
    var val = this.value;
    if (val == null) {
      val = '';
    }
    if (this.key === '') {
      return val;
    }
    return this.key + '=' + val;
  };
  Cookie.prototype.toString = function toString() {
    var str = this.cookieString();
    if (this.expires != Infinity) {
      if (this.expires instanceof Date) {
        str += '; Expires=' + formatDate(this.expires);
      } else {
        str += '; Expires=' + this.expires;
      }
    }
    if (this.maxAge != null && this.maxAge != Infinity) {
      str += '; Max-Age=' + this.maxAge;
    }
    if (this.domain && !this.hostOnly) {
      str += '; Domain=' + this.domain;
    }
    if (this.path) {
      str += '; Path=' + this.path;
    }
    if (this.secure) {
      str += '; Secure';
    }
    if (this.httpOnly) {
      str += '; HttpOnly';
    }
    if (this.extensions) {
      this.extensions.forEach(function (ext) {
        str += '; ' + ext;
      });
    }
    return str;
  };
  Cookie.prototype.TTL = function TTL(now2) {
    if (this.maxAge != null) {
      return this.maxAge <= 0 ? 0 : this.maxAge * 1e3;
    }
    var expires = this.expires;
    if (expires != Infinity) {
      if (!(expires instanceof Date)) {
        expires = parseDate(expires) || Infinity;
      }
      if (expires == Infinity) {
        return Infinity;
      }
      return expires.getTime() - (now2 || Date.now());
    }
    return Infinity;
  };
  Cookie.prototype.expiryTime = function expiryTime(now2) {
    if (this.maxAge != null) {
      var relativeTo = now2 || this.creation || new Date();
      var age = this.maxAge <= 0 ? -Infinity : this.maxAge * 1e3;
      return relativeTo.getTime() + age;
    }
    if (this.expires == Infinity) {
      return Infinity;
    }
    return this.expires.getTime();
  };
  Cookie.prototype.expiryDate = function expiryDate(now2) {
    var millisec = this.expiryTime(now2);
    if (millisec == Infinity) {
      return new Date(MAX_TIME);
    } else if (millisec == -Infinity) {
      return new Date(MIN_TIME);
    } else {
      return new Date(millisec);
    }
  };
  Cookie.prototype.isPersistent = function isPersistent() {
    return this.maxAge != null || this.expires != Infinity;
  };
  Cookie.prototype.cdomain = Cookie.prototype.canonicalizedDomain = function canonicalizedDomain() {
    if (this.domain == null) {
      return null;
    }
    return canonicalDomain(this.domain);
  };
  function CookieJar(store, options) {
    if (typeof options === 'boolean') {
      options = { rejectPublicSuffixes: options };
    } else if (options == null) {
      options = {};
    }
    if (options.rejectPublicSuffixes != null) {
      this.rejectPublicSuffixes = options.rejectPublicSuffixes;
    }
    if (options.looseMode != null) {
      this.enableLooseMode = options.looseMode;
    }
    if (!store) {
      store = new MemoryCookieStore();
    }
    this.store = store;
  }
  CookieJar.prototype.store = null;
  CookieJar.prototype.rejectPublicSuffixes = true;
  CookieJar.prototype.enableLooseMode = false;
  var CAN_BE_SYNC = [];
  CAN_BE_SYNC.push('setCookie');
  CookieJar.prototype.setCookie = function (cookie, url, options, cb) {
    var err;
    var context = getCookieContext(url);
    if (options instanceof Function) {
      cb = options;
      options = {};
    }
    var host = canonicalDomain(context.hostname);
    var loose = this.enableLooseMode;
    if (options.loose != null) {
      loose = options.loose;
    }
    if (!(cookie instanceof Cookie)) {
      cookie = Cookie.parse(cookie, { loose });
    }
    if (!cookie) {
      err = new Error('Cookie failed to parse');
      return cb(options.ignoreError ? null : err);
    }
    var now2 = options.now || new Date();
    if (this.rejectPublicSuffixes && cookie.domain) {
      var suffix = pubsuffix.getPublicSuffix(cookie.cdomain());
      if (suffix == null) {
        err = new Error('Cookie has domain set to a public suffix');
        return cb(options.ignoreError ? null : err);
      }
    }
    if (cookie.domain) {
      if (!domainMatch(host, cookie.cdomain(), false)) {
        err = new Error(
          "Cookie not in this host's domain. Cookie:" +
            cookie.cdomain() +
            ' Request:' +
            host,
        );
        return cb(options.ignoreError ? null : err);
      }
      if (cookie.hostOnly == null) {
        cookie.hostOnly = false;
      }
    } else {
      cookie.hostOnly = true;
      cookie.domain = host;
    }
    if (!cookie.path || cookie.path[0] !== '/') {
      cookie.path = defaultPath(context.pathname);
      cookie.pathIsDefault = true;
    }
    if (options.http === false && cookie.httpOnly) {
      err = new Error("Cookie is HttpOnly and this isn't an HTTP API");
      return cb(options.ignoreError ? null : err);
    }
    var store = this.store;
    if (!store.updateCookie) {
      store.updateCookie = function (oldCookie, newCookie, cb2) {
        this.putCookie(newCookie, cb2);
      };
    }
    function withCookie(err2, oldCookie) {
      if (err2) {
        return cb(err2);
      }
      var next = function (err3) {
        if (err3) {
          return cb(err3);
        } else {
          cb(null, cookie);
        }
      };
      if (oldCookie) {
        if (options.http === false && oldCookie.httpOnly) {
          err2 = new Error("old Cookie is HttpOnly and this isn't an HTTP API");
          return cb(options.ignoreError ? null : err2);
        }
        cookie.creation = oldCookie.creation;
        cookie.creationIndex = oldCookie.creationIndex;
        cookie.lastAccessed = now2;
        store.updateCookie(oldCookie, cookie, next);
      } else {
        cookie.creation = cookie.lastAccessed = now2;
        store.putCookie(cookie, next);
      }
    }
    store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);
  };
  CAN_BE_SYNC.push('getCookies');
  CookieJar.prototype.getCookies = function (url, options, cb) {
    var context = getCookieContext(url);
    if (options instanceof Function) {
      cb = options;
      options = {};
    }
    var host = canonicalDomain(context.hostname);
    var path = context.pathname || '/';
    var secure = options.secure;
    if (
      secure == null &&
      context.protocol &&
      (context.protocol == 'https:' || context.protocol == 'wss:')
    ) {
      secure = true;
    }
    var http = options.http;
    if (http == null) {
      http = true;
    }
    var now2 = options.now || Date.now();
    var expireCheck = options.expire !== false;
    var allPaths = !!options.allPaths;
    var store = this.store;
    function matchingCookie(c) {
      if (c.hostOnly) {
        if (c.domain != host) {
          return false;
        }
      } else {
        if (!domainMatch(host, c.domain, false)) {
          return false;
        }
      }
      if (!allPaths && !pathMatch(path, c.path)) {
        return false;
      }
      if (c.secure && !secure) {
        return false;
      }
      if (c.httpOnly && !http) {
        return false;
      }
      if (expireCheck && c.expiryTime() <= now2) {
        store.removeCookie(c.domain, c.path, c.key, function () {});
        return false;
      }
      return true;
    }
    store.findCookies(host, allPaths ? null : path, function (err, cookies) {
      if (err) {
        return cb(err);
      }
      cookies = cookies.filter(matchingCookie);
      if (options.sort !== false) {
        cookies = cookies.sort(cookieCompare);
      }
      var now3 = new Date();
      cookies.forEach(function (c) {
        c.lastAccessed = now3;
      });
      cb(null, cookies);
    });
  };
  CAN_BE_SYNC.push('getCookieString');
  CookieJar.prototype.getCookieString = function () {
    var args = Array.prototype.slice.call(arguments, 0);
    var cb = args.pop();
    var next = function (err, cookies) {
      if (err) {
        cb(err);
      } else {
        cb(
          null,
          cookies
            .sort(cookieCompare)
            .map(function (c) {
              return c.cookieString();
            })
            .join('; '),
        );
      }
    };
    args.push(next);
    this.getCookies.apply(this, args);
  };
  CAN_BE_SYNC.push('getSetCookieStrings');
  CookieJar.prototype.getSetCookieStrings = function () {
    var args = Array.prototype.slice.call(arguments, 0);
    var cb = args.pop();
    var next = function (err, cookies) {
      if (err) {
        cb(err);
      } else {
        cb(
          null,
          cookies.map(function (c) {
            return c.toString();
          }),
        );
      }
    };
    args.push(next);
    this.getCookies.apply(this, args);
  };
  CAN_BE_SYNC.push('serialize');
  CookieJar.prototype.serialize = function (cb) {
    var type = this.store.constructor.name;
    if (type === 'Object') {
      type = null;
    }
    var serialized = {
      version: 'tough-cookie@' + VERSION,
      storeType: type,
      rejectPublicSuffixes: !!this.rejectPublicSuffixes,
      cookies: [],
    };
    if (
      !(
        this.store.getAllCookies &&
        typeof this.store.getAllCookies === 'function'
      )
    ) {
      return cb(
        new Error(
          'store does not support getAllCookies and cannot be serialized',
        ),
      );
    }
    this.store.getAllCookies(function (err, cookies) {
      if (err) {
        return cb(err);
      }
      serialized.cookies = cookies.map(function (cookie) {
        cookie = cookie instanceof Cookie ? cookie.toJSON() : cookie;
        delete cookie.creationIndex;
        return cookie;
      });
      return cb(null, serialized);
    });
  };
  CookieJar.prototype.toJSON = function () {
    return this.serializeSync();
  };
  CAN_BE_SYNC.push('_importCookies');
  CookieJar.prototype._importCookies = function (serialized, cb) {
    var jar = this;
    var cookies = serialized.cookies;
    if (!cookies || !Array.isArray(cookies)) {
      return cb(new Error('serialized jar has no cookies array'));
    }
    cookies = cookies.slice();
    function putNext(err) {
      if (err) {
        return cb(err);
      }
      if (!cookies.length) {
        return cb(err, jar);
      }
      var cookie;
      try {
        cookie = fromJSON(cookies.shift());
      } catch (e) {
        return cb(e);
      }
      if (cookie === null) {
        return putNext(null);
      }
      jar.store.putCookie(cookie, putNext);
    }
    putNext();
  };
  CookieJar.deserialize = function (strOrObj, store, cb) {
    if (arguments.length !== 3) {
      cb = store;
      store = null;
    }
    var serialized;
    if (typeof strOrObj === 'string') {
      serialized = jsonParse(strOrObj);
      if (serialized instanceof Error) {
        return cb(serialized);
      }
    } else {
      serialized = strOrObj;
    }
    var jar = new CookieJar(store, serialized.rejectPublicSuffixes);
    jar._importCookies(serialized, function (err) {
      if (err) {
        return cb(err);
      }
      cb(null, jar);
    });
  };
  CookieJar.deserializeSync = function (strOrObj, store) {
    var serialized =
      typeof strOrObj === 'string' ? JSON.parse(strOrObj) : strOrObj;
    var jar = new CookieJar(store, serialized.rejectPublicSuffixes);
    if (!jar.store.synchronous) {
      throw new Error(
        'CookieJar store is not synchronous; use async API instead.',
      );
    }
    jar._importCookiesSync(serialized);
    return jar;
  };
  CookieJar.fromJSON = CookieJar.deserializeSync;
  CookieJar.prototype.clone = function (newStore, cb) {
    if (arguments.length === 1) {
      cb = newStore;
      newStore = null;
    }
    this.serialize(function (err, serialized) {
      if (err) {
        return cb(err);
      }
      CookieJar.deserialize(serialized, newStore, cb);
    });
  };
  CAN_BE_SYNC.push('removeAllCookies');
  CookieJar.prototype.removeAllCookies = function (cb) {
    var store = this.store;
    if (
      store.removeAllCookies instanceof Function &&
      store.removeAllCookies !== Store.prototype.removeAllCookies
    ) {
      return store.removeAllCookies(cb);
    }
    store.getAllCookies(function (err, cookies) {
      if (err) {
        return cb(err);
      }
      if (cookies.length === 0) {
        return cb(null);
      }
      var completedCount = 0;
      var removeErrors = [];
      function removeCookieCb(removeErr) {
        if (removeErr) {
          removeErrors.push(removeErr);
        }
        completedCount++;
        if (completedCount === cookies.length) {
          return cb(removeErrors.length ? removeErrors[0] : null);
        }
      }
      cookies.forEach(function (cookie) {
        store.removeCookie(
          cookie.domain,
          cookie.path,
          cookie.key,
          removeCookieCb,
        );
      });
    });
  };
  CookieJar.prototype._cloneSync = syncWrap('clone');
  CookieJar.prototype.cloneSync = function (newStore) {
    if (!newStore.synchronous) {
      throw new Error(
        'CookieJar clone destination store is not synchronous; use async API instead.',
      );
    }
    return this._cloneSync(newStore);
  };
  function syncWrap(method) {
    return function () {
      if (!this.store.synchronous) {
        throw new Error(
          'CookieJar store is not synchronous; use async API instead.',
        );
      }
      var args = Array.prototype.slice.call(arguments);
      var syncErr, syncResult;
      args.push(function syncCb(err, result) {
        syncErr = err;
        syncResult = result;
      });
      this[method].apply(this, args);
      if (syncErr) {
        throw syncErr;
      }
      return syncResult;
    };
  }
  CAN_BE_SYNC.forEach(function (method) {
    CookieJar.prototype[method + 'Sync'] = syncWrap(method);
  });
  exports2.version = VERSION;
  exports2.CookieJar = CookieJar;
  exports2.Cookie = Cookie;
  exports2.Store = Store;
  exports2.MemoryCookieStore = MemoryCookieStore;
  exports2.parseDate = parseDate;
  exports2.formatDate = formatDate;
  exports2.parse = parse;
  exports2.fromJSON = fromJSON;
  exports2.domainMatch = domainMatch;
  exports2.defaultPath = defaultPath;
  exports2.pathMatch = pathMatch;
  exports2.getPublicSuffix = pubsuffix.getPublicSuffix;
  exports2.cookieCompare = cookieCompare;
  exports2.permuteDomain = require_permuteDomain().permuteDomain;
  exports2.permutePath = permutePath;
  exports2.canonicalDomain = canonicalDomain;
});

// node_modules/request/lib/cookies.js
var require_cookies = __commonJS((exports2) => {
  'use strict';
  var tough = require_cookie();
  var Cookie = tough.Cookie;
  var CookieJar = tough.CookieJar;
  exports2.parse = function (str) {
    if (str && str.uri) {
      str = str.uri;
    }
    if (typeof str !== 'string') {
      throw new Error('The cookie function only accepts STRING as param');
    }
    return Cookie.parse(str, { loose: true });
  };
  function RequestJar(store) {
    var self2 = this;
    self2._jar = new CookieJar(store, { looseMode: true });
  }
  RequestJar.prototype.setCookie = function (cookieOrStr, uri, options) {
    var self2 = this;
    return self2._jar.setCookieSync(cookieOrStr, uri, options || {});
  };
  RequestJar.prototype.getCookieString = function (uri) {
    var self2 = this;
    return self2._jar.getCookieStringSync(uri);
  };
  RequestJar.prototype.getCookies = function (uri) {
    var self2 = this;
    return self2._jar.getCookiesSync(uri);
  };
  exports2.jar = function (store) {
    return new RequestJar(store);
  };
});

// node_modules/json-stringify-safe/stringify.js
var require_stringify = __commonJS((exports2, module2) => {
  exports2 = module2.exports = stringify;
  exports2.getSerialize = serializer;
  function stringify(obj, replacer, spaces, cycleReplacer) {
    return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces);
  }
  function serializer(replacer, cycleReplacer) {
    var stack = [],
      keys = [];
    if (cycleReplacer == null)
      cycleReplacer = function (key, value) {
        if (stack[0] === value) return '[Circular ~]';
        return (
          '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']'
        );
      };
    return function (key, value) {
      if (stack.length > 0) {
        var thisPos = stack.indexOf(this);
        ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
        ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
        if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value);
      } else stack.push(value);
      return replacer == null ? value : replacer.call(this, key, value);
    };
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports2, module2) => {
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var buffer = require('buffer');
  var Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (
    Buffer2.from &&
    Buffer2.alloc &&
    Buffer2.allocUnsafe &&
    Buffer2.allocUnsafeSlow
  ) {
    module2.exports = buffer;
  } else {
    copyProps(buffer, exports2);
    exports2.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function (arg, encodingOrOffset, length) {
    if (typeof arg === 'number') {
      throw new TypeError('Argument must not be a number');
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number');
    }
    var buf = Buffer2(size);
    if (fill !== void 0) {
      if (typeof encoding === 'string') {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function (size) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number');
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function (size) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number');
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/request/lib/helpers.js
var require_helpers = __commonJS((exports2) => {
  'use strict';
  var jsonSafeStringify = require_stringify();
  var crypto = require('crypto');
  var Buffer2 = require_safe_buffer().Buffer;
  var defer =
    typeof setImmediate === 'undefined' ? process.nextTick : setImmediate;
  function paramsHaveRequestBody(params) {
    return (
      params.body ||
      params.requestBodyStream ||
      (params.json && typeof params.json !== 'boolean') ||
      params.multipart
    );
  }
  function safeStringify(obj, replacer) {
    var ret;
    try {
      ret = JSON.stringify(obj, replacer);
    } catch (e) {
      ret = jsonSafeStringify(obj, replacer);
    }
    return ret;
  }
  function md5(str) {
    return crypto.createHash('md5').update(str).digest('hex');
  }
  function isReadStream(rs) {
    return rs.readable && rs.path && rs.mode;
  }
  function toBase64(str) {
    return Buffer2.from(str || '', 'utf8').toString('base64');
  }
  function copy(obj) {
    var o = {};
    Object.keys(obj).forEach(function (i) {
      o[i] = obj[i];
    });
    return o;
  }
  function version() {
    var numbers = process.version.replace('v', '').split('.');
    return {
      major: parseInt(numbers[0], 10),
      minor: parseInt(numbers[1], 10),
      patch: parseInt(numbers[2], 10),
    };
  }
  exports2.paramsHaveRequestBody = paramsHaveRequestBody;
  exports2.safeStringify = safeStringify;
  exports2.md5 = md5;
  exports2.isReadStream = isReadStream;
  exports2.toBase64 = toBase64;
  exports2.copy = copy;
  exports2.version = version;
  exports2.defer = defer;
});

// node_modules/aws-sign2/index.js
var require_aws_sign2 = __commonJS((exports2, module2) => {
  /*!
   *  Copyright 2010 LearnBoost <dev@learnboost.com>
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var crypto = require('crypto');
  var parse = require('url').parse;
  var keys = [
    'acl',
    'location',
    'logging',
    'notification',
    'partNumber',
    'policy',
    'requestPayment',
    'torrent',
    'uploadId',
    'uploads',
    'versionId',
    'versioning',
    'versions',
    'website',
  ];
  function authorization(options) {
    return 'AWS ' + options.key + ':' + sign(options);
  }
  module2.exports = authorization;
  module2.exports.authorization = authorization;
  function hmacSha1(options) {
    return crypto
      .createHmac('sha1', options.secret)
      .update(options.message)
      .digest('base64');
  }
  module2.exports.hmacSha1 = hmacSha1;
  function sign(options) {
    options.message = stringToSign(options);
    return hmacSha1(options);
  }
  module2.exports.sign = sign;
  function signQuery(options) {
    options.message = queryStringToSign(options);
    return hmacSha1(options);
  }
  module2.exports.signQuery = signQuery;
  function stringToSign(options) {
    var headers = options.amazonHeaders || '';
    if (headers) headers += '\n';
    var r = [
      options.verb,
      options.md5,
      options.contentType,
      options.date ? options.date.toUTCString() : '',
      headers + options.resource,
    ];
    return r.join('\n');
  }
  module2.exports.stringToSign = stringToSign;
  function queryStringToSign(options) {
    return 'GET\n\n\n' + options.date + '\n' + options.resource;
  }
  module2.exports.queryStringToSign = queryStringToSign;
  function canonicalizeHeaders(headers) {
    var buf = [],
      fields = Object.keys(headers);
    for (var i = 0, len = fields.length; i < len; ++i) {
      var field = fields[i],
        val = headers[field],
        field = field.toLowerCase();
      if (field.indexOf('x-amz') !== 0) continue;
      buf.push(field + ':' + val);
    }
    return buf.sort().join('\n');
  }
  module2.exports.canonicalizeHeaders = canonicalizeHeaders;
  function canonicalizeResource(resource) {
    var url = parse(resource, true),
      path = url.pathname,
      buf = [];
    Object.keys(url.query).forEach(function (key) {
      if (!~keys.indexOf(key)) return;
      var val =
        url.query[key] == '' ? '' : '=' + encodeURIComponent(url.query[key]);
      buf.push(key + val);
    });
    return path + (buf.length ? '?' + buf.sort().join('&') : '');
  }
  module2.exports.canonicalizeResource = canonicalizeResource;
});

// node_modules/aws4/lru.js
var require_lru = __commonJS((exports2, module2) => {
  module2.exports = function (size) {
    return new LruCache(size);
  };
  function LruCache(size) {
    this.capacity = size | 0;
    this.map = Object.create(null);
    this.list = new DoublyLinkedList();
  }
  LruCache.prototype.get = function (key) {
    var node = this.map[key];
    if (node == null) return void 0;
    this.used(node);
    return node.val;
  };
  LruCache.prototype.set = function (key, val) {
    var node = this.map[key];
    if (node != null) {
      node.val = val;
    } else {
      if (!this.capacity) this.prune();
      if (!this.capacity) return false;
      node = new DoublyLinkedNode(key, val);
      this.map[key] = node;
      this.capacity--;
    }
    this.used(node);
    return true;
  };
  LruCache.prototype.used = function (node) {
    this.list.moveToFront(node);
  };
  LruCache.prototype.prune = function () {
    var node = this.list.pop();
    if (node != null) {
      delete this.map[node.key];
      this.capacity++;
    }
  };
  function DoublyLinkedList() {
    this.firstNode = null;
    this.lastNode = null;
  }
  DoublyLinkedList.prototype.moveToFront = function (node) {
    if (this.firstNode == node) return;
    this.remove(node);
    if (this.firstNode == null) {
      this.firstNode = node;
      this.lastNode = node;
      node.prev = null;
      node.next = null;
    } else {
      node.prev = null;
      node.next = this.firstNode;
      node.next.prev = node;
      this.firstNode = node;
    }
  };
  DoublyLinkedList.prototype.pop = function () {
    var lastNode = this.lastNode;
    if (lastNode != null) {
      this.remove(lastNode);
    }
    return lastNode;
  };
  DoublyLinkedList.prototype.remove = function (node) {
    if (this.firstNode == node) {
      this.firstNode = node.next;
    } else if (node.prev != null) {
      node.prev.next = node.next;
    }
    if (this.lastNode == node) {
      this.lastNode = node.prev;
    } else if (node.next != null) {
      node.next.prev = node.prev;
    }
  };
  function DoublyLinkedNode(key, val) {
    this.key = key;
    this.val = val;
    this.prev = null;
    this.next = null;
  }
});

// node_modules/aws4/aws4.js
var require_aws4 = __commonJS((exports2) => {
  var aws4 = exports2;
  var url = require('url');
  var querystring = require('querystring');
  var crypto = require('crypto');
  var lru = require_lru();
  var credentialsCache = lru(1e3);
  function hmac(key, string, encoding) {
    return crypto
      .createHmac('sha256', key)
      .update(string, 'utf8')
      .digest(encoding);
  }
  function hash(string, encoding) {
    return crypto.createHash('sha256').update(string, 'utf8').digest(encoding);
  }
  function encodeRfc3986(urlEncodedString) {
    return urlEncodedString.replace(/[!'()*]/g, function (c) {
      return '%' + c.charCodeAt(0).toString(16).toUpperCase();
    });
  }
  function encodeRfc3986Full(str) {
    return encodeRfc3986(encodeURIComponent(str));
  }
  var HEADERS_TO_IGNORE = {
    authorization: true,
    connection: true,
    'x-amzn-trace-id': true,
    'user-agent': true,
    expect: true,
    'presigned-expires': true,
    range: true,
  };
  function RequestSigner(request, credentials) {
    if (typeof request === 'string') request = url.parse(request);
    var headers = (request.headers = request.headers || {}),
      hostParts =
        (!this.service || !this.region) &&
        this.matchHost(
          request.hostname || request.host || headers.Host || headers.host,
        );
    this.request = request;
    this.credentials = credentials || this.defaultCredentials();
    this.service = request.service || hostParts[0] || '';
    this.region = request.region || hostParts[1] || 'us-east-1';
    if (this.service === 'email') this.service = 'ses';
    if (!request.method && request.body) request.method = 'POST';
    if (!headers.Host && !headers.host) {
      headers.Host = request.hostname || request.host || this.createHost();
      if (request.port) headers.Host += ':' + request.port;
    }
    if (!request.hostname && !request.host)
      request.hostname = headers.Host || headers.host;
    this.isCodeCommitGit =
      this.service === 'codecommit' && request.method === 'GIT';
  }
  RequestSigner.prototype.matchHost = function (host) {
    var match = (host || '').match(
      /([^\.]+)\.(?:([^\.]*)\.)?amazonaws\.com(\.cn)?$/,
    );
    var hostParts = (match || []).slice(1, 3);
    if (hostParts[1] === 'es') hostParts = hostParts.reverse();
    if (hostParts[1] == 's3') {
      hostParts[0] = 's3';
      hostParts[1] = 'us-east-1';
    } else {
      for (var i = 0; i < 2; i++) {
        if (/^s3-/.test(hostParts[i])) {
          hostParts[1] = hostParts[i].slice(3);
          hostParts[0] = 's3';
          break;
        }
      }
    }
    return hostParts;
  };
  RequestSigner.prototype.isSingleRegion = function () {
    if (['s3', 'sdb'].indexOf(this.service) >= 0 && this.region === 'us-east-1')
      return true;
    return (
      ['cloudfront', 'ls', 'route53', 'iam', 'importexport', 'sts'].indexOf(
        this.service,
      ) >= 0
    );
  };
  RequestSigner.prototype.createHost = function () {
    var region = this.isSingleRegion() ? '' : '.' + this.region,
      subdomain = this.service === 'ses' ? 'email' : this.service;
    return subdomain + region + '.amazonaws.com';
  };
  RequestSigner.prototype.prepareRequest = function () {
    this.parsePath();
    var request = this.request,
      headers = request.headers,
      query;
    if (request.signQuery) {
      this.parsedPath.query = query = this.parsedPath.query || {};
      if (this.credentials.sessionToken)
        query['X-Amz-Security-Token'] = this.credentials.sessionToken;
      if (this.service === 's3' && !query['X-Amz-Expires'])
        query['X-Amz-Expires'] = 86400;
      if (query['X-Amz-Date']) this.datetime = query['X-Amz-Date'];
      else query['X-Amz-Date'] = this.getDateTime();
      query['X-Amz-Algorithm'] = 'AWS4-HMAC-SHA256';
      query['X-Amz-Credential'] =
        this.credentials.accessKeyId + '/' + this.credentialString();
      query['X-Amz-SignedHeaders'] = this.signedHeaders();
    } else {
      if (!request.doNotModifyHeaders && !this.isCodeCommitGit) {
        if (
          request.body &&
          !headers['Content-Type'] &&
          !headers['content-type']
        )
          headers['Content-Type'] =
            'application/x-www-form-urlencoded; charset=utf-8';
        if (
          request.body &&
          !headers['Content-Length'] &&
          !headers['content-length']
        )
          headers['Content-Length'] = Buffer.byteLength(request.body);
        if (
          this.credentials.sessionToken &&
          !headers['X-Amz-Security-Token'] &&
          !headers['x-amz-security-token']
        )
          headers['X-Amz-Security-Token'] = this.credentials.sessionToken;
        if (
          this.service === 's3' &&
          !headers['X-Amz-Content-Sha256'] &&
          !headers['x-amz-content-sha256']
        )
          headers['X-Amz-Content-Sha256'] = hash(
            this.request.body || '',
            'hex',
          );
        if (headers['X-Amz-Date'] || headers['x-amz-date'])
          this.datetime = headers['X-Amz-Date'] || headers['x-amz-date'];
        else headers['X-Amz-Date'] = this.getDateTime();
      }
      delete headers.Authorization;
      delete headers.authorization;
    }
  };
  RequestSigner.prototype.sign = function () {
    if (!this.parsedPath) this.prepareRequest();
    if (this.request.signQuery) {
      this.parsedPath.query['X-Amz-Signature'] = this.signature();
    } else {
      this.request.headers.Authorization = this.authHeader();
    }
    this.request.path = this.formatPath();
    return this.request;
  };
  RequestSigner.prototype.getDateTime = function () {
    if (!this.datetime) {
      var headers = this.request.headers,
        date = new Date(headers.Date || headers.date || new Date());
      this.datetime = date.toISOString().replace(/[:\-]|\.\d{3}/g, '');
      if (this.isCodeCommitGit) this.datetime = this.datetime.slice(0, -1);
    }
    return this.datetime;
  };
  RequestSigner.prototype.getDate = function () {
    return this.getDateTime().substr(0, 8);
  };
  RequestSigner.prototype.authHeader = function () {
    return [
      'AWS4-HMAC-SHA256 Credential=' +
        this.credentials.accessKeyId +
        '/' +
        this.credentialString(),
      'SignedHeaders=' + this.signedHeaders(),
      'Signature=' + this.signature(),
    ].join(', ');
  };
  RequestSigner.prototype.signature = function () {
    var date = this.getDate(),
      cacheKey = [
        this.credentials.secretAccessKey,
        date,
        this.region,
        this.service,
      ].join(),
      kDate,
      kRegion,
      kService,
      kCredentials = credentialsCache.get(cacheKey);
    if (!kCredentials) {
      kDate = hmac('AWS4' + this.credentials.secretAccessKey, date);
      kRegion = hmac(kDate, this.region);
      kService = hmac(kRegion, this.service);
      kCredentials = hmac(kService, 'aws4_request');
      credentialsCache.set(cacheKey, kCredentials);
    }
    return hmac(kCredentials, this.stringToSign(), 'hex');
  };
  RequestSigner.prototype.stringToSign = function () {
    return [
      'AWS4-HMAC-SHA256',
      this.getDateTime(),
      this.credentialString(),
      hash(this.canonicalString(), 'hex'),
    ].join('\n');
  };
  RequestSigner.prototype.canonicalString = function () {
    if (!this.parsedPath) this.prepareRequest();
    var pathStr = this.parsedPath.path,
      query = this.parsedPath.query,
      headers = this.request.headers,
      queryStr = '',
      normalizePath = this.service !== 's3',
      decodePath = this.service === 's3' || this.request.doNotEncodePath,
      decodeSlashesInPath = this.service === 's3',
      firstValOnly = this.service === 's3',
      bodyHash;
    if (this.service === 's3' && this.request.signQuery) {
      bodyHash = 'UNSIGNED-PAYLOAD';
    } else if (this.isCodeCommitGit) {
      bodyHash = '';
    } else {
      bodyHash =
        headers['X-Amz-Content-Sha256'] ||
        headers['x-amz-content-sha256'] ||
        hash(this.request.body || '', 'hex');
    }
    if (query) {
      var reducedQuery = Object.keys(query).reduce(function (obj, key) {
        if (!key) return obj;
        obj[encodeRfc3986Full(key)] = !Array.isArray(query[key])
          ? query[key]
          : firstValOnly
          ? query[key][0]
          : query[key];
        return obj;
      }, {});
      var encodedQueryPieces = [];
      Object.keys(reducedQuery)
        .sort()
        .forEach(function (key) {
          if (!Array.isArray(reducedQuery[key])) {
            encodedQueryPieces.push(
              key + '=' + encodeRfc3986Full(reducedQuery[key]),
            );
          } else {
            reducedQuery[key]
              .map(encodeRfc3986Full)
              .sort()
              .forEach(function (val) {
                encodedQueryPieces.push(key + '=' + val);
              });
          }
        });
      queryStr = encodedQueryPieces.join('&');
    }
    if (pathStr !== '/') {
      if (normalizePath) pathStr = pathStr.replace(/\/{2,}/g, '/');
      pathStr = pathStr
        .split('/')
        .reduce(function (path, piece) {
          if (normalizePath && piece === '..') {
            path.pop();
          } else if (!normalizePath || piece !== '.') {
            if (decodePath)
              piece = decodeURIComponent(piece.replace(/\+/g, ' '));
            path.push(encodeRfc3986Full(piece));
          }
          return path;
        }, [])
        .join('/');
      if (pathStr[0] !== '/') pathStr = '/' + pathStr;
      if (decodeSlashesInPath) pathStr = pathStr.replace(/%2F/g, '/');
    }
    return [
      this.request.method || 'GET',
      pathStr,
      queryStr,
      this.canonicalHeaders() + '\n',
      this.signedHeaders(),
      bodyHash,
    ].join('\n');
  };
  RequestSigner.prototype.canonicalHeaders = function () {
    var headers = this.request.headers;
    function trimAll(header) {
      return header.toString().trim().replace(/\s+/g, ' ');
    }
    return Object.keys(headers)
      .filter(function (key) {
        return HEADERS_TO_IGNORE[key.toLowerCase()] == null;
      })
      .sort(function (a, b) {
        return a.toLowerCase() < b.toLowerCase() ? -1 : 1;
      })
      .map(function (key) {
        return key.toLowerCase() + ':' + trimAll(headers[key]);
      })
      .join('\n');
  };
  RequestSigner.prototype.signedHeaders = function () {
    return Object.keys(this.request.headers)
      .map(function (key) {
        return key.toLowerCase();
      })
      .filter(function (key) {
        return HEADERS_TO_IGNORE[key] == null;
      })
      .sort()
      .join(';');
  };
  RequestSigner.prototype.credentialString = function () {
    return [this.getDate(), this.region, this.service, 'aws4_request'].join(
      '/',
    );
  };
  RequestSigner.prototype.defaultCredentials = function () {
    var env = process.env;
    return {
      accessKeyId: env.AWS_ACCESS_KEY_ID || env.AWS_ACCESS_KEY,
      secretAccessKey: env.AWS_SECRET_ACCESS_KEY || env.AWS_SECRET_KEY,
      sessionToken: env.AWS_SESSION_TOKEN,
    };
  };
  RequestSigner.prototype.parsePath = function () {
    var path = this.request.path || '/';
    if (/[^0-9A-Za-z;,/?:@&=+$\-_.!~*'()#%]/.test(path)) {
      path = encodeURI(decodeURI(path));
    }
    var queryIx = path.indexOf('?'),
      query = null;
    if (queryIx >= 0) {
      query = querystring.parse(path.slice(queryIx + 1));
      path = path.slice(0, queryIx);
    }
    this.parsedPath = {
      path,
      query,
    };
  };
  RequestSigner.prototype.formatPath = function () {
    var path = this.parsedPath.path,
      query = this.parsedPath.query;
    if (!query) return path;
    if (query[''] != null) delete query[''];
    return path + '?' + encodeRfc3986(querystring.stringify(query));
  };
  aws4.RequestSigner = RequestSigner;
  aws4.sign = function (request, credentials) {
    return new RequestSigner(request, credentials).sign();
  };
});

// node_modules/assert-plus/assert.js
var require_assert = __commonJS((exports2, module2) => {
  var assert = require('assert');
  var Stream = require('stream').Stream;
  var util = require('util');
  var UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;
  function _capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  function _toss(name, expected, oper, arg, actual) {
    throw new assert.AssertionError({
      message: util.format('%s (%s) is required', name, expected),
      actual: actual === void 0 ? typeof arg : actual(arg),
      expected,
      operator: oper || '===',
      stackStartFunction: _toss.caller,
    });
  }
  function _getClass(arg) {
    return Object.prototype.toString.call(arg).slice(8, -1);
  }
  function noop() {}
  var types = {
    bool: {
      check: function (arg) {
        return typeof arg === 'boolean';
      },
    },
    func: {
      check: function (arg) {
        return typeof arg === 'function';
      },
    },
    string: {
      check: function (arg) {
        return typeof arg === 'string';
      },
    },
    object: {
      check: function (arg) {
        return typeof arg === 'object' && arg !== null;
      },
    },
    number: {
      check: function (arg) {
        return typeof arg === 'number' && !isNaN(arg);
      },
    },
    finite: {
      check: function (arg) {
        return typeof arg === 'number' && !isNaN(arg) && isFinite(arg);
      },
    },
    buffer: {
      check: function (arg) {
        return Buffer.isBuffer(arg);
      },
      operator: 'Buffer.isBuffer',
    },
    array: {
      check: function (arg) {
        return Array.isArray(arg);
      },
      operator: 'Array.isArray',
    },
    stream: {
      check: function (arg) {
        return arg instanceof Stream;
      },
      operator: 'instanceof',
      actual: _getClass,
    },
    date: {
      check: function (arg) {
        return arg instanceof Date;
      },
      operator: 'instanceof',
      actual: _getClass,
    },
    regexp: {
      check: function (arg) {
        return arg instanceof RegExp;
      },
      operator: 'instanceof',
      actual: _getClass,
    },
    uuid: {
      check: function (arg) {
        return typeof arg === 'string' && UUID_REGEXP.test(arg);
      },
      operator: 'isUUID',
    },
  };
  function _setExports(ndebug) {
    var keys = Object.keys(types);
    var out;
    if (process.env.NODE_NDEBUG) {
      out = noop;
    } else {
      out = function (arg, msg) {
        if (!arg) {
          _toss(msg, 'true', arg);
        }
      };
    }
    keys.forEach(function (k) {
      if (ndebug) {
        out[k] = noop;
        return;
      }
      var type = types[k];
      out[k] = function (arg, msg) {
        if (!type.check(arg)) {
          _toss(msg, k, type.operator, arg, type.actual);
        }
      };
    });
    keys.forEach(function (k) {
      var name = 'optional' + _capitalize(k);
      if (ndebug) {
        out[name] = noop;
        return;
      }
      var type = types[k];
      out[name] = function (arg, msg) {
        if (arg === void 0 || arg === null) {
          return;
        }
        if (!type.check(arg)) {
          _toss(msg, k, type.operator, arg, type.actual);
        }
      };
    });
    keys.forEach(function (k) {
      var name = 'arrayOf' + _capitalize(k);
      if (ndebug) {
        out[name] = noop;
        return;
      }
      var type = types[k];
      var expected = '[' + k + ']';
      out[name] = function (arg, msg) {
        if (!Array.isArray(arg)) {
          _toss(msg, expected, type.operator, arg, type.actual);
        }
        var i;
        for (i = 0; i < arg.length; i++) {
          if (!type.check(arg[i])) {
            _toss(msg, expected, type.operator, arg, type.actual);
          }
        }
      };
    });
    keys.forEach(function (k) {
      var name = 'optionalArrayOf' + _capitalize(k);
      if (ndebug) {
        out[name] = noop;
        return;
      }
      var type = types[k];
      var expected = '[' + k + ']';
      out[name] = function (arg, msg) {
        if (arg === void 0 || arg === null) {
          return;
        }
        if (!Array.isArray(arg)) {
          _toss(msg, expected, type.operator, arg, type.actual);
        }
        var i;
        for (i = 0; i < arg.length; i++) {
          if (!type.check(arg[i])) {
            _toss(msg, expected, type.operator, arg, type.actual);
          }
        }
      };
    });
    Object.keys(assert).forEach(function (k) {
      if (k === 'AssertionError') {
        out[k] = assert[k];
        return;
      }
      if (ndebug) {
        out[k] = noop;
        return;
      }
      out[k] = assert[k];
    });
    out._setExports = _setExports;
    return out;
  }
  module2.exports = _setExports(process.env.NODE_NDEBUG);
});

// node_modules/safer-buffer/safer.js
var require_safer = __commonJS((exports2, module2) => {
  'use strict';
  var buffer = require('buffer');
  var Buffer2 = buffer.Buffer;
  var safer = {};
  var key;
  for (key in buffer) {
    if (!buffer.hasOwnProperty(key)) continue;
    if (key === 'SlowBuffer' || key === 'Buffer') continue;
    safer[key] = buffer[key];
  }
  var Safer = (safer.Buffer = {});
  for (key in Buffer2) {
    if (!Buffer2.hasOwnProperty(key)) continue;
    if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue;
    Safer[key] = Buffer2[key];
  }
  safer.Buffer.prototype = Buffer2.prototype;
  if (!Safer.from || Safer.from === Uint8Array.from) {
    Safer.from = function (value, encodingOrOffset, length) {
      if (typeof value === 'number') {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type ' +
            typeof value,
        );
      }
      if (value && typeof value.length === 'undefined') {
        throw new TypeError(
          'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
            typeof value,
        );
      }
      return Buffer2(value, encodingOrOffset, length);
    };
  }
  if (!Safer.alloc) {
    Safer.alloc = function (size, fill, encoding) {
      if (typeof size !== 'number') {
        throw new TypeError(
          'The "size" argument must be of type number. Received type ' +
            typeof size,
        );
      }
      if (size < 0 || size >= 2 * (1 << 30)) {
        throw new RangeError(
          'The value "' + size + '" is invalid for option "size"',
        );
      }
      var buf = Buffer2(size);
      if (!fill || fill.length === 0) {
        buf.fill(0);
      } else if (typeof encoding === 'string') {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
      return buf;
    };
  }
  if (!safer.kStringMaxLength) {
    try {
      safer.kStringMaxLength = process.binding('buffer').kStringMaxLength;
    } catch (e) {}
  }
  if (!safer.constants) {
    safer.constants = {
      MAX_LENGTH: safer.kMaxLength,
    };
    if (safer.kStringMaxLength) {
      safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
    }
  }
  module2.exports = safer;
});

// node_modules/sshpk/lib/algs.js
var require_algs = __commonJS((exports2, module2) => {
  var Buffer2 = require_safer().Buffer;
  var algInfo = {
    dsa: {
      parts: ['p', 'q', 'g', 'y'],
      sizePart: 'p',
    },
    rsa: {
      parts: ['e', 'n'],
      sizePart: 'n',
    },
    ecdsa: {
      parts: ['curve', 'Q'],
      sizePart: 'Q',
    },
    ed25519: {
      parts: ['A'],
      sizePart: 'A',
    },
  };
  algInfo['curve25519'] = algInfo['ed25519'];
  var algPrivInfo = {
    dsa: {
      parts: ['p', 'q', 'g', 'y', 'x'],
    },
    rsa: {
      parts: ['n', 'e', 'd', 'iqmp', 'p', 'q'],
    },
    ecdsa: {
      parts: ['curve', 'Q', 'd'],
    },
    ed25519: {
      parts: ['A', 'k'],
    },
  };
  algPrivInfo['curve25519'] = algPrivInfo['ed25519'];
  var hashAlgs = {
    md5: true,
    sha1: true,
    sha256: true,
    sha384: true,
    sha512: true,
  };
  var curves = {
    nistp256: {
      size: 256,
      pkcs8oid: '1.2.840.10045.3.1.7',
      p: Buffer2.from(
        '00ffffffff 00000001 00000000 0000000000000000 ffffffff ffffffff ffffffff'.replace(
          / /g,
          '',
        ),
        'hex',
      ),
      a: Buffer2.from(
        '00FFFFFFFF 00000001 00000000 0000000000000000 FFFFFFFF FFFFFFFF FFFFFFFC'.replace(
          / /g,
          '',
        ),
        'hex',
      ),
      b: Buffer2.from(
        '5ac635d8 aa3a93e7 b3ebbd55 769886bc651d06b0 cc53b0f6 3bce3c3e 27d2604b'.replace(
          / /g,
          '',
        ),
        'hex',
      ),
      s: Buffer2.from(
        '00c49d3608 86e70493 6a6678e1 139d26b7819f7e90'.replace(/ /g, ''),
        'hex',
      ),
      n: Buffer2.from(
        '00ffffffff 00000000 ffffffff ffffffffbce6faad a7179e84 f3b9cac2 fc632551'.replace(
          / /g,
          '',
        ),
        'hex',
      ),
      G: Buffer2.from(
        '046b17d1f2 e12c4247 f8bce6e5 63a440f277037d81 2deb33a0 f4a13945 d898c2964fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e162bce3357 6b315ece cbb64068 37bf51f5'.replace(
          / /g,
          '',
        ),
        'hex',
      ),
    },
    nistp384: {
      size: 384,
      pkcs8oid: '1.3.132.0.34',
      p: Buffer2.from(
        '00ffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff fffffffeffffffff 00000000 00000000 ffffffff'.replace(
          / /g,
          '',
        ),
        'hex',
      ),
      a: Buffer2.from(
        '00FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFEFFFFFFFF 00000000 00000000 FFFFFFFC'.replace(
          / /g,
          '',
        ),
        'hex',
      ),
      b: Buffer2.from(
        'b3312fa7 e23ee7e4 988e056b e3f82d19181d9c6e fe814112 0314088f 5013875ac656398d 8a2ed19d 2a85c8ed d3ec2aef'.replace(
          / /g,
          '',
        ),
        'hex',
      ),
      s: Buffer2.from(
        '00a335926a a319a27a 1d00896a 6773a4827acdac73'.replace(/ /g, ''),
        'hex',
      ),
      n: Buffer2.from(
        '00ffffffff ffffffff ffffffff ffffffffffffffff ffffffff c7634d81 f4372ddf581a0db2 48b0a77a ecec196a ccc52973'.replace(
          / /g,
          '',
        ),
        'hex',
      ),
      G: Buffer2.from(
        '04aa87ca22 be8b0537 8eb1c71e f320ad746e1d3b62 8ba79b98 59f741e0 82542a385502f25d bf55296c 3a545e38 72760ab73617de4a 96262c6f 5d9e98bf 9292dc29f8f41dbd 289a147c e9da3113 b5f0b8c00a60b1ce 1d7e819d 7a431d7c 90ea0e5f'.replace(
          / /g,
          '',
        ),
        'hex',
      ),
    },
    nistp521: {
      size: 521,
      pkcs8oid: '1.3.132.0.35',
      p: Buffer2.from(
        '01ffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffff'.replace(
          / /g,
          '',
        ),
        'hex',
      ),
      a: Buffer2.from(
        '01FFFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFFFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFC'.replace(
          / /g,
          '',
        ),
        'hex',
      ),
      b: Buffer2.from(
        '51953eb961 8e1c9a1f 929a21a0 b68540eea2da725b 99b315f3 b8b48991 8ef109e156193951 ec7e937b 1652c0bd 3bb1bf073573df88 3d2c34f1 ef451fd4 6b503f00'.replace(
          / /g,
          '',
        ),
        'hex',
      ),
      s: Buffer2.from(
        '00d09e8800 291cb853 96cc6717 393284aaa0da64ba'.replace(/ /g, ''),
        'hex',
      ),
      n: Buffer2.from(
        '01ffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff fffffffa51868783 bf2f966b 7fcc0148 f709a5d03bb5c9b8 899c47ae bb6fb71e 91386409'.replace(
          / /g,
          '',
        ),
        'hex',
      ),
      G: Buffer2.from(
        '0400c6 858e06b7 0404e9cd 9e3ecb66 2395b4429c648139 053fb521 f828af60 6b4d3dbaa14b5e77 efe75928 fe1dc127 a2ffa8de3348b3c1 856a429b f97e7e31 c2e5bd660118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd998f54449 579b4468 17afbd17 273e662c97ee7299 5ef42640 c550b901 3fad0761353c7086 a272c240 88be9476 9fd16650'.replace(
          / /g,
          '',
        ),
        'hex',
      ),
    },
  };
  module2.exports = {
    info: algInfo,
    privInfo: algPrivInfo,
    hashAlgs,
    curves,
  };
});

// node_modules/sshpk/lib/errors.js
var require_errors = __commonJS((exports2, module2) => {
  var assert = require_assert();
  var util = require('util');
  function FingerprintFormatError(fp, format) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, FingerprintFormatError);
    this.name = 'FingerprintFormatError';
    this.fingerprint = fp;
    this.format = format;
    this.message = 'Fingerprint format is not supported, or is invalid: ';
    if (fp !== void 0) this.message += ' fingerprint = ' + fp;
    if (format !== void 0) this.message += ' format = ' + format;
  }
  util.inherits(FingerprintFormatError, Error);
  function InvalidAlgorithmError(alg) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, InvalidAlgorithmError);
    this.name = 'InvalidAlgorithmError';
    this.algorithm = alg;
    this.message = 'Algorithm "' + alg + '" is not supported';
  }
  util.inherits(InvalidAlgorithmError, Error);
  function KeyParseError(name, format, innerErr) {
    if (Error.captureStackTrace) Error.captureStackTrace(this, KeyParseError);
    this.name = 'KeyParseError';
    this.format = format;
    this.keyName = name;
    this.innerErr = innerErr;
    this.message =
      'Failed to parse ' +
      name +
      ' as a valid ' +
      format +
      ' format key: ' +
      innerErr.message;
  }
  util.inherits(KeyParseError, Error);
  function SignatureParseError(type, format, innerErr) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, SignatureParseError);
    this.name = 'SignatureParseError';
    this.type = type;
    this.format = format;
    this.innerErr = innerErr;
    this.message =
      'Failed to parse the given data as a ' +
      type +
      ' signature in ' +
      format +
      ' format: ' +
      innerErr.message;
  }
  util.inherits(SignatureParseError, Error);
  function CertificateParseError(name, format, innerErr) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, CertificateParseError);
    this.name = 'CertificateParseError';
    this.format = format;
    this.certName = name;
    this.innerErr = innerErr;
    this.message =
      'Failed to parse ' +
      name +
      ' as a valid ' +
      format +
      ' format certificate: ' +
      innerErr.message;
  }
  util.inherits(CertificateParseError, Error);
  function KeyEncryptedError(name, format) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, KeyEncryptedError);
    this.name = 'KeyEncryptedError';
    this.format = format;
    this.keyName = name;
    this.message =
      'The ' +
      format +
      ' format key ' +
      name +
      ' is encrypted (password-protected), and no passphrase was provided in `options`';
  }
  util.inherits(KeyEncryptedError, Error);
  module2.exports = {
    FingerprintFormatError,
    InvalidAlgorithmError,
    KeyParseError,
    SignatureParseError,
    KeyEncryptedError,
    CertificateParseError,
  };
});

// node_modules/asn1/lib/ber/errors.js
var require_errors2 = __commonJS((exports2, module2) => {
  module2.exports = {
    newInvalidAsn1Error: function (msg) {
      var e = new Error();
      e.name = 'InvalidAsn1Error';
      e.message = msg || '';
      return e;
    },
  };
});

// node_modules/asn1/lib/ber/types.js
var require_types = __commonJS((exports2, module2) => {
  module2.exports = {
    EOC: 0,
    Boolean: 1,
    Integer: 2,
    BitString: 3,
    OctetString: 4,
    Null: 5,
    OID: 6,
    ObjectDescriptor: 7,
    External: 8,
    Real: 9,
    Enumeration: 10,
    PDV: 11,
    Utf8String: 12,
    RelativeOID: 13,
    Sequence: 16,
    Set: 17,
    NumericString: 18,
    PrintableString: 19,
    T61String: 20,
    VideotexString: 21,
    IA5String: 22,
    UTCTime: 23,
    GeneralizedTime: 24,
    GraphicString: 25,
    VisibleString: 26,
    GeneralString: 28,
    UniversalString: 29,
    CharacterString: 30,
    BMPString: 31,
    Constructor: 32,
    Context: 128,
  };
});

// node_modules/asn1/lib/ber/reader.js
var require_reader = __commonJS((exports2, module2) => {
  var assert = require('assert');
  var Buffer2 = require_safer().Buffer;
  var ASN1 = require_types();
  var errors = require_errors2();
  var newInvalidAsn1Error = errors.newInvalidAsn1Error;
  function Reader(data) {
    if (!data || !Buffer2.isBuffer(data))
      throw new TypeError('data must be a node Buffer');
    this._buf = data;
    this._size = data.length;
    this._len = 0;
    this._offset = 0;
  }
  Object.defineProperty(Reader.prototype, 'length', {
    enumerable: true,
    get: function () {
      return this._len;
    },
  });
  Object.defineProperty(Reader.prototype, 'offset', {
    enumerable: true,
    get: function () {
      return this._offset;
    },
  });
  Object.defineProperty(Reader.prototype, 'remain', {
    get: function () {
      return this._size - this._offset;
    },
  });
  Object.defineProperty(Reader.prototype, 'buffer', {
    get: function () {
      return this._buf.slice(this._offset);
    },
  });
  Reader.prototype.readByte = function (peek) {
    if (this._size - this._offset < 1) return null;
    var b = this._buf[this._offset] & 255;
    if (!peek) this._offset += 1;
    return b;
  };
  Reader.prototype.peek = function () {
    return this.readByte(true);
  };
  Reader.prototype.readLength = function (offset) {
    if (offset === void 0) offset = this._offset;
    if (offset >= this._size) return null;
    var lenB = this._buf[offset++] & 255;
    if (lenB === null) return null;
    if ((lenB & 128) === 128) {
      lenB &= 127;
      if (lenB === 0)
        throw newInvalidAsn1Error('Indefinite length not supported');
      if (lenB > 4) throw newInvalidAsn1Error('encoding too long');
      if (this._size - offset < lenB) return null;
      this._len = 0;
      for (var i = 0; i < lenB; i++)
        this._len = (this._len << 8) + (this._buf[offset++] & 255);
    } else {
      this._len = lenB;
    }
    return offset;
  };
  Reader.prototype.readSequence = function (tag) {
    var seq = this.peek();
    if (seq === null) return null;
    if (tag !== void 0 && tag !== seq)
      throw newInvalidAsn1Error(
        'Expected 0x' + tag.toString(16) + ': got 0x' + seq.toString(16),
      );
    var o = this.readLength(this._offset + 1);
    if (o === null) return null;
    this._offset = o;
    return seq;
  };
  Reader.prototype.readInt = function () {
    return this._readTag(ASN1.Integer);
  };
  Reader.prototype.readBoolean = function () {
    return this._readTag(ASN1.Boolean) === 0 ? false : true;
  };
  Reader.prototype.readEnumeration = function () {
    return this._readTag(ASN1.Enumeration);
  };
  Reader.prototype.readString = function (tag, retbuf) {
    if (!tag) tag = ASN1.OctetString;
    var b = this.peek();
    if (b === null) return null;
    if (b !== tag)
      throw newInvalidAsn1Error(
        'Expected 0x' + tag.toString(16) + ': got 0x' + b.toString(16),
      );
    var o = this.readLength(this._offset + 1);
    if (o === null) return null;
    if (this.length > this._size - o) return null;
    this._offset = o;
    if (this.length === 0) return retbuf ? Buffer2.alloc(0) : '';
    var str = this._buf.slice(this._offset, this._offset + this.length);
    this._offset += this.length;
    return retbuf ? str : str.toString('utf8');
  };
  Reader.prototype.readOID = function (tag) {
    if (!tag) tag = ASN1.OID;
    var b = this.readString(tag, true);
    if (b === null) return null;
    var values = [];
    var value = 0;
    for (var i = 0; i < b.length; i++) {
      var byte = b[i] & 255;
      value <<= 7;
      value += byte & 127;
      if ((byte & 128) === 0) {
        values.push(value);
        value = 0;
      }
    }
    value = values.shift();
    values.unshift(value % 40);
    values.unshift((value / 40) >> 0);
    return values.join('.');
  };
  Reader.prototype._readTag = function (tag) {
    assert.ok(tag !== void 0);
    var b = this.peek();
    if (b === null) return null;
    if (b !== tag)
      throw newInvalidAsn1Error(
        'Expected 0x' + tag.toString(16) + ': got 0x' + b.toString(16),
      );
    var o = this.readLength(this._offset + 1);
    if (o === null) return null;
    if (this.length > 4)
      throw newInvalidAsn1Error('Integer too long: ' + this.length);
    if (this.length > this._size - o) return null;
    this._offset = o;
    var fb = this._buf[this._offset];
    var value = 0;
    for (var i = 0; i < this.length; i++) {
      value <<= 8;
      value |= this._buf[this._offset++] & 255;
    }
    if ((fb & 128) === 128 && i !== 4) value -= 1 << (i * 8);
    return value >> 0;
  };
  module2.exports = Reader;
});

// node_modules/asn1/lib/ber/writer.js
var require_writer = __commonJS((exports2, module2) => {
  var assert = require('assert');
  var Buffer2 = require_safer().Buffer;
  var ASN1 = require_types();
  var errors = require_errors2();
  var newInvalidAsn1Error = errors.newInvalidAsn1Error;
  var DEFAULT_OPTS = {
    size: 1024,
    growthFactor: 8,
  };
  function merge(from, to) {
    assert.ok(from);
    assert.equal(typeof from, 'object');
    assert.ok(to);
    assert.equal(typeof to, 'object');
    var keys = Object.getOwnPropertyNames(from);
    keys.forEach(function (key) {
      if (to[key]) return;
      var value = Object.getOwnPropertyDescriptor(from, key);
      Object.defineProperty(to, key, value);
    });
    return to;
  }
  function Writer(options) {
    options = merge(DEFAULT_OPTS, options || {});
    this._buf = Buffer2.alloc(options.size || 1024);
    this._size = this._buf.length;
    this._offset = 0;
    this._options = options;
    this._seq = [];
  }
  Object.defineProperty(Writer.prototype, 'buffer', {
    get: function () {
      if (this._seq.length)
        throw newInvalidAsn1Error(this._seq.length + ' unended sequence(s)');
      return this._buf.slice(0, this._offset);
    },
  });
  Writer.prototype.writeByte = function (b) {
    if (typeof b !== 'number') throw new TypeError('argument must be a Number');
    this._ensure(1);
    this._buf[this._offset++] = b;
  };
  Writer.prototype.writeInt = function (i, tag) {
    if (typeof i !== 'number') throw new TypeError('argument must be a Number');
    if (typeof tag !== 'number') tag = ASN1.Integer;
    var sz = 4;
    while (
      ((i & 4286578688) === 0 || (i & 4286578688) === 4286578688 >> 0) &&
      sz > 1
    ) {
      sz--;
      i <<= 8;
    }
    if (sz > 4) throw newInvalidAsn1Error('BER ints cannot be > 0xffffffff');
    this._ensure(2 + sz);
    this._buf[this._offset++] = tag;
    this._buf[this._offset++] = sz;
    while (sz-- > 0) {
      this._buf[this._offset++] = (i & 4278190080) >>> 24;
      i <<= 8;
    }
  };
  Writer.prototype.writeNull = function () {
    this.writeByte(ASN1.Null);
    this.writeByte(0);
  };
  Writer.prototype.writeEnumeration = function (i, tag) {
    if (typeof i !== 'number') throw new TypeError('argument must be a Number');
    if (typeof tag !== 'number') tag = ASN1.Enumeration;
    return this.writeInt(i, tag);
  };
  Writer.prototype.writeBoolean = function (b, tag) {
    if (typeof b !== 'boolean')
      throw new TypeError('argument must be a Boolean');
    if (typeof tag !== 'number') tag = ASN1.Boolean;
    this._ensure(3);
    this._buf[this._offset++] = tag;
    this._buf[this._offset++] = 1;
    this._buf[this._offset++] = b ? 255 : 0;
  };
  Writer.prototype.writeString = function (s, tag) {
    if (typeof s !== 'string')
      throw new TypeError('argument must be a string (was: ' + typeof s + ')');
    if (typeof tag !== 'number') tag = ASN1.OctetString;
    var len = Buffer2.byteLength(s);
    this.writeByte(tag);
    this.writeLength(len);
    if (len) {
      this._ensure(len);
      this._buf.write(s, this._offset);
      this._offset += len;
    }
  };
  Writer.prototype.writeBuffer = function (buf, tag) {
    if (typeof tag !== 'number') throw new TypeError('tag must be a number');
    if (!Buffer2.isBuffer(buf))
      throw new TypeError('argument must be a buffer');
    this.writeByte(tag);
    this.writeLength(buf.length);
    this._ensure(buf.length);
    buf.copy(this._buf, this._offset, 0, buf.length);
    this._offset += buf.length;
  };
  Writer.prototype.writeStringArray = function (strings) {
    if (!strings instanceof Array)
      throw new TypeError('argument must be an Array[String]');
    var self2 = this;
    strings.forEach(function (s) {
      self2.writeString(s);
    });
  };
  Writer.prototype.writeOID = function (s, tag) {
    if (typeof s !== 'string') throw new TypeError('argument must be a string');
    if (typeof tag !== 'number') tag = ASN1.OID;
    if (!/^([0-9]+\.){3,}[0-9]+$/.test(s))
      throw new Error('argument is not a valid OID string');
    function encodeOctet(bytes2, octet) {
      if (octet < 128) {
        bytes2.push(octet);
      } else if (octet < 16384) {
        bytes2.push((octet >>> 7) | 128);
        bytes2.push(octet & 127);
      } else if (octet < 2097152) {
        bytes2.push((octet >>> 14) | 128);
        bytes2.push(((octet >>> 7) | 128) & 255);
        bytes2.push(octet & 127);
      } else if (octet < 268435456) {
        bytes2.push((octet >>> 21) | 128);
        bytes2.push(((octet >>> 14) | 128) & 255);
        bytes2.push(((octet >>> 7) | 128) & 255);
        bytes2.push(octet & 127);
      } else {
        bytes2.push(((octet >>> 28) | 128) & 255);
        bytes2.push(((octet >>> 21) | 128) & 255);
        bytes2.push(((octet >>> 14) | 128) & 255);
        bytes2.push(((octet >>> 7) | 128) & 255);
        bytes2.push(octet & 127);
      }
    }
    var tmp = s.split('.');
    var bytes = [];
    bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));
    tmp.slice(2).forEach(function (b) {
      encodeOctet(bytes, parseInt(b, 10));
    });
    var self2 = this;
    this._ensure(2 + bytes.length);
    this.writeByte(tag);
    this.writeLength(bytes.length);
    bytes.forEach(function (b) {
      self2.writeByte(b);
    });
  };
  Writer.prototype.writeLength = function (len) {
    if (typeof len !== 'number')
      throw new TypeError('argument must be a Number');
    this._ensure(4);
    if (len <= 127) {
      this._buf[this._offset++] = len;
    } else if (len <= 255) {
      this._buf[this._offset++] = 129;
      this._buf[this._offset++] = len;
    } else if (len <= 65535) {
      this._buf[this._offset++] = 130;
      this._buf[this._offset++] = len >> 8;
      this._buf[this._offset++] = len;
    } else if (len <= 16777215) {
      this._buf[this._offset++] = 131;
      this._buf[this._offset++] = len >> 16;
      this._buf[this._offset++] = len >> 8;
      this._buf[this._offset++] = len;
    } else {
      throw newInvalidAsn1Error('Length too long (> 4 bytes)');
    }
  };
  Writer.prototype.startSequence = function (tag) {
    if (typeof tag !== 'number') tag = ASN1.Sequence | ASN1.Constructor;
    this.writeByte(tag);
    this._seq.push(this._offset);
    this._ensure(3);
    this._offset += 3;
  };
  Writer.prototype.endSequence = function () {
    var seq = this._seq.pop();
    var start = seq + 3;
    var len = this._offset - start;
    if (len <= 127) {
      this._shift(start, len, -2);
      this._buf[seq] = len;
    } else if (len <= 255) {
      this._shift(start, len, -1);
      this._buf[seq] = 129;
      this._buf[seq + 1] = len;
    } else if (len <= 65535) {
      this._buf[seq] = 130;
      this._buf[seq + 1] = len >> 8;
      this._buf[seq + 2] = len;
    } else if (len <= 16777215) {
      this._shift(start, len, 1);
      this._buf[seq] = 131;
      this._buf[seq + 1] = len >> 16;
      this._buf[seq + 2] = len >> 8;
      this._buf[seq + 3] = len;
    } else {
      throw newInvalidAsn1Error('Sequence too long');
    }
  };
  Writer.prototype._shift = function (start, len, shift) {
    assert.ok(start !== void 0);
    assert.ok(len !== void 0);
    assert.ok(shift);
    this._buf.copy(this._buf, start + shift, start, start + len);
    this._offset += shift;
  };
  Writer.prototype._ensure = function (len) {
    assert.ok(len);
    if (this._size - this._offset < len) {
      var sz = this._size * this._options.growthFactor;
      if (sz - this._offset < len) sz += len;
      var buf = Buffer2.alloc(sz);
      this._buf.copy(buf, 0, 0, this._offset);
      this._buf = buf;
      this._size = sz;
    }
  };
  module2.exports = Writer;
});

// node_modules/asn1/lib/ber/index.js
var require_ber = __commonJS((exports2, module2) => {
  var errors = require_errors2();
  var types = require_types();
  var Reader = require_reader();
  var Writer = require_writer();
  module2.exports = {
    Reader,
    Writer,
  };
  for (var t in types) {
    if (types.hasOwnProperty(t)) module2.exports[t] = types[t];
  }
  for (var e in errors) {
    if (errors.hasOwnProperty(e)) module2.exports[e] = errors[e];
  }
});

// node_modules/asn1/lib/index.js
var require_lib = __commonJS((exports2, module2) => {
  var Ber = require_ber();
  module2.exports = {
    Ber,
    BerReader: Ber.Reader,
    BerWriter: Ber.Writer,
  };
});

// node_modules/jsbn/index.js
var require_jsbn = __commonJS((exports2, module2) => {
  (function () {
    var dbits;
    var canary = 244837814094590;
    var j_lm = (canary & 16777215) == 15715070;
    function BigInteger(a, b, c) {
      if (a != null)
        if (typeof a == 'number') this.fromNumber(a, b, c);
        else if (b == null && typeof a != 'string') this.fromString(a, 256);
        else this.fromString(a, b);
    }
    function nbi() {
      return new BigInteger(null);
    }
    function am1(i, x, w, j, c, n) {
      while (--n >= 0) {
        var v = x * this[i++] + w[j] + c;
        c = Math.floor(v / 67108864);
        w[j++] = v & 67108863;
      }
      return c;
    }
    function am2(i, x, w, j, c, n) {
      var xl = x & 32767,
        xh = x >> 15;
      while (--n >= 0) {
        var l = this[i] & 32767;
        var h = this[i++] >> 15;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 32767) << 15) + w[j] + (c & 1073741823);
        c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
        w[j++] = l & 1073741823;
      }
      return c;
    }
    function am3(i, x, w, j, c, n) {
      var xl = x & 16383,
        xh = x >> 14;
      while (--n >= 0) {
        var l = this[i] & 16383;
        var h = this[i++] >> 14;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 16383) << 14) + w[j] + c;
        c = (l >> 28) + (m >> 14) + xh * h;
        w[j++] = l & 268435455;
      }
      return c;
    }
    var inBrowser = typeof navigator !== 'undefined';
    if (
      inBrowser &&
      j_lm &&
      navigator.appName == 'Microsoft Internet Explorer'
    ) {
      BigInteger.prototype.am = am2;
      dbits = 30;
    } else if (inBrowser && j_lm && navigator.appName != 'Netscape') {
      BigInteger.prototype.am = am1;
      dbits = 26;
    } else {
      BigInteger.prototype.am = am3;
      dbits = 28;
    }
    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = (1 << dbits) - 1;
    BigInteger.prototype.DV = 1 << dbits;
    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2, BI_FP);
    BigInteger.prototype.F1 = BI_FP - dbits;
    BigInteger.prototype.F2 = 2 * dbits - BI_FP;
    var BI_RM = '0123456789abcdefghijklmnopqrstuvwxyz';
    var BI_RC = new Array();
    var rr, vv;
    rr = '0'.charCodeAt(0);
    for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
    rr = 'a'.charCodeAt(0);
    for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
    rr = 'A'.charCodeAt(0);
    for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
    function int2char(n) {
      return BI_RM.charAt(n);
    }
    function intAt(s, i) {
      var c = BI_RC[s.charCodeAt(i)];
      return c == null ? -1 : c;
    }
    function bnpCopyTo(r) {
      for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];
      r.t = this.t;
      r.s = this.s;
    }
    function bnpFromInt(x) {
      this.t = 1;
      this.s = x < 0 ? -1 : 0;
      if (x > 0) this[0] = x;
      else if (x < -1) this[0] = x + this.DV;
      else this.t = 0;
    }
    function nbv(i) {
      var r = nbi();
      r.fromInt(i);
      return r;
    }
    function bnpFromString(s, b) {
      var k;
      if (b == 16) k = 4;
      else if (b == 8) k = 3;
      else if (b == 256) k = 8;
      else if (b == 2) k = 1;
      else if (b == 32) k = 5;
      else if (b == 4) k = 2;
      else {
        this.fromRadix(s, b);
        return;
      }
      this.t = 0;
      this.s = 0;
      var i = s.length,
        mi = false,
        sh = 0;
      while (--i >= 0) {
        var x = k == 8 ? s[i] & 255 : intAt(s, i);
        if (x < 0) {
          if (s.charAt(i) == '-') mi = true;
          continue;
        }
        mi = false;
        if (sh == 0) this[this.t++] = x;
        else if (sh + k > this.DB) {
          this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;
          this[this.t++] = x >> (this.DB - sh);
        } else this[this.t - 1] |= x << sh;
        sh += k;
        if (sh >= this.DB) sh -= this.DB;
      }
      if (k == 8 && (s[0] & 128) != 0) {
        this.s = -1;
        if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;
      }
      this.clamp();
      if (mi) BigInteger.ZERO.subTo(this, this);
    }
    function bnpClamp() {
      var c = this.s & this.DM;
      while (this.t > 0 && this[this.t - 1] == c) --this.t;
    }
    function bnToString(b) {
      if (this.s < 0) return '-' + this.negate().toString(b);
      var k;
      if (b == 16) k = 4;
      else if (b == 8) k = 3;
      else if (b == 2) k = 1;
      else if (b == 32) k = 5;
      else if (b == 4) k = 2;
      else return this.toRadix(b);
      var km = (1 << k) - 1,
        d,
        m = false,
        r = '',
        i = this.t;
      var p = this.DB - ((i * this.DB) % k);
      if (i-- > 0) {
        if (p < this.DB && (d = this[i] >> p) > 0) {
          m = true;
          r = int2char(d);
        }
        while (i >= 0) {
          if (p < k) {
            d = (this[i] & ((1 << p) - 1)) << (k - p);
            d |= this[--i] >> (p += this.DB - k);
          } else {
            d = (this[i] >> (p -= k)) & km;
            if (p <= 0) {
              p += this.DB;
              --i;
            }
          }
          if (d > 0) m = true;
          if (m) r += int2char(d);
        }
      }
      return m ? r : '0';
    }
    function bnNegate() {
      var r = nbi();
      BigInteger.ZERO.subTo(this, r);
      return r;
    }
    function bnAbs() {
      return this.s < 0 ? this.negate() : this;
    }
    function bnCompareTo(a) {
      var r = this.s - a.s;
      if (r != 0) return r;
      var i = this.t;
      r = i - a.t;
      if (r != 0) return this.s < 0 ? -r : r;
      while (--i >= 0) if ((r = this[i] - a[i]) != 0) return r;
      return 0;
    }
    function nbits(x) {
      var r = 1,
        t2;
      if ((t2 = x >>> 16) != 0) {
        x = t2;
        r += 16;
      }
      if ((t2 = x >> 8) != 0) {
        x = t2;
        r += 8;
      }
      if ((t2 = x >> 4) != 0) {
        x = t2;
        r += 4;
      }
      if ((t2 = x >> 2) != 0) {
        x = t2;
        r += 2;
      }
      if ((t2 = x >> 1) != 0) {
        x = t2;
        r += 1;
      }
      return r;
    }
    function bnBitLength() {
      if (this.t <= 0) return 0;
      return (
        this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM))
      );
    }
    function bnpDLShiftTo(n, r) {
      var i;
      for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];
      for (i = n - 1; i >= 0; --i) r[i] = 0;
      r.t = this.t + n;
      r.s = this.s;
    }
    function bnpDRShiftTo(n, r) {
      for (var i = n; i < this.t; ++i) r[i - n] = this[i];
      r.t = Math.max(this.t - n, 0);
      r.s = this.s;
    }
    function bnpLShiftTo(n, r) {
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << cbs) - 1;
      var ds = Math.floor(n / this.DB),
        c = (this.s << bs) & this.DM,
        i;
      for (i = this.t - 1; i >= 0; --i) {
        r[i + ds + 1] = (this[i] >> cbs) | c;
        c = (this[i] & bm) << bs;
      }
      for (i = ds - 1; i >= 0; --i) r[i] = 0;
      r[ds] = c;
      r.t = this.t + ds + 1;
      r.s = this.s;
      r.clamp();
    }
    function bnpRShiftTo(n, r) {
      r.s = this.s;
      var ds = Math.floor(n / this.DB);
      if (ds >= this.t) {
        r.t = 0;
        return;
      }
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << bs) - 1;
      r[0] = this[ds] >> bs;
      for (var i = ds + 1; i < this.t; ++i) {
        r[i - ds - 1] |= (this[i] & bm) << cbs;
        r[i - ds] = this[i] >> bs;
      }
      if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;
      r.t = this.t - ds;
      r.clamp();
    }
    function bnpSubTo(a, r) {
      var i = 0,
        c = 0,
        m = Math.min(a.t, this.t);
      while (i < m) {
        c += this[i] - a[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c -= a.s;
        while (i < this.t) {
          c += this[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a.t) {
          c -= a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        c -= a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c < -1) r[i++] = this.DV + c;
      else if (c > 0) r[i++] = c;
      r.t = i;
      r.clamp();
    }
    function bnpMultiplyTo(a, r) {
      var x = this.abs(),
        y = a.abs();
      var i = x.t;
      r.t = i + y.t;
      while (--i >= 0) r[i] = 0;
      for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
      r.s = 0;
      r.clamp();
      if (this.s != a.s) BigInteger.ZERO.subTo(r, r);
    }
    function bnpSquareTo(r) {
      var x = this.abs();
      var i = (r.t = 2 * x.t);
      while (--i >= 0) r[i] = 0;
      for (i = 0; i < x.t - 1; ++i) {
        var c = x.am(i, x[i], r, 2 * i, 0, 1);
        if (
          (r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >=
          x.DV
        ) {
          r[i + x.t] -= x.DV;
          r[i + x.t + 1] = 1;
        }
      }
      if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
      r.s = 0;
      r.clamp();
    }
    function bnpDivRemTo(m, q2, r) {
      var pm = m.abs();
      if (pm.t <= 0) return;
      var pt = this.abs();
      if (pt.t < pm.t) {
        if (q2 != null) q2.fromInt(0);
        if (r != null) this.copyTo(r);
        return;
      }
      if (r == null) r = nbi();
      var y = nbi(),
        ts = this.s,
        ms = m.s;
      var nsh = this.DB - nbits(pm[pm.t - 1]);
      if (nsh > 0) {
        pm.lShiftTo(nsh, y);
        pt.lShiftTo(nsh, r);
      } else {
        pm.copyTo(y);
        pt.copyTo(r);
      }
      var ys = y.t;
      var y0 = y[ys - 1];
      if (y0 == 0) return;
      var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
      var d1 = this.FV / yt,
        d2 = (1 << this.F1) / yt,
        e = 1 << this.F2;
      var i = r.t,
        j = i - ys,
        t2 = q2 == null ? nbi() : q2;
      y.dlShiftTo(j, t2);
      if (r.compareTo(t2) >= 0) {
        r[r.t++] = 1;
        r.subTo(t2, r);
      }
      BigInteger.ONE.dlShiftTo(ys, t2);
      t2.subTo(y, y);
      while (y.t < ys) y[y.t++] = 0;
      while (--j >= 0) {
        var qd =
          r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
        if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
          y.dlShiftTo(j, t2);
          r.subTo(t2, r);
          while (r[i] < --qd) r.subTo(t2, r);
        }
      }
      if (q2 != null) {
        r.drShiftTo(ys, q2);
        if (ts != ms) BigInteger.ZERO.subTo(q2, q2);
      }
      r.t = ys;
      r.clamp();
      if (nsh > 0) r.rShiftTo(nsh, r);
      if (ts < 0) BigInteger.ZERO.subTo(r, r);
    }
    function bnMod(a) {
      var r = nbi();
      this.abs().divRemTo(a, null, r);
      if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);
      return r;
    }
    function Classic(m) {
      this.m = m;
    }
    function cConvert(x) {
      if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
      else return x;
    }
    function cRevert(x) {
      return x;
    }
    function cReduce(x) {
      x.divRemTo(this.m, null, x);
    }
    function cMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    function cSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;
    function bnpInvDigit() {
      if (this.t < 1) return 0;
      var x = this[0];
      if ((x & 1) == 0) return 0;
      var y = x & 3;
      y = (y * (2 - (x & 15) * y)) & 15;
      y = (y * (2 - (x & 255) * y)) & 255;
      y = (y * (2 - (((x & 65535) * y) & 65535))) & 65535;
      y = (y * (2 - ((x * y) % this.DV))) % this.DV;
      return y > 0 ? this.DV - y : -y;
    }
    function Montgomery(m) {
      this.m = m;
      this.mp = m.invDigit();
      this.mpl = this.mp & 32767;
      this.mph = this.mp >> 15;
      this.um = (1 << (m.DB - 15)) - 1;
      this.mt2 = 2 * m.t;
    }
    function montConvert(x) {
      var r = nbi();
      x.abs().dlShiftTo(this.m.t, r);
      r.divRemTo(this.m, null, r);
      if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);
      return r;
    }
    function montRevert(x) {
      var r = nbi();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }
    function montReduce(x) {
      while (x.t <= this.mt2) x[x.t++] = 0;
      for (var i = 0; i < this.m.t; ++i) {
        var j = x[i] & 32767;
        var u0 =
          (j * this.mpl +
            (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) &
          x.DM;
        j = i + this.m.t;
        x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
        while (x[j] >= x.DV) {
          x[j] -= x.DV;
          x[++j]++;
        }
      }
      x.clamp();
      x.drShiftTo(this.m.t, x);
      if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
    }
    function montSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function montMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;
    function bnpIsEven() {
      return (this.t > 0 ? this[0] & 1 : this.s) == 0;
    }
    function bnpExp(e, z2) {
      if (e > 4294967295 || e < 1) return BigInteger.ONE;
      var r = nbi(),
        r2 = nbi(),
        g = z2.convert(this),
        i = nbits(e) - 1;
      g.copyTo(r);
      while (--i >= 0) {
        z2.sqrTo(r, r2);
        if ((e & (1 << i)) > 0) z2.mulTo(r2, g, r);
        else {
          var t2 = r;
          r = r2;
          r2 = t2;
        }
      }
      return z2.revert(r);
    }
    function bnModPowInt(e, m) {
      var z2;
      if (e < 256 || m.isEven()) z2 = new Classic(m);
      else z2 = new Montgomery(m);
      return this.exp(e, z2);
    }
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);
    function bnClone() {
      var r = nbi();
      this.copyTo(r);
      return r;
    }
    function bnIntValue() {
      if (this.s < 0) {
        if (this.t == 1) return this[0] - this.DV;
        else if (this.t == 0) return -1;
      } else if (this.t == 1) return this[0];
      else if (this.t == 0) return 0;
      return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];
    }
    function bnByteValue() {
      return this.t == 0 ? this.s : (this[0] << 24) >> 24;
    }
    function bnShortValue() {
      return this.t == 0 ? this.s : (this[0] << 16) >> 16;
    }
    function bnpChunkSize(r) {
      return Math.floor((Math.LN2 * this.DB) / Math.log(r));
    }
    function bnSigNum() {
      if (this.s < 0) return -1;
      else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
      else return 1;
    }
    function bnpToRadix(b) {
      if (b == null) b = 10;
      if (this.signum() == 0 || b < 2 || b > 36) return '0';
      var cs = this.chunkSize(b);
      var a = Math.pow(b, cs);
      var d = nbv(a),
        y = nbi(),
        z2 = nbi(),
        r = '';
      this.divRemTo(d, y, z2);
      while (y.signum() > 0) {
        r = (a + z2.intValue()).toString(b).substr(1) + r;
        y.divRemTo(d, y, z2);
      }
      return z2.intValue().toString(b) + r;
    }
    function bnpFromRadix(s, b) {
      this.fromInt(0);
      if (b == null) b = 10;
      var cs = this.chunkSize(b);
      var d = Math.pow(b, cs),
        mi = false,
        j = 0,
        w = 0;
      for (var i = 0; i < s.length; ++i) {
        var x = intAt(s, i);
        if (x < 0) {
          if (s.charAt(i) == '-' && this.signum() == 0) mi = true;
          continue;
        }
        w = b * w + x;
        if (++j >= cs) {
          this.dMultiply(d);
          this.dAddOffset(w, 0);
          j = 0;
          w = 0;
        }
      }
      if (j > 0) {
        this.dMultiply(Math.pow(b, j));
        this.dAddOffset(w, 0);
      }
      if (mi) BigInteger.ZERO.subTo(this, this);
    }
    function bnpFromNumber(a, b, c) {
      if (typeof b == 'number') {
        if (a < 2) this.fromInt(1);
        else {
          this.fromNumber(a, c);
          if (!this.testBit(a - 1))
            this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
          if (this.isEven()) this.dAddOffset(1, 0);
          while (!this.isProbablePrime(b)) {
            this.dAddOffset(2, 0);
            if (this.bitLength() > a)
              this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
          }
        }
      } else {
        var x = new Array(),
          t2 = a & 7;
        x.length = (a >> 3) + 1;
        b.nextBytes(x);
        if (t2 > 0) x[0] &= (1 << t2) - 1;
        else x[0] = 0;
        this.fromString(x, 256);
      }
    }
    function bnToByteArray() {
      var i = this.t,
        r = new Array();
      r[0] = this.s;
      var p = this.DB - ((i * this.DB) % 8),
        d,
        k = 0;
      if (i-- > 0) {
        if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
          r[k++] = d | (this.s << (this.DB - p));
        while (i >= 0) {
          if (p < 8) {
            d = (this[i] & ((1 << p) - 1)) << (8 - p);
            d |= this[--i] >> (p += this.DB - 8);
          } else {
            d = (this[i] >> (p -= 8)) & 255;
            if (p <= 0) {
              p += this.DB;
              --i;
            }
          }
          if ((d & 128) != 0) d |= -256;
          if (k == 0 && (this.s & 128) != (d & 128)) ++k;
          if (k > 0 || d != this.s) r[k++] = d;
        }
      }
      return r;
    }
    function bnEquals(a) {
      return this.compareTo(a) == 0;
    }
    function bnMin(a) {
      return this.compareTo(a) < 0 ? this : a;
    }
    function bnMax(a) {
      return this.compareTo(a) > 0 ? this : a;
    }
    function bnpBitwiseTo(a, op, r) {
      var i,
        f,
        m = Math.min(a.t, this.t);
      for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);
      if (a.t < this.t) {
        f = a.s & this.DM;
        for (i = m; i < this.t; ++i) r[i] = op(this[i], f);
        r.t = this.t;
      } else {
        f = this.s & this.DM;
        for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);
        r.t = a.t;
      }
      r.s = op(this.s, a.s);
      r.clamp();
    }
    function op_and(x, y) {
      return x & y;
    }
    function bnAnd(a) {
      var r = nbi();
      this.bitwiseTo(a, op_and, r);
      return r;
    }
    function op_or(x, y) {
      return x | y;
    }
    function bnOr(a) {
      var r = nbi();
      this.bitwiseTo(a, op_or, r);
      return r;
    }
    function op_xor(x, y) {
      return x ^ y;
    }
    function bnXor(a) {
      var r = nbi();
      this.bitwiseTo(a, op_xor, r);
      return r;
    }
    function op_andnot(x, y) {
      return x & ~y;
    }
    function bnAndNot(a) {
      var r = nbi();
      this.bitwiseTo(a, op_andnot, r);
      return r;
    }
    function bnNot() {
      var r = nbi();
      for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];
      r.t = this.t;
      r.s = ~this.s;
      return r;
    }
    function bnShiftLeft(n) {
      var r = nbi();
      if (n < 0) this.rShiftTo(-n, r);
      else this.lShiftTo(n, r);
      return r;
    }
    function bnShiftRight(n) {
      var r = nbi();
      if (n < 0) this.lShiftTo(-n, r);
      else this.rShiftTo(n, r);
      return r;
    }
    function lbit(x) {
      if (x == 0) return -1;
      var r = 0;
      if ((x & 65535) == 0) {
        x >>= 16;
        r += 16;
      }
      if ((x & 255) == 0) {
        x >>= 8;
        r += 8;
      }
      if ((x & 15) == 0) {
        x >>= 4;
        r += 4;
      }
      if ((x & 3) == 0) {
        x >>= 2;
        r += 2;
      }
      if ((x & 1) == 0) ++r;
      return r;
    }
    function bnGetLowestSetBit() {
      for (var i = 0; i < this.t; ++i)
        if (this[i] != 0) return i * this.DB + lbit(this[i]);
      if (this.s < 0) return this.t * this.DB;
      return -1;
    }
    function cbit(x) {
      var r = 0;
      while (x != 0) {
        x &= x - 1;
        ++r;
      }
      return r;
    }
    function bnBitCount() {
      var r = 0,
        x = this.s & this.DM;
      for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);
      return r;
    }
    function bnTestBit(n) {
      var j = Math.floor(n / this.DB);
      if (j >= this.t) return this.s != 0;
      return (this[j] & (1 << n % this.DB)) != 0;
    }
    function bnpChangeBit(n, op) {
      var r = BigInteger.ONE.shiftLeft(n);
      this.bitwiseTo(r, op, r);
      return r;
    }
    function bnSetBit(n) {
      return this.changeBit(n, op_or);
    }
    function bnClearBit(n) {
      return this.changeBit(n, op_andnot);
    }
    function bnFlipBit(n) {
      return this.changeBit(n, op_xor);
    }
    function bnpAddTo(a, r) {
      var i = 0,
        c = 0,
        m = Math.min(a.t, this.t);
      while (i < m) {
        c += this[i] + a[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c += a.s;
        while (i < this.t) {
          c += this[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a.t) {
          c += a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c > 0) r[i++] = c;
      else if (c < -1) r[i++] = this.DV + c;
      r.t = i;
      r.clamp();
    }
    function bnAdd(a) {
      var r = nbi();
      this.addTo(a, r);
      return r;
    }
    function bnSubtract(a) {
      var r = nbi();
      this.subTo(a, r);
      return r;
    }
    function bnMultiply(a) {
      var r = nbi();
      this.multiplyTo(a, r);
      return r;
    }
    function bnSquare() {
      var r = nbi();
      this.squareTo(r);
      return r;
    }
    function bnDivide(a) {
      var r = nbi();
      this.divRemTo(a, r, null);
      return r;
    }
    function bnRemainder(a) {
      var r = nbi();
      this.divRemTo(a, null, r);
      return r;
    }
    function bnDivideAndRemainder(a) {
      var q2 = nbi(),
        r = nbi();
      this.divRemTo(a, q2, r);
      return new Array(q2, r);
    }
    function bnpDMultiply(n) {
      this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
      ++this.t;
      this.clamp();
    }
    function bnpDAddOffset(n, w) {
      if (n == 0) return;
      while (this.t <= w) this[this.t++] = 0;
      this[w] += n;
      while (this[w] >= this.DV) {
        this[w] -= this.DV;
        if (++w >= this.t) this[this.t++] = 0;
        ++this[w];
      }
    }
    function NullExp() {}
    function nNop(x) {
      return x;
    }
    function nMulTo(x, y, r) {
      x.multiplyTo(y, r);
    }
    function nSqrTo(x, r) {
      x.squareTo(r);
    }
    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;
    function bnPow(e) {
      return this.exp(e, new NullExp());
    }
    function bnpMultiplyLowerTo(a, n, r) {
      var i = Math.min(this.t + a.t, n);
      r.s = 0;
      r.t = i;
      while (i > 0) r[--i] = 0;
      var j;
      for (j = r.t - this.t; i < j; ++i)
        r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
      for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);
      r.clamp();
    }
    function bnpMultiplyUpperTo(a, n, r) {
      --n;
      var i = (r.t = this.t + a.t - n);
      r.s = 0;
      while (--i >= 0) r[i] = 0;
      for (i = Math.max(n - this.t, 0); i < a.t; ++i)
        r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
      r.clamp();
      r.drShiftTo(1, r);
    }
    function Barrett(m) {
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
      this.mu = this.r2.divide(m);
      this.m = m;
    }
    function barrettConvert(x) {
      if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
      else if (x.compareTo(this.m) < 0) return x;
      else {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
    }
    function barrettRevert(x) {
      return x;
    }
    function barrettReduce(x) {
      x.drShiftTo(this.m.t - 1, this.r2);
      if (x.t > this.m.t + 1) {
        x.t = this.m.t + 1;
        x.clamp();
      }
      this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
      this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
      while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
      x.subTo(this.r2, x);
      while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
    }
    function barrettSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function barrettMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;
    function bnModPow(e, m) {
      var i = e.bitLength(),
        k,
        r = nbv(1),
        z2;
      if (i <= 0) return r;
      else if (i < 18) k = 1;
      else if (i < 48) k = 3;
      else if (i < 144) k = 4;
      else if (i < 768) k = 5;
      else k = 6;
      if (i < 8) z2 = new Classic(m);
      else if (m.isEven()) z2 = new Barrett(m);
      else z2 = new Montgomery(m);
      var g = new Array(),
        n = 3,
        k1 = k - 1,
        km = (1 << k) - 1;
      g[1] = z2.convert(this);
      if (k > 1) {
        var g2 = nbi();
        z2.sqrTo(g[1], g2);
        while (n <= km) {
          g[n] = nbi();
          z2.mulTo(g2, g[n - 2], g[n]);
          n += 2;
        }
      }
      var j = e.t - 1,
        w,
        is1 = true,
        r2 = nbi(),
        t2;
      i = nbits(e[j]) - 1;
      while (j >= 0) {
        if (i >= k1) w = (e[j] >> (i - k1)) & km;
        else {
          w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);
          if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);
        }
        n = k;
        while ((w & 1) == 0) {
          w >>= 1;
          --n;
        }
        if ((i -= n) < 0) {
          i += this.DB;
          --j;
        }
        if (is1) {
          g[w].copyTo(r);
          is1 = false;
        } else {
          while (n > 1) {
            z2.sqrTo(r, r2);
            z2.sqrTo(r2, r);
            n -= 2;
          }
          if (n > 0) z2.sqrTo(r, r2);
          else {
            t2 = r;
            r = r2;
            r2 = t2;
          }
          z2.mulTo(r2, g[w], r);
        }
        while (j >= 0 && (e[j] & (1 << i)) == 0) {
          z2.sqrTo(r, r2);
          t2 = r;
          r = r2;
          r2 = t2;
          if (--i < 0) {
            i = this.DB - 1;
            --j;
          }
        }
      }
      return z2.revert(r);
    }
    function bnGCD(a) {
      var x = this.s < 0 ? this.negate() : this.clone();
      var y = a.s < 0 ? a.negate() : a.clone();
      if (x.compareTo(y) < 0) {
        var t2 = x;
        x = y;
        y = t2;
      }
      var i = x.getLowestSetBit(),
        g = y.getLowestSetBit();
      if (g < 0) return x;
      if (i < g) g = i;
      if (g > 0) {
        x.rShiftTo(g, x);
        y.rShiftTo(g, y);
      }
      while (x.signum() > 0) {
        if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
        if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);
        if (x.compareTo(y) >= 0) {
          x.subTo(y, x);
          x.rShiftTo(1, x);
        } else {
          y.subTo(x, y);
          y.rShiftTo(1, y);
        }
      }
      if (g > 0) y.lShiftTo(g, y);
      return y;
    }
    function bnpModInt(n) {
      if (n <= 0) return 0;
      var d = this.DV % n,
        r = this.s < 0 ? n - 1 : 0;
      if (this.t > 0)
        if (d == 0) r = this[0] % n;
        else for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;
      return r;
    }
    function bnModInverse(m) {
      var ac = m.isEven();
      if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
      var u = m.clone(),
        v = this.clone();
      var a = nbv(1),
        b = nbv(0),
        c = nbv(0),
        d = nbv(1);
      while (u.signum() != 0) {
        while (u.isEven()) {
          u.rShiftTo(1, u);
          if (ac) {
            if (!a.isEven() || !b.isEven()) {
              a.addTo(this, a);
              b.subTo(m, b);
            }
            a.rShiftTo(1, a);
          } else if (!b.isEven()) b.subTo(m, b);
          b.rShiftTo(1, b);
        }
        while (v.isEven()) {
          v.rShiftTo(1, v);
          if (ac) {
            if (!c.isEven() || !d.isEven()) {
              c.addTo(this, c);
              d.subTo(m, d);
            }
            c.rShiftTo(1, c);
          } else if (!d.isEven()) d.subTo(m, d);
          d.rShiftTo(1, d);
        }
        if (u.compareTo(v) >= 0) {
          u.subTo(v, u);
          if (ac) a.subTo(c, a);
          b.subTo(d, b);
        } else {
          v.subTo(u, v);
          if (ac) c.subTo(a, c);
          d.subTo(b, d);
        }
      }
      if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
      if (d.compareTo(m) >= 0) return d.subtract(m);
      if (d.signum() < 0) d.addTo(m, d);
      else return d;
      if (d.signum() < 0) return d.add(m);
      else return d;
    }
    var lowprimes = [
      2,
      3,
      5,
      7,
      11,
      13,
      17,
      19,
      23,
      29,
      31,
      37,
      41,
      43,
      47,
      53,
      59,
      61,
      67,
      71,
      73,
      79,
      83,
      89,
      97,
      101,
      103,
      107,
      109,
      113,
      127,
      131,
      137,
      139,
      149,
      151,
      157,
      163,
      167,
      173,
      179,
      181,
      191,
      193,
      197,
      199,
      211,
      223,
      227,
      229,
      233,
      239,
      241,
      251,
      257,
      263,
      269,
      271,
      277,
      281,
      283,
      293,
      307,
      311,
      313,
      317,
      331,
      337,
      347,
      349,
      353,
      359,
      367,
      373,
      379,
      383,
      389,
      397,
      401,
      409,
      419,
      421,
      431,
      433,
      439,
      443,
      449,
      457,
      461,
      463,
      467,
      479,
      487,
      491,
      499,
      503,
      509,
      521,
      523,
      541,
      547,
      557,
      563,
      569,
      571,
      577,
      587,
      593,
      599,
      601,
      607,
      613,
      617,
      619,
      631,
      641,
      643,
      647,
      653,
      659,
      661,
      673,
      677,
      683,
      691,
      701,
      709,
      719,
      727,
      733,
      739,
      743,
      751,
      757,
      761,
      769,
      773,
      787,
      797,
      809,
      811,
      821,
      823,
      827,
      829,
      839,
      853,
      857,
      859,
      863,
      877,
      881,
      883,
      887,
      907,
      911,
      919,
      929,
      937,
      941,
      947,
      953,
      967,
      971,
      977,
      983,
      991,
      997,
    ];
    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
    function bnIsProbablePrime(t2) {
      var i,
        x = this.abs();
      if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
        for (i = 0; i < lowprimes.length; ++i)
          if (x[0] == lowprimes[i]) return true;
        return false;
      }
      if (x.isEven()) return false;
      i = 1;
      while (i < lowprimes.length) {
        var m = lowprimes[i],
          j = i + 1;
        while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];
        m = x.modInt(m);
        while (i < j) if (m % lowprimes[i++] == 0) return false;
      }
      return x.millerRabin(t2);
    }
    function bnpMillerRabin(t2) {
      var n1 = this.subtract(BigInteger.ONE);
      var k = n1.getLowestSetBit();
      if (k <= 0) return false;
      var r = n1.shiftRight(k);
      t2 = (t2 + 1) >> 1;
      if (t2 > lowprimes.length) t2 = lowprimes.length;
      var a = nbi();
      for (var i = 0; i < t2; ++i) {
        a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
        var y = a.modPow(r, this);
        if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
          var j = 1;
          while (j++ < k && y.compareTo(n1) != 0) {
            y = y.modPowInt(2, this);
            if (y.compareTo(BigInteger.ONE) == 0) return false;
          }
          if (y.compareTo(n1) != 0) return false;
        }
      }
      return true;
    }
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
    BigInteger.prototype.square = bnSquare;
    BigInteger.prototype.Barrett = Barrett;
    var rng_state;
    var rng_pool;
    var rng_pptr;
    function rng_seed_int(x) {
      rng_pool[rng_pptr++] ^= x & 255;
      rng_pool[rng_pptr++] ^= (x >> 8) & 255;
      rng_pool[rng_pptr++] ^= (x >> 16) & 255;
      rng_pool[rng_pptr++] ^= (x >> 24) & 255;
      if (rng_pptr >= rng_psize) rng_pptr -= rng_psize;
    }
    function rng_seed_time() {
      rng_seed_int(new Date().getTime());
    }
    if (rng_pool == null) {
      rng_pool = new Array();
      rng_pptr = 0;
      var t;
      if (typeof window !== 'undefined' && window.crypto) {
        if (window.crypto.getRandomValues) {
          var ua = new Uint8Array(32);
          window.crypto.getRandomValues(ua);
          for (t = 0; t < 32; ++t) rng_pool[rng_pptr++] = ua[t];
        } else if (
          navigator.appName == 'Netscape' &&
          navigator.appVersion < '5'
        ) {
          var z = window.crypto.random(32);
          for (t = 0; t < z.length; ++t)
            rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
        }
      }
      while (rng_pptr < rng_psize) {
        t = Math.floor(65536 * Math.random());
        rng_pool[rng_pptr++] = t >>> 8;
        rng_pool[rng_pptr++] = t & 255;
      }
      rng_pptr = 0;
      rng_seed_time();
    }
    function rng_get_byte() {
      if (rng_state == null) {
        rng_seed_time();
        rng_state = prng_newstate();
        rng_state.init(rng_pool);
        for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
          rng_pool[rng_pptr] = 0;
        rng_pptr = 0;
      }
      return rng_state.next();
    }
    function rng_get_bytes(ba) {
      var i;
      for (i = 0; i < ba.length; ++i) ba[i] = rng_get_byte();
    }
    function SecureRandom2() {}
    SecureRandom2.prototype.nextBytes = rng_get_bytes;
    function Arcfour() {
      this.i = 0;
      this.j = 0;
      this.S = new Array();
    }
    function ARC4init(key) {
      var i, j, t2;
      for (i = 0; i < 256; ++i) this.S[i] = i;
      j = 0;
      for (i = 0; i < 256; ++i) {
        j = (j + this.S[i] + key[i % key.length]) & 255;
        t2 = this.S[i];
        this.S[i] = this.S[j];
        this.S[j] = t2;
      }
      this.i = 0;
      this.j = 0;
    }
    function ARC4next() {
      var t2;
      this.i = (this.i + 1) & 255;
      this.j = (this.j + this.S[this.i]) & 255;
      t2 = this.S[this.i];
      this.S[this.i] = this.S[this.j];
      this.S[this.j] = t2;
      return this.S[(t2 + this.S[this.i]) & 255];
    }
    Arcfour.prototype.init = ARC4init;
    Arcfour.prototype.next = ARC4next;
    function prng_newstate() {
      return new Arcfour();
    }
    var rng_psize = 256;
    BigInteger.SecureRandom = SecureRandom2;
    BigInteger.BigInteger = BigInteger;
    if (typeof exports2 !== 'undefined') {
      exports2 = module2.exports = BigInteger;
    } else {
      this.BigInteger = BigInteger;
      this.SecureRandom = SecureRandom2;
    }
  }.call(exports2));
});

// node_modules/ecc-jsbn/lib/ec.js
var require_ec = __commonJS((exports2, module2) => {
  var BigInteger = require_jsbn().BigInteger;
  var Barrett = BigInteger.prototype.Barrett;
  function ECFieldElementFp(q2, x) {
    this.x = x;
    this.q = q2;
  }
  function feFpEquals(other) {
    if (other == this) return true;
    return this.q.equals(other.q) && this.x.equals(other.x);
  }
  function feFpToBigInteger() {
    return this.x;
  }
  function feFpNegate() {
    return new ECFieldElementFp(this.q, this.x.negate().mod(this.q));
  }
  function feFpAdd(b) {
    return new ECFieldElementFp(
      this.q,
      this.x.add(b.toBigInteger()).mod(this.q),
    );
  }
  function feFpSubtract(b) {
    return new ECFieldElementFp(
      this.q,
      this.x.subtract(b.toBigInteger()).mod(this.q),
    );
  }
  function feFpMultiply(b) {
    return new ECFieldElementFp(
      this.q,
      this.x.multiply(b.toBigInteger()).mod(this.q),
    );
  }
  function feFpSquare() {
    return new ECFieldElementFp(this.q, this.x.square().mod(this.q));
  }
  function feFpDivide(b) {
    return new ECFieldElementFp(
      this.q,
      this.x.multiply(b.toBigInteger().modInverse(this.q)).mod(this.q),
    );
  }
  ECFieldElementFp.prototype.equals = feFpEquals;
  ECFieldElementFp.prototype.toBigInteger = feFpToBigInteger;
  ECFieldElementFp.prototype.negate = feFpNegate;
  ECFieldElementFp.prototype.add = feFpAdd;
  ECFieldElementFp.prototype.subtract = feFpSubtract;
  ECFieldElementFp.prototype.multiply = feFpMultiply;
  ECFieldElementFp.prototype.square = feFpSquare;
  ECFieldElementFp.prototype.divide = feFpDivide;
  function ECPointFp(curve, x, y, z) {
    this.curve = curve;
    this.x = x;
    this.y = y;
    if (z == null) {
      this.z = BigInteger.ONE;
    } else {
      this.z = z;
    }
    this.zinv = null;
  }
  function pointFpGetX() {
    if (this.zinv == null) {
      this.zinv = this.z.modInverse(this.curve.q);
    }
    var r = this.x.toBigInteger().multiply(this.zinv);
    this.curve.reduce(r);
    return this.curve.fromBigInteger(r);
  }
  function pointFpGetY() {
    if (this.zinv == null) {
      this.zinv = this.z.modInverse(this.curve.q);
    }
    var r = this.y.toBigInteger().multiply(this.zinv);
    this.curve.reduce(r);
    return this.curve.fromBigInteger(r);
  }
  function pointFpEquals(other) {
    if (other == this) return true;
    if (this.isInfinity()) return other.isInfinity();
    if (other.isInfinity()) return this.isInfinity();
    var u, v;
    u = other.y
      .toBigInteger()
      .multiply(this.z)
      .subtract(this.y.toBigInteger().multiply(other.z))
      .mod(this.curve.q);
    if (!u.equals(BigInteger.ZERO)) return false;
    v = other.x
      .toBigInteger()
      .multiply(this.z)
      .subtract(this.x.toBigInteger().multiply(other.z))
      .mod(this.curve.q);
    return v.equals(BigInteger.ZERO);
  }
  function pointFpIsInfinity() {
    if (this.x == null && this.y == null) return true;
    return (
      this.z.equals(BigInteger.ZERO) &&
      !this.y.toBigInteger().equals(BigInteger.ZERO)
    );
  }
  function pointFpNegate() {
    return new ECPointFp(this.curve, this.x, this.y.negate(), this.z);
  }
  function pointFpAdd(b) {
    if (this.isInfinity()) return b;
    if (b.isInfinity()) return this;
    var u = b.y
      .toBigInteger()
      .multiply(this.z)
      .subtract(this.y.toBigInteger().multiply(b.z))
      .mod(this.curve.q);
    var v = b.x
      .toBigInteger()
      .multiply(this.z)
      .subtract(this.x.toBigInteger().multiply(b.z))
      .mod(this.curve.q);
    if (BigInteger.ZERO.equals(v)) {
      if (BigInteger.ZERO.equals(u)) {
        return this.twice();
      }
      return this.curve.getInfinity();
    }
    var THREE = new BigInteger('3');
    var x1 = this.x.toBigInteger();
    var y1 = this.y.toBigInteger();
    var x2 = b.x.toBigInteger();
    var y2 = b.y.toBigInteger();
    var v2 = v.square();
    var v3 = v2.multiply(v);
    var x1v2 = x1.multiply(v2);
    var zu2 = u.square().multiply(this.z);
    var x3 = zu2
      .subtract(x1v2.shiftLeft(1))
      .multiply(b.z)
      .subtract(v3)
      .multiply(v)
      .mod(this.curve.q);
    var y3 = x1v2
      .multiply(THREE)
      .multiply(u)
      .subtract(y1.multiply(v3))
      .subtract(zu2.multiply(u))
      .multiply(b.z)
      .add(u.multiply(v3))
      .mod(this.curve.q);
    var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.q);
    return new ECPointFp(
      this.curve,
      this.curve.fromBigInteger(x3),
      this.curve.fromBigInteger(y3),
      z3,
    );
  }
  function pointFpTwice() {
    if (this.isInfinity()) return this;
    if (this.y.toBigInteger().signum() == 0) return this.curve.getInfinity();
    var THREE = new BigInteger('3');
    var x1 = this.x.toBigInteger();
    var y1 = this.y.toBigInteger();
    var y1z1 = y1.multiply(this.z);
    var y1sqz1 = y1z1.multiply(y1).mod(this.curve.q);
    var a = this.curve.a.toBigInteger();
    var w = x1.square().multiply(THREE);
    if (!BigInteger.ZERO.equals(a)) {
      w = w.add(this.z.square().multiply(a));
    }
    w = w.mod(this.curve.q);
    var x3 = w
      .square()
      .subtract(x1.shiftLeft(3).multiply(y1sqz1))
      .shiftLeft(1)
      .multiply(y1z1)
      .mod(this.curve.q);
    var y3 = w
      .multiply(THREE)
      .multiply(x1)
      .subtract(y1sqz1.shiftLeft(1))
      .shiftLeft(2)
      .multiply(y1sqz1)
      .subtract(w.square().multiply(w))
      .mod(this.curve.q);
    var z3 = y1z1.square().multiply(y1z1).shiftLeft(3).mod(this.curve.q);
    return new ECPointFp(
      this.curve,
      this.curve.fromBigInteger(x3),
      this.curve.fromBigInteger(y3),
      z3,
    );
  }
  function pointFpMultiply(k) {
    if (this.isInfinity()) return this;
    if (k.signum() == 0) return this.curve.getInfinity();
    var e = k;
    var h = e.multiply(new BigInteger('3'));
    var neg = this.negate();
    var R = this;
    var i;
    for (i = h.bitLength() - 2; i > 0; --i) {
      R = R.twice();
      var hBit = h.testBit(i);
      var eBit = e.testBit(i);
      if (hBit != eBit) {
        R = R.add(hBit ? this : neg);
      }
    }
    return R;
  }
  function pointFpMultiplyTwo(j, x, k) {
    var i;
    if (j.bitLength() > k.bitLength()) i = j.bitLength() - 1;
    else i = k.bitLength() - 1;
    var R = this.curve.getInfinity();
    var both = this.add(x);
    while (i >= 0) {
      R = R.twice();
      if (j.testBit(i)) {
        if (k.testBit(i)) {
          R = R.add(both);
        } else {
          R = R.add(this);
        }
      } else {
        if (k.testBit(i)) {
          R = R.add(x);
        }
      }
      --i;
    }
    return R;
  }
  ECPointFp.prototype.getX = pointFpGetX;
  ECPointFp.prototype.getY = pointFpGetY;
  ECPointFp.prototype.equals = pointFpEquals;
  ECPointFp.prototype.isInfinity = pointFpIsInfinity;
  ECPointFp.prototype.negate = pointFpNegate;
  ECPointFp.prototype.add = pointFpAdd;
  ECPointFp.prototype.twice = pointFpTwice;
  ECPointFp.prototype.multiply = pointFpMultiply;
  ECPointFp.prototype.multiplyTwo = pointFpMultiplyTwo;
  function ECCurveFp(q2, a, b) {
    this.q = q2;
    this.a = this.fromBigInteger(a);
    this.b = this.fromBigInteger(b);
    this.infinity = new ECPointFp(this, null, null);
    this.reducer = new Barrett(this.q);
  }
  function curveFpGetQ() {
    return this.q;
  }
  function curveFpGetA() {
    return this.a;
  }
  function curveFpGetB() {
    return this.b;
  }
  function curveFpEquals(other) {
    if (other == this) return true;
    return (
      this.q.equals(other.q) && this.a.equals(other.a) && this.b.equals(other.b)
    );
  }
  function curveFpGetInfinity() {
    return this.infinity;
  }
  function curveFpFromBigInteger(x) {
    return new ECFieldElementFp(this.q, x);
  }
  function curveReduce(x) {
    this.reducer.reduce(x);
  }
  function curveFpEncodePointHex(p) {
    if (p.isInfinity()) return '00';
    var xHex = p.getX().toBigInteger().toString(16);
    var yHex = p.getY().toBigInteger().toString(16);
    var oLen = this.getQ().toString(16).length;
    if (oLen % 2 != 0) oLen++;
    while (xHex.length < oLen) {
      xHex = '0' + xHex;
    }
    while (yHex.length < oLen) {
      yHex = '0' + yHex;
    }
    return '04' + xHex + yHex;
  }
  ECCurveFp.prototype.getQ = curveFpGetQ;
  ECCurveFp.prototype.getA = curveFpGetA;
  ECCurveFp.prototype.getB = curveFpGetB;
  ECCurveFp.prototype.equals = curveFpEquals;
  ECCurveFp.prototype.getInfinity = curveFpGetInfinity;
  ECCurveFp.prototype.fromBigInteger = curveFpFromBigInteger;
  ECCurveFp.prototype.reduce = curveReduce;
  ECCurveFp.prototype.encodePointHex = curveFpEncodePointHex;
  ECCurveFp.prototype.decodePointHex = function (s) {
    var yIsEven;
    switch (parseInt(s.substr(0, 2), 16)) {
      case 0:
        return this.infinity;
      case 2:
        yIsEven = false;
      case 3:
        if (yIsEven == void 0) yIsEven = true;
        var len = s.length - 2;
        var xHex = s.substr(2, len);
        var x = this.fromBigInteger(new BigInteger(xHex, 16));
        var alpha = x.multiply(x.square().add(this.getA())).add(this.getB());
        var beta = alpha.sqrt();
        if (beta == null) throw 'Invalid point compression';
        var betaValue = beta.toBigInteger();
        if (betaValue.testBit(0) != yIsEven) {
          beta = this.fromBigInteger(this.getQ().subtract(betaValue));
        }
        return new ECPointFp(this, x, beta);
      case 4:
      case 6:
      case 7:
        var len = (s.length - 2) / 2;
        var xHex = s.substr(2, len);
        var yHex = s.substr(len + 2, len);
        return new ECPointFp(
          this,
          this.fromBigInteger(new BigInteger(xHex, 16)),
          this.fromBigInteger(new BigInteger(yHex, 16)),
        );
      default:
        return null;
    }
  };
  ECCurveFp.prototype.encodeCompressedPointHex = function (p) {
    if (p.isInfinity()) return '00';
    var xHex = p.getX().toBigInteger().toString(16);
    var oLen = this.getQ().toString(16).length;
    if (oLen % 2 != 0) oLen++;
    while (xHex.length < oLen) xHex = '0' + xHex;
    var yPrefix;
    if (p.getY().toBigInteger().isEven()) yPrefix = '02';
    else yPrefix = '03';
    return yPrefix + xHex;
  };
  ECFieldElementFp.prototype.getR = function () {
    if (this.r != void 0) return this.r;
    this.r = null;
    var bitLength = this.q.bitLength();
    if (bitLength > 128) {
      var firstWord = this.q.shiftRight(bitLength - 64);
      if (firstWord.intValue() == -1) {
        this.r = BigInteger.ONE.shiftLeft(bitLength).subtract(this.q);
      }
    }
    return this.r;
  };
  ECFieldElementFp.prototype.modMult = function (x1, x2) {
    return this.modReduce(x1.multiply(x2));
  };
  ECFieldElementFp.prototype.modReduce = function (x) {
    if (this.getR() != null) {
      var qLen = q.bitLength();
      while (x.bitLength() > qLen + 1) {
        var u = x.shiftRight(qLen);
        var v = x.subtract(u.shiftLeft(qLen));
        if (!this.getR().equals(BigInteger.ONE)) {
          u = u.multiply(this.getR());
        }
        x = u.add(v);
      }
      while (x.compareTo(q) >= 0) {
        x = x.subtract(q);
      }
    } else {
      x = x.mod(q);
    }
    return x;
  };
  ECFieldElementFp.prototype.sqrt = function () {
    if (!this.q.testBit(0)) throw 'unsupported';
    if (this.q.testBit(1)) {
      var z = new ECFieldElementFp(
        this.q,
        this.x.modPow(this.q.shiftRight(2).add(BigInteger.ONE), this.q),
      );
      return z.square().equals(this) ? z : null;
    }
    var qMinusOne = this.q.subtract(BigInteger.ONE);
    var legendreExponent = qMinusOne.shiftRight(1);
    if (!this.x.modPow(legendreExponent, this.q).equals(BigInteger.ONE)) {
      return null;
    }
    var u = qMinusOne.shiftRight(2);
    var k = u.shiftLeft(1).add(BigInteger.ONE);
    var Q = this.x;
    var fourQ = modDouble(modDouble(Q));
    var U, V;
    do {
      var P;
      do {
        P = new BigInteger(this.q.bitLength(), new SecureRandom());
      } while (
        P.compareTo(this.q) >= 0 ||
        !P.multiply(P)
          .subtract(fourQ)
          .modPow(legendreExponent, this.q)
          .equals(qMinusOne)
      );
      var result = this.lucasSequence(P, Q, k);
      U = result[0];
      V = result[1];
      if (this.modMult(V, V).equals(fourQ)) {
        if (V.testBit(0)) {
          V = V.add(q);
        }
        V = V.shiftRight(1);
        return new ECFieldElementFp(q, V);
      }
    } while (U.equals(BigInteger.ONE) || U.equals(qMinusOne));
    return null;
  };
  ECFieldElementFp.prototype.lucasSequence = function (P, Q, k) {
    var n = k.bitLength();
    var s = k.getLowestSetBit();
    var Uh = BigInteger.ONE;
    var Vl = BigInteger.TWO;
    var Vh = P;
    var Ql = BigInteger.ONE;
    var Qh = BigInteger.ONE;
    for (var j = n - 1; j >= s + 1; --j) {
      Ql = this.modMult(Ql, Qh);
      if (k.testBit(j)) {
        Qh = this.modMult(Ql, Q);
        Uh = this.modMult(Uh, Vh);
        Vl = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
        Vh = this.modReduce(Vh.multiply(Vh).subtract(Qh.shiftLeft(1)));
      } else {
        Qh = Ql;
        Uh = this.modReduce(Uh.multiply(Vl).subtract(Ql));
        Vh = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
        Vl = this.modReduce(Vl.multiply(Vl).subtract(Ql.shiftLeft(1)));
      }
    }
    Ql = this.modMult(Ql, Qh);
    Qh = this.modMult(Ql, Q);
    Uh = this.modReduce(Uh.multiply(Vl).subtract(Ql));
    Vl = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
    Ql = this.modMult(Ql, Qh);
    for (var j = 1; j <= s; ++j) {
      Uh = this.modMult(Uh, Vl);
      Vl = this.modReduce(Vl.multiply(Vl).subtract(Ql.shiftLeft(1)));
      Ql = this.modMult(Ql, Ql);
    }
    return [Uh, Vl];
  };
  var exports2 = {
    ECCurveFp,
    ECPointFp,
    ECFieldElementFp,
  };
  module2.exports = exports2;
});

// node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS((exports2, module2) => {
  (function (nacl) {
    'use strict';
    var gf = function (init2) {
      var i,
        r = new Float64Array(16);
      if (init2) for (i = 0; i < init2.length; i++) r[i] = init2[i];
      return r;
    };
    var randombytes = function () {
      throw new Error('no PRNG');
    };
    var _0 = new Uint8Array(16);
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var gf0 = gf(),
      gf1 = gf([1]),
      _121665 = gf([56129, 1]),
      D = gf([
        30883,
        4953,
        19914,
        30187,
        55467,
        16705,
        2637,
        112,
        59544,
        30585,
        16505,
        36039,
        65139,
        11119,
        27886,
        20995,
      ]),
      D2 = gf([
        61785,
        9906,
        39828,
        60374,
        45398,
        33411,
        5274,
        224,
        53552,
        61171,
        33010,
        6542,
        64743,
        22239,
        55772,
        9222,
      ]),
      X = gf([
        54554,
        36645,
        11616,
        51542,
        42930,
        38181,
        51040,
        26924,
        56412,
        64982,
        57905,
        49316,
        21502,
        52590,
        14035,
        8553,
      ]),
      Y = gf([
        26200,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
      ]),
      I = gf([
        41136,
        18958,
        6951,
        50414,
        58488,
        44335,
        6150,
        12099,
        55207,
        15867,
        153,
        11085,
        57099,
        20417,
        9344,
        11139,
      ]);
    function ts64(x, i, h, l) {
      x[i] = (h >> 24) & 255;
      x[i + 1] = (h >> 16) & 255;
      x[i + 2] = (h >> 8) & 255;
      x[i + 3] = h & 255;
      x[i + 4] = (l >> 24) & 255;
      x[i + 5] = (l >> 16) & 255;
      x[i + 6] = (l >> 8) & 255;
      x[i + 7] = l & 255;
    }
    function vn(x, xi, y, yi, n) {
      var i,
        d = 0;
      for (i = 0; i < n; i++) d |= x[xi + i] ^ y[yi + i];
      return (1 & ((d - 1) >>> 8)) - 1;
    }
    function crypto_verify_16(x, xi, y, yi) {
      return vn(x, xi, y, yi, 16);
    }
    function crypto_verify_32(x, xi, y, yi) {
      return vn(x, xi, y, yi, 32);
    }
    function core_salsa20(o, p, k, c) {
      var j0 =
          (c[0] & 255) |
          ((c[1] & 255) << 8) |
          ((c[2] & 255) << 16) |
          ((c[3] & 255) << 24),
        j1 =
          (k[0] & 255) |
          ((k[1] & 255) << 8) |
          ((k[2] & 255) << 16) |
          ((k[3] & 255) << 24),
        j2 =
          (k[4] & 255) |
          ((k[5] & 255) << 8) |
          ((k[6] & 255) << 16) |
          ((k[7] & 255) << 24),
        j3 =
          (k[8] & 255) |
          ((k[9] & 255) << 8) |
          ((k[10] & 255) << 16) |
          ((k[11] & 255) << 24),
        j4 =
          (k[12] & 255) |
          ((k[13] & 255) << 8) |
          ((k[14] & 255) << 16) |
          ((k[15] & 255) << 24),
        j5 =
          (c[4] & 255) |
          ((c[5] & 255) << 8) |
          ((c[6] & 255) << 16) |
          ((c[7] & 255) << 24),
        j6 =
          (p[0] & 255) |
          ((p[1] & 255) << 8) |
          ((p[2] & 255) << 16) |
          ((p[3] & 255) << 24),
        j7 =
          (p[4] & 255) |
          ((p[5] & 255) << 8) |
          ((p[6] & 255) << 16) |
          ((p[7] & 255) << 24),
        j8 =
          (p[8] & 255) |
          ((p[9] & 255) << 8) |
          ((p[10] & 255) << 16) |
          ((p[11] & 255) << 24),
        j9 =
          (p[12] & 255) |
          ((p[13] & 255) << 8) |
          ((p[14] & 255) << 16) |
          ((p[15] & 255) << 24),
        j10 =
          (c[8] & 255) |
          ((c[9] & 255) << 8) |
          ((c[10] & 255) << 16) |
          ((c[11] & 255) << 24),
        j11 =
          (k[16] & 255) |
          ((k[17] & 255) << 8) |
          ((k[18] & 255) << 16) |
          ((k[19] & 255) << 24),
        j12 =
          (k[20] & 255) |
          ((k[21] & 255) << 8) |
          ((k[22] & 255) << 16) |
          ((k[23] & 255) << 24),
        j13 =
          (k[24] & 255) |
          ((k[25] & 255) << 8) |
          ((k[26] & 255) << 16) |
          ((k[27] & 255) << 24),
        j14 =
          (k[28] & 255) |
          ((k[29] & 255) << 8) |
          ((k[30] & 255) << 16) |
          ((k[31] & 255) << 24),
        j15 =
          (c[12] & 255) |
          ((c[13] & 255) << 8) |
          ((c[14] & 255) << 16) |
          ((c[15] & 255) << 24);
      var x0 = j0,
        x1 = j1,
        x2 = j2,
        x3 = j3,
        x4 = j4,
        x5 = j5,
        x6 = j6,
        x7 = j7,
        x8 = j8,
        x9 = j9,
        x10 = j10,
        x11 = j11,
        x12 = j12,
        x13 = j13,
        x14 = j14,
        x15 = j15,
        u;
      for (var i = 0; i < 20; i += 2) {
        u = (x0 + x12) | 0;
        x4 ^= (u << 7) | (u >>> (32 - 7));
        u = (x4 + x0) | 0;
        x8 ^= (u << 9) | (u >>> (32 - 9));
        u = (x8 + x4) | 0;
        x12 ^= (u << 13) | (u >>> (32 - 13));
        u = (x12 + x8) | 0;
        x0 ^= (u << 18) | (u >>> (32 - 18));
        u = (x5 + x1) | 0;
        x9 ^= (u << 7) | (u >>> (32 - 7));
        u = (x9 + x5) | 0;
        x13 ^= (u << 9) | (u >>> (32 - 9));
        u = (x13 + x9) | 0;
        x1 ^= (u << 13) | (u >>> (32 - 13));
        u = (x1 + x13) | 0;
        x5 ^= (u << 18) | (u >>> (32 - 18));
        u = (x10 + x6) | 0;
        x14 ^= (u << 7) | (u >>> (32 - 7));
        u = (x14 + x10) | 0;
        x2 ^= (u << 9) | (u >>> (32 - 9));
        u = (x2 + x14) | 0;
        x6 ^= (u << 13) | (u >>> (32 - 13));
        u = (x6 + x2) | 0;
        x10 ^= (u << 18) | (u >>> (32 - 18));
        u = (x15 + x11) | 0;
        x3 ^= (u << 7) | (u >>> (32 - 7));
        u = (x3 + x15) | 0;
        x7 ^= (u << 9) | (u >>> (32 - 9));
        u = (x7 + x3) | 0;
        x11 ^= (u << 13) | (u >>> (32 - 13));
        u = (x11 + x7) | 0;
        x15 ^= (u << 18) | (u >>> (32 - 18));
        u = (x0 + x3) | 0;
        x1 ^= (u << 7) | (u >>> (32 - 7));
        u = (x1 + x0) | 0;
        x2 ^= (u << 9) | (u >>> (32 - 9));
        u = (x2 + x1) | 0;
        x3 ^= (u << 13) | (u >>> (32 - 13));
        u = (x3 + x2) | 0;
        x0 ^= (u << 18) | (u >>> (32 - 18));
        u = (x5 + x4) | 0;
        x6 ^= (u << 7) | (u >>> (32 - 7));
        u = (x6 + x5) | 0;
        x7 ^= (u << 9) | (u >>> (32 - 9));
        u = (x7 + x6) | 0;
        x4 ^= (u << 13) | (u >>> (32 - 13));
        u = (x4 + x7) | 0;
        x5 ^= (u << 18) | (u >>> (32 - 18));
        u = (x10 + x9) | 0;
        x11 ^= (u << 7) | (u >>> (32 - 7));
        u = (x11 + x10) | 0;
        x8 ^= (u << 9) | (u >>> (32 - 9));
        u = (x8 + x11) | 0;
        x9 ^= (u << 13) | (u >>> (32 - 13));
        u = (x9 + x8) | 0;
        x10 ^= (u << 18) | (u >>> (32 - 18));
        u = (x15 + x14) | 0;
        x12 ^= (u << 7) | (u >>> (32 - 7));
        u = (x12 + x15) | 0;
        x13 ^= (u << 9) | (u >>> (32 - 9));
        u = (x13 + x12) | 0;
        x14 ^= (u << 13) | (u >>> (32 - 13));
        u = (x14 + x13) | 0;
        x15 ^= (u << 18) | (u >>> (32 - 18));
      }
      x0 = (x0 + j0) | 0;
      x1 = (x1 + j1) | 0;
      x2 = (x2 + j2) | 0;
      x3 = (x3 + j3) | 0;
      x4 = (x4 + j4) | 0;
      x5 = (x5 + j5) | 0;
      x6 = (x6 + j6) | 0;
      x7 = (x7 + j7) | 0;
      x8 = (x8 + j8) | 0;
      x9 = (x9 + j9) | 0;
      x10 = (x10 + j10) | 0;
      x11 = (x11 + j11) | 0;
      x12 = (x12 + j12) | 0;
      x13 = (x13 + j13) | 0;
      x14 = (x14 + j14) | 0;
      x15 = (x15 + j15) | 0;
      o[0] = (x0 >>> 0) & 255;
      o[1] = (x0 >>> 8) & 255;
      o[2] = (x0 >>> 16) & 255;
      o[3] = (x0 >>> 24) & 255;
      o[4] = (x1 >>> 0) & 255;
      o[5] = (x1 >>> 8) & 255;
      o[6] = (x1 >>> 16) & 255;
      o[7] = (x1 >>> 24) & 255;
      o[8] = (x2 >>> 0) & 255;
      o[9] = (x2 >>> 8) & 255;
      o[10] = (x2 >>> 16) & 255;
      o[11] = (x2 >>> 24) & 255;
      o[12] = (x3 >>> 0) & 255;
      o[13] = (x3 >>> 8) & 255;
      o[14] = (x3 >>> 16) & 255;
      o[15] = (x3 >>> 24) & 255;
      o[16] = (x4 >>> 0) & 255;
      o[17] = (x4 >>> 8) & 255;
      o[18] = (x4 >>> 16) & 255;
      o[19] = (x4 >>> 24) & 255;
      o[20] = (x5 >>> 0) & 255;
      o[21] = (x5 >>> 8) & 255;
      o[22] = (x5 >>> 16) & 255;
      o[23] = (x5 >>> 24) & 255;
      o[24] = (x6 >>> 0) & 255;
      o[25] = (x6 >>> 8) & 255;
      o[26] = (x6 >>> 16) & 255;
      o[27] = (x6 >>> 24) & 255;
      o[28] = (x7 >>> 0) & 255;
      o[29] = (x7 >>> 8) & 255;
      o[30] = (x7 >>> 16) & 255;
      o[31] = (x7 >>> 24) & 255;
      o[32] = (x8 >>> 0) & 255;
      o[33] = (x8 >>> 8) & 255;
      o[34] = (x8 >>> 16) & 255;
      o[35] = (x8 >>> 24) & 255;
      o[36] = (x9 >>> 0) & 255;
      o[37] = (x9 >>> 8) & 255;
      o[38] = (x9 >>> 16) & 255;
      o[39] = (x9 >>> 24) & 255;
      o[40] = (x10 >>> 0) & 255;
      o[41] = (x10 >>> 8) & 255;
      o[42] = (x10 >>> 16) & 255;
      o[43] = (x10 >>> 24) & 255;
      o[44] = (x11 >>> 0) & 255;
      o[45] = (x11 >>> 8) & 255;
      o[46] = (x11 >>> 16) & 255;
      o[47] = (x11 >>> 24) & 255;
      o[48] = (x12 >>> 0) & 255;
      o[49] = (x12 >>> 8) & 255;
      o[50] = (x12 >>> 16) & 255;
      o[51] = (x12 >>> 24) & 255;
      o[52] = (x13 >>> 0) & 255;
      o[53] = (x13 >>> 8) & 255;
      o[54] = (x13 >>> 16) & 255;
      o[55] = (x13 >>> 24) & 255;
      o[56] = (x14 >>> 0) & 255;
      o[57] = (x14 >>> 8) & 255;
      o[58] = (x14 >>> 16) & 255;
      o[59] = (x14 >>> 24) & 255;
      o[60] = (x15 >>> 0) & 255;
      o[61] = (x15 >>> 8) & 255;
      o[62] = (x15 >>> 16) & 255;
      o[63] = (x15 >>> 24) & 255;
    }
    function core_hsalsa20(o, p, k, c) {
      var j0 =
          (c[0] & 255) |
          ((c[1] & 255) << 8) |
          ((c[2] & 255) << 16) |
          ((c[3] & 255) << 24),
        j1 =
          (k[0] & 255) |
          ((k[1] & 255) << 8) |
          ((k[2] & 255) << 16) |
          ((k[3] & 255) << 24),
        j2 =
          (k[4] & 255) |
          ((k[5] & 255) << 8) |
          ((k[6] & 255) << 16) |
          ((k[7] & 255) << 24),
        j3 =
          (k[8] & 255) |
          ((k[9] & 255) << 8) |
          ((k[10] & 255) << 16) |
          ((k[11] & 255) << 24),
        j4 =
          (k[12] & 255) |
          ((k[13] & 255) << 8) |
          ((k[14] & 255) << 16) |
          ((k[15] & 255) << 24),
        j5 =
          (c[4] & 255) |
          ((c[5] & 255) << 8) |
          ((c[6] & 255) << 16) |
          ((c[7] & 255) << 24),
        j6 =
          (p[0] & 255) |
          ((p[1] & 255) << 8) |
          ((p[2] & 255) << 16) |
          ((p[3] & 255) << 24),
        j7 =
          (p[4] & 255) |
          ((p[5] & 255) << 8) |
          ((p[6] & 255) << 16) |
          ((p[7] & 255) << 24),
        j8 =
          (p[8] & 255) |
          ((p[9] & 255) << 8) |
          ((p[10] & 255) << 16) |
          ((p[11] & 255) << 24),
        j9 =
          (p[12] & 255) |
          ((p[13] & 255) << 8) |
          ((p[14] & 255) << 16) |
          ((p[15] & 255) << 24),
        j10 =
          (c[8] & 255) |
          ((c[9] & 255) << 8) |
          ((c[10] & 255) << 16) |
          ((c[11] & 255) << 24),
        j11 =
          (k[16] & 255) |
          ((k[17] & 255) << 8) |
          ((k[18] & 255) << 16) |
          ((k[19] & 255) << 24),
        j12 =
          (k[20] & 255) |
          ((k[21] & 255) << 8) |
          ((k[22] & 255) << 16) |
          ((k[23] & 255) << 24),
        j13 =
          (k[24] & 255) |
          ((k[25] & 255) << 8) |
          ((k[26] & 255) << 16) |
          ((k[27] & 255) << 24),
        j14 =
          (k[28] & 255) |
          ((k[29] & 255) << 8) |
          ((k[30] & 255) << 16) |
          ((k[31] & 255) << 24),
        j15 =
          (c[12] & 255) |
          ((c[13] & 255) << 8) |
          ((c[14] & 255) << 16) |
          ((c[15] & 255) << 24);
      var x0 = j0,
        x1 = j1,
        x2 = j2,
        x3 = j3,
        x4 = j4,
        x5 = j5,
        x6 = j6,
        x7 = j7,
        x8 = j8,
        x9 = j9,
        x10 = j10,
        x11 = j11,
        x12 = j12,
        x13 = j13,
        x14 = j14,
        x15 = j15,
        u;
      for (var i = 0; i < 20; i += 2) {
        u = (x0 + x12) | 0;
        x4 ^= (u << 7) | (u >>> (32 - 7));
        u = (x4 + x0) | 0;
        x8 ^= (u << 9) | (u >>> (32 - 9));
        u = (x8 + x4) | 0;
        x12 ^= (u << 13) | (u >>> (32 - 13));
        u = (x12 + x8) | 0;
        x0 ^= (u << 18) | (u >>> (32 - 18));
        u = (x5 + x1) | 0;
        x9 ^= (u << 7) | (u >>> (32 - 7));
        u = (x9 + x5) | 0;
        x13 ^= (u << 9) | (u >>> (32 - 9));
        u = (x13 + x9) | 0;
        x1 ^= (u << 13) | (u >>> (32 - 13));
        u = (x1 + x13) | 0;
        x5 ^= (u << 18) | (u >>> (32 - 18));
        u = (x10 + x6) | 0;
        x14 ^= (u << 7) | (u >>> (32 - 7));
        u = (x14 + x10) | 0;
        x2 ^= (u << 9) | (u >>> (32 - 9));
        u = (x2 + x14) | 0;
        x6 ^= (u << 13) | (u >>> (32 - 13));
        u = (x6 + x2) | 0;
        x10 ^= (u << 18) | (u >>> (32 - 18));
        u = (x15 + x11) | 0;
        x3 ^= (u << 7) | (u >>> (32 - 7));
        u = (x3 + x15) | 0;
        x7 ^= (u << 9) | (u >>> (32 - 9));
        u = (x7 + x3) | 0;
        x11 ^= (u << 13) | (u >>> (32 - 13));
        u = (x11 + x7) | 0;
        x15 ^= (u << 18) | (u >>> (32 - 18));
        u = (x0 + x3) | 0;
        x1 ^= (u << 7) | (u >>> (32 - 7));
        u = (x1 + x0) | 0;
        x2 ^= (u << 9) | (u >>> (32 - 9));
        u = (x2 + x1) | 0;
        x3 ^= (u << 13) | (u >>> (32 - 13));
        u = (x3 + x2) | 0;
        x0 ^= (u << 18) | (u >>> (32 - 18));
        u = (x5 + x4) | 0;
        x6 ^= (u << 7) | (u >>> (32 - 7));
        u = (x6 + x5) | 0;
        x7 ^= (u << 9) | (u >>> (32 - 9));
        u = (x7 + x6) | 0;
        x4 ^= (u << 13) | (u >>> (32 - 13));
        u = (x4 + x7) | 0;
        x5 ^= (u << 18) | (u >>> (32 - 18));
        u = (x10 + x9) | 0;
        x11 ^= (u << 7) | (u >>> (32 - 7));
        u = (x11 + x10) | 0;
        x8 ^= (u << 9) | (u >>> (32 - 9));
        u = (x8 + x11) | 0;
        x9 ^= (u << 13) | (u >>> (32 - 13));
        u = (x9 + x8) | 0;
        x10 ^= (u << 18) | (u >>> (32 - 18));
        u = (x15 + x14) | 0;
        x12 ^= (u << 7) | (u >>> (32 - 7));
        u = (x12 + x15) | 0;
        x13 ^= (u << 9) | (u >>> (32 - 9));
        u = (x13 + x12) | 0;
        x14 ^= (u << 13) | (u >>> (32 - 13));
        u = (x14 + x13) | 0;
        x15 ^= (u << 18) | (u >>> (32 - 18));
      }
      o[0] = (x0 >>> 0) & 255;
      o[1] = (x0 >>> 8) & 255;
      o[2] = (x0 >>> 16) & 255;
      o[3] = (x0 >>> 24) & 255;
      o[4] = (x5 >>> 0) & 255;
      o[5] = (x5 >>> 8) & 255;
      o[6] = (x5 >>> 16) & 255;
      o[7] = (x5 >>> 24) & 255;
      o[8] = (x10 >>> 0) & 255;
      o[9] = (x10 >>> 8) & 255;
      o[10] = (x10 >>> 16) & 255;
      o[11] = (x10 >>> 24) & 255;
      o[12] = (x15 >>> 0) & 255;
      o[13] = (x15 >>> 8) & 255;
      o[14] = (x15 >>> 16) & 255;
      o[15] = (x15 >>> 24) & 255;
      o[16] = (x6 >>> 0) & 255;
      o[17] = (x6 >>> 8) & 255;
      o[18] = (x6 >>> 16) & 255;
      o[19] = (x6 >>> 24) & 255;
      o[20] = (x7 >>> 0) & 255;
      o[21] = (x7 >>> 8) & 255;
      o[22] = (x7 >>> 16) & 255;
      o[23] = (x7 >>> 24) & 255;
      o[24] = (x8 >>> 0) & 255;
      o[25] = (x8 >>> 8) & 255;
      o[26] = (x8 >>> 16) & 255;
      o[27] = (x8 >>> 24) & 255;
      o[28] = (x9 >>> 0) & 255;
      o[29] = (x9 >>> 8) & 255;
      o[30] = (x9 >>> 16) & 255;
      o[31] = (x9 >>> 24) & 255;
    }
    function crypto_core_salsa20(out, inp, k, c) {
      core_salsa20(out, inp, k, c);
    }
    function crypto_core_hsalsa20(out, inp, k, c) {
      core_hsalsa20(out, inp, k, c);
    }
    var sigma = new Uint8Array([
      101,
      120,
      112,
      97,
      110,
      100,
      32,
      51,
      50,
      45,
      98,
      121,
      116,
      101,
      32,
      107,
    ]);
    function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
      var z = new Uint8Array(16),
        x = new Uint8Array(64);
      var u, i;
      for (i = 0; i < 16; i++) z[i] = 0;
      for (i = 0; i < 8; i++) z[i] = n[i];
      while (b >= 64) {
        crypto_core_salsa20(x, z, k, sigma);
        for (i = 0; i < 64; i++) c[cpos + i] = m[mpos + i] ^ x[i];
        u = 1;
        for (i = 8; i < 16; i++) {
          u = (u + (z[i] & 255)) | 0;
          z[i] = u & 255;
          u >>>= 8;
        }
        b -= 64;
        cpos += 64;
        mpos += 64;
      }
      if (b > 0) {
        crypto_core_salsa20(x, z, k, sigma);
        for (i = 0; i < b; i++) c[cpos + i] = m[mpos + i] ^ x[i];
      }
      return 0;
    }
    function crypto_stream_salsa20(c, cpos, b, n, k) {
      var z = new Uint8Array(16),
        x = new Uint8Array(64);
      var u, i;
      for (i = 0; i < 16; i++) z[i] = 0;
      for (i = 0; i < 8; i++) z[i] = n[i];
      while (b >= 64) {
        crypto_core_salsa20(x, z, k, sigma);
        for (i = 0; i < 64; i++) c[cpos + i] = x[i];
        u = 1;
        for (i = 8; i < 16; i++) {
          u = (u + (z[i] & 255)) | 0;
          z[i] = u & 255;
          u >>>= 8;
        }
        b -= 64;
        cpos += 64;
      }
      if (b > 0) {
        crypto_core_salsa20(x, z, k, sigma);
        for (i = 0; i < b; i++) c[cpos + i] = x[i];
      }
      return 0;
    }
    function crypto_stream(c, cpos, d, n, k) {
      var s = new Uint8Array(32);
      crypto_core_hsalsa20(s, n, k, sigma);
      var sn = new Uint8Array(8);
      for (var i = 0; i < 8; i++) sn[i] = n[i + 16];
      return crypto_stream_salsa20(c, cpos, d, sn, s);
    }
    function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
      var s = new Uint8Array(32);
      crypto_core_hsalsa20(s, n, k, sigma);
      var sn = new Uint8Array(8);
      for (var i = 0; i < 8; i++) sn[i] = n[i + 16];
      return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
    }
    var poly1305 = function (key) {
      this.buffer = new Uint8Array(16);
      this.r = new Uint16Array(10);
      this.h = new Uint16Array(10);
      this.pad = new Uint16Array(8);
      this.leftover = 0;
      this.fin = 0;
      var t0, t1, t2, t3, t4, t5, t6, t7;
      t0 = (key[0] & 255) | ((key[1] & 255) << 8);
      this.r[0] = t0 & 8191;
      t1 = (key[2] & 255) | ((key[3] & 255) << 8);
      this.r[1] = ((t0 >>> 13) | (t1 << 3)) & 8191;
      t2 = (key[4] & 255) | ((key[5] & 255) << 8);
      this.r[2] = ((t1 >>> 10) | (t2 << 6)) & 7939;
      t3 = (key[6] & 255) | ((key[7] & 255) << 8);
      this.r[3] = ((t2 >>> 7) | (t3 << 9)) & 8191;
      t4 = (key[8] & 255) | ((key[9] & 255) << 8);
      this.r[4] = ((t3 >>> 4) | (t4 << 12)) & 255;
      this.r[5] = (t4 >>> 1) & 8190;
      t5 = (key[10] & 255) | ((key[11] & 255) << 8);
      this.r[6] = ((t4 >>> 14) | (t5 << 2)) & 8191;
      t6 = (key[12] & 255) | ((key[13] & 255) << 8);
      this.r[7] = ((t5 >>> 11) | (t6 << 5)) & 8065;
      t7 = (key[14] & 255) | ((key[15] & 255) << 8);
      this.r[8] = ((t6 >>> 8) | (t7 << 8)) & 8191;
      this.r[9] = (t7 >>> 5) & 127;
      this.pad[0] = (key[16] & 255) | ((key[17] & 255) << 8);
      this.pad[1] = (key[18] & 255) | ((key[19] & 255) << 8);
      this.pad[2] = (key[20] & 255) | ((key[21] & 255) << 8);
      this.pad[3] = (key[22] & 255) | ((key[23] & 255) << 8);
      this.pad[4] = (key[24] & 255) | ((key[25] & 255) << 8);
      this.pad[5] = (key[26] & 255) | ((key[27] & 255) << 8);
      this.pad[6] = (key[28] & 255) | ((key[29] & 255) << 8);
      this.pad[7] = (key[30] & 255) | ((key[31] & 255) << 8);
    };
    poly1305.prototype.blocks = function (m, mpos, bytes) {
      var hibit = this.fin ? 0 : 1 << 11;
      var t0, t1, t2, t3, t4, t5, t6, t7, c;
      var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
      var h0 = this.h[0],
        h1 = this.h[1],
        h2 = this.h[2],
        h3 = this.h[3],
        h4 = this.h[4],
        h5 = this.h[5],
        h6 = this.h[6],
        h7 = this.h[7],
        h8 = this.h[8],
        h9 = this.h[9];
      var r0 = this.r[0],
        r1 = this.r[1],
        r2 = this.r[2],
        r3 = this.r[3],
        r4 = this.r[4],
        r5 = this.r[5],
        r6 = this.r[6],
        r7 = this.r[7],
        r8 = this.r[8],
        r9 = this.r[9];
      while (bytes >= 16) {
        t0 = (m[mpos + 0] & 255) | ((m[mpos + 1] & 255) << 8);
        h0 += t0 & 8191;
        t1 = (m[mpos + 2] & 255) | ((m[mpos + 3] & 255) << 8);
        h1 += ((t0 >>> 13) | (t1 << 3)) & 8191;
        t2 = (m[mpos + 4] & 255) | ((m[mpos + 5] & 255) << 8);
        h2 += ((t1 >>> 10) | (t2 << 6)) & 8191;
        t3 = (m[mpos + 6] & 255) | ((m[mpos + 7] & 255) << 8);
        h3 += ((t2 >>> 7) | (t3 << 9)) & 8191;
        t4 = (m[mpos + 8] & 255) | ((m[mpos + 9] & 255) << 8);
        h4 += ((t3 >>> 4) | (t4 << 12)) & 8191;
        h5 += (t4 >>> 1) & 8191;
        t5 = (m[mpos + 10] & 255) | ((m[mpos + 11] & 255) << 8);
        h6 += ((t4 >>> 14) | (t5 << 2)) & 8191;
        t6 = (m[mpos + 12] & 255) | ((m[mpos + 13] & 255) << 8);
        h7 += ((t5 >>> 11) | (t6 << 5)) & 8191;
        t7 = (m[mpos + 14] & 255) | ((m[mpos + 15] & 255) << 8);
        h8 += ((t6 >>> 8) | (t7 << 8)) & 8191;
        h9 += (t7 >>> 5) | hibit;
        c = 0;
        d0 = c;
        d0 += h0 * r0;
        d0 += h1 * (5 * r9);
        d0 += h2 * (5 * r8);
        d0 += h3 * (5 * r7);
        d0 += h4 * (5 * r6);
        c = d0 >>> 13;
        d0 &= 8191;
        d0 += h5 * (5 * r5);
        d0 += h6 * (5 * r4);
        d0 += h7 * (5 * r3);
        d0 += h8 * (5 * r2);
        d0 += h9 * (5 * r1);
        c += d0 >>> 13;
        d0 &= 8191;
        d1 = c;
        d1 += h0 * r1;
        d1 += h1 * r0;
        d1 += h2 * (5 * r9);
        d1 += h3 * (5 * r8);
        d1 += h4 * (5 * r7);
        c = d1 >>> 13;
        d1 &= 8191;
        d1 += h5 * (5 * r6);
        d1 += h6 * (5 * r5);
        d1 += h7 * (5 * r4);
        d1 += h8 * (5 * r3);
        d1 += h9 * (5 * r2);
        c += d1 >>> 13;
        d1 &= 8191;
        d2 = c;
        d2 += h0 * r2;
        d2 += h1 * r1;
        d2 += h2 * r0;
        d2 += h3 * (5 * r9);
        d2 += h4 * (5 * r8);
        c = d2 >>> 13;
        d2 &= 8191;
        d2 += h5 * (5 * r7);
        d2 += h6 * (5 * r6);
        d2 += h7 * (5 * r5);
        d2 += h8 * (5 * r4);
        d2 += h9 * (5 * r3);
        c += d2 >>> 13;
        d2 &= 8191;
        d3 = c;
        d3 += h0 * r3;
        d3 += h1 * r2;
        d3 += h2 * r1;
        d3 += h3 * r0;
        d3 += h4 * (5 * r9);
        c = d3 >>> 13;
        d3 &= 8191;
        d3 += h5 * (5 * r8);
        d3 += h6 * (5 * r7);
        d3 += h7 * (5 * r6);
        d3 += h8 * (5 * r5);
        d3 += h9 * (5 * r4);
        c += d3 >>> 13;
        d3 &= 8191;
        d4 = c;
        d4 += h0 * r4;
        d4 += h1 * r3;
        d4 += h2 * r2;
        d4 += h3 * r1;
        d4 += h4 * r0;
        c = d4 >>> 13;
        d4 &= 8191;
        d4 += h5 * (5 * r9);
        d4 += h6 * (5 * r8);
        d4 += h7 * (5 * r7);
        d4 += h8 * (5 * r6);
        d4 += h9 * (5 * r5);
        c += d4 >>> 13;
        d4 &= 8191;
        d5 = c;
        d5 += h0 * r5;
        d5 += h1 * r4;
        d5 += h2 * r3;
        d5 += h3 * r2;
        d5 += h4 * r1;
        c = d5 >>> 13;
        d5 &= 8191;
        d5 += h5 * r0;
        d5 += h6 * (5 * r9);
        d5 += h7 * (5 * r8);
        d5 += h8 * (5 * r7);
        d5 += h9 * (5 * r6);
        c += d5 >>> 13;
        d5 &= 8191;
        d6 = c;
        d6 += h0 * r6;
        d6 += h1 * r5;
        d6 += h2 * r4;
        d6 += h3 * r3;
        d6 += h4 * r2;
        c = d6 >>> 13;
        d6 &= 8191;
        d6 += h5 * r1;
        d6 += h6 * r0;
        d6 += h7 * (5 * r9);
        d6 += h8 * (5 * r8);
        d6 += h9 * (5 * r7);
        c += d6 >>> 13;
        d6 &= 8191;
        d7 = c;
        d7 += h0 * r7;
        d7 += h1 * r6;
        d7 += h2 * r5;
        d7 += h3 * r4;
        d7 += h4 * r3;
        c = d7 >>> 13;
        d7 &= 8191;
        d7 += h5 * r2;
        d7 += h6 * r1;
        d7 += h7 * r0;
        d7 += h8 * (5 * r9);
        d7 += h9 * (5 * r8);
        c += d7 >>> 13;
        d7 &= 8191;
        d8 = c;
        d8 += h0 * r8;
        d8 += h1 * r7;
        d8 += h2 * r6;
        d8 += h3 * r5;
        d8 += h4 * r4;
        c = d8 >>> 13;
        d8 &= 8191;
        d8 += h5 * r3;
        d8 += h6 * r2;
        d8 += h7 * r1;
        d8 += h8 * r0;
        d8 += h9 * (5 * r9);
        c += d8 >>> 13;
        d8 &= 8191;
        d9 = c;
        d9 += h0 * r9;
        d9 += h1 * r8;
        d9 += h2 * r7;
        d9 += h3 * r6;
        d9 += h4 * r5;
        c = d9 >>> 13;
        d9 &= 8191;
        d9 += h5 * r4;
        d9 += h6 * r3;
        d9 += h7 * r2;
        d9 += h8 * r1;
        d9 += h9 * r0;
        c += d9 >>> 13;
        d9 &= 8191;
        c = ((c << 2) + c) | 0;
        c = (c + d0) | 0;
        d0 = c & 8191;
        c = c >>> 13;
        d1 += c;
        h0 = d0;
        h1 = d1;
        h2 = d2;
        h3 = d3;
        h4 = d4;
        h5 = d5;
        h6 = d6;
        h7 = d7;
        h8 = d8;
        h9 = d9;
        mpos += 16;
        bytes -= 16;
      }
      this.h[0] = h0;
      this.h[1] = h1;
      this.h[2] = h2;
      this.h[3] = h3;
      this.h[4] = h4;
      this.h[5] = h5;
      this.h[6] = h6;
      this.h[7] = h7;
      this.h[8] = h8;
      this.h[9] = h9;
    };
    poly1305.prototype.finish = function (mac, macpos) {
      var g = new Uint16Array(10);
      var c, mask, f, i;
      if (this.leftover) {
        i = this.leftover;
        this.buffer[i++] = 1;
        for (; i < 16; i++) this.buffer[i] = 0;
        this.fin = 1;
        this.blocks(this.buffer, 0, 16);
      }
      c = this.h[1] >>> 13;
      this.h[1] &= 8191;
      for (i = 2; i < 10; i++) {
        this.h[i] += c;
        c = this.h[i] >>> 13;
        this.h[i] &= 8191;
      }
      this.h[0] += c * 5;
      c = this.h[0] >>> 13;
      this.h[0] &= 8191;
      this.h[1] += c;
      c = this.h[1] >>> 13;
      this.h[1] &= 8191;
      this.h[2] += c;
      g[0] = this.h[0] + 5;
      c = g[0] >>> 13;
      g[0] &= 8191;
      for (i = 1; i < 10; i++) {
        g[i] = this.h[i] + c;
        c = g[i] >>> 13;
        g[i] &= 8191;
      }
      g[9] -= 1 << 13;
      mask = (c ^ 1) - 1;
      for (i = 0; i < 10; i++) g[i] &= mask;
      mask = ~mask;
      for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];
      this.h[0] = (this.h[0] | (this.h[1] << 13)) & 65535;
      this.h[1] = ((this.h[1] >>> 3) | (this.h[2] << 10)) & 65535;
      this.h[2] = ((this.h[2] >>> 6) | (this.h[3] << 7)) & 65535;
      this.h[3] = ((this.h[3] >>> 9) | (this.h[4] << 4)) & 65535;
      this.h[4] =
        ((this.h[4] >>> 12) | (this.h[5] << 1) | (this.h[6] << 14)) & 65535;
      this.h[5] = ((this.h[6] >>> 2) | (this.h[7] << 11)) & 65535;
      this.h[6] = ((this.h[7] >>> 5) | (this.h[8] << 8)) & 65535;
      this.h[7] = ((this.h[8] >>> 8) | (this.h[9] << 5)) & 65535;
      f = this.h[0] + this.pad[0];
      this.h[0] = f & 65535;
      for (i = 1; i < 8; i++) {
        f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;
        this.h[i] = f & 65535;
      }
      mac[macpos + 0] = (this.h[0] >>> 0) & 255;
      mac[macpos + 1] = (this.h[0] >>> 8) & 255;
      mac[macpos + 2] = (this.h[1] >>> 0) & 255;
      mac[macpos + 3] = (this.h[1] >>> 8) & 255;
      mac[macpos + 4] = (this.h[2] >>> 0) & 255;
      mac[macpos + 5] = (this.h[2] >>> 8) & 255;
      mac[macpos + 6] = (this.h[3] >>> 0) & 255;
      mac[macpos + 7] = (this.h[3] >>> 8) & 255;
      mac[macpos + 8] = (this.h[4] >>> 0) & 255;
      mac[macpos + 9] = (this.h[4] >>> 8) & 255;
      mac[macpos + 10] = (this.h[5] >>> 0) & 255;
      mac[macpos + 11] = (this.h[5] >>> 8) & 255;
      mac[macpos + 12] = (this.h[6] >>> 0) & 255;
      mac[macpos + 13] = (this.h[6] >>> 8) & 255;
      mac[macpos + 14] = (this.h[7] >>> 0) & 255;
      mac[macpos + 15] = (this.h[7] >>> 8) & 255;
    };
    poly1305.prototype.update = function (m, mpos, bytes) {
      var i, want;
      if (this.leftover) {
        want = 16 - this.leftover;
        if (want > bytes) want = bytes;
        for (i = 0; i < want; i++) this.buffer[this.leftover + i] = m[mpos + i];
        bytes -= want;
        mpos += want;
        this.leftover += want;
        if (this.leftover < 16) return;
        this.blocks(this.buffer, 0, 16);
        this.leftover = 0;
      }
      if (bytes >= 16) {
        want = bytes - (bytes % 16);
        this.blocks(m, mpos, want);
        mpos += want;
        bytes -= want;
      }
      if (bytes) {
        for (i = 0; i < bytes; i++)
          this.buffer[this.leftover + i] = m[mpos + i];
        this.leftover += bytes;
      }
    };
    function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
      var s = new poly1305(k);
      s.update(m, mpos, n);
      s.finish(out, outpos);
      return 0;
    }
    function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
      var x = new Uint8Array(16);
      crypto_onetimeauth(x, 0, m, mpos, n, k);
      return crypto_verify_16(h, hpos, x, 0);
    }
    function crypto_secretbox(c, m, d, n, k) {
      var i;
      if (d < 32) return -1;
      crypto_stream_xor(c, 0, m, 0, d, n, k);
      crypto_onetimeauth(c, 16, c, 32, d - 32, c);
      for (i = 0; i < 16; i++) c[i] = 0;
      return 0;
    }
    function crypto_secretbox_open(m, c, d, n, k) {
      var i;
      var x = new Uint8Array(32);
      if (d < 32) return -1;
      crypto_stream(x, 0, 32, n, k);
      if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0) return -1;
      crypto_stream_xor(m, 0, c, 0, d, n, k);
      for (i = 0; i < 32; i++) m[i] = 0;
      return 0;
    }
    function set25519(r, a) {
      var i;
      for (i = 0; i < 16; i++) r[i] = a[i] | 0;
    }
    function car25519(o) {
      var i,
        v,
        c = 1;
      for (i = 0; i < 16; i++) {
        v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
      }
      o[0] += c - 1 + 37 * (c - 1);
    }
    function sel25519(p, q2, b) {
      var t,
        c = ~(b - 1);
      for (var i = 0; i < 16; i++) {
        t = c & (p[i] ^ q2[i]);
        p[i] ^= t;
        q2[i] ^= t;
      }
    }
    function pack25519(o, n) {
      var i, j, b;
      var m = gf(),
        t = gf();
      for (i = 0; i < 16; i++) t[i] = n[i];
      car25519(t);
      car25519(t);
      car25519(t);
      for (j = 0; j < 2; j++) {
        m[0] = t[0] - 65517;
        for (i = 1; i < 15; i++) {
          m[i] = t[i] - 65535 - ((m[i - 1] >> 16) & 1);
          m[i - 1] &= 65535;
        }
        m[15] = t[15] - 32767 - ((m[14] >> 16) & 1);
        b = (m[15] >> 16) & 1;
        m[14] &= 65535;
        sel25519(t, m, 1 - b);
      }
      for (i = 0; i < 16; i++) {
        o[2 * i] = t[i] & 255;
        o[2 * i + 1] = t[i] >> 8;
      }
    }
    function neq25519(a, b) {
      var c = new Uint8Array(32),
        d = new Uint8Array(32);
      pack25519(c, a);
      pack25519(d, b);
      return crypto_verify_32(c, 0, d, 0);
    }
    function par25519(a) {
      var d = new Uint8Array(32);
      pack25519(d, a);
      return d[0] & 1;
    }
    function unpack25519(o, n) {
      var i;
      for (i = 0; i < 16; i++) o[i] = n[2 * i] + (n[2 * i + 1] << 8);
      o[15] &= 32767;
    }
    function A(o, a, b) {
      for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
    }
    function Z(o, a, b) {
      for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
    }
    function M(o, a, b) {
      var v,
        c,
        t0 = 0,
        t1 = 0,
        t2 = 0,
        t3 = 0,
        t4 = 0,
        t5 = 0,
        t6 = 0,
        t7 = 0,
        t8 = 0,
        t9 = 0,
        t10 = 0,
        t11 = 0,
        t12 = 0,
        t13 = 0,
        t14 = 0,
        t15 = 0,
        t16 = 0,
        t17 = 0,
        t18 = 0,
        t19 = 0,
        t20 = 0,
        t21 = 0,
        t22 = 0,
        t23 = 0,
        t24 = 0,
        t25 = 0,
        t26 = 0,
        t27 = 0,
        t28 = 0,
        t29 = 0,
        t30 = 0,
        b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3],
        b4 = b[4],
        b5 = b[5],
        b6 = b[6],
        b7 = b[7],
        b8 = b[8],
        b9 = b[9],
        b10 = b[10],
        b11 = b[11],
        b12 = b[12],
        b13 = b[13],
        b14 = b[14],
        b15 = b[15];
      v = a[0];
      t0 += v * b0;
      t1 += v * b1;
      t2 += v * b2;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a[1];
      t1 += v * b0;
      t2 += v * b1;
      t3 += v * b2;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a[2];
      t2 += v * b0;
      t3 += v * b1;
      t4 += v * b2;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a[3];
      t3 += v * b0;
      t4 += v * b1;
      t5 += v * b2;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a[4];
      t4 += v * b0;
      t5 += v * b1;
      t6 += v * b2;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a[5];
      t5 += v * b0;
      t6 += v * b1;
      t7 += v * b2;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a[6];
      t6 += v * b0;
      t7 += v * b1;
      t8 += v * b2;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a[7];
      t7 += v * b0;
      t8 += v * b1;
      t9 += v * b2;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a[8];
      t8 += v * b0;
      t9 += v * b1;
      t10 += v * b2;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a[9];
      t9 += v * b0;
      t10 += v * b1;
      t11 += v * b2;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a[10];
      t10 += v * b0;
      t11 += v * b1;
      t12 += v * b2;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a[11];
      t11 += v * b0;
      t12 += v * b1;
      t13 += v * b2;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a[12];
      t12 += v * b0;
      t13 += v * b1;
      t14 += v * b2;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a[13];
      t13 += v * b0;
      t14 += v * b1;
      t15 += v * b2;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a[14];
      t14 += v * b0;
      t15 += v * b1;
      t16 += v * b2;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a[15];
      t15 += v * b0;
      t16 += v * b1;
      t17 += v * b2;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
    function S(o, a) {
      M(o, a, a);
    }
    function inv25519(o, i) {
      var c = gf();
      var a;
      for (a = 0; a < 16; a++) c[a] = i[a];
      for (a = 253; a >= 0; a--) {
        S(c, c);
        if (a !== 2 && a !== 4) M(c, c, i);
      }
      for (a = 0; a < 16; a++) o[a] = c[a];
    }
    function pow2523(o, i) {
      var c = gf();
      var a;
      for (a = 0; a < 16; a++) c[a] = i[a];
      for (a = 250; a >= 0; a--) {
        S(c, c);
        if (a !== 1) M(c, c, i);
      }
      for (a = 0; a < 16; a++) o[a] = c[a];
    }
    function crypto_scalarmult(q2, n, p) {
      var z = new Uint8Array(32);
      var x = new Float64Array(80),
        r,
        i;
      var a = gf(),
        b = gf(),
        c = gf(),
        d = gf(),
        e = gf(),
        f = gf();
      for (i = 0; i < 31; i++) z[i] = n[i];
      z[31] = (n[31] & 127) | 64;
      z[0] &= 248;
      unpack25519(x, p);
      for (i = 0; i < 16; i++) {
        b[i] = x[i];
        d[i] = a[i] = c[i] = 0;
      }
      a[0] = d[0] = 1;
      for (i = 254; i >= 0; --i) {
        r = (z[i >>> 3] >>> (i & 7)) & 1;
        sel25519(a, b, r);
        sel25519(c, d, r);
        A(e, a, c);
        Z(a, a, c);
        A(c, b, d);
        Z(b, b, d);
        S(d, e);
        S(f, a);
        M(a, c, a);
        M(c, b, e);
        A(e, a, c);
        Z(a, a, c);
        S(b, a);
        Z(c, d, f);
        M(a, c, _121665);
        A(a, a, d);
        M(c, c, a);
        M(a, d, f);
        M(d, b, x);
        S(b, e);
        sel25519(a, b, r);
        sel25519(c, d, r);
      }
      for (i = 0; i < 16; i++) {
        x[i + 16] = a[i];
        x[i + 32] = c[i];
        x[i + 48] = b[i];
        x[i + 64] = d[i];
      }
      var x32 = x.subarray(32);
      var x16 = x.subarray(16);
      inv25519(x32, x32);
      M(x16, x16, x32);
      pack25519(q2, x16);
      return 0;
    }
    function crypto_scalarmult_base(q2, n) {
      return crypto_scalarmult(q2, n, _9);
    }
    function crypto_box_keypair(y, x) {
      randombytes(x, 32);
      return crypto_scalarmult_base(y, x);
    }
    function crypto_box_beforenm(k, y, x) {
      var s = new Uint8Array(32);
      crypto_scalarmult(s, x, y);
      return crypto_core_hsalsa20(k, _0, s, sigma);
    }
    var crypto_box_afternm = crypto_secretbox;
    var crypto_box_open_afternm = crypto_secretbox_open;
    function crypto_box(c, m, d, n, y, x) {
      var k = new Uint8Array(32);
      crypto_box_beforenm(k, y, x);
      return crypto_box_afternm(c, m, d, n, k);
    }
    function crypto_box_open(m, c, d, n, y, x) {
      var k = new Uint8Array(32);
      crypto_box_beforenm(k, y, x);
      return crypto_box_open_afternm(m, c, d, n, k);
    }
    var K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591,
    ];
    function crypto_hashblocks_hl(hh, hl, m, n) {
      var wh = new Int32Array(16),
        wl = new Int32Array(16),
        bh0,
        bh1,
        bh2,
        bh3,
        bh4,
        bh5,
        bh6,
        bh7,
        bl0,
        bl1,
        bl2,
        bl3,
        bl4,
        bl5,
        bl6,
        bl7,
        th,
        tl,
        i,
        j,
        h,
        l,
        a,
        b,
        c,
        d;
      var ah0 = hh[0],
        ah1 = hh[1],
        ah2 = hh[2],
        ah3 = hh[3],
        ah4 = hh[4],
        ah5 = hh[5],
        ah6 = hh[6],
        ah7 = hh[7],
        al0 = hl[0],
        al1 = hl[1],
        al2 = hl[2],
        al3 = hl[3],
        al4 = hl[4],
        al5 = hl[5],
        al6 = hl[6],
        al7 = hl[7];
      var pos = 0;
      while (n >= 128) {
        for (i = 0; i < 16; i++) {
          j = 8 * i + pos;
          wh[i] =
            (m[j + 0] << 24) | (m[j + 1] << 16) | (m[j + 2] << 8) | m[j + 3];
          wl[i] =
            (m[j + 4] << 24) | (m[j + 5] << 16) | (m[j + 6] << 8) | m[j + 7];
        }
        for (i = 0; i < 80; i++) {
          bh0 = ah0;
          bh1 = ah1;
          bh2 = ah2;
          bh3 = ah3;
          bh4 = ah4;
          bh5 = ah5;
          bh6 = ah6;
          bh7 = ah7;
          bl0 = al0;
          bl1 = al1;
          bl2 = al2;
          bl3 = al3;
          bl4 = al4;
          bl5 = al5;
          bl6 = al6;
          bl7 = al7;
          h = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h =
            ((ah4 >>> 14) | (al4 << (32 - 14))) ^
            ((ah4 >>> 18) | (al4 << (32 - 18))) ^
            ((al4 >>> (41 - 32)) | (ah4 << (32 - (41 - 32))));
          l =
            ((al4 >>> 14) | (ah4 << (32 - 14))) ^
            ((al4 >>> 18) | (ah4 << (32 - 18))) ^
            ((ah4 >>> (41 - 32)) | (al4 << (32 - (41 - 32))));
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = (ah4 & ah5) ^ (~ah4 & ah6);
          l = (al4 & al5) ^ (~al4 & al6);
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = K[i * 2];
          l = K[i * 2 + 1];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = wh[i % 16];
          l = wl[i % 16];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          th = (c & 65535) | (d << 16);
          tl = (a & 65535) | (b << 16);
          h = th;
          l = tl;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h =
            ((ah0 >>> 28) | (al0 << (32 - 28))) ^
            ((al0 >>> (34 - 32)) | (ah0 << (32 - (34 - 32)))) ^
            ((al0 >>> (39 - 32)) | (ah0 << (32 - (39 - 32))));
          l =
            ((al0 >>> 28) | (ah0 << (32 - 28))) ^
            ((ah0 >>> (34 - 32)) | (al0 << (32 - (34 - 32)))) ^
            ((ah0 >>> (39 - 32)) | (al0 << (32 - (39 - 32))));
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
          l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          bh7 = (c & 65535) | (d << 16);
          bl7 = (a & 65535) | (b << 16);
          h = bh3;
          l = bl3;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = th;
          l = tl;
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          bh3 = (c & 65535) | (d << 16);
          bl3 = (a & 65535) | (b << 16);
          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;
          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;
          if (i % 16 === 15) {
            for (j = 0; j < 16; j++) {
              h = wh[j];
              l = wl[j];
              a = l & 65535;
              b = l >>> 16;
              c = h & 65535;
              d = h >>> 16;
              h = wh[(j + 9) % 16];
              l = wl[(j + 9) % 16];
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              th = wh[(j + 1) % 16];
              tl = wl[(j + 1) % 16];
              h =
                ((th >>> 1) | (tl << (32 - 1))) ^
                ((th >>> 8) | (tl << (32 - 8))) ^
                (th >>> 7);
              l =
                ((tl >>> 1) | (th << (32 - 1))) ^
                ((tl >>> 8) | (th << (32 - 8))) ^
                ((tl >>> 7) | (th << (32 - 7)));
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              th = wh[(j + 14) % 16];
              tl = wl[(j + 14) % 16];
              h =
                ((th >>> 19) | (tl << (32 - 19))) ^
                ((tl >>> (61 - 32)) | (th << (32 - (61 - 32)))) ^
                (th >>> 6);
              l =
                ((tl >>> 19) | (th << (32 - 19))) ^
                ((th >>> (61 - 32)) | (tl << (32 - (61 - 32)))) ^
                ((tl >>> 6) | (th << (32 - 6)));
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              wh[j] = (c & 65535) | (d << 16);
              wl[j] = (a & 65535) | (b << 16);
            }
          }
        }
        h = ah0;
        l = al0;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[0];
        l = hl[0];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[0] = ah0 = (c & 65535) | (d << 16);
        hl[0] = al0 = (a & 65535) | (b << 16);
        h = ah1;
        l = al1;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[1];
        l = hl[1];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[1] = ah1 = (c & 65535) | (d << 16);
        hl[1] = al1 = (a & 65535) | (b << 16);
        h = ah2;
        l = al2;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[2];
        l = hl[2];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[2] = ah2 = (c & 65535) | (d << 16);
        hl[2] = al2 = (a & 65535) | (b << 16);
        h = ah3;
        l = al3;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[3];
        l = hl[3];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[3] = ah3 = (c & 65535) | (d << 16);
        hl[3] = al3 = (a & 65535) | (b << 16);
        h = ah4;
        l = al4;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[4];
        l = hl[4];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[4] = ah4 = (c & 65535) | (d << 16);
        hl[4] = al4 = (a & 65535) | (b << 16);
        h = ah5;
        l = al5;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[5];
        l = hl[5];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[5] = ah5 = (c & 65535) | (d << 16);
        hl[5] = al5 = (a & 65535) | (b << 16);
        h = ah6;
        l = al6;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[6];
        l = hl[6];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[6] = ah6 = (c & 65535) | (d << 16);
        hl[6] = al6 = (a & 65535) | (b << 16);
        h = ah7;
        l = al7;
        a = l & 65535;
        b = l >>> 16;
        c = h & 65535;
        d = h >>> 16;
        h = hh[7];
        l = hl[7];
        a += l & 65535;
        b += l >>> 16;
        c += h & 65535;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[7] = ah7 = (c & 65535) | (d << 16);
        hl[7] = al7 = (a & 65535) | (b << 16);
        pos += 128;
        n -= 128;
      }
      return n;
    }
    function crypto_hash(out, m, n) {
      var hh = new Int32Array(8),
        hl = new Int32Array(8),
        x = new Uint8Array(256),
        i,
        b = n;
      hh[0] = 1779033703;
      hh[1] = 3144134277;
      hh[2] = 1013904242;
      hh[3] = 2773480762;
      hh[4] = 1359893119;
      hh[5] = 2600822924;
      hh[6] = 528734635;
      hh[7] = 1541459225;
      hl[0] = 4089235720;
      hl[1] = 2227873595;
      hl[2] = 4271175723;
      hl[3] = 1595750129;
      hl[4] = 2917565137;
      hl[5] = 725511199;
      hl[6] = 4215389547;
      hl[7] = 327033209;
      crypto_hashblocks_hl(hh, hl, m, n);
      n %= 128;
      for (i = 0; i < n; i++) x[i] = m[b - n + i];
      x[n] = 128;
      n = 256 - 128 * (n < 112 ? 1 : 0);
      x[n - 9] = 0;
      ts64(x, n - 8, (b / 536870912) | 0, b << 3);
      crypto_hashblocks_hl(hh, hl, x, n);
      for (i = 0; i < 8; i++) ts64(out, 8 * i, hh[i], hl[i]);
      return 0;
    }
    function add(p, q2) {
      var a = gf(),
        b = gf(),
        c = gf(),
        d = gf(),
        e = gf(),
        f = gf(),
        g = gf(),
        h = gf(),
        t = gf();
      Z(a, p[1], p[0]);
      Z(t, q2[1], q2[0]);
      M(a, a, t);
      A(b, p[0], p[1]);
      A(t, q2[0], q2[1]);
      M(b, b, t);
      M(c, p[3], q2[3]);
      M(c, c, D2);
      M(d, p[2], q2[2]);
      A(d, d, d);
      Z(e, b, a);
      Z(f, d, c);
      A(g, d, c);
      A(h, b, a);
      M(p[0], e, f);
      M(p[1], h, g);
      M(p[2], g, f);
      M(p[3], e, h);
    }
    function cswap(p, q2, b) {
      var i;
      for (i = 0; i < 4; i++) {
        sel25519(p[i], q2[i], b);
      }
    }
    function pack(r, p) {
      var tx = gf(),
        ty = gf(),
        zi = gf();
      inv25519(zi, p[2]);
      M(tx, p[0], zi);
      M(ty, p[1], zi);
      pack25519(r, ty);
      r[31] ^= par25519(tx) << 7;
    }
    function scalarmult(p, q2, s) {
      var b, i;
      set25519(p[0], gf0);
      set25519(p[1], gf1);
      set25519(p[2], gf1);
      set25519(p[3], gf0);
      for (i = 255; i >= 0; --i) {
        b = (s[(i / 8) | 0] >> (i & 7)) & 1;
        cswap(p, q2, b);
        add(q2, p);
        add(p, p);
        cswap(p, q2, b);
      }
    }
    function scalarbase(p, s) {
      var q2 = [gf(), gf(), gf(), gf()];
      set25519(q2[0], X);
      set25519(q2[1], Y);
      set25519(q2[2], gf1);
      M(q2[3], X, Y);
      scalarmult(p, q2, s);
    }
    function crypto_sign_keypair(pk, sk, seeded) {
      var d = new Uint8Array(64);
      var p = [gf(), gf(), gf(), gf()];
      var i;
      if (!seeded) randombytes(sk, 32);
      crypto_hash(d, sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      scalarbase(p, d);
      pack(pk, p);
      for (i = 0; i < 32; i++) sk[i + 32] = pk[i];
      return 0;
    }
    var L = new Float64Array([
      237,
      211,
      245,
      92,
      26,
      99,
      18,
      88,
      214,
      156,
      247,
      162,
      222,
      249,
      222,
      20,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      16,
    ]);
    function modL(r, x) {
      var carry, i, j, k;
      for (i = 63; i >= 32; --i) {
        carry = 0;
        for (j = i - 32, k = i - 12; j < k; ++j) {
          x[j] += carry - 16 * x[i] * L[j - (i - 32)];
          carry = (x[j] + 128) >> 8;
          x[j] -= carry * 256;
        }
        x[j] += carry;
        x[i] = 0;
      }
      carry = 0;
      for (j = 0; j < 32; j++) {
        x[j] += carry - (x[31] >> 4) * L[j];
        carry = x[j] >> 8;
        x[j] &= 255;
      }
      for (j = 0; j < 32; j++) x[j] -= carry * L[j];
      for (i = 0; i < 32; i++) {
        x[i + 1] += x[i] >> 8;
        r[i] = x[i] & 255;
      }
    }
    function reduce(r) {
      var x = new Float64Array(64),
        i;
      for (i = 0; i < 64; i++) x[i] = r[i];
      for (i = 0; i < 64; i++) r[i] = 0;
      modL(r, x);
    }
    function crypto_sign(sm, m, n, sk) {
      var d = new Uint8Array(64),
        h = new Uint8Array(64),
        r = new Uint8Array(64);
      var i,
        j,
        x = new Float64Array(64);
      var p = [gf(), gf(), gf(), gf()];
      crypto_hash(d, sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      var smlen = n + 64;
      for (i = 0; i < n; i++) sm[64 + i] = m[i];
      for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];
      crypto_hash(r, sm.subarray(32), n + 32);
      reduce(r);
      scalarbase(p, r);
      pack(sm, p);
      for (i = 32; i < 64; i++) sm[i] = sk[i];
      crypto_hash(h, sm, n + 64);
      reduce(h);
      for (i = 0; i < 64; i++) x[i] = 0;
      for (i = 0; i < 32; i++) x[i] = r[i];
      for (i = 0; i < 32; i++) {
        for (j = 0; j < 32; j++) {
          x[i + j] += h[i] * d[j];
        }
      }
      modL(sm.subarray(32), x);
      return smlen;
    }
    function unpackneg(r, p) {
      var t = gf(),
        chk = gf(),
        num = gf(),
        den = gf(),
        den2 = gf(),
        den4 = gf(),
        den6 = gf();
      set25519(r[2], gf1);
      unpack25519(r[1], p);
      S(num, r[1]);
      M(den, num, D);
      Z(num, num, r[2]);
      A(den, r[2], den);
      S(den2, den);
      S(den4, den2);
      M(den6, den4, den2);
      M(t, den6, num);
      M(t, t, den);
      pow2523(t, t);
      M(t, t, num);
      M(t, t, den);
      M(t, t, den);
      M(r[0], t, den);
      S(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num)) M(r[0], r[0], I);
      S(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num)) return -1;
      if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);
      M(r[3], r[0], r[1]);
      return 0;
    }
    function crypto_sign_open(m, sm, n, pk) {
      var i, mlen;
      var t = new Uint8Array(32),
        h = new Uint8Array(64);
      var p = [gf(), gf(), gf(), gf()],
        q2 = [gf(), gf(), gf(), gf()];
      mlen = -1;
      if (n < 64) return -1;
      if (unpackneg(q2, pk)) return -1;
      for (i = 0; i < n; i++) m[i] = sm[i];
      for (i = 0; i < 32; i++) m[i + 32] = pk[i];
      crypto_hash(h, m, n);
      reduce(h);
      scalarmult(p, q2, h);
      scalarbase(q2, sm.subarray(32));
      add(p, q2);
      pack(t, p);
      n -= 64;
      if (crypto_verify_32(sm, 0, t, 0)) {
        for (i = 0; i < n; i++) m[i] = 0;
        return -1;
      }
      for (i = 0; i < n; i++) m[i] = sm[i + 64];
      mlen = n;
      return mlen;
    }
    var crypto_secretbox_KEYBYTES = 32,
      crypto_secretbox_NONCEBYTES = 24,
      crypto_secretbox_ZEROBYTES = 32,
      crypto_secretbox_BOXZEROBYTES = 16,
      crypto_scalarmult_BYTES = 32,
      crypto_scalarmult_SCALARBYTES = 32,
      crypto_box_PUBLICKEYBYTES = 32,
      crypto_box_SECRETKEYBYTES = 32,
      crypto_box_BEFORENMBYTES = 32,
      crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
      crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
      crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
      crypto_sign_BYTES = 64,
      crypto_sign_PUBLICKEYBYTES = 32,
      crypto_sign_SECRETKEYBYTES = 64,
      crypto_sign_SEEDBYTES = 32,
      crypto_hash_BYTES = 64;
    nacl.lowlevel = {
      crypto_core_hsalsa20,
      crypto_stream_xor,
      crypto_stream,
      crypto_stream_salsa20_xor,
      crypto_stream_salsa20,
      crypto_onetimeauth,
      crypto_onetimeauth_verify,
      crypto_verify_16,
      crypto_verify_32,
      crypto_secretbox,
      crypto_secretbox_open,
      crypto_scalarmult,
      crypto_scalarmult_base,
      crypto_box_beforenm,
      crypto_box_afternm,
      crypto_box,
      crypto_box_open,
      crypto_box_keypair,
      crypto_hash,
      crypto_sign,
      crypto_sign_keypair,
      crypto_sign_open,
      crypto_secretbox_KEYBYTES,
      crypto_secretbox_NONCEBYTES,
      crypto_secretbox_ZEROBYTES,
      crypto_secretbox_BOXZEROBYTES,
      crypto_scalarmult_BYTES,
      crypto_scalarmult_SCALARBYTES,
      crypto_box_PUBLICKEYBYTES,
      crypto_box_SECRETKEYBYTES,
      crypto_box_BEFORENMBYTES,
      crypto_box_NONCEBYTES,
      crypto_box_ZEROBYTES,
      crypto_box_BOXZEROBYTES,
      crypto_sign_BYTES,
      crypto_sign_PUBLICKEYBYTES,
      crypto_sign_SECRETKEYBYTES,
      crypto_sign_SEEDBYTES,
      crypto_hash_BYTES,
    };
    function checkLengths(k, n) {
      if (k.length !== crypto_secretbox_KEYBYTES)
        throw new Error('bad key size');
      if (n.length !== crypto_secretbox_NONCEBYTES)
        throw new Error('bad nonce size');
    }
    function checkBoxLengths(pk, sk) {
      if (pk.length !== crypto_box_PUBLICKEYBYTES)
        throw new Error('bad public key size');
      if (sk.length !== crypto_box_SECRETKEYBYTES)
        throw new Error('bad secret key size');
    }
    function checkArrayTypes() {
      var t, i;
      for (i = 0; i < arguments.length; i++) {
        if (
          (t = Object.prototype.toString.call(arguments[i])) !==
          '[object Uint8Array]'
        )
          throw new TypeError('unexpected type ' + t + ', use Uint8Array');
      }
    }
    function cleanup(arr) {
      for (var i = 0; i < arr.length; i++) arr[i] = 0;
    }
    if (!nacl.util) {
      nacl.util = {};
      nacl.util.decodeUTF8 = nacl.util.encodeUTF8 = nacl.util.encodeBase64 = nacl.util.decodeBase64 = function () {
        throw new Error(
          'nacl.util moved into separate package: https://github.com/dchest/tweetnacl-util-js',
        );
      };
    }
    nacl.randomBytes = function (n) {
      var b = new Uint8Array(n);
      randombytes(b, n);
      return b;
    };
    nacl.secretbox = function (msg, nonce, key) {
      checkArrayTypes(msg, nonce, key);
      checkLengths(key, nonce);
      var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
      var c = new Uint8Array(m.length);
      for (var i = 0; i < msg.length; i++)
        m[i + crypto_secretbox_ZEROBYTES] = msg[i];
      crypto_secretbox(c, m, m.length, nonce, key);
      return c.subarray(crypto_secretbox_BOXZEROBYTES);
    };
    nacl.secretbox.open = function (box, nonce, key) {
      checkArrayTypes(box, nonce, key);
      checkLengths(key, nonce);
      var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
      var m = new Uint8Array(c.length);
      for (var i = 0; i < box.length; i++)
        c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
      if (c.length < 32) return false;
      if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return false;
      return m.subarray(crypto_secretbox_ZEROBYTES);
    };
    nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
    nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
    nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
    nacl.scalarMult = function (n, p) {
      checkArrayTypes(n, p);
      if (n.length !== crypto_scalarmult_SCALARBYTES)
        throw new Error('bad n size');
      if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
      var q2 = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult(q2, n, p);
      return q2;
    };
    nacl.scalarMult.base = function (n) {
      checkArrayTypes(n);
      if (n.length !== crypto_scalarmult_SCALARBYTES)
        throw new Error('bad n size');
      var q2 = new Uint8Array(crypto_scalarmult_BYTES);
      crypto_scalarmult_base(q2, n);
      return q2;
    };
    nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
    nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
    nacl.box = function (msg, nonce, publicKey, secretKey) {
      var k = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox(msg, nonce, k);
    };
    nacl.box.before = function (publicKey, secretKey) {
      checkArrayTypes(publicKey, secretKey);
      checkBoxLengths(publicKey, secretKey);
      var k = new Uint8Array(crypto_box_BEFORENMBYTES);
      crypto_box_beforenm(k, publicKey, secretKey);
      return k;
    };
    nacl.box.after = nacl.secretbox;
    nacl.box.open = function (msg, nonce, publicKey, secretKey) {
      var k = nacl.box.before(publicKey, secretKey);
      return nacl.secretbox.open(msg, nonce, k);
    };
    nacl.box.open.after = nacl.secretbox.open;
    nacl.box.keyPair = function () {
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
      crypto_box_keypair(pk, sk);
      return { publicKey: pk, secretKey: sk };
    };
    nacl.box.keyPair.fromSecretKey = function (secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_box_SECRETKEYBYTES)
        throw new Error('bad secret key size');
      var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
      crypto_scalarmult_base(pk, secretKey);
      return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
    };
    nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
    nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
    nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
    nacl.box.nonceLength = crypto_box_NONCEBYTES;
    nacl.box.overheadLength = nacl.secretbox.overheadLength;
    nacl.sign = function (msg, secretKey) {
      checkArrayTypes(msg, secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error('bad secret key size');
      var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
      crypto_sign(signedMsg, msg, msg.length, secretKey);
      return signedMsg;
    };
    nacl.sign.open = function (signedMsg, publicKey) {
      if (arguments.length !== 2)
        throw new Error(
          'nacl.sign.open accepts 2 arguments; did you mean to use nacl.sign.detached.verify?',
        );
      checkArrayTypes(signedMsg, publicKey);
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error('bad public key size');
      var tmp = new Uint8Array(signedMsg.length);
      var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
      if (mlen < 0) return null;
      var m = new Uint8Array(mlen);
      for (var i = 0; i < m.length; i++) m[i] = tmp[i];
      return m;
    };
    nacl.sign.detached = function (msg, secretKey) {
      var signedMsg = nacl.sign(msg, secretKey);
      var sig = new Uint8Array(crypto_sign_BYTES);
      for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
      return sig;
    };
    nacl.sign.detached.verify = function (msg, sig, publicKey) {
      checkArrayTypes(msg, sig, publicKey);
      if (sig.length !== crypto_sign_BYTES)
        throw new Error('bad signature size');
      if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
        throw new Error('bad public key size');
      var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
      var m = new Uint8Array(crypto_sign_BYTES + msg.length);
      var i;
      for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
      for (i = 0; i < msg.length; i++) sm[i + crypto_sign_BYTES] = msg[i];
      return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
    };
    nacl.sign.keyPair = function () {
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      crypto_sign_keypair(pk, sk);
      return { publicKey: pk, secretKey: sk };
    };
    nacl.sign.keyPair.fromSecretKey = function (secretKey) {
      checkArrayTypes(secretKey);
      if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
        throw new Error('bad secret key size');
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32 + i];
      return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
    };
    nacl.sign.keyPair.fromSeed = function (seed) {
      checkArrayTypes(seed);
      if (seed.length !== crypto_sign_SEEDBYTES)
        throw new Error('bad seed size');
      var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
      var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
      for (var i = 0; i < 32; i++) sk[i] = seed[i];
      crypto_sign_keypair(pk, sk, true);
      return { publicKey: pk, secretKey: sk };
    };
    nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
    nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
    nacl.sign.seedLength = crypto_sign_SEEDBYTES;
    nacl.sign.signatureLength = crypto_sign_BYTES;
    nacl.hash = function (msg) {
      checkArrayTypes(msg);
      var h = new Uint8Array(crypto_hash_BYTES);
      crypto_hash(h, msg, msg.length);
      return h;
    };
    nacl.hash.hashLength = crypto_hash_BYTES;
    nacl.verify = function (x, y) {
      checkArrayTypes(x, y);
      if (x.length === 0 || y.length === 0) return false;
      if (x.length !== y.length) return false;
      return vn(x, 0, y, 0, x.length) === 0 ? true : false;
    };
    nacl.setPRNG = function (fn) {
      randombytes = fn;
    };
    (function () {
      var crypto =
        typeof self !== 'undefined' ? self.crypto || self.msCrypto : null;
      if (crypto && crypto.getRandomValues) {
        var QUOTA = 65536;
        nacl.setPRNG(function (x, n) {
          var i,
            v = new Uint8Array(n);
          for (i = 0; i < n; i += QUOTA) {
            crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
          }
          for (i = 0; i < n; i++) x[i] = v[i];
          cleanup(v);
        });
      } else if (true) {
        crypto = require('crypto');
        if (crypto && crypto.randomBytes) {
          nacl.setPRNG(function (x, n) {
            var i,
              v = crypto.randomBytes(n);
            for (i = 0; i < n; i++) x[i] = v[i];
            cleanup(v);
          });
        }
      }
    })();
  })(
    typeof module2 !== 'undefined' && module2.exports
      ? module2.exports
      : (self.nacl = self.nacl || {}),
  );
});

// node_modules/sshpk/lib/utils.js
var require_utils4 = __commonJS((exports2, module2) => {
  module2.exports = {
    bufferSplit,
    addRSAMissing,
    calculateDSAPublic,
    calculateED25519Public,
    calculateX25519Public,
    mpNormalize,
    mpDenormalize,
    ecNormalize,
    countZeros,
    assertCompatible,
    isCompatible,
    opensslKeyDeriv,
    opensshCipherInfo,
    publicFromPrivateECDSA,
    zeroPadToLength,
    writeBitString,
    readBitString,
    pbkdf2,
  };
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var PrivateKey = require_private_key();
  var Key = require_key();
  var crypto = require('crypto');
  var algs = require_algs();
  var asn1 = require_lib();
  var ec = require_ec();
  var jsbn = require_jsbn().BigInteger;
  var nacl = require_nacl_fast();
  var MAX_CLASS_DEPTH = 3;
  function isCompatible(obj, klass, needVer) {
    if (obj === null || typeof obj !== 'object') return false;
    if (needVer === void 0) needVer = klass.prototype._sshpkApiVersion;
    if (
      obj instanceof klass &&
      klass.prototype._sshpkApiVersion[0] == needVer[0]
    )
      return true;
    var proto = Object.getPrototypeOf(obj);
    var depth = 0;
    while (proto.constructor.name !== klass.name) {
      proto = Object.getPrototypeOf(proto);
      if (!proto || ++depth > MAX_CLASS_DEPTH) return false;
    }
    if (proto.constructor.name !== klass.name) return false;
    var ver = proto._sshpkApiVersion;
    if (ver === void 0) ver = klass._oldVersionDetect(obj);
    if (ver[0] != needVer[0] || ver[1] < needVer[1]) return false;
    return true;
  }
  function assertCompatible(obj, klass, needVer, name) {
    if (name === void 0) name = 'object';
    assert.ok(obj, name + ' must not be null');
    assert.object(obj, name + ' must be an object');
    if (needVer === void 0) needVer = klass.prototype._sshpkApiVersion;
    if (
      obj instanceof klass &&
      klass.prototype._sshpkApiVersion[0] == needVer[0]
    )
      return;
    var proto = Object.getPrototypeOf(obj);
    var depth = 0;
    while (proto.constructor.name !== klass.name) {
      proto = Object.getPrototypeOf(proto);
      assert.ok(
        proto && ++depth <= MAX_CLASS_DEPTH,
        name + ' must be a ' + klass.name + ' instance',
      );
    }
    assert.strictEqual(
      proto.constructor.name,
      klass.name,
      name + ' must be a ' + klass.name + ' instance',
    );
    var ver = proto._sshpkApiVersion;
    if (ver === void 0) ver = klass._oldVersionDetect(obj);
    assert.ok(
      ver[0] == needVer[0] && ver[1] >= needVer[1],
      name +
        ' must be compatible with ' +
        klass.name +
        ' klass version ' +
        needVer[0] +
        '.' +
        needVer[1],
    );
  }
  var CIPHER_LEN = {
    'des-ede3-cbc': { key: 24, iv: 8 },
    'aes-128-cbc': { key: 16, iv: 16 },
    'aes-256-cbc': { key: 32, iv: 16 },
  };
  var PKCS5_SALT_LEN = 8;
  function opensslKeyDeriv(cipher, salt, passphrase, count) {
    assert.buffer(salt, 'salt');
    assert.buffer(passphrase, 'passphrase');
    assert.number(count, 'iteration count');
    var clen = CIPHER_LEN[cipher];
    assert.object(clen, 'supported cipher');
    salt = salt.slice(0, PKCS5_SALT_LEN);
    var D, D_prev, bufs;
    var material = Buffer2.alloc(0);
    while (material.length < clen.key + clen.iv) {
      bufs = [];
      if (D_prev) bufs.push(D_prev);
      bufs.push(passphrase);
      bufs.push(salt);
      D = Buffer2.concat(bufs);
      for (var j = 0; j < count; ++j)
        D = crypto.createHash('md5').update(D).digest();
      material = Buffer2.concat([material, D]);
      D_prev = D;
    }
    return {
      key: material.slice(0, clen.key),
      iv: material.slice(clen.key, clen.key + clen.iv),
    };
  }
  function pbkdf2(hashAlg, salt, iterations, size, passphrase) {
    var hkey = Buffer2.alloc(salt.length + 4);
    salt.copy(hkey);
    var gen = 0,
      ts = [];
    var i = 1;
    while (gen < size) {
      var t = T(i++);
      gen += t.length;
      ts.push(t);
    }
    return Buffer2.concat(ts).slice(0, size);
    function T(I) {
      hkey.writeUInt32BE(I, hkey.length - 4);
      var hmac = crypto.createHmac(hashAlg, passphrase);
      hmac.update(hkey);
      var Ti = hmac.digest();
      var Uc = Ti;
      var c = 1;
      while (c++ < iterations) {
        hmac = crypto.createHmac(hashAlg, passphrase);
        hmac.update(Uc);
        Uc = hmac.digest();
        for (var x = 0; x < Ti.length; ++x) Ti[x] ^= Uc[x];
      }
      return Ti;
    }
  }
  function countZeros(buf) {
    var o = 0,
      obit = 8;
    while (o < buf.length) {
      var mask = 1 << obit;
      if ((buf[o] & mask) === mask) break;
      obit--;
      if (obit < 0) {
        o++;
        obit = 8;
      }
    }
    return o * 8 + (8 - obit) - 1;
  }
  function bufferSplit(buf, chr) {
    assert.buffer(buf);
    assert.string(chr);
    var parts = [];
    var lastPart = 0;
    var matches = 0;
    for (var i = 0; i < buf.length; ++i) {
      if (buf[i] === chr.charCodeAt(matches)) ++matches;
      else if (buf[i] === chr.charCodeAt(0)) matches = 1;
      else matches = 0;
      if (matches >= chr.length) {
        var newPart = i + 1;
        parts.push(buf.slice(lastPart, newPart - matches));
        lastPart = newPart;
        matches = 0;
      }
    }
    if (lastPart <= buf.length) parts.push(buf.slice(lastPart, buf.length));
    return parts;
  }
  function ecNormalize(buf, addZero) {
    assert.buffer(buf);
    if (buf[0] === 0 && buf[1] === 4) {
      if (addZero) return buf;
      return buf.slice(1);
    } else if (buf[0] === 4) {
      if (!addZero) return buf;
    } else {
      while (buf[0] === 0) buf = buf.slice(1);
      if (buf[0] === 2 || buf[0] === 3)
        throw new Error('Compressed elliptic curve points are not supported');
      if (buf[0] !== 4) throw new Error('Not a valid elliptic curve point');
      if (!addZero) return buf;
    }
    var b = Buffer2.alloc(buf.length + 1);
    b[0] = 0;
    buf.copy(b, 1);
    return b;
  }
  function readBitString(der, tag) {
    if (tag === void 0) tag = asn1.Ber.BitString;
    var buf = der.readString(tag, true);
    assert.strictEqual(
      buf[0],
      0,
      'bit strings with unused bits are not supported (0x' +
        buf[0].toString(16) +
        ')',
    );
    return buf.slice(1);
  }
  function writeBitString(der, buf, tag) {
    if (tag === void 0) tag = asn1.Ber.BitString;
    var b = Buffer2.alloc(buf.length + 1);
    b[0] = 0;
    buf.copy(b, 1);
    der.writeBuffer(b, tag);
  }
  function mpNormalize(buf) {
    assert.buffer(buf);
    while (buf.length > 1 && buf[0] === 0 && (buf[1] & 128) === 0)
      buf = buf.slice(1);
    if ((buf[0] & 128) === 128) {
      var b = Buffer2.alloc(buf.length + 1);
      b[0] = 0;
      buf.copy(b, 1);
      buf = b;
    }
    return buf;
  }
  function mpDenormalize(buf) {
    assert.buffer(buf);
    while (buf.length > 1 && buf[0] === 0) buf = buf.slice(1);
    return buf;
  }
  function zeroPadToLength(buf, len) {
    assert.buffer(buf);
    assert.number(len);
    while (buf.length > len) {
      assert.equal(buf[0], 0);
      buf = buf.slice(1);
    }
    while (buf.length < len) {
      var b = Buffer2.alloc(buf.length + 1);
      b[0] = 0;
      buf.copy(b, 1);
      buf = b;
    }
    return buf;
  }
  function bigintToMpBuf(bigint) {
    var buf = Buffer2.from(bigint.toByteArray());
    buf = mpNormalize(buf);
    return buf;
  }
  function calculateDSAPublic(g, p, x) {
    assert.buffer(g);
    assert.buffer(p);
    assert.buffer(x);
    g = new jsbn(g);
    p = new jsbn(p);
    x = new jsbn(x);
    var y = g.modPow(x, p);
    var ybuf = bigintToMpBuf(y);
    return ybuf;
  }
  function calculateED25519Public(k) {
    assert.buffer(k);
    var kp = nacl.sign.keyPair.fromSeed(new Uint8Array(k));
    return Buffer2.from(kp.publicKey);
  }
  function calculateX25519Public(k) {
    assert.buffer(k);
    var kp = nacl.box.keyPair.fromSeed(new Uint8Array(k));
    return Buffer2.from(kp.publicKey);
  }
  function addRSAMissing(key) {
    assert.object(key);
    assertCompatible(key, PrivateKey, [1, 1]);
    var d = new jsbn(key.part.d.data);
    var buf;
    if (!key.part.dmodp) {
      var p = new jsbn(key.part.p.data);
      var dmodp = d.mod(p.subtract(1));
      buf = bigintToMpBuf(dmodp);
      key.part.dmodp = { name: 'dmodp', data: buf };
      key.parts.push(key.part.dmodp);
    }
    if (!key.part.dmodq) {
      var q2 = new jsbn(key.part.q.data);
      var dmodq = d.mod(q2.subtract(1));
      buf = bigintToMpBuf(dmodq);
      key.part.dmodq = { name: 'dmodq', data: buf };
      key.parts.push(key.part.dmodq);
    }
  }
  function publicFromPrivateECDSA(curveName, priv) {
    assert.string(curveName, 'curveName');
    assert.buffer(priv);
    var params = algs.curves[curveName];
    var p = new jsbn(params.p);
    var a = new jsbn(params.a);
    var b = new jsbn(params.b);
    var curve = new ec.ECCurveFp(p, a, b);
    var G = curve.decodePointHex(params.G.toString('hex'));
    var d = new jsbn(mpNormalize(priv));
    var pub = G.multiply(d);
    pub = Buffer2.from(curve.encodePointHex(pub), 'hex');
    var parts = [];
    parts.push({ name: 'curve', data: Buffer2.from(curveName) });
    parts.push({ name: 'Q', data: pub });
    var key = new Key({ type: 'ecdsa', curve, parts });
    return key;
  }
  function opensshCipherInfo(cipher) {
    var inf = {};
    switch (cipher) {
      case '3des-cbc':
        inf.keySize = 24;
        inf.blockSize = 8;
        inf.opensslName = 'des-ede3-cbc';
        break;
      case 'blowfish-cbc':
        inf.keySize = 16;
        inf.blockSize = 8;
        inf.opensslName = 'bf-cbc';
        break;
      case 'aes128-cbc':
      case 'aes128-ctr':
      case 'aes128-gcm@openssh.com':
        inf.keySize = 16;
        inf.blockSize = 16;
        inf.opensslName = 'aes-128-' + cipher.slice(7, 10);
        break;
      case 'aes192-cbc':
      case 'aes192-ctr':
      case 'aes192-gcm@openssh.com':
        inf.keySize = 24;
        inf.blockSize = 16;
        inf.opensslName = 'aes-192-' + cipher.slice(7, 10);
        break;
      case 'aes256-cbc':
      case 'aes256-ctr':
      case 'aes256-gcm@openssh.com':
        inf.keySize = 32;
        inf.blockSize = 16;
        inf.opensslName = 'aes-256-' + cipher.slice(7, 10);
        break;
      default:
        throw new Error('Unsupported openssl cipher "' + cipher + '"');
    }
    return inf;
  }
});

// node_modules/sshpk/lib/ssh-buffer.js
var require_ssh_buffer = __commonJS((exports2, module2) => {
  module2.exports = SSHBuffer;
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  function SSHBuffer(opts) {
    assert.object(opts, 'options');
    if (opts.buffer !== void 0) assert.buffer(opts.buffer, 'options.buffer');
    this._size = opts.buffer ? opts.buffer.length : 1024;
    this._buffer = opts.buffer || Buffer2.alloc(this._size);
    this._offset = 0;
  }
  SSHBuffer.prototype.toBuffer = function () {
    return this._buffer.slice(0, this._offset);
  };
  SSHBuffer.prototype.atEnd = function () {
    return this._offset >= this._buffer.length;
  };
  SSHBuffer.prototype.remainder = function () {
    return this._buffer.slice(this._offset);
  };
  SSHBuffer.prototype.skip = function (n) {
    this._offset += n;
  };
  SSHBuffer.prototype.expand = function () {
    this._size *= 2;
    var buf = Buffer2.alloc(this._size);
    this._buffer.copy(buf, 0);
    this._buffer = buf;
  };
  SSHBuffer.prototype.readPart = function () {
    return { data: this.readBuffer() };
  };
  SSHBuffer.prototype.readBuffer = function () {
    var len = this._buffer.readUInt32BE(this._offset);
    this._offset += 4;
    assert.ok(
      this._offset + len <= this._buffer.length,
      'length out of bounds at +0x' +
        this._offset.toString(16) +
        ' (data truncated?)',
    );
    var buf = this._buffer.slice(this._offset, this._offset + len);
    this._offset += len;
    return buf;
  };
  SSHBuffer.prototype.readString = function () {
    return this.readBuffer().toString();
  };
  SSHBuffer.prototype.readCString = function () {
    var offset = this._offset;
    while (offset < this._buffer.length && this._buffer[offset] !== 0) offset++;
    assert.ok(offset < this._buffer.length, 'c string does not terminate');
    var str = this._buffer.slice(this._offset, offset).toString();
    this._offset = offset + 1;
    return str;
  };
  SSHBuffer.prototype.readInt = function () {
    var v = this._buffer.readUInt32BE(this._offset);
    this._offset += 4;
    return v;
  };
  SSHBuffer.prototype.readInt64 = function () {
    assert.ok(
      this._offset + 8 < this._buffer.length,
      'buffer not long enough to read Int64',
    );
    var v = this._buffer.slice(this._offset, this._offset + 8);
    this._offset += 8;
    return v;
  };
  SSHBuffer.prototype.readChar = function () {
    var v = this._buffer[this._offset++];
    return v;
  };
  SSHBuffer.prototype.writeBuffer = function (buf) {
    while (this._offset + 4 + buf.length > this._size) this.expand();
    this._buffer.writeUInt32BE(buf.length, this._offset);
    this._offset += 4;
    buf.copy(this._buffer, this._offset);
    this._offset += buf.length;
  };
  SSHBuffer.prototype.writeString = function (str) {
    this.writeBuffer(Buffer2.from(str, 'utf8'));
  };
  SSHBuffer.prototype.writeCString = function (str) {
    while (this._offset + 1 + str.length > this._size) this.expand();
    this._buffer.write(str, this._offset);
    this._offset += str.length;
    this._buffer[this._offset++] = 0;
  };
  SSHBuffer.prototype.writeInt = function (v) {
    while (this._offset + 4 > this._size) this.expand();
    this._buffer.writeUInt32BE(v, this._offset);
    this._offset += 4;
  };
  SSHBuffer.prototype.writeInt64 = function (v) {
    assert.buffer(v, 'value');
    if (v.length > 8) {
      var lead = v.slice(0, v.length - 8);
      for (var i = 0; i < lead.length; ++i) {
        assert.strictEqual(lead[i], 0, 'must fit in 64 bits of precision');
      }
      v = v.slice(v.length - 8, v.length);
    }
    while (this._offset + 8 > this._size) this.expand();
    v.copy(this._buffer, this._offset);
    this._offset += 8;
  };
  SSHBuffer.prototype.writeChar = function (v) {
    while (this._offset + 1 > this._size) this.expand();
    this._buffer[this._offset++] = v;
  };
  SSHBuffer.prototype.writePart = function (p) {
    this.writeBuffer(p.data);
  };
  SSHBuffer.prototype.write = function (buf) {
    while (this._offset + buf.length > this._size) this.expand();
    buf.copy(this._buffer, this._offset);
    this._offset += buf.length;
  };
});

// node_modules/sshpk/lib/signature.js
var require_signature = __commonJS((exports2, module2) => {
  module2.exports = Signature;
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var crypto = require('crypto');
  var errs = require_errors();
  var utils = require_utils4();
  var asn1 = require_lib();
  var SSHBuffer = require_ssh_buffer();
  var InvalidAlgorithmError = errs.InvalidAlgorithmError;
  var SignatureParseError = errs.SignatureParseError;
  function Signature(opts) {
    assert.object(opts, 'options');
    assert.arrayOfObject(opts.parts, 'options.parts');
    assert.string(opts.type, 'options.type');
    var partLookup = {};
    for (var i = 0; i < opts.parts.length; ++i) {
      var part = opts.parts[i];
      partLookup[part.name] = part;
    }
    this.type = opts.type;
    this.hashAlgorithm = opts.hashAlgo;
    this.curve = opts.curve;
    this.parts = opts.parts;
    this.part = partLookup;
  }
  Signature.prototype.toBuffer = function (format) {
    if (format === void 0) format = 'asn1';
    assert.string(format, 'format');
    var buf;
    var stype = 'ssh-' + this.type;
    switch (this.type) {
      case 'rsa':
        switch (this.hashAlgorithm) {
          case 'sha256':
            stype = 'rsa-sha2-256';
            break;
          case 'sha512':
            stype = 'rsa-sha2-512';
            break;
          case 'sha1':
          case void 0:
            break;
          default:
            throw new Error(
              'SSH signature format does not support hash algorithm ' +
                this.hashAlgorithm,
            );
        }
        if (format === 'ssh') {
          buf = new SSHBuffer({});
          buf.writeString(stype);
          buf.writePart(this.part.sig);
          return buf.toBuffer();
        } else {
          return this.part.sig.data;
        }
        break;
      case 'ed25519':
        if (format === 'ssh') {
          buf = new SSHBuffer({});
          buf.writeString(stype);
          buf.writePart(this.part.sig);
          return buf.toBuffer();
        } else {
          return this.part.sig.data;
        }
        break;
      case 'dsa':
      case 'ecdsa':
        var r, s;
        if (format === 'asn1') {
          var der = new asn1.BerWriter();
          der.startSequence();
          r = utils.mpNormalize(this.part.r.data);
          s = utils.mpNormalize(this.part.s.data);
          der.writeBuffer(r, asn1.Ber.Integer);
          der.writeBuffer(s, asn1.Ber.Integer);
          der.endSequence();
          return der.buffer;
        } else if (format === 'ssh' && this.type === 'dsa') {
          buf = new SSHBuffer({});
          buf.writeString('ssh-dss');
          r = this.part.r.data;
          if (r.length > 20 && r[0] === 0) r = r.slice(1);
          s = this.part.s.data;
          if (s.length > 20 && s[0] === 0) s = s.slice(1);
          if (
            (this.hashAlgorithm && this.hashAlgorithm !== 'sha1') ||
            r.length + s.length !== 40
          ) {
            throw new Error(
              'OpenSSH only supports DSA signatures with SHA1 hash',
            );
          }
          buf.writeBuffer(Buffer2.concat([r, s]));
          return buf.toBuffer();
        } else if (format === 'ssh' && this.type === 'ecdsa') {
          var inner = new SSHBuffer({});
          r = this.part.r.data;
          inner.writeBuffer(r);
          inner.writePart(this.part.s);
          buf = new SSHBuffer({});
          var curve;
          if (r[0] === 0) r = r.slice(1);
          var sz = r.length * 8;
          if (sz === 256) curve = 'nistp256';
          else if (sz === 384) curve = 'nistp384';
          else if (sz === 528) curve = 'nistp521';
          buf.writeString('ecdsa-sha2-' + curve);
          buf.writeBuffer(inner.toBuffer());
          return buf.toBuffer();
        }
        throw new Error('Invalid signature format');
      default:
        throw new Error('Invalid signature data');
    }
  };
  Signature.prototype.toString = function (format) {
    assert.optionalString(format, 'format');
    return this.toBuffer(format).toString('base64');
  };
  Signature.parse = function (data, type, format) {
    if (typeof data === 'string') data = Buffer2.from(data, 'base64');
    assert.buffer(data, 'data');
    assert.string(format, 'format');
    assert.string(type, 'type');
    var opts = {};
    opts.type = type.toLowerCase();
    opts.parts = [];
    try {
      assert.ok(data.length > 0, 'signature must not be empty');
      switch (opts.type) {
        case 'rsa':
          return parseOneNum(data, type, format, opts);
        case 'ed25519':
          return parseOneNum(data, type, format, opts);
        case 'dsa':
        case 'ecdsa':
          if (format === 'asn1') return parseDSAasn1(data, type, format, opts);
          else if (opts.type === 'dsa')
            return parseDSA(data, type, format, opts);
          else return parseECDSA(data, type, format, opts);
        default:
          throw new InvalidAlgorithmError(type);
      }
    } catch (e) {
      if (e instanceof InvalidAlgorithmError) throw e;
      throw new SignatureParseError(type, format, e);
    }
  };
  function parseOneNum(data, type, format, opts) {
    if (format === 'ssh') {
      try {
        var buf = new SSHBuffer({ buffer: data });
        var head = buf.readString();
      } catch (e) {}
      if (buf !== void 0) {
        var msg =
          'SSH signature does not match expected type (expected ' +
          type +
          ', got ' +
          head +
          ')';
        switch (head) {
          case 'ssh-rsa':
            assert.strictEqual(type, 'rsa', msg);
            opts.hashAlgo = 'sha1';
            break;
          case 'rsa-sha2-256':
            assert.strictEqual(type, 'rsa', msg);
            opts.hashAlgo = 'sha256';
            break;
          case 'rsa-sha2-512':
            assert.strictEqual(type, 'rsa', msg);
            opts.hashAlgo = 'sha512';
            break;
          case 'ssh-ed25519':
            assert.strictEqual(type, 'ed25519', msg);
            opts.hashAlgo = 'sha512';
            break;
          default:
            throw new Error('Unknown SSH signature type: ' + head);
        }
        var sig = buf.readPart();
        assert.ok(buf.atEnd(), 'extra trailing bytes');
        sig.name = 'sig';
        opts.parts.push(sig);
        return new Signature(opts);
      }
    }
    opts.parts.push({ name: 'sig', data });
    return new Signature(opts);
  }
  function parseDSAasn1(data, type, format, opts) {
    var der = new asn1.BerReader(data);
    der.readSequence();
    var r = der.readString(asn1.Ber.Integer, true);
    var s = der.readString(asn1.Ber.Integer, true);
    opts.parts.push({ name: 'r', data: utils.mpNormalize(r) });
    opts.parts.push({ name: 's', data: utils.mpNormalize(s) });
    return new Signature(opts);
  }
  function parseDSA(data, type, format, opts) {
    if (data.length != 40) {
      var buf = new SSHBuffer({ buffer: data });
      var d = buf.readBuffer();
      if (d.toString('ascii') === 'ssh-dss') d = buf.readBuffer();
      assert.ok(buf.atEnd(), 'extra trailing bytes');
      assert.strictEqual(d.length, 40, 'invalid inner length');
      data = d;
    }
    opts.parts.push({ name: 'r', data: data.slice(0, 20) });
    opts.parts.push({ name: 's', data: data.slice(20, 40) });
    return new Signature(opts);
  }
  function parseECDSA(data, type, format, opts) {
    var buf = new SSHBuffer({ buffer: data });
    var r, s;
    var inner = buf.readBuffer();
    var stype = inner.toString('ascii');
    if (stype.slice(0, 6) === 'ecdsa-') {
      var parts = stype.split('-');
      assert.strictEqual(parts[0], 'ecdsa');
      assert.strictEqual(parts[1], 'sha2');
      opts.curve = parts[2];
      switch (opts.curve) {
        case 'nistp256':
          opts.hashAlgo = 'sha256';
          break;
        case 'nistp384':
          opts.hashAlgo = 'sha384';
          break;
        case 'nistp521':
          opts.hashAlgo = 'sha512';
          break;
        default:
          throw new Error('Unsupported ECDSA curve: ' + opts.curve);
      }
      inner = buf.readBuffer();
      assert.ok(buf.atEnd(), 'extra trailing bytes on outer');
      buf = new SSHBuffer({ buffer: inner });
      r = buf.readPart();
    } else {
      r = { data: inner };
    }
    s = buf.readPart();
    assert.ok(buf.atEnd(), 'extra trailing bytes');
    r.name = 'r';
    s.name = 's';
    opts.parts.push(r);
    opts.parts.push(s);
    return new Signature(opts);
  }
  Signature.isSignature = function (obj, ver) {
    return utils.isCompatible(obj, Signature, ver);
  };
  Signature.prototype._sshpkApiVersion = [2, 1];
  Signature._oldVersionDetect = function (obj) {
    assert.func(obj.toBuffer);
    if (obj.hasOwnProperty('hashAlgorithm')) return [2, 0];
    return [1, 0];
  };
});

// node_modules/ecc-jsbn/lib/sec.js
var require_sec = __commonJS((exports2, module2) => {
  var BigInteger = require_jsbn().BigInteger;
  var ECCurveFp = require_ec().ECCurveFp;
  function X9ECParameters(curve, g, n, h) {
    this.curve = curve;
    this.g = g;
    this.n = n;
    this.h = h;
  }
  function x9getCurve() {
    return this.curve;
  }
  function x9getG() {
    return this.g;
  }
  function x9getN() {
    return this.n;
  }
  function x9getH() {
    return this.h;
  }
  X9ECParameters.prototype.getCurve = x9getCurve;
  X9ECParameters.prototype.getG = x9getG;
  X9ECParameters.prototype.getN = x9getN;
  X9ECParameters.prototype.getH = x9getH;
  function fromHex(s) {
    return new BigInteger(s, 16);
  }
  function secp128r1() {
    var p = fromHex('FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF');
    var a = fromHex('FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC');
    var b = fromHex('E87579C11079F43DD824993C2CEE5ED3');
    var n = fromHex('FFFFFFFE0000000075A30D1B9038A115');
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex(
      '04161FF7528B899B2D0C28607CA52C5B86CF5AC8395BAFEB13C02DA292DDED7A83',
    );
    return new X9ECParameters(curve, G, n, h);
  }
  function secp160k1() {
    var p = fromHex('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73');
    var a = BigInteger.ZERO;
    var b = fromHex('7');
    var n = fromHex('0100000000000000000001B8FA16DFAB9ACA16B6B3');
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex(
      '043B4C382CE37AA192A4019E763036F4F5DD4D7EBB938CF935318FDCED6BC28286531733C3F03C4FEE',
    );
    return new X9ECParameters(curve, G, n, h);
  }
  function secp160r1() {
    var p = fromHex('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF');
    var a = fromHex('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC');
    var b = fromHex('1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45');
    var n = fromHex('0100000000000000000001F4C8F927AED3CA752257');
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex(
      '044A96B5688EF573284664698968C38BB913CBFC8223A628553168947D59DCC912042351377AC5FB32',
    );
    return new X9ECParameters(curve, G, n, h);
  }
  function secp192k1() {
    var p = fromHex('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37');
    var a = BigInteger.ZERO;
    var b = fromHex('3');
    var n = fromHex('FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D');
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex(
      '04DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D',
    );
    return new X9ECParameters(curve, G, n, h);
  }
  function secp192r1() {
    var p = fromHex('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF');
    var a = fromHex('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC');
    var b = fromHex('64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1');
    var n = fromHex('FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831');
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex(
      '04188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF101207192B95FFC8DA78631011ED6B24CDD573F977A11E794811',
    );
    return new X9ECParameters(curve, G, n, h);
  }
  function secp224r1() {
    var p = fromHex('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001');
    var a = fromHex('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE');
    var b = fromHex('B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4');
    var n = fromHex('FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D');
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex(
      '04B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34',
    );
    return new X9ECParameters(curve, G, n, h);
  }
  function secp256r1() {
    var p = fromHex(
      'FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF',
    );
    var a = fromHex(
      'FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC',
    );
    var b = fromHex(
      '5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B',
    );
    var n = fromHex(
      'FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551',
    );
    var h = BigInteger.ONE;
    var curve = new ECCurveFp(p, a, b);
    var G = curve.decodePointHex(
      '046B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C2964FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5',
    );
    return new X9ECParameters(curve, G, n, h);
  }
  module2.exports = {
    secp128r1,
    secp160k1,
    secp160r1,
    secp192k1,
    secp192r1,
    secp224r1,
    secp256r1,
  };
});

// node_modules/ecc-jsbn/index.js
var require_ecc_jsbn = __commonJS((exports2) => {
  var crypto = require('crypto');
  var BigInteger = require_jsbn().BigInteger;
  var ECPointFp = require_ec().ECPointFp;
  var Buffer2 = require_safer().Buffer;
  exports2.ECCurves = require_sec();
  function unstupid(hex, len) {
    return hex.length >= len ? hex : unstupid('0' + hex, len);
  }
  exports2.ECKey = function (curve, key, isPublic) {
    var priv;
    var c = curve();
    var n = c.getN();
    var bytes = Math.floor(n.bitLength() / 8);
    if (key) {
      if (isPublic) {
        var curve = c.getCurve();
        this.P = curve.decodePointHex(key.toString('hex'));
      } else {
        if (key.length != bytes) return false;
        priv = new BigInteger(key.toString('hex'), 16);
      }
    } else {
      var n1 = n.subtract(BigInteger.ONE);
      var r = new BigInteger(crypto.randomBytes(n.bitLength()));
      priv = r.mod(n1).add(BigInteger.ONE);
      this.P = c.getG().multiply(priv);
    }
    if (this.P) {
      this.PublicKey = Buffer2.from(
        c.getCurve().encodeCompressedPointHex(this.P),
        'hex',
      );
    }
    if (priv) {
      this.PrivateKey = Buffer2.from(
        unstupid(priv.toString(16), bytes * 2),
        'hex',
      );
      this.deriveSharedSecret = function (key2) {
        if (!key2 || !key2.P) return false;
        var S = key2.P.multiply(priv);
        return Buffer2.from(
          unstupid(S.getX().toBigInteger().toString(16), bytes * 2),
          'hex',
        );
      };
    }
  };
});

// node_modules/sshpk/lib/dhe.js
var require_dhe = __commonJS((exports2, module2) => {
  module2.exports = {
    DiffieHellman,
    generateECDSA,
    generateED25519,
  };
  var assert = require_assert();
  var crypto = require('crypto');
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var utils = require_utils4();
  var nacl = require_nacl_fast();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var CRYPTO_HAVE_ECDH = crypto.createECDH !== void 0;
  var ecdh = require_ecc_jsbn();
  var ec = require_ec();
  var jsbn = require_jsbn().BigInteger;
  function DiffieHellman(key) {
    utils.assertCompatible(key, Key, [1, 4], 'key');
    this._isPriv = PrivateKey.isPrivateKey(key, [1, 3]);
    this._algo = key.type;
    this._curve = key.curve;
    this._key = key;
    if (key.type === 'dsa') {
      if (!CRYPTO_HAVE_ECDH) {
        throw new Error(
          'Due to bugs in the node 0.10 crypto API, node 0.12.x or later is required to use DH',
        );
      }
      this._dh = crypto.createDiffieHellman(
        key.part.p.data,
        void 0,
        key.part.g.data,
        void 0,
      );
      this._p = key.part.p;
      this._g = key.part.g;
      if (this._isPriv) this._dh.setPrivateKey(key.part.x.data);
      this._dh.setPublicKey(key.part.y.data);
    } else if (key.type === 'ecdsa') {
      if (!CRYPTO_HAVE_ECDH) {
        this._ecParams = new X9ECParameters(this._curve);
        if (this._isPriv) {
          this._priv = new ECPrivate(this._ecParams, key.part.d.data);
        }
        return;
      }
      var curve = {
        nistp256: 'prime256v1',
        nistp384: 'secp384r1',
        nistp521: 'secp521r1',
      }[key.curve];
      this._dh = crypto.createECDH(curve);
      if (
        typeof this._dh !== 'object' ||
        typeof this._dh.setPrivateKey !== 'function'
      ) {
        CRYPTO_HAVE_ECDH = false;
        DiffieHellman.call(this, key);
        return;
      }
      if (this._isPriv) this._dh.setPrivateKey(key.part.d.data);
      this._dh.setPublicKey(key.part.Q.data);
    } else if (key.type === 'curve25519') {
      if (this._isPriv) {
        utils.assertCompatible(key, PrivateKey, [1, 5], 'key');
        this._priv = key.part.k.data;
      }
    } else {
      throw new Error('DH not supported for ' + key.type + ' keys');
    }
  }
  DiffieHellman.prototype.getPublicKey = function () {
    if (this._isPriv) return this._key.toPublic();
    return this._key;
  };
  DiffieHellman.prototype.getPrivateKey = function () {
    if (this._isPriv) return this._key;
    else return void 0;
  };
  DiffieHellman.prototype.getKey = DiffieHellman.prototype.getPrivateKey;
  DiffieHellman.prototype._keyCheck = function (pk, isPub) {
    assert.object(pk, 'key');
    if (!isPub) utils.assertCompatible(pk, PrivateKey, [1, 3], 'key');
    utils.assertCompatible(pk, Key, [1, 4], 'key');
    if (pk.type !== this._algo) {
      throw new Error(
        'A ' +
          pk.type +
          ' key cannot be used in ' +
          this._algo +
          ' Diffie-Hellman',
      );
    }
    if (pk.curve !== this._curve) {
      throw new Error(
        'A key from the ' +
          pk.curve +
          ' curve cannot be used with a ' +
          this._curve +
          ' Diffie-Hellman',
      );
    }
    if (pk.type === 'dsa') {
      assert.deepEqual(pk.part.p, this._p, 'DSA key prime does not match');
      assert.deepEqual(pk.part.g, this._g, 'DSA key generator does not match');
    }
  };
  DiffieHellman.prototype.setKey = function (pk) {
    this._keyCheck(pk);
    if (pk.type === 'dsa') {
      this._dh.setPrivateKey(pk.part.x.data);
      this._dh.setPublicKey(pk.part.y.data);
    } else if (pk.type === 'ecdsa') {
      if (CRYPTO_HAVE_ECDH) {
        this._dh.setPrivateKey(pk.part.d.data);
        this._dh.setPublicKey(pk.part.Q.data);
      } else {
        this._priv = new ECPrivate(this._ecParams, pk.part.d.data);
      }
    } else if (pk.type === 'curve25519') {
      var k = pk.part.k;
      if (!pk.part.k) k = pk.part.r;
      this._priv = k.data;
      if (this._priv[0] === 0) this._priv = this._priv.slice(1);
      this._priv = this._priv.slice(0, 32);
    }
    this._key = pk;
    this._isPriv = true;
  };
  DiffieHellman.prototype.setPrivateKey = DiffieHellman.prototype.setKey;
  DiffieHellman.prototype.computeSecret = function (otherpk) {
    this._keyCheck(otherpk, true);
    if (!this._isPriv)
      throw new Error(
        'DH exchange has not been initialized with a private key yet',
      );
    var pub;
    if (this._algo === 'dsa') {
      return this._dh.computeSecret(otherpk.part.y.data);
    } else if (this._algo === 'ecdsa') {
      if (CRYPTO_HAVE_ECDH) {
        return this._dh.computeSecret(otherpk.part.Q.data);
      } else {
        pub = new ECPublic(this._ecParams, otherpk.part.Q.data);
        return this._priv.deriveSharedSecret(pub);
      }
    } else if (this._algo === 'curve25519') {
      pub = otherpk.part.A.data;
      while (pub[0] === 0 && pub.length > 32) pub = pub.slice(1);
      var priv = this._priv;
      assert.strictEqual(pub.length, 32);
      assert.strictEqual(priv.length, 32);
      var secret = nacl.box.before(new Uint8Array(pub), new Uint8Array(priv));
      return Buffer2.from(secret);
    }
    throw new Error('Invalid algorithm: ' + this._algo);
  };
  DiffieHellman.prototype.generateKey = function () {
    var parts = [];
    var priv, pub;
    if (this._algo === 'dsa') {
      this._dh.generateKeys();
      parts.push({ name: 'p', data: this._p.data });
      parts.push({ name: 'q', data: this._key.part.q.data });
      parts.push({ name: 'g', data: this._g.data });
      parts.push({ name: 'y', data: this._dh.getPublicKey() });
      parts.push({ name: 'x', data: this._dh.getPrivateKey() });
      this._key = new PrivateKey({
        type: 'dsa',
        parts,
      });
      this._isPriv = true;
      return this._key;
    } else if (this._algo === 'ecdsa') {
      if (CRYPTO_HAVE_ECDH) {
        this._dh.generateKeys();
        parts.push({
          name: 'curve',
          data: Buffer2.from(this._curve),
        });
        parts.push({ name: 'Q', data: this._dh.getPublicKey() });
        parts.push({ name: 'd', data: this._dh.getPrivateKey() });
        this._key = new PrivateKey({
          type: 'ecdsa',
          curve: this._curve,
          parts,
        });
        this._isPriv = true;
        return this._key;
      } else {
        var n = this._ecParams.getN();
        var r = new jsbn(crypto.randomBytes(n.bitLength()));
        var n1 = n.subtract(jsbn.ONE);
        priv = r.mod(n1).add(jsbn.ONE);
        pub = this._ecParams.getG().multiply(priv);
        priv = Buffer2.from(priv.toByteArray());
        pub = Buffer2.from(
          this._ecParams.getCurve().encodePointHex(pub),
          'hex',
        );
        this._priv = new ECPrivate(this._ecParams, priv);
        parts.push({
          name: 'curve',
          data: Buffer2.from(this._curve),
        });
        parts.push({ name: 'Q', data: pub });
        parts.push({ name: 'd', data: priv });
        this._key = new PrivateKey({
          type: 'ecdsa',
          curve: this._curve,
          parts,
        });
        this._isPriv = true;
        return this._key;
      }
    } else if (this._algo === 'curve25519') {
      var pair = nacl.box.keyPair();
      priv = Buffer2.from(pair.secretKey);
      pub = Buffer2.from(pair.publicKey);
      priv = Buffer2.concat([priv, pub]);
      assert.strictEqual(priv.length, 64);
      assert.strictEqual(pub.length, 32);
      parts.push({ name: 'A', data: pub });
      parts.push({ name: 'k', data: priv });
      this._key = new PrivateKey({
        type: 'curve25519',
        parts,
      });
      this._isPriv = true;
      return this._key;
    }
    throw new Error('Invalid algorithm: ' + this._algo);
  };
  DiffieHellman.prototype.generateKeys = DiffieHellman.prototype.generateKey;
  function X9ECParameters(name) {
    var params = algs.curves[name];
    assert.object(params);
    var p = new jsbn(params.p);
    var a = new jsbn(params.a);
    var b = new jsbn(params.b);
    var n = new jsbn(params.n);
    var h = jsbn.ONE;
    var curve = new ec.ECCurveFp(p, a, b);
    var G = curve.decodePointHex(params.G.toString('hex'));
    this.curve = curve;
    this.g = G;
    this.n = n;
    this.h = h;
  }
  X9ECParameters.prototype.getCurve = function () {
    return this.curve;
  };
  X9ECParameters.prototype.getG = function () {
    return this.g;
  };
  X9ECParameters.prototype.getN = function () {
    return this.n;
  };
  X9ECParameters.prototype.getH = function () {
    return this.h;
  };
  function ECPublic(params, buffer) {
    this._params = params;
    if (buffer[0] === 0) buffer = buffer.slice(1);
    this._pub = params.getCurve().decodePointHex(buffer.toString('hex'));
  }
  function ECPrivate(params, buffer) {
    this._params = params;
    this._priv = new jsbn(utils.mpNormalize(buffer));
  }
  ECPrivate.prototype.deriveSharedSecret = function (pubKey) {
    assert.ok(pubKey instanceof ECPublic);
    var S = pubKey._pub.multiply(this._priv);
    return Buffer2.from(S.getX().toBigInteger().toByteArray());
  };
  function generateED25519() {
    var pair = nacl.sign.keyPair();
    var priv = Buffer2.from(pair.secretKey);
    var pub = Buffer2.from(pair.publicKey);
    assert.strictEqual(priv.length, 64);
    assert.strictEqual(pub.length, 32);
    var parts = [];
    parts.push({ name: 'A', data: pub });
    parts.push({ name: 'k', data: priv.slice(0, 32) });
    var key = new PrivateKey({
      type: 'ed25519',
      parts,
    });
    return key;
  }
  function generateECDSA(curve) {
    var parts = [];
    var key;
    if (CRYPTO_HAVE_ECDH) {
      var osCurve = {
        nistp256: 'prime256v1',
        nistp384: 'secp384r1',
        nistp521: 'secp521r1',
      }[curve];
      var dh = crypto.createECDH(osCurve);
      dh.generateKeys();
      parts.push({
        name: 'curve',
        data: Buffer2.from(curve),
      });
      parts.push({ name: 'Q', data: dh.getPublicKey() });
      parts.push({ name: 'd', data: dh.getPrivateKey() });
      key = new PrivateKey({
        type: 'ecdsa',
        curve,
        parts,
      });
      return key;
    } else {
      var ecParams = new X9ECParameters(curve);
      var n = ecParams.getN();
      var cByteLen = Math.ceil((n.bitLength() + 64) / 8);
      var c = new jsbn(crypto.randomBytes(cByteLen));
      var n1 = n.subtract(jsbn.ONE);
      var priv = c.mod(n1).add(jsbn.ONE);
      var pub = ecParams.getG().multiply(priv);
      priv = Buffer2.from(priv.toByteArray());
      pub = Buffer2.from(ecParams.getCurve().encodePointHex(pub), 'hex');
      parts.push({ name: 'curve', data: Buffer2.from(curve) });
      parts.push({ name: 'Q', data: pub });
      parts.push({ name: 'd', data: priv });
      key = new PrivateKey({
        type: 'ecdsa',
        curve,
        parts,
      });
      return key;
    }
  }
});

// node_modules/sshpk/lib/ed-compat.js
var require_ed_compat = __commonJS((exports2, module2) => {
  module2.exports = {
    Verifier,
    Signer,
  };
  var nacl = require_nacl_fast();
  var stream = require('stream');
  var util = require('util');
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var Signature = require_signature();
  function Verifier(key, hashAlgo) {
    if (hashAlgo.toLowerCase() !== 'sha512')
      throw new Error('ED25519 only supports the use of SHA-512 hashes');
    this.key = key;
    this.chunks = [];
    stream.Writable.call(this, {});
  }
  util.inherits(Verifier, stream.Writable);
  Verifier.prototype._write = function (chunk, enc, cb) {
    this.chunks.push(chunk);
    cb();
  };
  Verifier.prototype.update = function (chunk) {
    if (typeof chunk === 'string') chunk = Buffer2.from(chunk, 'binary');
    this.chunks.push(chunk);
  };
  Verifier.prototype.verify = function (signature, fmt) {
    var sig;
    if (Signature.isSignature(signature, [2, 0])) {
      if (signature.type !== 'ed25519') return false;
      sig = signature.toBuffer('raw');
    } else if (typeof signature === 'string') {
      sig = Buffer2.from(signature, 'base64');
    } else if (Signature.isSignature(signature, [1, 0])) {
      throw new Error(
        'signature was created by too old a version of sshpk and cannot be verified',
      );
    }
    assert.buffer(sig);
    return nacl.sign.detached.verify(
      new Uint8Array(Buffer2.concat(this.chunks)),
      new Uint8Array(sig),
      new Uint8Array(this.key.part.A.data),
    );
  };
  function Signer(key, hashAlgo) {
    if (hashAlgo.toLowerCase() !== 'sha512')
      throw new Error('ED25519 only supports the use of SHA-512 hashes');
    this.key = key;
    this.chunks = [];
    stream.Writable.call(this, {});
  }
  util.inherits(Signer, stream.Writable);
  Signer.prototype._write = function (chunk, enc, cb) {
    this.chunks.push(chunk);
    cb();
  };
  Signer.prototype.update = function (chunk) {
    if (typeof chunk === 'string') chunk = Buffer2.from(chunk, 'binary');
    this.chunks.push(chunk);
  };
  Signer.prototype.sign = function () {
    var sig = nacl.sign.detached(
      new Uint8Array(Buffer2.concat(this.chunks)),
      new Uint8Array(
        Buffer2.concat([this.key.part.k.data, this.key.part.A.data]),
      ),
    );
    var sigBuf = Buffer2.from(sig);
    var sigObj = Signature.parse(sigBuf, 'ed25519', 'raw');
    sigObj.hashAlgorithm = 'sha512';
    return sigObj;
  };
});

// node_modules/sshpk/lib/formats/pkcs8.js
var require_pkcs8 = __commonJS((exports2, module2) => {
  module2.exports = {
    read,
    readPkcs8,
    write,
    writePkcs8,
    pkcs8ToBuffer,
    readECDSACurve,
    writeECDSACurve,
  };
  var assert = require_assert();
  var asn1 = require_lib();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var utils = require_utils4();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var pem = require_pem();
  function read(buf, options) {
    return pem.read(buf, options, 'pkcs8');
  }
  function write(key, options) {
    return pem.write(key, options, 'pkcs8');
  }
  function readMPInt(der, nm) {
    assert.strictEqual(der.peek(), asn1.Ber.Integer, nm + ' is not an Integer');
    return utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
  }
  function readPkcs8(alg, type, der) {
    if (der.peek() === asn1.Ber.Integer) {
      assert.strictEqual(
        type,
        'private',
        'unexpected Integer at start of public key',
      );
      der.readString(asn1.Ber.Integer, true);
    }
    der.readSequence();
    var next = der.offset + der.length;
    var oid = der.readOID();
    switch (oid) {
      case '1.2.840.113549.1.1.1':
        der._offset = next;
        if (type === 'public') return readPkcs8RSAPublic(der);
        else return readPkcs8RSAPrivate(der);
      case '1.2.840.10040.4.1':
        if (type === 'public') return readPkcs8DSAPublic(der);
        else return readPkcs8DSAPrivate(der);
      case '1.2.840.10045.2.1':
        if (type === 'public') return readPkcs8ECDSAPublic(der);
        else return readPkcs8ECDSAPrivate(der);
      case '1.3.101.112':
        if (type === 'public') {
          return readPkcs8EdDSAPublic(der);
        } else {
          return readPkcs8EdDSAPrivate(der);
        }
      case '1.3.101.110':
        if (type === 'public') {
          return readPkcs8X25519Public(der);
        } else {
          return readPkcs8X25519Private(der);
        }
      default:
        throw new Error('Unknown key type OID ' + oid);
    }
  }
  function readPkcs8RSAPublic(der) {
    der.readSequence(asn1.Ber.BitString);
    der.readByte();
    der.readSequence();
    var n = readMPInt(der, 'modulus');
    var e = readMPInt(der, 'exponent');
    var key = {
      type: 'rsa',
      source: der.originalInput,
      parts: [
        { name: 'e', data: e },
        { name: 'n', data: n },
      ],
    };
    return new Key(key);
  }
  function readPkcs8RSAPrivate(der) {
    der.readSequence(asn1.Ber.OctetString);
    der.readSequence();
    var ver = readMPInt(der, 'version');
    assert.equal(ver[0], 0, 'unknown RSA private key version');
    var n = readMPInt(der, 'modulus');
    var e = readMPInt(der, 'public exponent');
    var d = readMPInt(der, 'private exponent');
    var p = readMPInt(der, 'prime1');
    var q2 = readMPInt(der, 'prime2');
    var dmodp = readMPInt(der, 'exponent1');
    var dmodq = readMPInt(der, 'exponent2');
    var iqmp = readMPInt(der, 'iqmp');
    var key = {
      type: 'rsa',
      parts: [
        { name: 'n', data: n },
        { name: 'e', data: e },
        { name: 'd', data: d },
        { name: 'iqmp', data: iqmp },
        { name: 'p', data: p },
        { name: 'q', data: q2 },
        { name: 'dmodp', data: dmodp },
        { name: 'dmodq', data: dmodq },
      ],
    };
    return new PrivateKey(key);
  }
  function readPkcs8DSAPublic(der) {
    der.readSequence();
    var p = readMPInt(der, 'p');
    var q2 = readMPInt(der, 'q');
    var g = readMPInt(der, 'g');
    der.readSequence(asn1.Ber.BitString);
    der.readByte();
    var y = readMPInt(der, 'y');
    var key = {
      type: 'dsa',
      parts: [
        { name: 'p', data: p },
        { name: 'q', data: q2 },
        { name: 'g', data: g },
        { name: 'y', data: y },
      ],
    };
    return new Key(key);
  }
  function readPkcs8DSAPrivate(der) {
    der.readSequence();
    var p = readMPInt(der, 'p');
    var q2 = readMPInt(der, 'q');
    var g = readMPInt(der, 'g');
    der.readSequence(asn1.Ber.OctetString);
    var x = readMPInt(der, 'x');
    var y = utils.calculateDSAPublic(g, p, x);
    var key = {
      type: 'dsa',
      parts: [
        { name: 'p', data: p },
        { name: 'q', data: q2 },
        { name: 'g', data: g },
        { name: 'y', data: y },
        { name: 'x', data: x },
      ],
    };
    return new PrivateKey(key);
  }
  function readECDSACurve(der) {
    var curveName, curveNames;
    var j, c, cd;
    if (der.peek() === asn1.Ber.OID) {
      var oid = der.readOID();
      curveNames = Object.keys(algs.curves);
      for (j = 0; j < curveNames.length; ++j) {
        c = curveNames[j];
        cd = algs.curves[c];
        if (cd.pkcs8oid === oid) {
          curveName = c;
          break;
        }
      }
    } else {
      der.readSequence();
      var version = der.readString(asn1.Ber.Integer, true);
      assert.strictEqual(version[0], 1, 'ECDSA key not version 1');
      var curve = {};
      der.readSequence();
      var fieldTypeOid = der.readOID();
      assert.strictEqual(
        fieldTypeOid,
        '1.2.840.10045.1.1',
        'ECDSA key is not from a prime-field',
      );
      var p = (curve.p = utils.mpNormalize(
        der.readString(asn1.Ber.Integer, true),
      ));
      curve.size = p.length * 8 - utils.countZeros(p);
      der.readSequence();
      curve.a = utils.mpNormalize(der.readString(asn1.Ber.OctetString, true));
      curve.b = utils.mpNormalize(der.readString(asn1.Ber.OctetString, true));
      if (der.peek() === asn1.Ber.BitString)
        curve.s = der.readString(asn1.Ber.BitString, true);
      curve.G = der.readString(asn1.Ber.OctetString, true);
      assert.strictEqual(curve.G[0], 4, 'uncompressed G is required');
      curve.n = utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
      curve.h = utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
      assert.strictEqual(curve.h[0], 1, 'a cofactor=1 curve is required');
      curveNames = Object.keys(algs.curves);
      var ks = Object.keys(curve);
      for (j = 0; j < curveNames.length; ++j) {
        c = curveNames[j];
        cd = algs.curves[c];
        var equal = true;
        for (var i = 0; i < ks.length; ++i) {
          var k = ks[i];
          if (cd[k] === void 0) continue;
          if (typeof cd[k] === 'object' && cd[k].equals !== void 0) {
            if (!cd[k].equals(curve[k])) {
              equal = false;
              break;
            }
          } else if (Buffer2.isBuffer(cd[k])) {
            if (cd[k].toString('binary') !== curve[k].toString('binary')) {
              equal = false;
              break;
            }
          } else {
            if (cd[k] !== curve[k]) {
              equal = false;
              break;
            }
          }
        }
        if (equal) {
          curveName = c;
          break;
        }
      }
    }
    return curveName;
  }
  function readPkcs8ECDSAPrivate(der) {
    var curveName = readECDSACurve(der);
    assert.string(curveName, 'a known elliptic curve');
    der.readSequence(asn1.Ber.OctetString);
    der.readSequence();
    var version = readMPInt(der, 'version');
    assert.equal(version[0], 1, 'unknown version of ECDSA key');
    var d = der.readString(asn1.Ber.OctetString, true);
    var Q;
    if (der.peek() == 160) {
      der.readSequence(160);
      der._offset += der.length;
    }
    if (der.peek() == 161) {
      der.readSequence(161);
      Q = der.readString(asn1.Ber.BitString, true);
      Q = utils.ecNormalize(Q);
    }
    if (Q === void 0) {
      var pub = utils.publicFromPrivateECDSA(curveName, d);
      Q = pub.part.Q.data;
    }
    var key = {
      type: 'ecdsa',
      parts: [
        { name: 'curve', data: Buffer2.from(curveName) },
        { name: 'Q', data: Q },
        { name: 'd', data: d },
      ],
    };
    return new PrivateKey(key);
  }
  function readPkcs8ECDSAPublic(der) {
    var curveName = readECDSACurve(der);
    assert.string(curveName, 'a known elliptic curve');
    var Q = der.readString(asn1.Ber.BitString, true);
    Q = utils.ecNormalize(Q);
    var key = {
      type: 'ecdsa',
      parts: [
        { name: 'curve', data: Buffer2.from(curveName) },
        { name: 'Q', data: Q },
      ],
    };
    return new Key(key);
  }
  function readPkcs8EdDSAPublic(der) {
    if (der.peek() === 0) der.readByte();
    var A = utils.readBitString(der);
    var key = {
      type: 'ed25519',
      parts: [{ name: 'A', data: utils.zeroPadToLength(A, 32) }],
    };
    return new Key(key);
  }
  function readPkcs8X25519Public(der) {
    var A = utils.readBitString(der);
    var key = {
      type: 'curve25519',
      parts: [{ name: 'A', data: utils.zeroPadToLength(A, 32) }],
    };
    return new Key(key);
  }
  function readPkcs8EdDSAPrivate(der) {
    if (der.peek() === 0) der.readByte();
    der.readSequence(asn1.Ber.OctetString);
    var k = der.readString(asn1.Ber.OctetString, true);
    k = utils.zeroPadToLength(k, 32);
    var A;
    if (der.peek() === asn1.Ber.BitString) {
      A = utils.readBitString(der);
      A = utils.zeroPadToLength(A, 32);
    } else {
      A = utils.calculateED25519Public(k);
    }
    var key = {
      type: 'ed25519',
      parts: [
        { name: 'A', data: utils.zeroPadToLength(A, 32) },
        { name: 'k', data: utils.zeroPadToLength(k, 32) },
      ],
    };
    return new PrivateKey(key);
  }
  function readPkcs8X25519Private(der) {
    if (der.peek() === 0) der.readByte();
    der.readSequence(asn1.Ber.OctetString);
    var k = der.readString(asn1.Ber.OctetString, true);
    k = utils.zeroPadToLength(k, 32);
    var A = utils.calculateX25519Public(k);
    var key = {
      type: 'curve25519',
      parts: [
        { name: 'A', data: utils.zeroPadToLength(A, 32) },
        { name: 'k', data: utils.zeroPadToLength(k, 32) },
      ],
    };
    return new PrivateKey(key);
  }
  function pkcs8ToBuffer(key) {
    var der = new asn1.BerWriter();
    writePkcs8(der, key);
    return der.buffer;
  }
  function writePkcs8(der, key) {
    der.startSequence();
    if (PrivateKey.isPrivateKey(key)) {
      var sillyInt = Buffer2.from([0]);
      der.writeBuffer(sillyInt, asn1.Ber.Integer);
    }
    der.startSequence();
    switch (key.type) {
      case 'rsa':
        der.writeOID('1.2.840.113549.1.1.1');
        if (PrivateKey.isPrivateKey(key)) writePkcs8RSAPrivate(key, der);
        else writePkcs8RSAPublic(key, der);
        break;
      case 'dsa':
        der.writeOID('1.2.840.10040.4.1');
        if (PrivateKey.isPrivateKey(key)) writePkcs8DSAPrivate(key, der);
        else writePkcs8DSAPublic(key, der);
        break;
      case 'ecdsa':
        der.writeOID('1.2.840.10045.2.1');
        if (PrivateKey.isPrivateKey(key)) writePkcs8ECDSAPrivate(key, der);
        else writePkcs8ECDSAPublic(key, der);
        break;
      case 'ed25519':
        der.writeOID('1.3.101.112');
        if (PrivateKey.isPrivateKey(key))
          throw new Error(
            'Ed25519 private keys in pkcs8 format are not supported',
          );
        writePkcs8EdDSAPublic(key, der);
        break;
      default:
        throw new Error('Unsupported key type: ' + key.type);
    }
    der.endSequence();
  }
  function writePkcs8RSAPrivate(key, der) {
    der.writeNull();
    der.endSequence();
    der.startSequence(asn1.Ber.OctetString);
    der.startSequence();
    var version = Buffer2.from([0]);
    der.writeBuffer(version, asn1.Ber.Integer);
    der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.d.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
    if (!key.part.dmodp || !key.part.dmodq) utils.addRSAMissing(key);
    der.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);
    der.endSequence();
    der.endSequence();
  }
  function writePkcs8RSAPublic(key, der) {
    der.writeNull();
    der.endSequence();
    der.startSequence(asn1.Ber.BitString);
    der.writeByte(0);
    der.startSequence();
    der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
    der.endSequence();
    der.endSequence();
  }
  function writePkcs8DSAPrivate(key, der) {
    der.startSequence();
    der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
    der.endSequence();
    der.endSequence();
    der.startSequence(asn1.Ber.OctetString);
    der.writeBuffer(key.part.x.data, asn1.Ber.Integer);
    der.endSequence();
  }
  function writePkcs8DSAPublic(key, der) {
    der.startSequence();
    der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
    der.endSequence();
    der.endSequence();
    der.startSequence(asn1.Ber.BitString);
    der.writeByte(0);
    der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
    der.endSequence();
  }
  function writeECDSACurve(key, der) {
    var curve = algs.curves[key.curve];
    if (curve.pkcs8oid) {
      der.writeOID(curve.pkcs8oid);
    } else {
      der.startSequence();
      var version = Buffer2.from([1]);
      der.writeBuffer(version, asn1.Ber.Integer);
      der.startSequence();
      der.writeOID('1.2.840.10045.1.1');
      der.writeBuffer(curve.p, asn1.Ber.Integer);
      der.endSequence();
      der.startSequence();
      var a = curve.p;
      if (a[0] === 0) a = a.slice(1);
      der.writeBuffer(a, asn1.Ber.OctetString);
      der.writeBuffer(curve.b, asn1.Ber.OctetString);
      der.writeBuffer(curve.s, asn1.Ber.BitString);
      der.endSequence();
      der.writeBuffer(curve.G, asn1.Ber.OctetString);
      der.writeBuffer(curve.n, asn1.Ber.Integer);
      var h = curve.h;
      if (!h) {
        h = Buffer2.from([1]);
      }
      der.writeBuffer(h, asn1.Ber.Integer);
      der.endSequence();
    }
  }
  function writePkcs8ECDSAPublic(key, der) {
    writeECDSACurve(key, der);
    der.endSequence();
    var Q = utils.ecNormalize(key.part.Q.data, true);
    der.writeBuffer(Q, asn1.Ber.BitString);
  }
  function writePkcs8ECDSAPrivate(key, der) {
    writeECDSACurve(key, der);
    der.endSequence();
    der.startSequence(asn1.Ber.OctetString);
    der.startSequence();
    var version = Buffer2.from([1]);
    der.writeBuffer(version, asn1.Ber.Integer);
    der.writeBuffer(key.part.d.data, asn1.Ber.OctetString);
    der.startSequence(161);
    var Q = utils.ecNormalize(key.part.Q.data, true);
    der.writeBuffer(Q, asn1.Ber.BitString);
    der.endSequence();
    der.endSequence();
    der.endSequence();
  }
  function writePkcs8EdDSAPublic(key, der) {
    der.endSequence();
    utils.writeBitString(der, key.part.A.data);
  }
});

// node_modules/sshpk/lib/formats/pkcs1.js
var require_pkcs1 = __commonJS((exports2, module2) => {
  module2.exports = {
    read,
    readPkcs1,
    write,
    writePkcs1,
  };
  var assert = require_assert();
  var asn1 = require_lib();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var utils = require_utils4();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var pem = require_pem();
  var pkcs8 = require_pkcs8();
  var readECDSACurve = pkcs8.readECDSACurve;
  function read(buf, options) {
    return pem.read(buf, options, 'pkcs1');
  }
  function write(key, options) {
    return pem.write(key, options, 'pkcs1');
  }
  function readMPInt(der, nm) {
    assert.strictEqual(der.peek(), asn1.Ber.Integer, nm + ' is not an Integer');
    return utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
  }
  function readPkcs1(alg, type, der) {
    switch (alg) {
      case 'RSA':
        if (type === 'public') return readPkcs1RSAPublic(der);
        else if (type === 'private') return readPkcs1RSAPrivate(der);
        throw new Error('Unknown key type: ' + type);
      case 'DSA':
        if (type === 'public') return readPkcs1DSAPublic(der);
        else if (type === 'private') return readPkcs1DSAPrivate(der);
        throw new Error('Unknown key type: ' + type);
      case 'EC':
      case 'ECDSA':
        if (type === 'private') return readPkcs1ECDSAPrivate(der);
        else if (type === 'public') return readPkcs1ECDSAPublic(der);
        throw new Error('Unknown key type: ' + type);
      case 'EDDSA':
      case 'EdDSA':
        if (type === 'private') return readPkcs1EdDSAPrivate(der);
        throw new Error(type + ' keys not supported with EdDSA');
      default:
        throw new Error('Unknown key algo: ' + alg);
    }
  }
  function readPkcs1RSAPublic(der) {
    var n = readMPInt(der, 'modulus');
    var e = readMPInt(der, 'exponent');
    var key = {
      type: 'rsa',
      parts: [
        { name: 'e', data: e },
        { name: 'n', data: n },
      ],
    };
    return new Key(key);
  }
  function readPkcs1RSAPrivate(der) {
    var version = readMPInt(der, 'version');
    assert.strictEqual(version[0], 0);
    var n = readMPInt(der, 'modulus');
    var e = readMPInt(der, 'public exponent');
    var d = readMPInt(der, 'private exponent');
    var p = readMPInt(der, 'prime1');
    var q2 = readMPInt(der, 'prime2');
    var dmodp = readMPInt(der, 'exponent1');
    var dmodq = readMPInt(der, 'exponent2');
    var iqmp = readMPInt(der, 'iqmp');
    var key = {
      type: 'rsa',
      parts: [
        { name: 'n', data: n },
        { name: 'e', data: e },
        { name: 'd', data: d },
        { name: 'iqmp', data: iqmp },
        { name: 'p', data: p },
        { name: 'q', data: q2 },
        { name: 'dmodp', data: dmodp },
        { name: 'dmodq', data: dmodq },
      ],
    };
    return new PrivateKey(key);
  }
  function readPkcs1DSAPrivate(der) {
    var version = readMPInt(der, 'version');
    assert.strictEqual(version.readUInt8(0), 0);
    var p = readMPInt(der, 'p');
    var q2 = readMPInt(der, 'q');
    var g = readMPInt(der, 'g');
    var y = readMPInt(der, 'y');
    var x = readMPInt(der, 'x');
    var key = {
      type: 'dsa',
      parts: [
        { name: 'p', data: p },
        { name: 'q', data: q2 },
        { name: 'g', data: g },
        { name: 'y', data: y },
        { name: 'x', data: x },
      ],
    };
    return new PrivateKey(key);
  }
  function readPkcs1EdDSAPrivate(der) {
    var version = readMPInt(der, 'version');
    assert.strictEqual(version.readUInt8(0), 1);
    var k = der.readString(asn1.Ber.OctetString, true);
    der.readSequence(160);
    var oid = der.readOID();
    assert.strictEqual(oid, '1.3.101.112', 'the ed25519 curve identifier');
    der.readSequence(161);
    var A = utils.readBitString(der);
    var key = {
      type: 'ed25519',
      parts: [
        { name: 'A', data: utils.zeroPadToLength(A, 32) },
        { name: 'k', data: k },
      ],
    };
    return new PrivateKey(key);
  }
  function readPkcs1DSAPublic(der) {
    var y = readMPInt(der, 'y');
    var p = readMPInt(der, 'p');
    var q2 = readMPInt(der, 'q');
    var g = readMPInt(der, 'g');
    var key = {
      type: 'dsa',
      parts: [
        { name: 'y', data: y },
        { name: 'p', data: p },
        { name: 'q', data: q2 },
        { name: 'g', data: g },
      ],
    };
    return new Key(key);
  }
  function readPkcs1ECDSAPublic(der) {
    der.readSequence();
    var oid = der.readOID();
    assert.strictEqual(oid, '1.2.840.10045.2.1', 'must be ecPublicKey');
    var curveOid = der.readOID();
    var curve;
    var curves = Object.keys(algs.curves);
    for (var j = 0; j < curves.length; ++j) {
      var c = curves[j];
      var cd = algs.curves[c];
      if (cd.pkcs8oid === curveOid) {
        curve = c;
        break;
      }
    }
    assert.string(curve, 'a known ECDSA named curve');
    var Q = der.readString(asn1.Ber.BitString, true);
    Q = utils.ecNormalize(Q);
    var key = {
      type: 'ecdsa',
      parts: [
        { name: 'curve', data: Buffer2.from(curve) },
        { name: 'Q', data: Q },
      ],
    };
    return new Key(key);
  }
  function readPkcs1ECDSAPrivate(der) {
    var version = readMPInt(der, 'version');
    assert.strictEqual(version.readUInt8(0), 1);
    var d = der.readString(asn1.Ber.OctetString, true);
    der.readSequence(160);
    var curve = readECDSACurve(der);
    assert.string(curve, 'a known elliptic curve');
    der.readSequence(161);
    var Q = der.readString(asn1.Ber.BitString, true);
    Q = utils.ecNormalize(Q);
    var key = {
      type: 'ecdsa',
      parts: [
        { name: 'curve', data: Buffer2.from(curve) },
        { name: 'Q', data: Q },
        { name: 'd', data: d },
      ],
    };
    return new PrivateKey(key);
  }
  function writePkcs1(der, key) {
    der.startSequence();
    switch (key.type) {
      case 'rsa':
        if (PrivateKey.isPrivateKey(key)) writePkcs1RSAPrivate(der, key);
        else writePkcs1RSAPublic(der, key);
        break;
      case 'dsa':
        if (PrivateKey.isPrivateKey(key)) writePkcs1DSAPrivate(der, key);
        else writePkcs1DSAPublic(der, key);
        break;
      case 'ecdsa':
        if (PrivateKey.isPrivateKey(key)) writePkcs1ECDSAPrivate(der, key);
        else writePkcs1ECDSAPublic(der, key);
        break;
      case 'ed25519':
        if (PrivateKey.isPrivateKey(key)) writePkcs1EdDSAPrivate(der, key);
        else writePkcs1EdDSAPublic(der, key);
        break;
      default:
        throw new Error('Unknown key algo: ' + key.type);
    }
    der.endSequence();
  }
  function writePkcs1RSAPublic(der, key) {
    der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
  }
  function writePkcs1RSAPrivate(der, key) {
    var ver = Buffer2.from([0]);
    der.writeBuffer(ver, asn1.Ber.Integer);
    der.writeBuffer(key.part.n.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.e.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.d.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
    if (!key.part.dmodp || !key.part.dmodq) utils.addRSAMissing(key);
    der.writeBuffer(key.part.dmodp.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.dmodq.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.iqmp.data, asn1.Ber.Integer);
  }
  function writePkcs1DSAPrivate(der, key) {
    var ver = Buffer2.from([0]);
    der.writeBuffer(ver, asn1.Ber.Integer);
    der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.x.data, asn1.Ber.Integer);
  }
  function writePkcs1DSAPublic(der, key) {
    der.writeBuffer(key.part.y.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.p.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.q.data, asn1.Ber.Integer);
    der.writeBuffer(key.part.g.data, asn1.Ber.Integer);
  }
  function writePkcs1ECDSAPublic(der, key) {
    der.startSequence();
    der.writeOID('1.2.840.10045.2.1');
    var curve = key.part.curve.data.toString();
    var curveOid = algs.curves[curve].pkcs8oid;
    assert.string(curveOid, 'a known ECDSA named curve');
    der.writeOID(curveOid);
    der.endSequence();
    var Q = utils.ecNormalize(key.part.Q.data, true);
    der.writeBuffer(Q, asn1.Ber.BitString);
  }
  function writePkcs1ECDSAPrivate(der, key) {
    var ver = Buffer2.from([1]);
    der.writeBuffer(ver, asn1.Ber.Integer);
    der.writeBuffer(key.part.d.data, asn1.Ber.OctetString);
    der.startSequence(160);
    var curve = key.part.curve.data.toString();
    var curveOid = algs.curves[curve].pkcs8oid;
    assert.string(curveOid, 'a known ECDSA named curve');
    der.writeOID(curveOid);
    der.endSequence();
    der.startSequence(161);
    var Q = utils.ecNormalize(key.part.Q.data, true);
    der.writeBuffer(Q, asn1.Ber.BitString);
    der.endSequence();
  }
  function writePkcs1EdDSAPrivate(der, key) {
    var ver = Buffer2.from([1]);
    der.writeBuffer(ver, asn1.Ber.Integer);
    der.writeBuffer(key.part.k.data, asn1.Ber.OctetString);
    der.startSequence(160);
    der.writeOID('1.3.101.112');
    der.endSequence();
    der.startSequence(161);
    utils.writeBitString(der, key.part.A.data);
    der.endSequence();
  }
  function writePkcs1EdDSAPublic(der, key) {
    throw new Error('Public keys are not supported for EdDSA PKCS#1');
  }
});

// node_modules/sshpk/lib/formats/rfc4253.js
var require_rfc4253 = __commonJS((exports2, module2) => {
  module2.exports = {
    read: read.bind(void 0, false, void 0),
    readType: read.bind(void 0, false),
    write,
    readPartial: read.bind(void 0, true),
    readInternal: read,
    keyTypeToAlg,
    algToKeyType,
  };
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var utils = require_utils4();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var SSHBuffer = require_ssh_buffer();
  function algToKeyType(alg) {
    assert.string(alg);
    if (alg === 'ssh-dss') return 'dsa';
    else if (alg === 'ssh-rsa') return 'rsa';
    else if (alg === 'ssh-ed25519') return 'ed25519';
    else if (alg === 'ssh-curve25519') return 'curve25519';
    else if (alg.match(/^ecdsa-sha2-/)) return 'ecdsa';
    else throw new Error('Unknown algorithm ' + alg);
  }
  function keyTypeToAlg(key) {
    assert.object(key);
    if (key.type === 'dsa') return 'ssh-dss';
    else if (key.type === 'rsa') return 'ssh-rsa';
    else if (key.type === 'ed25519') return 'ssh-ed25519';
    else if (key.type === 'curve25519') return 'ssh-curve25519';
    else if (key.type === 'ecdsa')
      return 'ecdsa-sha2-' + key.part.curve.data.toString();
    else throw new Error('Unknown key type ' + key.type);
  }
  function read(partial, type, buf, options) {
    if (typeof buf === 'string') buf = Buffer2.from(buf);
    assert.buffer(buf, 'buf');
    var key = {};
    var parts = (key.parts = []);
    var sshbuf = new SSHBuffer({ buffer: buf });
    var alg = sshbuf.readString();
    assert.ok(!sshbuf.atEnd(), 'key must have at least one part');
    key.type = algToKeyType(alg);
    var partCount = algs.info[key.type].parts.length;
    if (type && type === 'private')
      partCount = algs.privInfo[key.type].parts.length;
    while (!sshbuf.atEnd() && parts.length < partCount)
      parts.push(sshbuf.readPart());
    while (!partial && !sshbuf.atEnd()) parts.push(sshbuf.readPart());
    assert.ok(parts.length >= 1, 'key must have at least one part');
    assert.ok(partial || sshbuf.atEnd(), 'leftover bytes at end of key');
    var Constructor = Key;
    var algInfo = algs.info[key.type];
    if (type === 'private' || algInfo.parts.length !== parts.length) {
      algInfo = algs.privInfo[key.type];
      Constructor = PrivateKey;
    }
    assert.strictEqual(algInfo.parts.length, parts.length);
    if (key.type === 'ecdsa') {
      var res = /^ecdsa-sha2-(.+)$/.exec(alg);
      assert.ok(res !== null);
      assert.strictEqual(res[1], parts[0].data.toString());
    }
    var normalized = true;
    for (var i = 0; i < algInfo.parts.length; ++i) {
      var p = parts[i];
      p.name = algInfo.parts[i];
      if (key.type === 'ed25519' && p.name === 'k')
        p.data = p.data.slice(0, 32);
      if (p.name !== 'curve' && algInfo.normalize !== false) {
        var nd;
        if (key.type === 'ed25519') {
          nd = utils.zeroPadToLength(p.data, 32);
        } else {
          nd = utils.mpNormalize(p.data);
        }
        if (nd.toString('binary') !== p.data.toString('binary')) {
          p.data = nd;
          normalized = false;
        }
      }
    }
    if (normalized) key._rfc4253Cache = sshbuf.toBuffer();
    if (partial && typeof partial === 'object') {
      partial.remainder = sshbuf.remainder();
      partial.consumed = sshbuf._offset;
    }
    return new Constructor(key);
  }
  function write(key, options) {
    assert.object(key);
    var alg = keyTypeToAlg(key);
    var i;
    var algInfo = algs.info[key.type];
    if (PrivateKey.isPrivateKey(key)) algInfo = algs.privInfo[key.type];
    var parts = algInfo.parts;
    var buf = new SSHBuffer({});
    buf.writeString(alg);
    for (i = 0; i < parts.length; ++i) {
      var data = key.part[parts[i]].data;
      if (algInfo.normalize !== false) {
        if (key.type === 'ed25519') data = utils.zeroPadToLength(data, 32);
        else data = utils.mpNormalize(data);
      }
      if (key.type === 'ed25519' && parts[i] === 'k')
        data = Buffer2.concat([data, key.part.A.data]);
      buf.writeBuffer(data);
    }
    return buf.toBuffer();
  }
});

// node_modules/bcrypt-pbkdf/index.js
var require_bcrypt_pbkdf = __commonJS((exports2, module2) => {
  'use strict';
  var crypto_hash_sha512 = require_nacl_fast().lowlevel.crypto_hash;
  var BLF_J = 0;
  var Blowfish = function () {
    this.S = [
      new Uint32Array([
        3509652390,
        2564797868,
        805139163,
        3491422135,
        3101798381,
        1780907670,
        3128725573,
        4046225305,
        614570311,
        3012652279,
        134345442,
        2240740374,
        1667834072,
        1901547113,
        2757295779,
        4103290238,
        227898511,
        1921955416,
        1904987480,
        2182433518,
        2069144605,
        3260701109,
        2620446009,
        720527379,
        3318853667,
        677414384,
        3393288472,
        3101374703,
        2390351024,
        1614419982,
        1822297739,
        2954791486,
        3608508353,
        3174124327,
        2024746970,
        1432378464,
        3864339955,
        2857741204,
        1464375394,
        1676153920,
        1439316330,
        715854006,
        3033291828,
        289532110,
        2706671279,
        2087905683,
        3018724369,
        1668267050,
        732546397,
        1947742710,
        3462151702,
        2609353502,
        2950085171,
        1814351708,
        2050118529,
        680887927,
        999245976,
        1800124847,
        3300911131,
        1713906067,
        1641548236,
        4213287313,
        1216130144,
        1575780402,
        4018429277,
        3917837745,
        3693486850,
        3949271944,
        596196993,
        3549867205,
        258830323,
        2213823033,
        772490370,
        2760122372,
        1774776394,
        2652871518,
        566650946,
        4142492826,
        1728879713,
        2882767088,
        1783734482,
        3629395816,
        2517608232,
        2874225571,
        1861159788,
        326777828,
        3124490320,
        2130389656,
        2716951837,
        967770486,
        1724537150,
        2185432712,
        2364442137,
        1164943284,
        2105845187,
        998989502,
        3765401048,
        2244026483,
        1075463327,
        1455516326,
        1322494562,
        910128902,
        469688178,
        1117454909,
        936433444,
        3490320968,
        3675253459,
        1240580251,
        122909385,
        2157517691,
        634681816,
        4142456567,
        3825094682,
        3061402683,
        2540495037,
        79693498,
        3249098678,
        1084186820,
        1583128258,
        426386531,
        1761308591,
        1047286709,
        322548459,
        995290223,
        1845252383,
        2603652396,
        3431023940,
        2942221577,
        3202600964,
        3727903485,
        1712269319,
        422464435,
        3234572375,
        1170764815,
        3523960633,
        3117677531,
        1434042557,
        442511882,
        3600875718,
        1076654713,
        1738483198,
        4213154764,
        2393238008,
        3677496056,
        1014306527,
        4251020053,
        793779912,
        2902807211,
        842905082,
        4246964064,
        1395751752,
        1040244610,
        2656851899,
        3396308128,
        445077038,
        3742853595,
        3577915638,
        679411651,
        2892444358,
        2354009459,
        1767581616,
        3150600392,
        3791627101,
        3102740896,
        284835224,
        4246832056,
        1258075500,
        768725851,
        2589189241,
        3069724005,
        3532540348,
        1274779536,
        3789419226,
        2764799539,
        1660621633,
        3471099624,
        4011903706,
        913787905,
        3497959166,
        737222580,
        2514213453,
        2928710040,
        3937242737,
        1804850592,
        3499020752,
        2949064160,
        2386320175,
        2390070455,
        2415321851,
        4061277028,
        2290661394,
        2416832540,
        1336762016,
        1754252060,
        3520065937,
        3014181293,
        791618072,
        3188594551,
        3933548030,
        2332172193,
        3852520463,
        3043980520,
        413987798,
        3465142937,
        3030929376,
        4245938359,
        2093235073,
        3534596313,
        375366246,
        2157278981,
        2479649556,
        555357303,
        3870105701,
        2008414854,
        3344188149,
        4221384143,
        3956125452,
        2067696032,
        3594591187,
        2921233993,
        2428461,
        544322398,
        577241275,
        1471733935,
        610547355,
        4027169054,
        1432588573,
        1507829418,
        2025931657,
        3646575487,
        545086370,
        48609733,
        2200306550,
        1653985193,
        298326376,
        1316178497,
        3007786442,
        2064951626,
        458293330,
        2589141269,
        3591329599,
        3164325604,
        727753846,
        2179363840,
        146436021,
        1461446943,
        4069977195,
        705550613,
        3059967265,
        3887724982,
        4281599278,
        3313849956,
        1404054877,
        2845806497,
        146425753,
        1854211946,
      ]),
      new Uint32Array([
        1266315497,
        3048417604,
        3681880366,
        3289982499,
        290971e4,
        1235738493,
        2632868024,
        2414719590,
        3970600049,
        1771706367,
        1449415276,
        3266420449,
        422970021,
        1963543593,
        2690192192,
        3826793022,
        1062508698,
        1531092325,
        1804592342,
        2583117782,
        2714934279,
        4024971509,
        1294809318,
        4028980673,
        1289560198,
        2221992742,
        1669523910,
        35572830,
        157838143,
        1052438473,
        1016535060,
        1802137761,
        1753167236,
        1386275462,
        3080475397,
        2857371447,
        1040679964,
        2145300060,
        2390574316,
        1461121720,
        2956646967,
        4031777805,
        4028374788,
        33600511,
        2920084762,
        1018524850,
        629373528,
        3691585981,
        3515945977,
        2091462646,
        2486323059,
        586499841,
        988145025,
        935516892,
        3367335476,
        2599673255,
        2839830854,
        265290510,
        3972581182,
        2759138881,
        3795373465,
        1005194799,
        847297441,
        406762289,
        1314163512,
        1332590856,
        1866599683,
        4127851711,
        750260880,
        613907577,
        1450815602,
        3165620655,
        3734664991,
        3650291728,
        3012275730,
        3704569646,
        1427272223,
        778793252,
        1343938022,
        2676280711,
        2052605720,
        1946737175,
        3164576444,
        3914038668,
        3967478842,
        3682934266,
        1661551462,
        3294938066,
        4011595847,
        840292616,
        3712170807,
        616741398,
        312560963,
        711312465,
        1351876610,
        322626781,
        1910503582,
        271666773,
        2175563734,
        1594956187,
        70604529,
        3617834859,
        1007753275,
        1495573769,
        4069517037,
        2549218298,
        2663038764,
        504708206,
        2263041392,
        3941167025,
        2249088522,
        1514023603,
        1998579484,
        1312622330,
        694541497,
        2582060303,
        2151582166,
        1382467621,
        776784248,
        2618340202,
        3323268794,
        2497899128,
        2784771155,
        503983604,
        4076293799,
        907881277,
        423175695,
        432175456,
        1378068232,
        4145222326,
        3954048622,
        3938656102,
        3820766613,
        2793130115,
        2977904593,
        26017576,
        3274890735,
        3194772133,
        1700274565,
        1756076034,
        4006520079,
        3677328699,
        720338349,
        1533947780,
        354530856,
        688349552,
        3973924725,
        1637815568,
        332179504,
        3949051286,
        53804574,
        2852348879,
        3044236432,
        1282449977,
        3583942155,
        3416972820,
        4006381244,
        1617046695,
        2628476075,
        3002303598,
        1686838959,
        431878346,
        2686675385,
        1700445008,
        1080580658,
        1009431731,
        832498133,
        3223435511,
        2605976345,
        2271191193,
        2516031870,
        1648197032,
        4164389018,
        2548247927,
        300782431,
        375919233,
        238389289,
        3353747414,
        2531188641,
        2019080857,
        1475708069,
        455242339,
        2609103871,
        448939670,
        3451063019,
        1395535956,
        2413381860,
        1841049896,
        1491858159,
        885456874,
        4264095073,
        4001119347,
        1565136089,
        3898914787,
        1108368660,
        540939232,
        1173283510,
        2745871338,
        3681308437,
        4207628240,
        3343053890,
        4016749493,
        1699691293,
        1103962373,
        3625875870,
        2256883143,
        3830138730,
        1031889488,
        3479347698,
        1535977030,
        4236805024,
        3251091107,
        2132092099,
        1774941330,
        1199868427,
        1452454533,
        157007616,
        2904115357,
        342012276,
        595725824,
        1480756522,
        206960106,
        497939518,
        591360097,
        863170706,
        2375253569,
        3596610801,
        1814182875,
        2094937945,
        3421402208,
        1082520231,
        3463918190,
        2785509508,
        435703966,
        3908032597,
        1641649973,
        2842273706,
        3305899714,
        1510255612,
        2148256476,
        2655287854,
        3276092548,
        4258621189,
        236887753,
        3681803219,
        274041037,
        1734335097,
        3815195456,
        3317970021,
        1899903192,
        1026095262,
        4050517792,
        356393447,
        2410691914,
        3873677099,
        3682840055,
      ]),
      new Uint32Array([
        3913112168,
        2491498743,
        4132185628,
        2489919796,
        1091903735,
        1979897079,
        3170134830,
        3567386728,
        3557303409,
        857797738,
        1136121015,
        1342202287,
        507115054,
        2535736646,
        337727348,
        3213592640,
        1301675037,
        2528481711,
        1895095763,
        1721773893,
        3216771564,
        62756741,
        2142006736,
        835421444,
        2531993523,
        1442658625,
        3659876326,
        2882144922,
        676362277,
        1392781812,
        170690266,
        3921047035,
        1759253602,
        3611846912,
        1745797284,
        664899054,
        1329594018,
        3901205900,
        3045908486,
        2062866102,
        2865634940,
        3543621612,
        3464012697,
        1080764994,
        553557557,
        3656615353,
        3996768171,
        991055499,
        499776247,
        1265440854,
        648242737,
        3940784050,
        980351604,
        3713745714,
        1749149687,
        3396870395,
        4211799374,
        3640570775,
        1161844396,
        3125318951,
        1431517754,
        545492359,
        4268468663,
        3499529547,
        1437099964,
        2702547544,
        3433638243,
        2581715763,
        2787789398,
        1060185593,
        1593081372,
        2418618748,
        4260947970,
        69676912,
        2159744348,
        86519011,
        2512459080,
        3838209314,
        1220612927,
        3339683548,
        133810670,
        1090789135,
        1078426020,
        1569222167,
        845107691,
        3583754449,
        4072456591,
        1091646820,
        628848692,
        1613405280,
        3757631651,
        526609435,
        236106946,
        48312990,
        2942717905,
        3402727701,
        1797494240,
        859738849,
        992217954,
        4005476642,
        2243076622,
        3870952857,
        3732016268,
        765654824,
        3490871365,
        2511836413,
        1685915746,
        3888969200,
        1414112111,
        2273134842,
        3281911079,
        4080962846,
        172450625,
        2569994100,
        980381355,
        4109958455,
        2819808352,
        2716589560,
        2568741196,
        3681446669,
        3329971472,
        1835478071,
        660984891,
        3704678404,
        4045999559,
        3422617507,
        3040415634,
        1762651403,
        1719377915,
        3470491036,
        2693910283,
        3642056355,
        3138596744,
        1364962596,
        2073328063,
        1983633131,
        926494387,
        3423689081,
        2150032023,
        4096667949,
        1749200295,
        3328846651,
        309677260,
        2016342300,
        1779581495,
        3079819751,
        111262694,
        1274766160,
        443224088,
        298511866,
        1025883608,
        3806446537,
        1145181785,
        168956806,
        3641502830,
        3584813610,
        1689216846,
        3666258015,
        3200248200,
        1692713982,
        2646376535,
        4042768518,
        1618508792,
        1610833997,
        3523052358,
        4130873264,
        2001055236,
        3610705100,
        2202168115,
        4028541809,
        2961195399,
        1006657119,
        2006996926,
        3186142756,
        1430667929,
        3210227297,
        1314452623,
        4074634658,
        4101304120,
        2273951170,
        1399257539,
        3367210612,
        3027628629,
        1190975929,
        2062231137,
        2333990788,
        2221543033,
        2438960610,
        1181637006,
        548689776,
        2362791313,
        3372408396,
        3104550113,
        3145860560,
        296247880,
        1970579870,
        3078560182,
        3769228297,
        1714227617,
        3291629107,
        3898220290,
        166772364,
        1251581989,
        493813264,
        448347421,
        195405023,
        2709975567,
        677966185,
        3703036547,
        1463355134,
        2715995803,
        1338867538,
        1343315457,
        2802222074,
        2684532164,
        233230375,
        2599980071,
        2000651841,
        3277868038,
        1638401717,
        4028070440,
        3237316320,
        6314154,
        819756386,
        300326615,
        590932579,
        1405279636,
        3267499572,
        3150704214,
        2428286686,
        3959192993,
        3461946742,
        1862657033,
        1266418056,
        963775037,
        2089974820,
        2263052895,
        1917689273,
        448879540,
        3550394620,
        3981727096,
        150775221,
        3627908307,
        1303187396,
        508620638,
        2975983352,
        2726630617,
        1817252668,
        1876281319,
        1457606340,
        908771278,
        3720792119,
        3617206836,
        2455994898,
        1729034894,
        1080033504,
      ]),
      new Uint32Array([
        976866871,
        3556439503,
        2881648439,
        1522871579,
        1555064734,
        1336096578,
        3548522304,
        2579274686,
        3574697629,
        3205460757,
        3593280638,
        3338716283,
        3079412587,
        564236357,
        2993598910,
        1781952180,
        1464380207,
        3163844217,
        3332601554,
        1699332808,
        1393555694,
        1183702653,
        3581086237,
        1288719814,
        691649499,
        2847557200,
        2895455976,
        3193889540,
        2717570544,
        1781354906,
        1676643554,
        2592534050,
        3230253752,
        1126444790,
        2770207658,
        2633158820,
        2210423226,
        2615765581,
        2414155088,
        3127139286,
        673620729,
        2805611233,
        1269405062,
        4015350505,
        3341807571,
        4149409754,
        1057255273,
        2012875353,
        2162469141,
        2276492801,
        2601117357,
        993977747,
        3918593370,
        2654263191,
        753973209,
        36408145,
        2530585658,
        25011837,
        3520020182,
        2088578344,
        530523599,
        2918365339,
        1524020338,
        1518925132,
        3760827505,
        3759777254,
        1202760957,
        3985898139,
        3906192525,
        674977740,
        4174734889,
        2031300136,
        2019492241,
        3983892565,
        4153806404,
        3822280332,
        352677332,
        2297720250,
        60907813,
        90501309,
        3286998549,
        1016092578,
        2535922412,
        2839152426,
        457141659,
        509813237,
        4120667899,
        652014361,
        1966332200,
        2975202805,
        55981186,
        2327461051,
        676427537,
        3255491064,
        2882294119,
        3433927263,
        1307055953,
        942726286,
        933058658,
        2468411793,
        3933900994,
        4215176142,
        1361170020,
        2001714738,
        2830558078,
        3274259782,
        1222529897,
        1679025792,
        2729314320,
        3714953764,
        1770335741,
        151462246,
        3013232138,
        1682292957,
        1483529935,
        471910574,
        1539241949,
        458788160,
        3436315007,
        1807016891,
        3718408830,
        978976581,
        1043663428,
        3165965781,
        1927990952,
        4200891579,
        2372276910,
        3208408903,
        3533431907,
        1412390302,
        2931980059,
        4132332400,
        1947078029,
        3881505623,
        4168226417,
        2941484381,
        1077988104,
        1320477388,
        886195818,
        18198404,
        3786409e3,
        2509781533,
        112762804,
        3463356488,
        1866414978,
        891333506,
        18488651,
        661792760,
        1628790961,
        3885187036,
        3141171499,
        876946877,
        2693282273,
        1372485963,
        791857591,
        2686433993,
        3759982718,
        3167212022,
        3472953795,
        2716379847,
        445679433,
        3561995674,
        3504004811,
        3574258232,
        54117162,
        3331405415,
        2381918588,
        3769707343,
        4154350007,
        1140177722,
        4074052095,
        668550556,
        3214352940,
        367459370,
        261225585,
        2610173221,
        4209349473,
        3468074219,
        3265815641,
        314222801,
        3066103646,
        3808782860,
        282218597,
        3406013506,
        3773591054,
        379116347,
        1285071038,
        846784868,
        2669647154,
        3771962079,
        3550491691,
        2305946142,
        453669953,
        1268987020,
        3317592352,
        3279303384,
        3744833421,
        2610507566,
        3859509063,
        266596637,
        3847019092,
        517658769,
        3462560207,
        3443424879,
        370717030,
        4247526661,
        2224018117,
        4143653529,
        4112773975,
        2788324899,
        2477274417,
        1456262402,
        2901442914,
        1517677493,
        1846949527,
        2295493580,
        3734397586,
        2176403920,
        1280348187,
        1908823572,
        3871786941,
        846861322,
        1172426758,
        3287448474,
        3383383037,
        1655181056,
        3139813346,
        901632758,
        1897031941,
        2986607138,
        3066810236,
        3447102507,
        1393639104,
        373351379,
        950779232,
        625454576,
        3124240540,
        4148612726,
        2007998917,
        544563296,
        2244738638,
        2330496472,
        2058025392,
        1291430526,
        424198748,
        50039436,
        29584100,
        3605783033,
        2429876329,
        2791104160,
        1057563949,
        3255363231,
        3075367218,
        3463963227,
        1469046755,
        985887462,
      ]),
    ];
    this.P = new Uint32Array([
      608135816,
      2242054355,
      320440878,
      57701188,
      2752067618,
      698298832,
      137296536,
      3964562569,
      1160258022,
      953160567,
      3193202383,
      887688300,
      3232508343,
      3380367581,
      1065670069,
      3041331479,
      2450970073,
      2306472731,
    ]);
  };
  function F(S, x8, i) {
    return (
      ((S[0][x8[i + 3]] + S[1][x8[i + 2]]) ^ S[2][x8[i + 1]]) + S[3][x8[i]]
    );
  }
  Blowfish.prototype.encipher = function (x, x8) {
    if (x8 === void 0) {
      x8 = new Uint8Array(x.buffer);
      if (x.byteOffset !== 0) x8 = x8.subarray(x.byteOffset);
    }
    x[0] ^= this.P[0];
    for (var i = 1; i < 16; i += 2) {
      x[1] ^= F(this.S, x8, 0) ^ this.P[i];
      x[0] ^= F(this.S, x8, 4) ^ this.P[i + 1];
    }
    var t = x[0];
    x[0] = x[1] ^ this.P[17];
    x[1] = t;
  };
  Blowfish.prototype.decipher = function (x) {
    var x8 = new Uint8Array(x.buffer);
    if (x.byteOffset !== 0) x8 = x8.subarray(x.byteOffset);
    x[0] ^= this.P[17];
    for (var i = 16; i > 0; i -= 2) {
      x[1] ^= F(this.S, x8, 0) ^ this.P[i];
      x[0] ^= F(this.S, x8, 4) ^ this.P[i - 1];
    }
    var t = x[0];
    x[0] = x[1] ^ this.P[0];
    x[1] = t;
  };
  function stream2word(data, databytes) {
    var i,
      temp = 0;
    for (i = 0; i < 4; i++, BLF_J++) {
      if (BLF_J >= databytes) BLF_J = 0;
      temp = (temp << 8) | data[BLF_J];
    }
    return temp;
  }
  Blowfish.prototype.expand0state = function (key, keybytes) {
    var d = new Uint32Array(2),
      i,
      k;
    var d8 = new Uint8Array(d.buffer);
    for (i = 0, BLF_J = 0; i < 18; i++) {
      this.P[i] ^= stream2word(key, keybytes);
    }
    BLF_J = 0;
    for (i = 0; i < 18; i += 2) {
      this.encipher(d, d8);
      this.P[i] = d[0];
      this.P[i + 1] = d[1];
    }
    for (i = 0; i < 4; i++) {
      for (k = 0; k < 256; k += 2) {
        this.encipher(d, d8);
        this.S[i][k] = d[0];
        this.S[i][k + 1] = d[1];
      }
    }
  };
  Blowfish.prototype.expandstate = function (data, databytes, key, keybytes) {
    var d = new Uint32Array(2),
      i,
      k;
    for (i = 0, BLF_J = 0; i < 18; i++) {
      this.P[i] ^= stream2word(key, keybytes);
    }
    for (i = 0, BLF_J = 0; i < 18; i += 2) {
      d[0] ^= stream2word(data, databytes);
      d[1] ^= stream2word(data, databytes);
      this.encipher(d);
      this.P[i] = d[0];
      this.P[i + 1] = d[1];
    }
    for (i = 0; i < 4; i++) {
      for (k = 0; k < 256; k += 2) {
        d[0] ^= stream2word(data, databytes);
        d[1] ^= stream2word(data, databytes);
        this.encipher(d);
        this.S[i][k] = d[0];
        this.S[i][k + 1] = d[1];
      }
    }
    BLF_J = 0;
  };
  Blowfish.prototype.enc = function (data, blocks) {
    for (var i = 0; i < blocks; i++) {
      this.encipher(data.subarray(i * 2));
    }
  };
  Blowfish.prototype.dec = function (data, blocks) {
    for (var i = 0; i < blocks; i++) {
      this.decipher(data.subarray(i * 2));
    }
  };
  var BCRYPT_BLOCKS = 8;
  var BCRYPT_HASHSIZE = 32;
  function bcrypt_hash(sha2pass, sha2salt, out) {
    var state = new Blowfish(),
      cdata = new Uint32Array(BCRYPT_BLOCKS),
      i,
      ciphertext = new Uint8Array([
        79,
        120,
        121,
        99,
        104,
        114,
        111,
        109,
        97,
        116,
        105,
        99,
        66,
        108,
        111,
        119,
        102,
        105,
        115,
        104,
        83,
        119,
        97,
        116,
        68,
        121,
        110,
        97,
        109,
        105,
        116,
        101,
      ]);
    state.expandstate(sha2salt, 64, sha2pass, 64);
    for (i = 0; i < 64; i++) {
      state.expand0state(sha2salt, 64);
      state.expand0state(sha2pass, 64);
    }
    for (i = 0; i < BCRYPT_BLOCKS; i++)
      cdata[i] = stream2word(ciphertext, ciphertext.byteLength);
    for (i = 0; i < 64; i++) state.enc(cdata, cdata.byteLength / 8);
    for (i = 0; i < BCRYPT_BLOCKS; i++) {
      out[4 * i + 3] = cdata[i] >>> 24;
      out[4 * i + 2] = cdata[i] >>> 16;
      out[4 * i + 1] = cdata[i] >>> 8;
      out[4 * i + 0] = cdata[i];
    }
  }
  function bcrypt_pbkdf(pass, passlen, salt, saltlen, key, keylen, rounds) {
    var sha2pass = new Uint8Array(64),
      sha2salt = new Uint8Array(64),
      out = new Uint8Array(BCRYPT_HASHSIZE),
      tmpout = new Uint8Array(BCRYPT_HASHSIZE),
      countsalt = new Uint8Array(saltlen + 4),
      i,
      j,
      amt,
      stride,
      dest,
      count,
      origkeylen = keylen;
    if (rounds < 1) return -1;
    if (
      passlen === 0 ||
      saltlen === 0 ||
      keylen === 0 ||
      keylen > out.byteLength * out.byteLength ||
      saltlen > 1 << 20
    )
      return -1;
    stride = Math.floor((keylen + out.byteLength - 1) / out.byteLength);
    amt = Math.floor((keylen + stride - 1) / stride);
    for (i = 0; i < saltlen; i++) countsalt[i] = salt[i];
    crypto_hash_sha512(sha2pass, pass, passlen);
    for (count = 1; keylen > 0; count++) {
      countsalt[saltlen + 0] = count >>> 24;
      countsalt[saltlen + 1] = count >>> 16;
      countsalt[saltlen + 2] = count >>> 8;
      countsalt[saltlen + 3] = count;
      crypto_hash_sha512(sha2salt, countsalt, saltlen + 4);
      bcrypt_hash(sha2pass, sha2salt, tmpout);
      for (i = out.byteLength; i--; ) out[i] = tmpout[i];
      for (i = 1; i < rounds; i++) {
        crypto_hash_sha512(sha2salt, tmpout, tmpout.byteLength);
        bcrypt_hash(sha2pass, sha2salt, tmpout);
        for (j = 0; j < out.byteLength; j++) out[j] ^= tmpout[j];
      }
      amt = Math.min(amt, keylen);
      for (i = 0; i < amt; i++) {
        dest = i * stride + (count - 1);
        if (dest >= origkeylen) break;
        key[dest] = out[i];
      }
      keylen -= i;
    }
    return 0;
  }
  module2.exports = {
    BLOCKS: BCRYPT_BLOCKS,
    HASHSIZE: BCRYPT_HASHSIZE,
    hash: bcrypt_hash,
    pbkdf: bcrypt_pbkdf,
  };
});

// node_modules/sshpk/lib/formats/ssh-private.js
var require_ssh_private = __commonJS((exports2, module2) => {
  module2.exports = {
    read,
    readSSHPrivate,
    write,
  };
  var assert = require_assert();
  var asn1 = require_lib();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var utils = require_utils4();
  var crypto = require('crypto');
  var Key = require_key();
  var PrivateKey = require_private_key();
  var pem = require_pem();
  var rfc4253 = require_rfc4253();
  var SSHBuffer = require_ssh_buffer();
  var errors = require_errors();
  var bcrypt;
  function read(buf, options) {
    return pem.read(buf, options);
  }
  var MAGIC = 'openssh-key-v1';
  function readSSHPrivate(type, buf, options) {
    buf = new SSHBuffer({ buffer: buf });
    var magic = buf.readCString();
    assert.strictEqual(magic, MAGIC, 'bad magic string');
    var cipher = buf.readString();
    var kdf = buf.readString();
    var kdfOpts = buf.readBuffer();
    var nkeys = buf.readInt();
    if (nkeys !== 1) {
      throw new Error(
        'OpenSSH-format key file contains multiple keys: this is unsupported.',
      );
    }
    var pubKey = buf.readBuffer();
    if (type === 'public') {
      assert.ok(buf.atEnd(), 'excess bytes left after key');
      return rfc4253.read(pubKey);
    }
    var privKeyBlob = buf.readBuffer();
    assert.ok(buf.atEnd(), 'excess bytes left after key');
    var kdfOptsBuf = new SSHBuffer({ buffer: kdfOpts });
    switch (kdf) {
      case 'none':
        if (cipher !== 'none') {
          throw new Error(
            'OpenSSH-format key uses KDF "none" but specifies a cipher other than "none"',
          );
        }
        break;
      case 'bcrypt':
        var salt = kdfOptsBuf.readBuffer();
        var rounds = kdfOptsBuf.readInt();
        var cinf = utils.opensshCipherInfo(cipher);
        if (bcrypt === void 0) {
          bcrypt = require_bcrypt_pbkdf();
        }
        if (typeof options.passphrase === 'string') {
          options.passphrase = Buffer2.from(options.passphrase, 'utf-8');
        }
        if (!Buffer2.isBuffer(options.passphrase)) {
          throw new errors.KeyEncryptedError(options.filename, 'OpenSSH');
        }
        var pass = new Uint8Array(options.passphrase);
        var salti = new Uint8Array(salt);
        var out = new Uint8Array(cinf.keySize + cinf.blockSize);
        var res = bcrypt.pbkdf(
          pass,
          pass.length,
          salti,
          salti.length,
          out,
          out.length,
          rounds,
        );
        if (res !== 0) {
          throw new Error(
            'bcrypt_pbkdf function returned failure, parameters invalid',
          );
        }
        out = Buffer2.from(out);
        var ckey = out.slice(0, cinf.keySize);
        var iv = out.slice(cinf.keySize, cinf.keySize + cinf.blockSize);
        var cipherStream = crypto.createDecipheriv(cinf.opensslName, ckey, iv);
        cipherStream.setAutoPadding(false);
        var chunk,
          chunks = [];
        cipherStream.once('error', function (e) {
          if (e.toString().indexOf('bad decrypt') !== -1) {
            throw new Error(
              'Incorrect passphrase supplied, could not decrypt key',
            );
          }
          throw e;
        });
        cipherStream.write(privKeyBlob);
        cipherStream.end();
        while ((chunk = cipherStream.read()) !== null) chunks.push(chunk);
        privKeyBlob = Buffer2.concat(chunks);
        break;
      default:
        throw new Error('OpenSSH-format key uses unknown KDF "' + kdf + '"');
    }
    buf = new SSHBuffer({ buffer: privKeyBlob });
    var checkInt1 = buf.readInt();
    var checkInt2 = buf.readInt();
    if (checkInt1 !== checkInt2) {
      throw new Error('Incorrect passphrase supplied, could not decrypt key');
    }
    var ret = {};
    var key = rfc4253.readInternal(ret, 'private', buf.remainder());
    buf.skip(ret.consumed);
    var comment = buf.readString();
    key.comment = comment;
    return key;
  }
  function write(key, options) {
    var pubKey;
    if (PrivateKey.isPrivateKey(key)) pubKey = key.toPublic();
    else pubKey = key;
    var cipher = 'none';
    var kdf = 'none';
    var kdfopts = Buffer2.alloc(0);
    var cinf = { blockSize: 8 };
    var passphrase;
    if (options !== void 0) {
      passphrase = options.passphrase;
      if (typeof passphrase === 'string')
        passphrase = Buffer2.from(passphrase, 'utf-8');
      if (passphrase !== void 0) {
        assert.buffer(passphrase, 'options.passphrase');
        assert.optionalString(options.cipher, 'options.cipher');
        cipher = options.cipher;
        if (cipher === void 0) cipher = 'aes128-ctr';
        cinf = utils.opensshCipherInfo(cipher);
        kdf = 'bcrypt';
      }
    }
    var privBuf;
    if (PrivateKey.isPrivateKey(key)) {
      privBuf = new SSHBuffer({});
      var checkInt = crypto.randomBytes(4).readUInt32BE(0);
      privBuf.writeInt(checkInt);
      privBuf.writeInt(checkInt);
      privBuf.write(key.toBuffer('rfc4253'));
      privBuf.writeString(key.comment || '');
      var n = 1;
      while (privBuf._offset % cinf.blockSize !== 0) privBuf.writeChar(n++);
      privBuf = privBuf.toBuffer();
    }
    switch (kdf) {
      case 'none':
        break;
      case 'bcrypt':
        var salt = crypto.randomBytes(16);
        var rounds = 16;
        var kdfssh = new SSHBuffer({});
        kdfssh.writeBuffer(salt);
        kdfssh.writeInt(rounds);
        kdfopts = kdfssh.toBuffer();
        if (bcrypt === void 0) {
          bcrypt = require_bcrypt_pbkdf();
        }
        var pass = new Uint8Array(passphrase);
        var salti = new Uint8Array(salt);
        var out = new Uint8Array(cinf.keySize + cinf.blockSize);
        var res = bcrypt.pbkdf(
          pass,
          pass.length,
          salti,
          salti.length,
          out,
          out.length,
          rounds,
        );
        if (res !== 0) {
          throw new Error(
            'bcrypt_pbkdf function returned failure, parameters invalid',
          );
        }
        out = Buffer2.from(out);
        var ckey = out.slice(0, cinf.keySize);
        var iv = out.slice(cinf.keySize, cinf.keySize + cinf.blockSize);
        var cipherStream = crypto.createCipheriv(cinf.opensslName, ckey, iv);
        cipherStream.setAutoPadding(false);
        var chunk,
          chunks = [];
        cipherStream.once('error', function (e) {
          throw e;
        });
        cipherStream.write(privBuf);
        cipherStream.end();
        while ((chunk = cipherStream.read()) !== null) chunks.push(chunk);
        privBuf = Buffer2.concat(chunks);
        break;
      default:
        throw new Error('Unsupported kdf ' + kdf);
    }
    var buf = new SSHBuffer({});
    buf.writeCString(MAGIC);
    buf.writeString(cipher);
    buf.writeString(kdf);
    buf.writeBuffer(kdfopts);
    buf.writeInt(1);
    buf.writeBuffer(pubKey.toBuffer('rfc4253'));
    if (privBuf) buf.writeBuffer(privBuf);
    buf = buf.toBuffer();
    var header;
    if (PrivateKey.isPrivateKey(key)) header = 'OPENSSH PRIVATE KEY';
    else header = 'OPENSSH PUBLIC KEY';
    var tmp = buf.toString('base64');
    var len = tmp.length + tmp.length / 70 + 18 + 16 + header.length * 2 + 10;
    buf = Buffer2.alloc(len);
    var o = 0;
    o += buf.write('-----BEGIN ' + header + '-----\n', o);
    for (var i = 0; i < tmp.length; ) {
      var limit = i + 70;
      if (limit > tmp.length) limit = tmp.length;
      o += buf.write(tmp.slice(i, limit), o);
      buf[o++] = 10;
      i = limit;
    }
    o += buf.write('-----END ' + header + '-----\n', o);
    return buf.slice(0, o);
  }
});

// node_modules/sshpk/lib/formats/pem.js
var require_pem = __commonJS((exports2, module2) => {
  module2.exports = {
    read,
    write,
  };
  var assert = require_assert();
  var asn1 = require_lib();
  var crypto = require('crypto');
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var utils = require_utils4();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var pkcs1 = require_pkcs1();
  var pkcs8 = require_pkcs8();
  var sshpriv = require_ssh_private();
  var rfc4253 = require_rfc4253();
  var errors = require_errors();
  var OID_PBES2 = '1.2.840.113549.1.5.13';
  var OID_PBKDF2 = '1.2.840.113549.1.5.12';
  var OID_TO_CIPHER = {
    '1.2.840.113549.3.7': '3des-cbc',
    '2.16.840.1.101.3.4.1.2': 'aes128-cbc',
    '2.16.840.1.101.3.4.1.42': 'aes256-cbc',
  };
  var CIPHER_TO_OID = {};
  Object.keys(OID_TO_CIPHER).forEach(function (k) {
    CIPHER_TO_OID[OID_TO_CIPHER[k]] = k;
  });
  var OID_TO_HASH = {
    '1.2.840.113549.2.7': 'sha1',
    '1.2.840.113549.2.9': 'sha256',
    '1.2.840.113549.2.11': 'sha512',
  };
  var HASH_TO_OID = {};
  Object.keys(OID_TO_HASH).forEach(function (k) {
    HASH_TO_OID[OID_TO_HASH[k]] = k;
  });
  function read(buf, options, forceType) {
    var input = buf;
    if (typeof buf !== 'string') {
      assert.buffer(buf, 'buf');
      buf = buf.toString('ascii');
    }
    var lines = buf.trim().split(/[\r\n]+/g);
    var m;
    var si = -1;
    while (!m && si < lines.length) {
      m = lines[++si].match(
        /[-]+[ ]*BEGIN ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/,
      );
    }
    assert.ok(m, 'invalid PEM header');
    var m2;
    var ei = lines.length;
    while (!m2 && ei > 0) {
      m2 = lines[--ei].match(
        /[-]+[ ]*END ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/,
      );
    }
    assert.ok(m2, 'invalid PEM footer');
    assert.equal(m[2], m2[2]);
    var type = m[2].toLowerCase();
    var alg;
    if (m[1]) {
      assert.equal(m[1], m2[1], 'PEM header and footer mismatch');
      alg = m[1].trim();
    }
    lines = lines.slice(si, ei + 1);
    var headers = {};
    while (true) {
      lines = lines.slice(1);
      m = lines[0].match(/^([A-Za-z0-9-]+): (.+)$/);
      if (!m) break;
      headers[m[1].toLowerCase()] = m[2];
    }
    lines = lines.slice(0, -1).join('');
    buf = Buffer2.from(lines, 'base64');
    var cipher, key, iv;
    if (headers['proc-type']) {
      var parts = headers['proc-type'].split(',');
      if (parts[0] === '4' && parts[1] === 'ENCRYPTED') {
        if (typeof options.passphrase === 'string') {
          options.passphrase = Buffer2.from(options.passphrase, 'utf-8');
        }
        if (!Buffer2.isBuffer(options.passphrase)) {
          throw new errors.KeyEncryptedError(options.filename, 'PEM');
        } else {
          parts = headers['dek-info'].split(',');
          assert.ok(parts.length === 2);
          cipher = parts[0].toLowerCase();
          iv = Buffer2.from(parts[1], 'hex');
          key = utils.opensslKeyDeriv(cipher, iv, options.passphrase, 1).key;
        }
      }
    }
    if (alg && alg.toLowerCase() === 'encrypted') {
      var eder = new asn1.BerReader(buf);
      var pbesEnd;
      eder.readSequence();
      eder.readSequence();
      pbesEnd = eder.offset + eder.length;
      var method = eder.readOID();
      if (method !== OID_PBES2) {
        throw new Error('Unsupported PEM/PKCS8 encryption scheme: ' + method);
      }
      eder.readSequence();
      eder.readSequence();
      var kdfEnd = eder.offset + eder.length;
      var kdfOid = eder.readOID();
      if (kdfOid !== OID_PBKDF2)
        throw new Error('Unsupported PBES2 KDF: ' + kdfOid);
      eder.readSequence();
      var salt = eder.readString(asn1.Ber.OctetString, true);
      var iterations = eder.readInt();
      var hashAlg = 'sha1';
      if (eder.offset < kdfEnd) {
        eder.readSequence();
        var hashAlgOid = eder.readOID();
        hashAlg = OID_TO_HASH[hashAlgOid];
        if (hashAlg === void 0) {
          throw new Error('Unsupported PBKDF2 hash: ' + hashAlgOid);
        }
      }
      eder._offset = kdfEnd;
      eder.readSequence();
      var cipherOid = eder.readOID();
      cipher = OID_TO_CIPHER[cipherOid];
      if (cipher === void 0) {
        throw new Error('Unsupported PBES2 cipher: ' + cipherOid);
      }
      iv = eder.readString(asn1.Ber.OctetString, true);
      eder._offset = pbesEnd;
      buf = eder.readString(asn1.Ber.OctetString, true);
      if (typeof options.passphrase === 'string') {
        options.passphrase = Buffer2.from(options.passphrase, 'utf-8');
      }
      if (!Buffer2.isBuffer(options.passphrase)) {
        throw new errors.KeyEncryptedError(options.filename, 'PEM');
      }
      var cinfo = utils.opensshCipherInfo(cipher);
      cipher = cinfo.opensslName;
      key = utils.pbkdf2(
        hashAlg,
        salt,
        iterations,
        cinfo.keySize,
        options.passphrase,
      );
      alg = void 0;
    }
    if (cipher && key && iv) {
      var cipherStream = crypto.createDecipheriv(cipher, key, iv);
      var chunk,
        chunks = [];
      cipherStream.once('error', function (e) {
        if (e.toString().indexOf('bad decrypt') !== -1) {
          throw new Error(
            'Incorrect passphrase supplied, could not decrypt key',
          );
        }
        throw e;
      });
      cipherStream.write(buf);
      cipherStream.end();
      while ((chunk = cipherStream.read()) !== null) chunks.push(chunk);
      buf = Buffer2.concat(chunks);
    }
    if (alg && alg.toLowerCase() === 'openssh')
      return sshpriv.readSSHPrivate(type, buf, options);
    if (alg && alg.toLowerCase() === 'ssh2')
      return rfc4253.readType(type, buf, options);
    var der = new asn1.BerReader(buf);
    der.originalInput = input;
    der.readSequence();
    if (alg) {
      if (forceType) assert.strictEqual(forceType, 'pkcs1');
      return pkcs1.readPkcs1(alg, type, der);
    } else {
      if (forceType) assert.strictEqual(forceType, 'pkcs8');
      return pkcs8.readPkcs8(alg, type, der);
    }
  }
  function write(key, options, type) {
    assert.object(key);
    var alg = {
      ecdsa: 'EC',
      rsa: 'RSA',
      dsa: 'DSA',
      ed25519: 'EdDSA',
    }[key.type];
    var header;
    var der = new asn1.BerWriter();
    if (PrivateKey.isPrivateKey(key)) {
      if (type && type === 'pkcs8') {
        header = 'PRIVATE KEY';
        pkcs8.writePkcs8(der, key);
      } else {
        if (type) assert.strictEqual(type, 'pkcs1');
        header = alg + ' PRIVATE KEY';
        pkcs1.writePkcs1(der, key);
      }
    } else if (Key.isKey(key)) {
      if (type && type === 'pkcs1') {
        header = alg + ' PUBLIC KEY';
        pkcs1.writePkcs1(der, key);
      } else {
        if (type) assert.strictEqual(type, 'pkcs8');
        header = 'PUBLIC KEY';
        pkcs8.writePkcs8(der, key);
      }
    } else {
      throw new Error('key is not a Key or PrivateKey');
    }
    var tmp = der.buffer.toString('base64');
    var len = tmp.length + tmp.length / 64 + 18 + 16 + header.length * 2 + 10;
    var buf = Buffer2.alloc(len);
    var o = 0;
    o += buf.write('-----BEGIN ' + header + '-----\n', o);
    for (var i = 0; i < tmp.length; ) {
      var limit = i + 64;
      if (limit > tmp.length) limit = tmp.length;
      o += buf.write(tmp.slice(i, limit), o);
      buf[o++] = 10;
      i = limit;
    }
    o += buf.write('-----END ' + header + '-----\n', o);
    return buf.slice(0, o);
  }
});

// node_modules/sshpk/lib/formats/ssh.js
var require_ssh = __commonJS((exports2, module2) => {
  module2.exports = {
    read,
    write,
  };
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var rfc4253 = require_rfc4253();
  var utils = require_utils4();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var sshpriv = require_ssh_private();
  var SSHKEY_RE = /^([a-z0-9-]+)[ \t]+([a-zA-Z0-9+\/]+[=]*)([ \t]+([^ \t][^\n]*[\n]*)?)?$/;
  var SSHKEY_RE2 = /^([a-z0-9-]+)[ \t\n]+([a-zA-Z0-9+\/][a-zA-Z0-9+\/ \t\n=]*)([^a-zA-Z0-9+\/ \t\n=].*)?$/;
  function read(buf, options) {
    if (typeof buf !== 'string') {
      assert.buffer(buf, 'buf');
      buf = buf.toString('ascii');
    }
    var trimmed = buf.trim().replace(/[\\\r]/g, '');
    var m = trimmed.match(SSHKEY_RE);
    if (!m) m = trimmed.match(SSHKEY_RE2);
    assert.ok(m, 'key must match regex');
    var type = rfc4253.algToKeyType(m[1]);
    var kbuf = Buffer2.from(m[2], 'base64');
    var key;
    var ret = {};
    if (m[4]) {
      try {
        key = rfc4253.read(kbuf);
      } catch (e) {
        m = trimmed.match(SSHKEY_RE2);
        assert.ok(m, 'key must match regex');
        kbuf = Buffer2.from(m[2], 'base64');
        key = rfc4253.readInternal(ret, 'public', kbuf);
      }
    } else {
      key = rfc4253.readInternal(ret, 'public', kbuf);
    }
    assert.strictEqual(type, key.type);
    if (m[4] && m[4].length > 0) {
      key.comment = m[4];
    } else if (ret.consumed) {
      var data = m[2] + (m[3] ? m[3] : '');
      var realOffset = Math.ceil(ret.consumed / 3) * 4;
      data =
        data.slice(0, realOffset - 2).replace(/[^a-zA-Z0-9+\/=]/g, '') +
        data.slice(realOffset - 2);
      var padding = ret.consumed % 3;
      if (padding > 0 && data.slice(realOffset - 1, realOffset) !== '=')
        realOffset--;
      while (data.slice(realOffset, realOffset + 1) === '=') realOffset++;
      var trailer = data.slice(realOffset);
      trailer = trailer.replace(/[\r\n]/g, ' ').replace(/^\s+/, '');
      if (trailer.match(/^[a-zA-Z0-9]/)) key.comment = trailer;
    }
    return key;
  }
  function write(key, options) {
    assert.object(key);
    if (!Key.isKey(key)) throw new Error('Must be a public key');
    var parts = [];
    var alg = rfc4253.keyTypeToAlg(key);
    parts.push(alg);
    var buf = rfc4253.write(key);
    parts.push(buf.toString('base64'));
    if (key.comment) parts.push(key.comment);
    return Buffer2.from(parts.join(' '));
  }
});

// node_modules/sshpk/lib/formats/dnssec.js
var require_dnssec = __commonJS((exports2, module2) => {
  module2.exports = {
    read,
    write,
  };
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var Key = require_key();
  var PrivateKey = require_private_key();
  var utils = require_utils4();
  var SSHBuffer = require_ssh_buffer();
  var Dhe = require_dhe();
  var supportedAlgos = {
    'rsa-sha1': 5,
    'rsa-sha256': 8,
    'rsa-sha512': 10,
    'ecdsa-p256-sha256': 13,
    'ecdsa-p384-sha384': 14,
  };
  var supportedAlgosById = {};
  Object.keys(supportedAlgos).forEach(function (k) {
    supportedAlgosById[supportedAlgos[k]] = k.toUpperCase();
  });
  function read(buf, options) {
    if (typeof buf !== 'string') {
      assert.buffer(buf, 'buf');
      buf = buf.toString('ascii');
    }
    var lines = buf.split('\n');
    if (lines[0].match(/^Private-key-format\: v1/)) {
      var algElems = lines[1].split(' ');
      var algoNum = parseInt(algElems[1], 10);
      var algoName = algElems[2];
      if (!supportedAlgosById[algoNum])
        throw new Error('Unsupported algorithm: ' + algoName);
      return readDNSSECPrivateKey(algoNum, lines.slice(2));
    }
    var line = 0;
    while (lines[line].match(/^\;/)) line++;
    if (
      (lines[line].match(/\. IN KEY /) || lines[line].match(/\. IN DNSKEY /)) &&
      lines[line + 1].length === 0
    ) {
      return readRFC3110(lines[line]);
    }
    throw new Error('Cannot parse dnssec key');
  }
  function readRFC3110(keyString) {
    var elems = keyString.split(' ');
    var algorithm = parseInt(elems[5], 10);
    if (!supportedAlgosById[algorithm])
      throw new Error('Unsupported algorithm: ' + algorithm);
    var base64key = elems.slice(6, elems.length).join();
    var keyBuffer = Buffer2.from(base64key, 'base64');
    if (supportedAlgosById[algorithm].match(/^RSA-/)) {
      var publicExponentLen = keyBuffer.readUInt8(0);
      if (publicExponentLen != 3 && publicExponentLen != 1)
        throw new Error('Cannot parse dnssec key: unsupported exponent length');
      var publicExponent = keyBuffer.slice(1, publicExponentLen + 1);
      publicExponent = utils.mpNormalize(publicExponent);
      var modulus = keyBuffer.slice(1 + publicExponentLen);
      modulus = utils.mpNormalize(modulus);
      var rsaKey = {
        type: 'rsa',
        parts: [],
      };
      rsaKey.parts.push({ name: 'e', data: publicExponent });
      rsaKey.parts.push({ name: 'n', data: modulus });
      return new Key(rsaKey);
    }
    if (
      supportedAlgosById[algorithm] === 'ECDSA-P384-SHA384' ||
      supportedAlgosById[algorithm] === 'ECDSA-P256-SHA256'
    ) {
      var curve = 'nistp384';
      var size = 384;
      if (supportedAlgosById[algorithm].match(/^ECDSA-P256-SHA256/)) {
        curve = 'nistp256';
        size = 256;
      }
      var ecdsaKey = {
        type: 'ecdsa',
        curve,
        size,
        parts: [
          { name: 'curve', data: Buffer2.from(curve) },
          { name: 'Q', data: utils.ecNormalize(keyBuffer) },
        ],
      };
      return new Key(ecdsaKey);
    }
    throw new Error('Unsupported algorithm: ' + supportedAlgosById[algorithm]);
  }
  function elementToBuf(e) {
    return Buffer2.from(e.split(' ')[1], 'base64');
  }
  function readDNSSECRSAPrivateKey(elements) {
    var rsaParams = {};
    elements.forEach(function (element) {
      if (element.split(' ')[0] === 'Modulus:')
        rsaParams['n'] = elementToBuf(element);
      else if (element.split(' ')[0] === 'PublicExponent:')
        rsaParams['e'] = elementToBuf(element);
      else if (element.split(' ')[0] === 'PrivateExponent:')
        rsaParams['d'] = elementToBuf(element);
      else if (element.split(' ')[0] === 'Prime1:')
        rsaParams['p'] = elementToBuf(element);
      else if (element.split(' ')[0] === 'Prime2:')
        rsaParams['q'] = elementToBuf(element);
      else if (element.split(' ')[0] === 'Exponent1:')
        rsaParams['dmodp'] = elementToBuf(element);
      else if (element.split(' ')[0] === 'Exponent2:')
        rsaParams['dmodq'] = elementToBuf(element);
      else if (element.split(' ')[0] === 'Coefficient:')
        rsaParams['iqmp'] = elementToBuf(element);
    });
    var key = {
      type: 'rsa',
      parts: [
        { name: 'e', data: utils.mpNormalize(rsaParams['e']) },
        { name: 'n', data: utils.mpNormalize(rsaParams['n']) },
        { name: 'd', data: utils.mpNormalize(rsaParams['d']) },
        { name: 'p', data: utils.mpNormalize(rsaParams['p']) },
        { name: 'q', data: utils.mpNormalize(rsaParams['q']) },
        {
          name: 'dmodp',
          data: utils.mpNormalize(rsaParams['dmodp']),
        },
        {
          name: 'dmodq',
          data: utils.mpNormalize(rsaParams['dmodq']),
        },
        {
          name: 'iqmp',
          data: utils.mpNormalize(rsaParams['iqmp']),
        },
      ],
    };
    return new PrivateKey(key);
  }
  function readDNSSECPrivateKey(alg, elements) {
    if (supportedAlgosById[alg].match(/^RSA-/)) {
      return readDNSSECRSAPrivateKey(elements);
    }
    if (
      supportedAlgosById[alg] === 'ECDSA-P384-SHA384' ||
      supportedAlgosById[alg] === 'ECDSA-P256-SHA256'
    ) {
      var d = Buffer2.from(elements[0].split(' ')[1], 'base64');
      var curve = 'nistp384';
      var size = 384;
      if (supportedAlgosById[alg] === 'ECDSA-P256-SHA256') {
        curve = 'nistp256';
        size = 256;
      }
      var publicKey = utils.publicFromPrivateECDSA(curve, d);
      var Q = publicKey.part['Q'].data;
      var ecdsaKey = {
        type: 'ecdsa',
        curve,
        size,
        parts: [
          { name: 'curve', data: Buffer2.from(curve) },
          { name: 'd', data: d },
          { name: 'Q', data: Q },
        ],
      };
      return new PrivateKey(ecdsaKey);
    }
    throw new Error('Unsupported algorithm: ' + supportedAlgosById[alg]);
  }
  function dnssecTimestamp(date) {
    var year = date.getFullYear() + '';
    var month = date.getMonth() + 1;
    var timestampStr = year + month + date.getUTCDate();
    timestampStr += '' + date.getUTCHours() + date.getUTCMinutes();
    timestampStr += date.getUTCSeconds();
    return timestampStr;
  }
  function rsaAlgFromOptions(opts) {
    if (!opts || !opts.hashAlgo || opts.hashAlgo === 'sha1')
      return '5 (RSASHA1)';
    else if (opts.hashAlgo === 'sha256') return '8 (RSASHA256)';
    else if (opts.hashAlgo === 'sha512') return '10 (RSASHA512)';
    else throw new Error('Unknown or unsupported hash: ' + opts.hashAlgo);
  }
  function writeRSA(key, options) {
    if (!key.part.dmodp || !key.part.dmodq) {
      utils.addRSAMissing(key);
    }
    var out = '';
    out += 'Private-key-format: v1.3\n';
    out += 'Algorithm: ' + rsaAlgFromOptions(options) + '\n';
    var n = utils.mpDenormalize(key.part['n'].data);
    out += 'Modulus: ' + n.toString('base64') + '\n';
    var e = utils.mpDenormalize(key.part['e'].data);
    out += 'PublicExponent: ' + e.toString('base64') + '\n';
    var d = utils.mpDenormalize(key.part['d'].data);
    out += 'PrivateExponent: ' + d.toString('base64') + '\n';
    var p = utils.mpDenormalize(key.part['p'].data);
    out += 'Prime1: ' + p.toString('base64') + '\n';
    var q2 = utils.mpDenormalize(key.part['q'].data);
    out += 'Prime2: ' + q2.toString('base64') + '\n';
    var dmodp = utils.mpDenormalize(key.part['dmodp'].data);
    out += 'Exponent1: ' + dmodp.toString('base64') + '\n';
    var dmodq = utils.mpDenormalize(key.part['dmodq'].data);
    out += 'Exponent2: ' + dmodq.toString('base64') + '\n';
    var iqmp = utils.mpDenormalize(key.part['iqmp'].data);
    out += 'Coefficient: ' + iqmp.toString('base64') + '\n';
    var timestamp = new Date();
    out += 'Created: ' + dnssecTimestamp(timestamp) + '\n';
    out += 'Publish: ' + dnssecTimestamp(timestamp) + '\n';
    out += 'Activate: ' + dnssecTimestamp(timestamp) + '\n';
    return Buffer2.from(out, 'ascii');
  }
  function writeECDSA(key, options) {
    var out = '';
    out += 'Private-key-format: v1.3\n';
    if (key.curve === 'nistp256') {
      out += 'Algorithm: 13 (ECDSAP256SHA256)\n';
    } else if (key.curve === 'nistp384') {
      out += 'Algorithm: 14 (ECDSAP384SHA384)\n';
    } else {
      throw new Error('Unsupported curve');
    }
    var base64Key = key.part['d'].data.toString('base64');
    out += 'PrivateKey: ' + base64Key + '\n';
    var timestamp = new Date();
    out += 'Created: ' + dnssecTimestamp(timestamp) + '\n';
    out += 'Publish: ' + dnssecTimestamp(timestamp) + '\n';
    out += 'Activate: ' + dnssecTimestamp(timestamp) + '\n';
    return Buffer2.from(out, 'ascii');
  }
  function write(key, options) {
    if (PrivateKey.isPrivateKey(key)) {
      if (key.type === 'rsa') {
        return writeRSA(key, options);
      } else if (key.type === 'ecdsa') {
        return writeECDSA(key, options);
      } else {
        throw new Error('Unsupported algorithm: ' + key.type);
      }
    } else if (Key.isKey(key)) {
      throw new Error('Format "dnssec" only supports writing private keys');
    } else {
      throw new Error('key is not a Key or PrivateKey');
    }
  }
});

// node_modules/sshpk/lib/formats/putty.js
var require_putty = __commonJS((exports2, module2) => {
  module2.exports = {
    read,
    write,
  };
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var rfc4253 = require_rfc4253();
  var Key = require_key();
  var errors = require_errors();
  function read(buf, options) {
    var lines = buf.toString('ascii').split(/[\r\n]+/);
    var found = false;
    var parts;
    var si = 0;
    while (si < lines.length) {
      parts = splitHeader(lines[si++]);
      if (parts && parts[0].toLowerCase() === 'putty-user-key-file-2') {
        found = true;
        break;
      }
    }
    if (!found) {
      throw new Error('No PuTTY format first line found');
    }
    var alg = parts[1];
    parts = splitHeader(lines[si++]);
    assert.equal(parts[0].toLowerCase(), 'encryption');
    parts = splitHeader(lines[si++]);
    assert.equal(parts[0].toLowerCase(), 'comment');
    var comment = parts[1];
    parts = splitHeader(lines[si++]);
    assert.equal(parts[0].toLowerCase(), 'public-lines');
    var publicLines = parseInt(parts[1], 10);
    if (
      !isFinite(publicLines) ||
      publicLines < 0 ||
      publicLines > lines.length
    ) {
      throw new Error('Invalid public-lines count');
    }
    var publicBuf = Buffer2.from(
      lines.slice(si, si + publicLines).join(''),
      'base64',
    );
    var keyType = rfc4253.algToKeyType(alg);
    var key = rfc4253.read(publicBuf);
    if (key.type !== keyType) {
      throw new Error('Outer key algorithm mismatch');
    }
    key.comment = comment;
    return key;
  }
  function splitHeader(line) {
    var idx = line.indexOf(':');
    if (idx === -1) return null;
    var header = line.slice(0, idx);
    ++idx;
    while (line[idx] === ' ') ++idx;
    var rest = line.slice(idx);
    return [header, rest];
  }
  function write(key, options) {
    assert.object(key);
    if (!Key.isKey(key)) throw new Error('Must be a public key');
    var alg = rfc4253.keyTypeToAlg(key);
    var buf = rfc4253.write(key);
    var comment = key.comment || '';
    var b64 = buf.toString('base64');
    var lines = wrap(b64, 64);
    lines.unshift('Public-Lines: ' + lines.length);
    lines.unshift('Comment: ' + comment);
    lines.unshift('Encryption: none');
    lines.unshift('PuTTY-User-Key-File-2: ' + alg);
    return Buffer2.from(lines.join('\n') + '\n');
  }
  function wrap(txt, len) {
    var lines = [];
    var pos = 0;
    while (pos < txt.length) {
      lines.push(txt.slice(pos, pos + 64));
      pos += 64;
    }
    return lines;
  }
});

// node_modules/sshpk/lib/formats/auto.js
var require_auto = __commonJS((exports2, module2) => {
  module2.exports = {
    read,
    write,
  };
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var utils = require_utils4();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var pem = require_pem();
  var ssh = require_ssh();
  var rfc4253 = require_rfc4253();
  var dnssec = require_dnssec();
  var putty = require_putty();
  var DNSSEC_PRIVKEY_HEADER_PREFIX = 'Private-key-format: v1';
  function read(buf, options) {
    if (typeof buf === 'string') {
      if (buf.trim().match(/^[-]+[ ]*BEGIN/)) return pem.read(buf, options);
      if (buf.match(/^\s*ssh-[a-z]/)) return ssh.read(buf, options);
      if (buf.match(/^\s*ecdsa-/)) return ssh.read(buf, options);
      if (buf.match(/^putty-user-key-file-2:/i))
        return putty.read(buf, options);
      if (findDNSSECHeader(buf)) return dnssec.read(buf, options);
      buf = Buffer2.from(buf, 'binary');
    } else {
      assert.buffer(buf);
      if (findPEMHeader(buf)) return pem.read(buf, options);
      if (findSSHHeader(buf)) return ssh.read(buf, options);
      if (findPuTTYHeader(buf)) return putty.read(buf, options);
      if (findDNSSECHeader(buf)) return dnssec.read(buf, options);
    }
    if (buf.readUInt32BE(0) < buf.length) return rfc4253.read(buf, options);
    throw new Error('Failed to auto-detect format of key');
  }
  function findPuTTYHeader(buf) {
    var offset = 0;
    while (
      offset < buf.length &&
      (buf[offset] === 32 || buf[offset] === 10 || buf[offset] === 9)
    )
      ++offset;
    if (
      offset + 22 <= buf.length &&
      buf
        .slice(offset, offset + 22)
        .toString('ascii')
        .toLowerCase() === 'putty-user-key-file-2:'
    )
      return true;
    return false;
  }
  function findSSHHeader(buf) {
    var offset = 0;
    while (
      offset < buf.length &&
      (buf[offset] === 32 || buf[offset] === 10 || buf[offset] === 9)
    )
      ++offset;
    if (
      offset + 4 <= buf.length &&
      buf.slice(offset, offset + 4).toString('ascii') === 'ssh-'
    )
      return true;
    if (
      offset + 6 <= buf.length &&
      buf.slice(offset, offset + 6).toString('ascii') === 'ecdsa-'
    )
      return true;
    return false;
  }
  function findPEMHeader(buf) {
    var offset = 0;
    while (offset < buf.length && (buf[offset] === 32 || buf[offset] === 10))
      ++offset;
    if (buf[offset] !== 45) return false;
    while (offset < buf.length && buf[offset] === 45) ++offset;
    while (offset < buf.length && buf[offset] === 32) ++offset;
    if (
      offset + 5 > buf.length ||
      buf.slice(offset, offset + 5).toString('ascii') !== 'BEGIN'
    )
      return false;
    return true;
  }
  function findDNSSECHeader(buf) {
    if (buf.length <= DNSSEC_PRIVKEY_HEADER_PREFIX.length) return false;
    var headerCheck = buf.slice(0, DNSSEC_PRIVKEY_HEADER_PREFIX.length);
    if (headerCheck.toString('ascii') === DNSSEC_PRIVKEY_HEADER_PREFIX)
      return true;
    if (typeof buf !== 'string') {
      buf = buf.toString('ascii');
    }
    var lines = buf.split('\n');
    var line = 0;
    while (lines[line].match(/^\;/)) line++;
    if (lines[line].toString('ascii').match(/\. IN KEY /)) return true;
    if (lines[line].toString('ascii').match(/\. IN DNSKEY /)) return true;
    return false;
  }
  function write(key, options) {
    throw new Error('"auto" format cannot be used for writing');
  }
});

// node_modules/sshpk/lib/private-key.js
var require_private_key = __commonJS((exports2, module2) => {
  module2.exports = PrivateKey;
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var crypto = require('crypto');
  var Fingerprint = require_fingerprint();
  var Signature = require_signature();
  var errs = require_errors();
  var util = require('util');
  var utils = require_utils4();
  var dhe = require_dhe();
  var generateECDSA = dhe.generateECDSA;
  var generateED25519 = dhe.generateED25519;
  var edCompat = require_ed_compat();
  var nacl = require_nacl_fast();
  var Key = require_key();
  var InvalidAlgorithmError = errs.InvalidAlgorithmError;
  var KeyParseError = errs.KeyParseError;
  var KeyEncryptedError = errs.KeyEncryptedError;
  var formats = {};
  formats['auto'] = require_auto();
  formats['pem'] = require_pem();
  formats['pkcs1'] = require_pkcs1();
  formats['pkcs8'] = require_pkcs8();
  formats['rfc4253'] = require_rfc4253();
  formats['ssh-private'] = require_ssh_private();
  formats['openssh'] = formats['ssh-private'];
  formats['ssh'] = formats['ssh-private'];
  formats['dnssec'] = require_dnssec();
  function PrivateKey(opts) {
    assert.object(opts, 'options');
    Key.call(this, opts);
    this._pubCache = void 0;
  }
  util.inherits(PrivateKey, Key);
  PrivateKey.formats = formats;
  PrivateKey.prototype.toBuffer = function (format, options) {
    if (format === void 0) format = 'pkcs1';
    assert.string(format, 'format');
    assert.object(formats[format], 'formats[format]');
    assert.optionalObject(options, 'options');
    return formats[format].write(this, options);
  };
  PrivateKey.prototype.hash = function (algo, type) {
    return this.toPublic().hash(algo, type);
  };
  PrivateKey.prototype.fingerprint = function (algo, type) {
    return this.toPublic().fingerprint(algo, type);
  };
  PrivateKey.prototype.toPublic = function () {
    if (this._pubCache) return this._pubCache;
    var algInfo = algs.info[this.type];
    var pubParts = [];
    for (var i = 0; i < algInfo.parts.length; ++i) {
      var p = algInfo.parts[i];
      pubParts.push(this.part[p]);
    }
    this._pubCache = new Key({
      type: this.type,
      source: this,
      parts: pubParts,
    });
    if (this.comment) this._pubCache.comment = this.comment;
    return this._pubCache;
  };
  PrivateKey.prototype.derive = function (newType) {
    assert.string(newType, 'type');
    var priv, pub, pair;
    if (this.type === 'ed25519' && newType === 'curve25519') {
      priv = this.part.k.data;
      if (priv[0] === 0) priv = priv.slice(1);
      pair = nacl.box.keyPair.fromSecretKey(new Uint8Array(priv));
      pub = Buffer2.from(pair.publicKey);
      return new PrivateKey({
        type: 'curve25519',
        parts: [
          { name: 'A', data: utils.mpNormalize(pub) },
          { name: 'k', data: utils.mpNormalize(priv) },
        ],
      });
    } else if (this.type === 'curve25519' && newType === 'ed25519') {
      priv = this.part.k.data;
      if (priv[0] === 0) priv = priv.slice(1);
      pair = nacl.sign.keyPair.fromSeed(new Uint8Array(priv));
      pub = Buffer2.from(pair.publicKey);
      return new PrivateKey({
        type: 'ed25519',
        parts: [
          { name: 'A', data: utils.mpNormalize(pub) },
          { name: 'k', data: utils.mpNormalize(priv) },
        ],
      });
    }
    throw new Error(
      'Key derivation not supported from ' + this.type + ' to ' + newType,
    );
  };
  PrivateKey.prototype.createVerify = function (hashAlgo) {
    return this.toPublic().createVerify(hashAlgo);
  };
  PrivateKey.prototype.createSign = function (hashAlgo) {
    if (hashAlgo === void 0) hashAlgo = this.defaultHashAlgorithm();
    assert.string(hashAlgo, 'hash algorithm');
    if (this.type === 'ed25519' && edCompat !== void 0)
      return new edCompat.Signer(this, hashAlgo);
    if (this.type === 'curve25519')
      throw new Error(
        'Curve25519 keys are not suitable for signing or verification',
      );
    var v, nm, err;
    try {
      nm = hashAlgo.toUpperCase();
      v = crypto.createSign(nm);
    } catch (e) {
      err = e;
    }
    if (
      v === void 0 ||
      (err instanceof Error && err.message.match(/Unknown message digest/))
    ) {
      nm = 'RSA-';
      nm += hashAlgo.toUpperCase();
      v = crypto.createSign(nm);
    }
    assert.ok(v, 'failed to create verifier');
    var oldSign = v.sign.bind(v);
    var key = this.toBuffer('pkcs1');
    var type = this.type;
    var curve = this.curve;
    v.sign = function () {
      var sig = oldSign(key);
      if (typeof sig === 'string') sig = Buffer2.from(sig, 'binary');
      sig = Signature.parse(sig, type, 'asn1');
      sig.hashAlgorithm = hashAlgo;
      sig.curve = curve;
      return sig;
    };
    return v;
  };
  PrivateKey.parse = function (data, format, options) {
    if (typeof data !== 'string') assert.buffer(data, 'data');
    if (format === void 0) format = 'auto';
    assert.string(format, 'format');
    if (typeof options === 'string') options = { filename: options };
    assert.optionalObject(options, 'options');
    if (options === void 0) options = {};
    assert.optionalString(options.filename, 'options.filename');
    if (options.filename === void 0) options.filename = '(unnamed)';
    assert.object(formats[format], 'formats[format]');
    try {
      var k = formats[format].read(data, options);
      assert.ok(k instanceof PrivateKey, 'key is not a private key');
      if (!k.comment) k.comment = options.filename;
      return k;
    } catch (e) {
      if (e.name === 'KeyEncryptedError') throw e;
      throw new KeyParseError(options.filename, format, e);
    }
  };
  PrivateKey.isPrivateKey = function (obj, ver) {
    return utils.isCompatible(obj, PrivateKey, ver);
  };
  PrivateKey.generate = function (type, options) {
    if (options === void 0) options = {};
    assert.object(options, 'options');
    switch (type) {
      case 'ecdsa':
        if (options.curve === void 0) options.curve = 'nistp256';
        assert.string(options.curve, 'options.curve');
        return generateECDSA(options.curve);
      case 'ed25519':
        return generateED25519();
      default:
        throw new Error(
          'Key generation not supported with key type "' + type + '"',
        );
    }
  };
  PrivateKey.prototype._sshpkApiVersion = [1, 6];
  PrivateKey._oldVersionDetect = function (obj) {
    assert.func(obj.toPublic);
    assert.func(obj.createSign);
    if (obj.derive) return [1, 3];
    if (obj.defaultHashAlgorithm) return [1, 2];
    if (obj.formats['auto']) return [1, 1];
    return [1, 0];
  };
});

// node_modules/sshpk/lib/identity.js
var require_identity = __commonJS((exports2, module2) => {
  module2.exports = Identity;
  var assert = require_assert();
  var algs = require_algs();
  var crypto = require('crypto');
  var Fingerprint = require_fingerprint();
  var Signature = require_signature();
  var errs = require_errors();
  var util = require('util');
  var utils = require_utils4();
  var asn1 = require_lib();
  var Buffer2 = require_safer().Buffer;
  var DNS_NAME_RE = /^([*]|[a-z0-9][a-z0-9\-]{0,62})(?:\.([*]|[a-z0-9][a-z0-9\-]{0,62}))*$/i;
  var oids = {};
  oids.cn = '2.5.4.3';
  oids.o = '2.5.4.10';
  oids.ou = '2.5.4.11';
  oids.l = '2.5.4.7';
  oids.s = '2.5.4.8';
  oids.c = '2.5.4.6';
  oids.sn = '2.5.4.4';
  oids.postalCode = '2.5.4.17';
  oids.serialNumber = '2.5.4.5';
  oids.street = '2.5.4.9';
  oids.x500UniqueIdentifier = '2.5.4.45';
  oids.role = '2.5.4.72';
  oids.telephoneNumber = '2.5.4.20';
  oids.description = '2.5.4.13';
  oids.dc = '0.9.2342.19200300.100.1.25';
  oids.uid = '0.9.2342.19200300.100.1.1';
  oids.mail = '0.9.2342.19200300.100.1.3';
  oids.title = '2.5.4.12';
  oids.gn = '2.5.4.42';
  oids.initials = '2.5.4.43';
  oids.pseudonym = '2.5.4.65';
  oids.emailAddress = '1.2.840.113549.1.9.1';
  var unoids = {};
  Object.keys(oids).forEach(function (k) {
    unoids[oids[k]] = k;
  });
  function Identity(opts) {
    var self2 = this;
    assert.object(opts, 'options');
    assert.arrayOfObject(opts.components, 'options.components');
    this.components = opts.components;
    this.componentLookup = {};
    this.components.forEach(function (c) {
      if (c.name && !c.oid) c.oid = oids[c.name];
      if (c.oid && !c.name) c.name = unoids[c.oid];
      if (self2.componentLookup[c.name] === void 0)
        self2.componentLookup[c.name] = [];
      self2.componentLookup[c.name].push(c);
    });
    if (this.componentLookup.cn && this.componentLookup.cn.length > 0) {
      this.cn = this.componentLookup.cn[0].value;
    }
    assert.optionalString(opts.type, 'options.type');
    if (opts.type === void 0) {
      if (
        this.components.length === 1 &&
        this.componentLookup.cn &&
        this.componentLookup.cn.length === 1 &&
        this.componentLookup.cn[0].value.match(DNS_NAME_RE)
      ) {
        this.type = 'host';
        this.hostname = this.componentLookup.cn[0].value;
      } else if (
        this.componentLookup.dc &&
        this.components.length === this.componentLookup.dc.length
      ) {
        this.type = 'host';
        this.hostname = this.componentLookup.dc
          .map(function (c) {
            return c.value;
          })
          .join('.');
      } else if (
        this.componentLookup.uid &&
        this.components.length === this.componentLookup.uid.length
      ) {
        this.type = 'user';
        this.uid = this.componentLookup.uid[0].value;
      } else if (
        this.componentLookup.cn &&
        this.componentLookup.cn.length === 1 &&
        this.componentLookup.cn[0].value.match(DNS_NAME_RE)
      ) {
        this.type = 'host';
        this.hostname = this.componentLookup.cn[0].value;
      } else if (
        this.componentLookup.uid &&
        this.componentLookup.uid.length === 1
      ) {
        this.type = 'user';
        this.uid = this.componentLookup.uid[0].value;
      } else if (
        this.componentLookup.mail &&
        this.componentLookup.mail.length === 1
      ) {
        this.type = 'email';
        this.email = this.componentLookup.mail[0].value;
      } else if (
        this.componentLookup.cn &&
        this.componentLookup.cn.length === 1
      ) {
        this.type = 'user';
        this.uid = this.componentLookup.cn[0].value;
      } else {
        this.type = 'unknown';
      }
    } else {
      this.type = opts.type;
      if (this.type === 'host') this.hostname = opts.hostname;
      else if (this.type === 'user') this.uid = opts.uid;
      else if (this.type === 'email') this.email = opts.email;
      else throw new Error('Unknown type ' + this.type);
    }
  }
  Identity.prototype.toString = function () {
    return this.components
      .map(function (c) {
        var n = c.name.toUpperCase();
        n = n.replace(/=/g, '\\=');
        var v = c.value;
        v = v.replace(/,/g, '\\,');
        return n + '=' + v;
      })
      .join(', ');
  };
  Identity.prototype.get = function (name, asArray) {
    assert.string(name, 'name');
    var arr = this.componentLookup[name];
    if (arr === void 0 || arr.length === 0) return void 0;
    if (!asArray && arr.length > 1)
      throw new Error('Multiple values for attribute ' + name);
    if (!asArray) return arr[0].value;
    return arr.map(function (c) {
      return c.value;
    });
  };
  Identity.prototype.toArray = function (idx) {
    return this.components.map(function (c) {
      return {
        name: c.name,
        value: c.value,
      };
    });
  };
  var NOT_PRINTABLE = /[^a-zA-Z0-9 '(),+.\/:=?-]/;
  var NOT_IA5 = /[^\x00-\x7f]/;
  Identity.prototype.toAsn1 = function (der, tag) {
    der.startSequence(tag);
    this.components.forEach(function (c) {
      der.startSequence(asn1.Ber.Constructor | asn1.Ber.Set);
      der.startSequence();
      der.writeOID(c.oid);
      if (c.asn1type === asn1.Ber.Utf8String || c.value.match(NOT_IA5)) {
        var v = Buffer2.from(c.value, 'utf8');
        der.writeBuffer(v, asn1.Ber.Utf8String);
      } else if (
        c.asn1type === asn1.Ber.IA5String ||
        c.value.match(NOT_PRINTABLE)
      ) {
        der.writeString(c.value, asn1.Ber.IA5String);
      } else {
        var type = asn1.Ber.PrintableString;
        if (c.asn1type !== void 0) type = c.asn1type;
        der.writeString(c.value, type);
      }
      der.endSequence();
      der.endSequence();
    });
    der.endSequence();
  };
  function globMatch(a, b) {
    if (a === '**' || b === '**') return true;
    var aParts = a.split('.');
    var bParts = b.split('.');
    if (aParts.length !== bParts.length) return false;
    for (var i = 0; i < aParts.length; ++i) {
      if (aParts[i] === '*' || bParts[i] === '*') continue;
      if (aParts[i] !== bParts[i]) return false;
    }
    return true;
  }
  Identity.prototype.equals = function (other) {
    if (!Identity.isIdentity(other, [1, 0])) return false;
    if (other.components.length !== this.components.length) return false;
    for (var i = 0; i < this.components.length; ++i) {
      if (this.components[i].oid !== other.components[i].oid) return false;
      if (!globMatch(this.components[i].value, other.components[i].value)) {
        return false;
      }
    }
    return true;
  };
  Identity.forHost = function (hostname) {
    assert.string(hostname, 'hostname');
    return new Identity({
      type: 'host',
      hostname,
      components: [{ name: 'cn', value: hostname }],
    });
  };
  Identity.forUser = function (uid) {
    assert.string(uid, 'uid');
    return new Identity({
      type: 'user',
      uid,
      components: [{ name: 'uid', value: uid }],
    });
  };
  Identity.forEmail = function (email) {
    assert.string(email, 'email');
    return new Identity({
      type: 'email',
      email,
      components: [{ name: 'mail', value: email }],
    });
  };
  Identity.parseDN = function (dn) {
    assert.string(dn, 'dn');
    var parts = [''];
    var idx = 0;
    var rem = dn;
    while (rem.length > 0) {
      var m;
      if ((m = /^,/.exec(rem)) !== null) {
        parts[++idx] = '';
        rem = rem.slice(m[0].length);
      } else if ((m = /^\\,/.exec(rem)) !== null) {
        parts[idx] += ',';
        rem = rem.slice(m[0].length);
      } else if ((m = /^\\./.exec(rem)) !== null) {
        parts[idx] += m[0];
        rem = rem.slice(m[0].length);
      } else if ((m = /^[^\\,]+/.exec(rem)) !== null) {
        parts[idx] += m[0];
        rem = rem.slice(m[0].length);
      } else {
        throw new Error('Failed to parse DN');
      }
    }
    var cmps = parts.map(function (c) {
      c = c.trim();
      var eqPos = c.indexOf('=');
      while (eqPos > 0 && c.charAt(eqPos - 1) === '\\')
        eqPos = c.indexOf('=', eqPos + 1);
      if (eqPos === -1) {
        throw new Error('Failed to parse DN');
      }
      var name = c.slice(0, eqPos).toLowerCase().replace(/\\=/g, '=');
      var value = c.slice(eqPos + 1);
      return { name, value };
    });
    return new Identity({ components: cmps });
  };
  Identity.fromArray = function (components) {
    assert.arrayOfObject(components, 'components');
    components.forEach(function (cmp) {
      assert.object(cmp, 'component');
      assert.string(cmp.name, 'component.name');
      if (!Buffer2.isBuffer(cmp.value) && !(typeof cmp.value === 'string')) {
        throw new Error('Invalid component value');
      }
    });
    return new Identity({ components });
  };
  Identity.parseAsn1 = function (der, top) {
    var components = [];
    der.readSequence(top);
    var end = der.offset + der.length;
    while (der.offset < end) {
      der.readSequence(asn1.Ber.Constructor | asn1.Ber.Set);
      var after = der.offset + der.length;
      der.readSequence();
      var oid = der.readOID();
      var type = der.peek();
      var value;
      switch (type) {
        case asn1.Ber.PrintableString:
        case asn1.Ber.IA5String:
        case asn1.Ber.OctetString:
        case asn1.Ber.T61String:
          value = der.readString(type);
          break;
        case asn1.Ber.Utf8String:
          value = der.readString(type, true);
          value = value.toString('utf8');
          break;
        case asn1.Ber.CharacterString:
        case asn1.Ber.BMPString:
          value = der.readString(type, true);
          value = value.toString('utf16le');
          break;
        default:
          throw new Error('Unknown asn1 type ' + type);
      }
      components.push({ oid, asn1type: type, value });
      der._offset = after;
    }
    der._offset = end;
    return new Identity({
      components,
    });
  };
  Identity.isIdentity = function (obj, ver) {
    return utils.isCompatible(obj, Identity, ver);
  };
  Identity.prototype._sshpkApiVersion = [1, 0];
  Identity._oldVersionDetect = function (obj) {
    return [1, 0];
  };
});

// node_modules/sshpk/lib/formats/openssh-cert.js
var require_openssh_cert = __commonJS((exports2, module2) => {
  module2.exports = {
    read,
    verify,
    sign,
    signAsync,
    write,
    fromBuffer,
    toBuffer,
  };
  var assert = require_assert();
  var SSHBuffer = require_ssh_buffer();
  var crypto = require('crypto');
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var Identity = require_identity();
  var rfc4253 = require_rfc4253();
  var Signature = require_signature();
  var utils = require_utils4();
  var Certificate = require_certificate();
  function verify(cert, key) {
    return false;
  }
  var TYPES = {
    user: 1,
    host: 2,
  };
  Object.keys(TYPES).forEach(function (k) {
    TYPES[TYPES[k]] = k;
  });
  var ECDSA_ALGO = /^ecdsa-sha2-([^@-]+)-cert-v01@openssh.com$/;
  function read(buf, options) {
    if (Buffer2.isBuffer(buf)) buf = buf.toString('ascii');
    var parts = buf.trim().split(/[ \t\n]+/g);
    if (parts.length < 2 || parts.length > 3)
      throw new Error('Not a valid SSH certificate line');
    var algo = parts[0];
    var data = parts[1];
    data = Buffer2.from(data, 'base64');
    return fromBuffer(data, algo);
  }
  function fromBuffer(data, algo, partial) {
    var sshbuf = new SSHBuffer({ buffer: data });
    var innerAlgo = sshbuf.readString();
    if (algo !== void 0 && innerAlgo !== algo)
      throw new Error('SSH certificate algorithm mismatch');
    if (algo === void 0) algo = innerAlgo;
    var cert = {};
    cert.signatures = {};
    cert.signatures.openssh = {};
    cert.signatures.openssh.nonce = sshbuf.readBuffer();
    var key = {};
    var parts = (key.parts = []);
    key.type = getAlg(algo);
    var partCount = algs.info[key.type].parts.length;
    while (parts.length < partCount) parts.push(sshbuf.readPart());
    assert.ok(parts.length >= 1, 'key must have at least one part');
    var algInfo = algs.info[key.type];
    if (key.type === 'ecdsa') {
      var res = ECDSA_ALGO.exec(algo);
      assert.ok(res !== null);
      assert.strictEqual(res[1], parts[0].data.toString());
    }
    for (var i = 0; i < algInfo.parts.length; ++i) {
      parts[i].name = algInfo.parts[i];
      if (parts[i].name !== 'curve' && algInfo.normalize !== false) {
        var p = parts[i];
        p.data = utils.mpNormalize(p.data);
      }
    }
    cert.subjectKey = new Key(key);
    cert.serial = sshbuf.readInt64();
    var type = TYPES[sshbuf.readInt()];
    assert.string(type, 'valid cert type');
    cert.signatures.openssh.keyId = sshbuf.readString();
    var principals = [];
    var pbuf = sshbuf.readBuffer();
    var psshbuf = new SSHBuffer({ buffer: pbuf });
    while (!psshbuf.atEnd()) principals.push(psshbuf.readString());
    if (principals.length === 0) principals = ['*'];
    cert.subjects = principals.map(function (pr) {
      if (type === 'user') return Identity.forUser(pr);
      else if (type === 'host') return Identity.forHost(pr);
      throw new Error('Unknown identity type ' + type);
    });
    cert.validFrom = int64ToDate(sshbuf.readInt64());
    cert.validUntil = int64ToDate(sshbuf.readInt64());
    var exts = [];
    var extbuf = new SSHBuffer({ buffer: sshbuf.readBuffer() });
    var ext;
    while (!extbuf.atEnd()) {
      ext = { critical: true };
      ext.name = extbuf.readString();
      ext.data = extbuf.readBuffer();
      exts.push(ext);
    }
    extbuf = new SSHBuffer({ buffer: sshbuf.readBuffer() });
    while (!extbuf.atEnd()) {
      ext = { critical: false };
      ext.name = extbuf.readString();
      ext.data = extbuf.readBuffer();
      exts.push(ext);
    }
    cert.signatures.openssh.exts = exts;
    sshbuf.readBuffer();
    var signingKeyBuf = sshbuf.readBuffer();
    cert.issuerKey = rfc4253.read(signingKeyBuf);
    cert.issuer = Identity.forHost('**');
    var sigBuf = sshbuf.readBuffer();
    cert.signatures.openssh.signature = Signature.parse(
      sigBuf,
      cert.issuerKey.type,
      'ssh',
    );
    if (partial !== void 0) {
      partial.remainder = sshbuf.remainder();
      partial.consumed = sshbuf._offset;
    }
    return new Certificate(cert);
  }
  function int64ToDate(buf) {
    var i = buf.readUInt32BE(0) * 4294967296;
    i += buf.readUInt32BE(4);
    var d = new Date();
    d.setTime(i * 1e3);
    d.sourceInt64 = buf;
    return d;
  }
  function dateToInt64(date) {
    if (date.sourceInt64 !== void 0) return date.sourceInt64;
    var i = Math.round(date.getTime() / 1e3);
    var upper = Math.floor(i / 4294967296);
    var lower = Math.floor(i % 4294967296);
    var buf = Buffer2.alloc(8);
    buf.writeUInt32BE(upper, 0);
    buf.writeUInt32BE(lower, 4);
    return buf;
  }
  function sign(cert, key) {
    if (cert.signatures.openssh === void 0) cert.signatures.openssh = {};
    try {
      var blob = toBuffer(cert, true);
    } catch (e) {
      delete cert.signatures.openssh;
      return false;
    }
    var sig = cert.signatures.openssh;
    var hashAlgo = void 0;
    if (key.type === 'rsa' || key.type === 'dsa') hashAlgo = 'sha1';
    var signer = key.createSign(hashAlgo);
    signer.write(blob);
    sig.signature = signer.sign();
    return true;
  }
  function signAsync(cert, signer, done) {
    if (cert.signatures.openssh === void 0) cert.signatures.openssh = {};
    try {
      var blob = toBuffer(cert, true);
    } catch (e) {
      delete cert.signatures.openssh;
      done(e);
      return;
    }
    var sig = cert.signatures.openssh;
    signer(blob, function (err, signature) {
      if (err) {
        done(err);
        return;
      }
      try {
        signature.toBuffer('ssh');
      } catch (e) {
        done(e);
        return;
      }
      sig.signature = signature;
      done();
    });
  }
  function write(cert, options) {
    if (options === void 0) options = {};
    var blob = toBuffer(cert);
    var out = getCertType(cert.subjectKey) + ' ' + blob.toString('base64');
    if (options.comment) out = out + ' ' + options.comment;
    return out;
  }
  function toBuffer(cert, noSig) {
    assert.object(cert.signatures.openssh, 'signature for openssh format');
    var sig = cert.signatures.openssh;
    if (sig.nonce === void 0) sig.nonce = crypto.randomBytes(16);
    var buf = new SSHBuffer({});
    buf.writeString(getCertType(cert.subjectKey));
    buf.writeBuffer(sig.nonce);
    var key = cert.subjectKey;
    var algInfo = algs.info[key.type];
    algInfo.parts.forEach(function (part) {
      buf.writePart(key.part[part]);
    });
    buf.writeInt64(cert.serial);
    var type = cert.subjects[0].type;
    assert.notStrictEqual(type, 'unknown');
    cert.subjects.forEach(function (id) {
      assert.strictEqual(id.type, type);
    });
    type = TYPES[type];
    buf.writeInt(type);
    if (sig.keyId === void 0) {
      sig.keyId =
        cert.subjects[0].type +
        '_' +
        (cert.subjects[0].uid || cert.subjects[0].hostname);
    }
    buf.writeString(sig.keyId);
    var sub = new SSHBuffer({});
    cert.subjects.forEach(function (id) {
      if (type === TYPES.host) sub.writeString(id.hostname);
      else if (type === TYPES.user) sub.writeString(id.uid);
    });
    buf.writeBuffer(sub.toBuffer());
    buf.writeInt64(dateToInt64(cert.validFrom));
    buf.writeInt64(dateToInt64(cert.validUntil));
    var exts = sig.exts;
    if (exts === void 0) exts = [];
    var extbuf = new SSHBuffer({});
    exts.forEach(function (ext) {
      if (ext.critical !== true) return;
      extbuf.writeString(ext.name);
      extbuf.writeBuffer(ext.data);
    });
    buf.writeBuffer(extbuf.toBuffer());
    extbuf = new SSHBuffer({});
    exts.forEach(function (ext) {
      if (ext.critical === true) return;
      extbuf.writeString(ext.name);
      extbuf.writeBuffer(ext.data);
    });
    buf.writeBuffer(extbuf.toBuffer());
    buf.writeBuffer(Buffer2.alloc(0));
    sub = rfc4253.write(cert.issuerKey);
    buf.writeBuffer(sub);
    if (!noSig) buf.writeBuffer(sig.signature.toBuffer('ssh'));
    return buf.toBuffer();
  }
  function getAlg(certType) {
    if (certType === 'ssh-rsa-cert-v01@openssh.com') return 'rsa';
    if (certType === 'ssh-dss-cert-v01@openssh.com') return 'dsa';
    if (certType.match(ECDSA_ALGO)) return 'ecdsa';
    if (certType === 'ssh-ed25519-cert-v01@openssh.com') return 'ed25519';
    throw new Error('Unsupported cert type ' + certType);
  }
  function getCertType(key) {
    if (key.type === 'rsa') return 'ssh-rsa-cert-v01@openssh.com';
    if (key.type === 'dsa') return 'ssh-dss-cert-v01@openssh.com';
    if (key.type === 'ecdsa')
      return 'ecdsa-sha2-' + key.curve + '-cert-v01@openssh.com';
    if (key.type === 'ed25519') return 'ssh-ed25519-cert-v01@openssh.com';
    throw new Error('Unsupported key type ' + key.type);
  }
});

// node_modules/sshpk/lib/formats/x509.js
var require_x509 = __commonJS((exports2, module2) => {
  module2.exports = {
    read,
    verify,
    sign,
    signAsync,
    write,
  };
  var assert = require_assert();
  var asn1 = require_lib();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var utils = require_utils4();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var pem = require_pem();
  var Identity = require_identity();
  var Signature = require_signature();
  var Certificate = require_certificate();
  var pkcs8 = require_pkcs8();
  function readMPInt(der, nm) {
    assert.strictEqual(der.peek(), asn1.Ber.Integer, nm + ' is not an Integer');
    return utils.mpNormalize(der.readString(asn1.Ber.Integer, true));
  }
  function verify(cert, key) {
    var sig = cert.signatures.x509;
    assert.object(sig, 'x509 signature');
    var algParts = sig.algo.split('-');
    if (algParts[0] !== key.type) return false;
    var blob = sig.cache;
    if (blob === void 0) {
      var der = new asn1.BerWriter();
      writeTBSCert(cert, der);
      blob = der.buffer;
    }
    var verifier = key.createVerify(algParts[1]);
    verifier.write(blob);
    return verifier.verify(sig.signature);
  }
  function Local(i) {
    return asn1.Ber.Context | asn1.Ber.Constructor | i;
  }
  function Context(i) {
    return asn1.Ber.Context | i;
  }
  var SIGN_ALGS = {
    'rsa-md5': '1.2.840.113549.1.1.4',
    'rsa-sha1': '1.2.840.113549.1.1.5',
    'rsa-sha256': '1.2.840.113549.1.1.11',
    'rsa-sha384': '1.2.840.113549.1.1.12',
    'rsa-sha512': '1.2.840.113549.1.1.13',
    'dsa-sha1': '1.2.840.10040.4.3',
    'dsa-sha256': '2.16.840.1.101.3.4.3.2',
    'ecdsa-sha1': '1.2.840.10045.4.1',
    'ecdsa-sha256': '1.2.840.10045.4.3.2',
    'ecdsa-sha384': '1.2.840.10045.4.3.3',
    'ecdsa-sha512': '1.2.840.10045.4.3.4',
    'ed25519-sha512': '1.3.101.112',
  };
  Object.keys(SIGN_ALGS).forEach(function (k) {
    SIGN_ALGS[SIGN_ALGS[k]] = k;
  });
  SIGN_ALGS['1.3.14.3.2.3'] = 'rsa-md5';
  SIGN_ALGS['1.3.14.3.2.29'] = 'rsa-sha1';
  var EXTS = {
    issuerKeyId: '2.5.29.35',
    altName: '2.5.29.17',
    basicConstraints: '2.5.29.19',
    keyUsage: '2.5.29.15',
    extKeyUsage: '2.5.29.37',
  };
  function read(buf, options) {
    if (typeof buf === 'string') {
      buf = Buffer2.from(buf, 'binary');
    }
    assert.buffer(buf, 'buf');
    var der = new asn1.BerReader(buf);
    der.readSequence();
    if (Math.abs(der.length - der.remain) > 1) {
      throw new Error('DER sequence does not contain whole byte stream');
    }
    var tbsStart = der.offset;
    der.readSequence();
    var sigOffset = der.offset + der.length;
    var tbsEnd = sigOffset;
    if (der.peek() === Local(0)) {
      der.readSequence(Local(0));
      var version = der.readInt();
      assert.ok(version <= 3, 'only x.509 versions up to v3 supported');
    }
    var cert = {};
    cert.signatures = {};
    var sig = (cert.signatures.x509 = {});
    sig.extras = {};
    cert.serial = readMPInt(der, 'serial');
    der.readSequence();
    var after = der.offset + der.length;
    var certAlgOid = der.readOID();
    var certAlg = SIGN_ALGS[certAlgOid];
    if (certAlg === void 0)
      throw new Error('unknown signature algorithm ' + certAlgOid);
    der._offset = after;
    cert.issuer = Identity.parseAsn1(der);
    der.readSequence();
    cert.validFrom = readDate(der);
    cert.validUntil = readDate(der);
    cert.subjects = [Identity.parseAsn1(der)];
    der.readSequence();
    after = der.offset + der.length;
    cert.subjectKey = pkcs8.readPkcs8(void 0, 'public', der);
    der._offset = after;
    if (der.peek() === Local(1)) {
      der.readSequence(Local(1));
      sig.extras.issuerUniqueID = buf.slice(
        der.offset,
        der.offset + der.length,
      );
      der._offset += der.length;
    }
    if (der.peek() === Local(2)) {
      der.readSequence(Local(2));
      sig.extras.subjectUniqueID = buf.slice(
        der.offset,
        der.offset + der.length,
      );
      der._offset += der.length;
    }
    if (der.peek() === Local(3)) {
      der.readSequence(Local(3));
      var extEnd = der.offset + der.length;
      der.readSequence();
      while (der.offset < extEnd) readExtension(cert, buf, der);
      assert.strictEqual(der.offset, extEnd);
    }
    assert.strictEqual(der.offset, sigOffset);
    der.readSequence();
    after = der.offset + der.length;
    var sigAlgOid = der.readOID();
    var sigAlg = SIGN_ALGS[sigAlgOid];
    if (sigAlg === void 0)
      throw new Error('unknown signature algorithm ' + sigAlgOid);
    der._offset = after;
    var sigData = der.readString(asn1.Ber.BitString, true);
    if (sigData[0] === 0) sigData = sigData.slice(1);
    var algParts = sigAlg.split('-');
    sig.signature = Signature.parse(sigData, algParts[0], 'asn1');
    sig.signature.hashAlgorithm = algParts[1];
    sig.algo = sigAlg;
    sig.cache = buf.slice(tbsStart, tbsEnd);
    return new Certificate(cert);
  }
  function readDate(der) {
    if (der.peek() === asn1.Ber.UTCTime) {
      return utcTimeToDate(der.readString(asn1.Ber.UTCTime));
    } else if (der.peek() === asn1.Ber.GeneralizedTime) {
      return gTimeToDate(der.readString(asn1.Ber.GeneralizedTime));
    } else {
      throw new Error('Unsupported date format');
    }
  }
  function writeDate(der, date) {
    if (date.getUTCFullYear() >= 2050 || date.getUTCFullYear() < 1950) {
      der.writeString(dateToGTime(date), asn1.Ber.GeneralizedTime);
    } else {
      der.writeString(dateToUTCTime(date), asn1.Ber.UTCTime);
    }
  }
  var ALTNAME = {
    OtherName: Local(0),
    RFC822Name: Context(1),
    DNSName: Context(2),
    X400Address: Local(3),
    DirectoryName: Local(4),
    EDIPartyName: Local(5),
    URI: Context(6),
    IPAddress: Context(7),
    OID: Context(8),
  };
  var EXTPURPOSE = {
    serverAuth: '1.3.6.1.5.5.7.3.1',
    clientAuth: '1.3.6.1.5.5.7.3.2',
    codeSigning: '1.3.6.1.5.5.7.3.3',
    joyentDocker: '1.3.6.1.4.1.38678.1.4.1',
    joyentCmon: '1.3.6.1.4.1.38678.1.4.2',
  };
  var EXTPURPOSE_REV = {};
  Object.keys(EXTPURPOSE).forEach(function (k) {
    EXTPURPOSE_REV[EXTPURPOSE[k]] = k;
  });
  var KEYUSEBITS = [
    'signature',
    'identity',
    'keyEncryption',
    'encryption',
    'keyAgreement',
    'ca',
    'crl',
  ];
  function readExtension(cert, buf, der) {
    der.readSequence();
    var after = der.offset + der.length;
    var extId = der.readOID();
    var id;
    var sig = cert.signatures.x509;
    if (!sig.extras.exts) sig.extras.exts = [];
    var critical;
    if (der.peek() === asn1.Ber.Boolean) critical = der.readBoolean();
    switch (extId) {
      case EXTS.basicConstraints:
        der.readSequence(asn1.Ber.OctetString);
        der.readSequence();
        var bcEnd = der.offset + der.length;
        var ca = false;
        if (der.peek() === asn1.Ber.Boolean) ca = der.readBoolean();
        if (cert.purposes === void 0) cert.purposes = [];
        if (ca === true) cert.purposes.push('ca');
        var bc = { oid: extId, critical };
        if (der.offset < bcEnd && der.peek() === asn1.Ber.Integer)
          bc.pathLen = der.readInt();
        sig.extras.exts.push(bc);
        break;
      case EXTS.extKeyUsage:
        der.readSequence(asn1.Ber.OctetString);
        der.readSequence();
        if (cert.purposes === void 0) cert.purposes = [];
        var ekEnd = der.offset + der.length;
        while (der.offset < ekEnd) {
          var oid = der.readOID();
          cert.purposes.push(EXTPURPOSE_REV[oid] || oid);
        }
        if (
          cert.purposes.indexOf('serverAuth') !== -1 &&
          cert.purposes.indexOf('clientAuth') === -1
        ) {
          cert.subjects.forEach(function (ide) {
            if (ide.type !== 'host') {
              ide.type = 'host';
              ide.hostname = ide.uid || ide.email || ide.components[0].value;
            }
          });
        } else if (
          cert.purposes.indexOf('clientAuth') !== -1 &&
          cert.purposes.indexOf('serverAuth') === -1
        ) {
          cert.subjects.forEach(function (ide) {
            if (ide.type !== 'user') {
              ide.type = 'user';
              ide.uid = ide.hostname || ide.email || ide.components[0].value;
            }
          });
        }
        sig.extras.exts.push({ oid: extId, critical });
        break;
      case EXTS.keyUsage:
        der.readSequence(asn1.Ber.OctetString);
        var bits = der.readString(asn1.Ber.BitString, true);
        var setBits = readBitField(bits, KEYUSEBITS);
        setBits.forEach(function (bit) {
          if (cert.purposes === void 0) cert.purposes = [];
          if (cert.purposes.indexOf(bit) === -1) cert.purposes.push(bit);
        });
        sig.extras.exts.push({
          oid: extId,
          critical,
          bits,
        });
        break;
      case EXTS.altName:
        der.readSequence(asn1.Ber.OctetString);
        der.readSequence();
        var aeEnd = der.offset + der.length;
        while (der.offset < aeEnd) {
          switch (der.peek()) {
            case ALTNAME.OtherName:
            case ALTNAME.EDIPartyName:
              der.readSequence();
              der._offset += der.length;
              break;
            case ALTNAME.OID:
              der.readOID(ALTNAME.OID);
              break;
            case ALTNAME.RFC822Name:
              var email = der.readString(ALTNAME.RFC822Name);
              id = Identity.forEmail(email);
              if (!cert.subjects[0].equals(id)) cert.subjects.push(id);
              break;
            case ALTNAME.DirectoryName:
              der.readSequence(ALTNAME.DirectoryName);
              id = Identity.parseAsn1(der);
              if (!cert.subjects[0].equals(id)) cert.subjects.push(id);
              break;
            case ALTNAME.DNSName:
              var host = der.readString(ALTNAME.DNSName);
              id = Identity.forHost(host);
              if (!cert.subjects[0].equals(id)) cert.subjects.push(id);
              break;
            default:
              der.readString(der.peek());
              break;
          }
        }
        sig.extras.exts.push({ oid: extId, critical });
        break;
      default:
        sig.extras.exts.push({
          oid: extId,
          critical,
          data: der.readString(asn1.Ber.OctetString, true),
        });
        break;
    }
    der._offset = after;
  }
  var UTCTIME_RE = /^([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;
  function utcTimeToDate(t) {
    var m = t.match(UTCTIME_RE);
    assert.ok(m, 'timestamps must be in UTC');
    var d = new Date();
    var thisYear = d.getUTCFullYear();
    var century = Math.floor(thisYear / 100) * 100;
    var year = parseInt(m[1], 10);
    if (thisYear % 100 < 50 && year >= 60) year += century - 1;
    else year += century;
    d.setUTCFullYear(year, parseInt(m[2], 10) - 1, parseInt(m[3], 10));
    d.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));
    if (m[6] && m[6].length > 0) d.setUTCSeconds(parseInt(m[6], 10));
    return d;
  }
  var GTIME_RE = /^([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;
  function gTimeToDate(t) {
    var m = t.match(GTIME_RE);
    assert.ok(m);
    var d = new Date();
    d.setUTCFullYear(
      parseInt(m[1], 10),
      parseInt(m[2], 10) - 1,
      parseInt(m[3], 10),
    );
    d.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));
    if (m[6] && m[6].length > 0) d.setUTCSeconds(parseInt(m[6], 10));
    return d;
  }
  function zeroPad(n, m) {
    if (m === void 0) m = 2;
    var s = '' + n;
    while (s.length < m) s = '0' + s;
    return s;
  }
  function dateToUTCTime(d) {
    var s = '';
    s += zeroPad(d.getUTCFullYear() % 100);
    s += zeroPad(d.getUTCMonth() + 1);
    s += zeroPad(d.getUTCDate());
    s += zeroPad(d.getUTCHours());
    s += zeroPad(d.getUTCMinutes());
    s += zeroPad(d.getUTCSeconds());
    s += 'Z';
    return s;
  }
  function dateToGTime(d) {
    var s = '';
    s += zeroPad(d.getUTCFullYear(), 4);
    s += zeroPad(d.getUTCMonth() + 1);
    s += zeroPad(d.getUTCDate());
    s += zeroPad(d.getUTCHours());
    s += zeroPad(d.getUTCMinutes());
    s += zeroPad(d.getUTCSeconds());
    s += 'Z';
    return s;
  }
  function sign(cert, key) {
    if (cert.signatures.x509 === void 0) cert.signatures.x509 = {};
    var sig = cert.signatures.x509;
    sig.algo = key.type + '-' + key.defaultHashAlgorithm();
    if (SIGN_ALGS[sig.algo] === void 0) return false;
    var der = new asn1.BerWriter();
    writeTBSCert(cert, der);
    var blob = der.buffer;
    sig.cache = blob;
    var signer = key.createSign();
    signer.write(blob);
    cert.signatures.x509.signature = signer.sign();
    return true;
  }
  function signAsync(cert, signer, done) {
    if (cert.signatures.x509 === void 0) cert.signatures.x509 = {};
    var sig = cert.signatures.x509;
    var der = new asn1.BerWriter();
    writeTBSCert(cert, der);
    var blob = der.buffer;
    sig.cache = blob;
    signer(blob, function (err, signature) {
      if (err) {
        done(err);
        return;
      }
      sig.algo = signature.type + '-' + signature.hashAlgorithm;
      if (SIGN_ALGS[sig.algo] === void 0) {
        done(new Error('Invalid signing algorithm "' + sig.algo + '"'));
        return;
      }
      sig.signature = signature;
      done();
    });
  }
  function write(cert, options) {
    var sig = cert.signatures.x509;
    assert.object(sig, 'x509 signature');
    var der = new asn1.BerWriter();
    der.startSequence();
    if (sig.cache) {
      der._ensure(sig.cache.length);
      sig.cache.copy(der._buf, der._offset);
      der._offset += sig.cache.length;
    } else {
      writeTBSCert(cert, der);
    }
    der.startSequence();
    der.writeOID(SIGN_ALGS[sig.algo]);
    if (sig.algo.match(/^rsa-/)) der.writeNull();
    der.endSequence();
    var sigData = sig.signature.toBuffer('asn1');
    var data = Buffer2.alloc(sigData.length + 1);
    data[0] = 0;
    sigData.copy(data, 1);
    der.writeBuffer(data, asn1.Ber.BitString);
    der.endSequence();
    return der.buffer;
  }
  function writeTBSCert(cert, der) {
    var sig = cert.signatures.x509;
    assert.object(sig, 'x509 signature');
    der.startSequence();
    der.startSequence(Local(0));
    der.writeInt(2);
    der.endSequence();
    der.writeBuffer(utils.mpNormalize(cert.serial), asn1.Ber.Integer);
    der.startSequence();
    der.writeOID(SIGN_ALGS[sig.algo]);
    if (sig.algo.match(/^rsa-/)) der.writeNull();
    der.endSequence();
    cert.issuer.toAsn1(der);
    der.startSequence();
    writeDate(der, cert.validFrom);
    writeDate(der, cert.validUntil);
    der.endSequence();
    var subject = cert.subjects[0];
    var altNames = cert.subjects.slice(1);
    subject.toAsn1(der);
    pkcs8.writePkcs8(der, cert.subjectKey);
    if (sig.extras && sig.extras.issuerUniqueID) {
      der.writeBuffer(sig.extras.issuerUniqueID, Local(1));
    }
    if (sig.extras && sig.extras.subjectUniqueID) {
      der.writeBuffer(sig.extras.subjectUniqueID, Local(2));
    }
    if (
      altNames.length > 0 ||
      subject.type === 'host' ||
      (cert.purposes !== void 0 && cert.purposes.length > 0) ||
      (sig.extras && sig.extras.exts)
    ) {
      der.startSequence(Local(3));
      der.startSequence();
      var exts = [];
      if (cert.purposes !== void 0 && cert.purposes.length > 0) {
        exts.push({
          oid: EXTS.basicConstraints,
          critical: true,
        });
        exts.push({
          oid: EXTS.keyUsage,
          critical: true,
        });
        exts.push({
          oid: EXTS.extKeyUsage,
          critical: true,
        });
      }
      exts.push({ oid: EXTS.altName });
      if (sig.extras && sig.extras.exts) exts = sig.extras.exts;
      for (var i = 0; i < exts.length; ++i) {
        der.startSequence();
        der.writeOID(exts[i].oid);
        if (exts[i].critical !== void 0) der.writeBoolean(exts[i].critical);
        if (exts[i].oid === EXTS.altName) {
          der.startSequence(asn1.Ber.OctetString);
          der.startSequence();
          if (subject.type === 'host') {
            der.writeString(subject.hostname, Context(2));
          }
          for (var j = 0; j < altNames.length; ++j) {
            if (altNames[j].type === 'host') {
              der.writeString(altNames[j].hostname, ALTNAME.DNSName);
            } else if (altNames[j].type === 'email') {
              der.writeString(altNames[j].email, ALTNAME.RFC822Name);
            } else {
              der.startSequence(ALTNAME.DirectoryName);
              altNames[j].toAsn1(der);
              der.endSequence();
            }
          }
          der.endSequence();
          der.endSequence();
        } else if (exts[i].oid === EXTS.basicConstraints) {
          der.startSequence(asn1.Ber.OctetString);
          der.startSequence();
          var ca = cert.purposes.indexOf('ca') !== -1;
          var pathLen = exts[i].pathLen;
          der.writeBoolean(ca);
          if (pathLen !== void 0) der.writeInt(pathLen);
          der.endSequence();
          der.endSequence();
        } else if (exts[i].oid === EXTS.extKeyUsage) {
          der.startSequence(asn1.Ber.OctetString);
          der.startSequence();
          cert.purposes.forEach(function (purpose) {
            if (purpose === 'ca') return;
            if (KEYUSEBITS.indexOf(purpose) !== -1) return;
            var oid = purpose;
            if (EXTPURPOSE[purpose] !== void 0) oid = EXTPURPOSE[purpose];
            der.writeOID(oid);
          });
          der.endSequence();
          der.endSequence();
        } else if (exts[i].oid === EXTS.keyUsage) {
          der.startSequence(asn1.Ber.OctetString);
          if (exts[i].bits !== void 0) {
            der.writeBuffer(exts[i].bits, asn1.Ber.BitString);
          } else {
            var bits = writeBitField(cert.purposes, KEYUSEBITS);
            der.writeBuffer(bits, asn1.Ber.BitString);
          }
          der.endSequence();
        } else {
          der.writeBuffer(exts[i].data, asn1.Ber.OctetString);
        }
        der.endSequence();
      }
      der.endSequence();
      der.endSequence();
    }
    der.endSequence();
  }
  function readBitField(bits, bitIndex) {
    var bitLen = 8 * (bits.length - 1) - bits[0];
    var setBits = {};
    for (var i = 0; i < bitLen; ++i) {
      var byteN = 1 + Math.floor(i / 8);
      var bit = 7 - (i % 8);
      var mask = 1 << bit;
      var bitVal = (bits[byteN] & mask) !== 0;
      var name = bitIndex[i];
      if (bitVal && typeof name === 'string') {
        setBits[name] = true;
      }
    }
    return Object.keys(setBits);
  }
  function writeBitField(setBits, bitIndex) {
    var bitLen = bitIndex.length;
    var blen = Math.ceil(bitLen / 8);
    var unused = blen * 8 - bitLen;
    var bits = Buffer2.alloc(1 + blen);
    bits[0] = unused;
    for (var i = 0; i < bitLen; ++i) {
      var byteN = 1 + Math.floor(i / 8);
      var bit = 7 - (i % 8);
      var mask = 1 << bit;
      var name = bitIndex[i];
      if (name === void 0) continue;
      var bitVal = setBits.indexOf(name) !== -1;
      if (bitVal) {
        bits[byteN] |= mask;
      }
    }
    return bits;
  }
});

// node_modules/sshpk/lib/formats/x509-pem.js
var require_x509_pem = __commonJS((exports2, module2) => {
  var x509 = require_x509();
  module2.exports = {
    read,
    verify: x509.verify,
    sign: x509.sign,
    write,
  };
  var assert = require_assert();
  var asn1 = require_lib();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var utils = require_utils4();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var pem = require_pem();
  var Identity = require_identity();
  var Signature = require_signature();
  var Certificate = require_certificate();
  function read(buf, options) {
    if (typeof buf !== 'string') {
      assert.buffer(buf, 'buf');
      buf = buf.toString('ascii');
    }
    var lines = buf.trim().split(/[\r\n]+/g);
    var m;
    var si = -1;
    while (!m && si < lines.length) {
      m = lines[++si].match(/[-]+[ ]*BEGIN CERTIFICATE[ ]*[-]+/);
    }
    assert.ok(m, 'invalid PEM header');
    var m2;
    var ei = lines.length;
    while (!m2 && ei > 0) {
      m2 = lines[--ei].match(/[-]+[ ]*END CERTIFICATE[ ]*[-]+/);
    }
    assert.ok(m2, 'invalid PEM footer');
    lines = lines.slice(si, ei + 1);
    var headers = {};
    while (true) {
      lines = lines.slice(1);
      m = lines[0].match(/^([A-Za-z0-9-]+): (.+)$/);
      if (!m) break;
      headers[m[1].toLowerCase()] = m[2];
    }
    lines = lines.slice(0, -1).join('');
    buf = Buffer2.from(lines, 'base64');
    return x509.read(buf, options);
  }
  function write(cert, options) {
    var dbuf = x509.write(cert, options);
    var header = 'CERTIFICATE';
    var tmp = dbuf.toString('base64');
    var len = tmp.length + tmp.length / 64 + 18 + 16 + header.length * 2 + 10;
    var buf = Buffer2.alloc(len);
    var o = 0;
    o += buf.write('-----BEGIN ' + header + '-----\n', o);
    for (var i = 0; i < tmp.length; ) {
      var limit = i + 64;
      if (limit > tmp.length) limit = tmp.length;
      o += buf.write(tmp.slice(i, limit), o);
      buf[o++] = 10;
      i = limit;
    }
    o += buf.write('-----END ' + header + '-----\n', o);
    return buf.slice(0, o);
  }
});

// node_modules/sshpk/lib/certificate.js
var require_certificate = __commonJS((exports2, module2) => {
  module2.exports = Certificate;
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var crypto = require('crypto');
  var Fingerprint = require_fingerprint();
  var Signature = require_signature();
  var errs = require_errors();
  var util = require('util');
  var utils = require_utils4();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var Identity = require_identity();
  var formats = {};
  formats['openssh'] = require_openssh_cert();
  formats['x509'] = require_x509();
  formats['pem'] = require_x509_pem();
  var CertificateParseError = errs.CertificateParseError;
  var InvalidAlgorithmError = errs.InvalidAlgorithmError;
  function Certificate(opts) {
    assert.object(opts, 'options');
    assert.arrayOfObject(opts.subjects, 'options.subjects');
    utils.assertCompatible(
      opts.subjects[0],
      Identity,
      [1, 0],
      'options.subjects',
    );
    utils.assertCompatible(opts.subjectKey, Key, [1, 0], 'options.subjectKey');
    utils.assertCompatible(opts.issuer, Identity, [1, 0], 'options.issuer');
    if (opts.issuerKey !== void 0) {
      utils.assertCompatible(opts.issuerKey, Key, [1, 0], 'options.issuerKey');
    }
    assert.object(opts.signatures, 'options.signatures');
    assert.buffer(opts.serial, 'options.serial');
    assert.date(opts.validFrom, 'options.validFrom');
    assert.date(opts.validUntil, 'optons.validUntil');
    assert.optionalArrayOfString(opts.purposes, 'options.purposes');
    this._hashCache = {};
    this.subjects = opts.subjects;
    this.issuer = opts.issuer;
    this.subjectKey = opts.subjectKey;
    this.issuerKey = opts.issuerKey;
    this.signatures = opts.signatures;
    this.serial = opts.serial;
    this.validFrom = opts.validFrom;
    this.validUntil = opts.validUntil;
    this.purposes = opts.purposes;
  }
  Certificate.formats = formats;
  Certificate.prototype.toBuffer = function (format, options) {
    if (format === void 0) format = 'x509';
    assert.string(format, 'format');
    assert.object(formats[format], 'formats[format]');
    assert.optionalObject(options, 'options');
    return formats[format].write(this, options);
  };
  Certificate.prototype.toString = function (format, options) {
    if (format === void 0) format = 'pem';
    return this.toBuffer(format, options).toString();
  };
  Certificate.prototype.fingerprint = function (algo) {
    if (algo === void 0) algo = 'sha256';
    assert.string(algo, 'algorithm');
    var opts = {
      type: 'certificate',
      hash: this.hash(algo),
      algorithm: algo,
    };
    return new Fingerprint(opts);
  };
  Certificate.prototype.hash = function (algo) {
    assert.string(algo, 'algorithm');
    algo = algo.toLowerCase();
    if (algs.hashAlgs[algo] === void 0) throw new InvalidAlgorithmError(algo);
    if (this._hashCache[algo]) return this._hashCache[algo];
    var hash = crypto.createHash(algo).update(this.toBuffer('x509')).digest();
    this._hashCache[algo] = hash;
    return hash;
  };
  Certificate.prototype.isExpired = function (when) {
    if (when === void 0) when = new Date();
    return !(
      when.getTime() >= this.validFrom.getTime() &&
      when.getTime() < this.validUntil.getTime()
    );
  };
  Certificate.prototype.isSignedBy = function (issuerCert) {
    utils.assertCompatible(issuerCert, Certificate, [1, 0], 'issuer');
    if (!this.issuer.equals(issuerCert.subjects[0])) return false;
    if (
      this.issuer.purposes &&
      this.issuer.purposes.length > 0 &&
      this.issuer.purposes.indexOf('ca') === -1
    ) {
      return false;
    }
    return this.isSignedByKey(issuerCert.subjectKey);
  };
  Certificate.prototype.getExtension = function (keyOrOid) {
    assert.string(keyOrOid, 'keyOrOid');
    var ext = this.getExtensions().filter(function (maybeExt) {
      if (maybeExt.format === 'x509') return maybeExt.oid === keyOrOid;
      if (maybeExt.format === 'openssh') return maybeExt.name === keyOrOid;
      return false;
    })[0];
    return ext;
  };
  Certificate.prototype.getExtensions = function () {
    var exts = [];
    var x509 = this.signatures.x509;
    if (x509 && x509.extras && x509.extras.exts) {
      x509.extras.exts.forEach(function (ext) {
        ext.format = 'x509';
        exts.push(ext);
      });
    }
    var openssh = this.signatures.openssh;
    if (openssh && openssh.exts) {
      openssh.exts.forEach(function (ext) {
        ext.format = 'openssh';
        exts.push(ext);
      });
    }
    return exts;
  };
  Certificate.prototype.isSignedByKey = function (issuerKey) {
    utils.assertCompatible(issuerKey, Key, [1, 2], 'issuerKey');
    if (this.issuerKey !== void 0) {
      return this.issuerKey.fingerprint('sha512').matches(issuerKey);
    }
    var fmt = Object.keys(this.signatures)[0];
    var valid = formats[fmt].verify(this, issuerKey);
    if (valid) this.issuerKey = issuerKey;
    return valid;
  };
  Certificate.prototype.signWith = function (key) {
    utils.assertCompatible(key, PrivateKey, [1, 2], 'key');
    var fmts = Object.keys(formats);
    var didOne = false;
    for (var i = 0; i < fmts.length; ++i) {
      if (fmts[i] !== 'pem') {
        var ret = formats[fmts[i]].sign(this, key);
        if (ret === true) didOne = true;
      }
    }
    if (!didOne) {
      throw new Error(
        'Failed to sign the certificate for any available certificate formats',
      );
    }
  };
  Certificate.createSelfSigned = function (subjectOrSubjects, key, options) {
    var subjects;
    if (Array.isArray(subjectOrSubjects)) subjects = subjectOrSubjects;
    else subjects = [subjectOrSubjects];
    assert.arrayOfObject(subjects);
    subjects.forEach(function (subject) {
      utils.assertCompatible(subject, Identity, [1, 0], 'subject');
    });
    utils.assertCompatible(key, PrivateKey, [1, 2], 'private key');
    assert.optionalObject(options, 'options');
    if (options === void 0) options = {};
    assert.optionalObject(options.validFrom, 'options.validFrom');
    assert.optionalObject(options.validUntil, 'options.validUntil');
    var validFrom = options.validFrom;
    var validUntil = options.validUntil;
    if (validFrom === void 0) validFrom = new Date();
    if (validUntil === void 0) {
      assert.optionalNumber(options.lifetime, 'options.lifetime');
      var lifetime = options.lifetime;
      if (lifetime === void 0) lifetime = 10 * 365 * 24 * 3600;
      validUntil = new Date();
      validUntil.setTime(validUntil.getTime() + lifetime * 1e3);
    }
    assert.optionalBuffer(options.serial, 'options.serial');
    var serial = options.serial;
    if (serial === void 0) serial = Buffer2.from('0000000000000001', 'hex');
    var purposes = options.purposes;
    if (purposes === void 0) purposes = [];
    if (purposes.indexOf('signature') === -1) purposes.push('signature');
    if (purposes.indexOf('ca') === -1) purposes.push('ca');
    if (purposes.indexOf('crl') === -1) purposes.push('crl');
    if (purposes.length <= 3) {
      var hostSubjects = subjects.filter(function (subject) {
        return subject.type === 'host';
      });
      var userSubjects = subjects.filter(function (subject) {
        return subject.type === 'user';
      });
      if (hostSubjects.length > 0) {
        if (purposes.indexOf('serverAuth') === -1) purposes.push('serverAuth');
      }
      if (userSubjects.length > 0) {
        if (purposes.indexOf('clientAuth') === -1) purposes.push('clientAuth');
      }
      if (userSubjects.length > 0 || hostSubjects.length > 0) {
        if (purposes.indexOf('keyAgreement') === -1)
          purposes.push('keyAgreement');
        if (key.type === 'rsa' && purposes.indexOf('encryption') === -1)
          purposes.push('encryption');
      }
    }
    var cert = new Certificate({
      subjects,
      issuer: subjects[0],
      subjectKey: key.toPublic(),
      issuerKey: key.toPublic(),
      signatures: {},
      serial,
      validFrom,
      validUntil,
      purposes,
    });
    cert.signWith(key);
    return cert;
  };
  Certificate.create = function (
    subjectOrSubjects,
    key,
    issuer,
    issuerKey,
    options,
  ) {
    var subjects;
    if (Array.isArray(subjectOrSubjects)) subjects = subjectOrSubjects;
    else subjects = [subjectOrSubjects];
    assert.arrayOfObject(subjects);
    subjects.forEach(function (subject) {
      utils.assertCompatible(subject, Identity, [1, 0], 'subject');
    });
    utils.assertCompatible(key, Key, [1, 0], 'key');
    if (PrivateKey.isPrivateKey(key)) key = key.toPublic();
    utils.assertCompatible(issuer, Identity, [1, 0], 'issuer');
    utils.assertCompatible(issuerKey, PrivateKey, [1, 2], 'issuer key');
    assert.optionalObject(options, 'options');
    if (options === void 0) options = {};
    assert.optionalObject(options.validFrom, 'options.validFrom');
    assert.optionalObject(options.validUntil, 'options.validUntil');
    var validFrom = options.validFrom;
    var validUntil = options.validUntil;
    if (validFrom === void 0) validFrom = new Date();
    if (validUntil === void 0) {
      assert.optionalNumber(options.lifetime, 'options.lifetime');
      var lifetime = options.lifetime;
      if (lifetime === void 0) lifetime = 10 * 365 * 24 * 3600;
      validUntil = new Date();
      validUntil.setTime(validUntil.getTime() + lifetime * 1e3);
    }
    assert.optionalBuffer(options.serial, 'options.serial');
    var serial = options.serial;
    if (serial === void 0) serial = Buffer2.from('0000000000000001', 'hex');
    var purposes = options.purposes;
    if (purposes === void 0) purposes = [];
    if (purposes.indexOf('signature') === -1) purposes.push('signature');
    if (options.ca === true) {
      if (purposes.indexOf('ca') === -1) purposes.push('ca');
      if (purposes.indexOf('crl') === -1) purposes.push('crl');
    }
    var hostSubjects = subjects.filter(function (subject) {
      return subject.type === 'host';
    });
    var userSubjects = subjects.filter(function (subject) {
      return subject.type === 'user';
    });
    if (hostSubjects.length > 0) {
      if (purposes.indexOf('serverAuth') === -1) purposes.push('serverAuth');
    }
    if (userSubjects.length > 0) {
      if (purposes.indexOf('clientAuth') === -1) purposes.push('clientAuth');
    }
    if (userSubjects.length > 0 || hostSubjects.length > 0) {
      if (purposes.indexOf('keyAgreement') === -1)
        purposes.push('keyAgreement');
      if (key.type === 'rsa' && purposes.indexOf('encryption') === -1)
        purposes.push('encryption');
    }
    var cert = new Certificate({
      subjects,
      issuer,
      subjectKey: key,
      issuerKey: issuerKey.toPublic(),
      signatures: {},
      serial,
      validFrom,
      validUntil,
      purposes,
    });
    cert.signWith(issuerKey);
    return cert;
  };
  Certificate.parse = function (data, format, options) {
    if (typeof data !== 'string') assert.buffer(data, 'data');
    if (format === void 0) format = 'auto';
    assert.string(format, 'format');
    if (typeof options === 'string') options = { filename: options };
    assert.optionalObject(options, 'options');
    if (options === void 0) options = {};
    assert.optionalString(options.filename, 'options.filename');
    if (options.filename === void 0) options.filename = '(unnamed)';
    assert.object(formats[format], 'formats[format]');
    try {
      var k = formats[format].read(data, options);
      return k;
    } catch (e) {
      throw new CertificateParseError(options.filename, format, e);
    }
  };
  Certificate.isCertificate = function (obj, ver) {
    return utils.isCompatible(obj, Certificate, ver);
  };
  Certificate.prototype._sshpkApiVersion = [1, 1];
  Certificate._oldVersionDetect = function (obj) {
    return [1, 0];
  };
});

// node_modules/sshpk/lib/fingerprint.js
var require_fingerprint = __commonJS((exports2, module2) => {
  module2.exports = Fingerprint;
  var assert = require_assert();
  var Buffer2 = require_safer().Buffer;
  var algs = require_algs();
  var crypto = require('crypto');
  var errs = require_errors();
  var Key = require_key();
  var PrivateKey = require_private_key();
  var Certificate = require_certificate();
  var utils = require_utils4();
  var FingerprintFormatError = errs.FingerprintFormatError;
  var InvalidAlgorithmError = errs.InvalidAlgorithmError;
  function Fingerprint(opts) {
    assert.object(opts, 'options');
    assert.string(opts.type, 'options.type');
    assert.buffer(opts.hash, 'options.hash');
    assert.string(opts.algorithm, 'options.algorithm');
    this.algorithm = opts.algorithm.toLowerCase();
    if (algs.hashAlgs[this.algorithm] !== true)
      throw new InvalidAlgorithmError(this.algorithm);
    this.hash = opts.hash;
    this.type = opts.type;
    this.hashType = opts.hashType;
  }
  Fingerprint.prototype.toString = function (format) {
    if (format === void 0) {
      if (this.algorithm === 'md5' || this.hashType === 'spki') format = 'hex';
      else format = 'base64';
    }
    assert.string(format);
    switch (format) {
      case 'hex':
        if (this.hashType === 'spki') return this.hash.toString('hex');
        return addColons(this.hash.toString('hex'));
      case 'base64':
        if (this.hashType === 'spki') return this.hash.toString('base64');
        return sshBase64Format(this.algorithm, this.hash.toString('base64'));
      default:
        throw new FingerprintFormatError(void 0, format);
    }
  };
  Fingerprint.prototype.matches = function (other) {
    assert.object(other, 'key or certificate');
    if (this.type === 'key' && this.hashType !== 'ssh') {
      utils.assertCompatible(other, Key, [1, 7], 'key with spki');
      if (PrivateKey.isPrivateKey(other)) {
        utils.assertCompatible(
          other,
          PrivateKey,
          [1, 6],
          'privatekey with spki support',
        );
      }
    } else if (this.type === 'key') {
      utils.assertCompatible(other, Key, [1, 0], 'key');
    } else {
      utils.assertCompatible(other, Certificate, [1, 0], 'certificate');
    }
    var theirHash = other.hash(this.algorithm, this.hashType);
    var theirHash2 = crypto
      .createHash(this.algorithm)
      .update(theirHash)
      .digest('base64');
    if (this.hash2 === void 0)
      this.hash2 = crypto
        .createHash(this.algorithm)
        .update(this.hash)
        .digest('base64');
    return this.hash2 === theirHash2;
  };
  var base64RE = /^[A-Za-z0-9+\/=]+$/;
  var hexRE = /^[a-fA-F0-9]+$/;
  Fingerprint.parse = function (fp, options) {
    assert.string(fp, 'fingerprint');
    var alg, hash, enAlgs;
    if (Array.isArray(options)) {
      enAlgs = options;
      options = {};
    }
    assert.optionalObject(options, 'options');
    if (options === void 0) options = {};
    if (options.enAlgs !== void 0) enAlgs = options.enAlgs;
    if (options.algorithms !== void 0) enAlgs = options.algorithms;
    assert.optionalArrayOfString(enAlgs, 'algorithms');
    var hashType = 'ssh';
    if (options.hashType !== void 0) hashType = options.hashType;
    assert.string(hashType, 'options.hashType');
    var parts = fp.split(':');
    if (parts.length == 2) {
      alg = parts[0].toLowerCase();
      if (!base64RE.test(parts[1])) throw new FingerprintFormatError(fp);
      try {
        hash = Buffer2.from(parts[1], 'base64');
      } catch (e) {
        throw new FingerprintFormatError(fp);
      }
    } else if (parts.length > 2) {
      alg = 'md5';
      if (parts[0].toLowerCase() === 'md5') parts = parts.slice(1);
      parts = parts.map(function (p) {
        while (p.length < 2) p = '0' + p;
        if (p.length > 2) throw new FingerprintFormatError(fp);
        return p;
      });
      parts = parts.join('');
      if (!hexRE.test(parts) || parts.length % 2 !== 0)
        throw new FingerprintFormatError(fp);
      try {
        hash = Buffer2.from(parts, 'hex');
      } catch (e) {
        throw new FingerprintFormatError(fp);
      }
    } else {
      if (hexRE.test(fp)) {
        hash = Buffer2.from(fp, 'hex');
      } else if (base64RE.test(fp)) {
        hash = Buffer2.from(fp, 'base64');
      } else {
        throw new FingerprintFormatError(fp);
      }
      switch (hash.length) {
        case 32:
          alg = 'sha256';
          break;
        case 16:
          alg = 'md5';
          break;
        case 20:
          alg = 'sha1';
          break;
        case 64:
          alg = 'sha512';
          break;
        default:
          throw new FingerprintFormatError(fp);
      }
      if (options.hashType === void 0) hashType = 'spki';
    }
    if (alg === void 0) throw new FingerprintFormatError(fp);
    if (algs.hashAlgs[alg] === void 0) throw new InvalidAlgorithmError(alg);
    if (enAlgs !== void 0) {
      enAlgs = enAlgs.map(function (a) {
        return a.toLowerCase();
      });
      if (enAlgs.indexOf(alg) === -1) throw new InvalidAlgorithmError(alg);
    }
    return new Fingerprint({
      algorithm: alg,
      hash,
      type: options.type || 'key',
      hashType,
    });
  };
  function addColons(s) {
    return s.replace(/(.{2})(?=.)/g, '$1:');
  }
  function base64Strip(s) {
    return s.replace(/=*$/, '');
  }
  function sshBase64Format(alg, h) {
    return alg.toUpperCase() + ':' + base64Strip(h);
  }
  Fingerprint.isFingerprint = function (obj, ver) {
    return utils.isCompatible(obj, Fingerprint, ver);
  };
  Fingerprint.prototype._sshpkApiVersion = [1, 2];
  Fingerprint._oldVersionDetect = function (obj) {
    assert.func(obj.toString);
    assert.func(obj.matches);
    return [1, 0];
  };
});

// node_modules/sshpk/lib/key.js
var require_key = __commonJS((exports2, module2) => {
  module2.exports = Key;
  var assert = require_assert();
  var algs = require_algs();
  var crypto = require('crypto');
  var Fingerprint = require_fingerprint();
  var Signature = require_signature();
  var DiffieHellman = require_dhe().DiffieHellman;
  var errs = require_errors();
  var utils = require_utils4();
  var PrivateKey = require_private_key();
  var edCompat;
  try {
    edCompat = require_ed_compat();
  } catch (e) {}
  var InvalidAlgorithmError = errs.InvalidAlgorithmError;
  var KeyParseError = errs.KeyParseError;
  var formats = {};
  formats['auto'] = require_auto();
  formats['pem'] = require_pem();
  formats['pkcs1'] = require_pkcs1();
  formats['pkcs8'] = require_pkcs8();
  formats['rfc4253'] = require_rfc4253();
  formats['ssh'] = require_ssh();
  formats['ssh-private'] = require_ssh_private();
  formats['openssh'] = formats['ssh-private'];
  formats['dnssec'] = require_dnssec();
  formats['putty'] = require_putty();
  formats['ppk'] = formats['putty'];
  function Key(opts) {
    assert.object(opts, 'options');
    assert.arrayOfObject(opts.parts, 'options.parts');
    assert.string(opts.type, 'options.type');
    assert.optionalString(opts.comment, 'options.comment');
    var algInfo = algs.info[opts.type];
    if (typeof algInfo !== 'object') throw new InvalidAlgorithmError(opts.type);
    var partLookup = {};
    for (var i = 0; i < opts.parts.length; ++i) {
      var part = opts.parts[i];
      partLookup[part.name] = part;
    }
    this.type = opts.type;
    this.parts = opts.parts;
    this.part = partLookup;
    this.comment = void 0;
    this.source = opts.source;
    this._rfc4253Cache = opts._rfc4253Cache;
    this._hashCache = {};
    var sz;
    this.curve = void 0;
    if (this.type === 'ecdsa') {
      var curve = this.part.curve.data.toString();
      this.curve = curve;
      sz = algs.curves[curve].size;
    } else if (this.type === 'ed25519' || this.type === 'curve25519') {
      sz = 256;
      this.curve = 'curve25519';
    } else {
      var szPart = this.part[algInfo.sizePart];
      sz = szPart.data.length;
      sz = sz * 8 - utils.countZeros(szPart.data);
    }
    this.size = sz;
  }
  Key.formats = formats;
  Key.prototype.toBuffer = function (format, options) {
    if (format === void 0) format = 'ssh';
    assert.string(format, 'format');
    assert.object(formats[format], 'formats[format]');
    assert.optionalObject(options, 'options');
    if (format === 'rfc4253') {
      if (this._rfc4253Cache === void 0)
        this._rfc4253Cache = formats['rfc4253'].write(this);
      return this._rfc4253Cache;
    }
    return formats[format].write(this, options);
  };
  Key.prototype.toString = function (format, options) {
    return this.toBuffer(format, options).toString();
  };
  Key.prototype.hash = function (algo, type) {
    assert.string(algo, 'algorithm');
    assert.optionalString(type, 'type');
    if (type === void 0) type = 'ssh';
    algo = algo.toLowerCase();
    if (algs.hashAlgs[algo] === void 0) throw new InvalidAlgorithmError(algo);
    var cacheKey = algo + '||' + type;
    if (this._hashCache[cacheKey]) return this._hashCache[cacheKey];
    var buf;
    if (type === 'ssh') {
      buf = this.toBuffer('rfc4253');
    } else if (type === 'spki') {
      buf = formats.pkcs8.pkcs8ToBuffer(this);
    } else {
      throw new Error('Hash type ' + type + ' not supported');
    }
    var hash = crypto.createHash(algo).update(buf).digest();
    this._hashCache[cacheKey] = hash;
    return hash;
  };
  Key.prototype.fingerprint = function (algo, type) {
    if (algo === void 0) algo = 'sha256';
    if (type === void 0) type = 'ssh';
    assert.string(algo, 'algorithm');
    assert.string(type, 'type');
    var opts = {
      type: 'key',
      hash: this.hash(algo, type),
      algorithm: algo,
      hashType: type,
    };
    return new Fingerprint(opts);
  };
  Key.prototype.defaultHashAlgorithm = function () {
    var hashAlgo = 'sha1';
    if (this.type === 'rsa') hashAlgo = 'sha256';
    if (this.type === 'dsa' && this.size > 1024) hashAlgo = 'sha256';
    if (this.type === 'ed25519') hashAlgo = 'sha512';
    if (this.type === 'ecdsa') {
      if (this.size <= 256) hashAlgo = 'sha256';
      else if (this.size <= 384) hashAlgo = 'sha384';
      else hashAlgo = 'sha512';
    }
    return hashAlgo;
  };
  Key.prototype.createVerify = function (hashAlgo) {
    if (hashAlgo === void 0) hashAlgo = this.defaultHashAlgorithm();
    assert.string(hashAlgo, 'hash algorithm');
    if (this.type === 'ed25519' && edCompat !== void 0)
      return new edCompat.Verifier(this, hashAlgo);
    if (this.type === 'curve25519')
      throw new Error(
        'Curve25519 keys are not suitable for signing or verification',
      );
    var v, nm, err;
    try {
      nm = hashAlgo.toUpperCase();
      v = crypto.createVerify(nm);
    } catch (e) {
      err = e;
    }
    if (
      v === void 0 ||
      (err instanceof Error && err.message.match(/Unknown message digest/))
    ) {
      nm = 'RSA-';
      nm += hashAlgo.toUpperCase();
      v = crypto.createVerify(nm);
    }
    assert.ok(v, 'failed to create verifier');
    var oldVerify = v.verify.bind(v);
    var key = this.toBuffer('pkcs8');
    var curve = this.curve;
    var self2 = this;
    v.verify = function (signature, fmt) {
      if (Signature.isSignature(signature, [2, 0])) {
        if (signature.type !== self2.type) return false;
        if (signature.hashAlgorithm && signature.hashAlgorithm !== hashAlgo)
          return false;
        if (
          signature.curve &&
          self2.type === 'ecdsa' &&
          signature.curve !== curve
        )
          return false;
        return oldVerify(key, signature.toBuffer('asn1'));
      } else if (typeof signature === 'string' || Buffer.isBuffer(signature)) {
        return oldVerify(key, signature, fmt);
      } else if (Signature.isSignature(signature, [1, 0])) {
        throw new Error(
          'signature was created by too old a version of sshpk and cannot be verified',
        );
      } else {
        throw new TypeError(
          'signature must be a string, Buffer, or Signature object',
        );
      }
    };
    return v;
  };
  Key.prototype.createDiffieHellman = function () {
    if (this.type === 'rsa')
      throw new Error('RSA keys do not support Diffie-Hellman');
    return new DiffieHellman(this);
  };
  Key.prototype.createDH = Key.prototype.createDiffieHellman;
  Key.parse = function (data, format, options) {
    if (typeof data !== 'string') assert.buffer(data, 'data');
    if (format === void 0) format = 'auto';
    assert.string(format, 'format');
    if (typeof options === 'string') options = { filename: options };
    assert.optionalObject(options, 'options');
    if (options === void 0) options = {};
    assert.optionalString(options.filename, 'options.filename');
    if (options.filename === void 0) options.filename = '(unnamed)';
    assert.object(formats[format], 'formats[format]');
    try {
      var k = formats[format].read(data, options);
      if (k instanceof PrivateKey) k = k.toPublic();
      if (!k.comment) k.comment = options.filename;
      return k;
    } catch (e) {
      if (e.name === 'KeyEncryptedError') throw e;
      throw new KeyParseError(options.filename, format, e);
    }
  };
  Key.isKey = function (obj, ver) {
    return utils.isCompatible(obj, Key, ver);
  };
  Key.prototype._sshpkApiVersion = [1, 7];
  Key._oldVersionDetect = function (obj) {
    assert.func(obj.toBuffer);
    assert.func(obj.fingerprint);
    if (obj.createDH) return [1, 4];
    if (obj.defaultHashAlgorithm) return [1, 3];
    if (obj.formats['auto']) return [1, 2];
    if (obj.formats['pkcs1']) return [1, 1];
    return [1, 0];
  };
});

// node_modules/sshpk/lib/index.js
var require_lib2 = __commonJS((exports2, module2) => {
  var Key = require_key();
  var Fingerprint = require_fingerprint();
  var Signature = require_signature();
  var PrivateKey = require_private_key();
  var Certificate = require_certificate();
  var Identity = require_identity();
  var errs = require_errors();
  module2.exports = {
    Key,
    parseKey: Key.parse,
    Fingerprint,
    parseFingerprint: Fingerprint.parse,
    Signature,
    parseSignature: Signature.parse,
    PrivateKey,
    parsePrivateKey: PrivateKey.parse,
    generatePrivateKey: PrivateKey.generate,
    Certificate,
    parseCertificate: Certificate.parse,
    createSelfSignedCertificate: Certificate.createSelfSigned,
    createCertificate: Certificate.create,
    Identity,
    identityFromDN: Identity.parseDN,
    identityForHost: Identity.forHost,
    identityForUser: Identity.forUser,
    identityForEmail: Identity.forEmail,
    identityFromArray: Identity.fromArray,
    FingerprintFormatError: errs.FingerprintFormatError,
    InvalidAlgorithmError: errs.InvalidAlgorithmError,
    KeyParseError: errs.KeyParseError,
    SignatureParseError: errs.SignatureParseError,
    KeyEncryptedError: errs.KeyEncryptedError,
    CertificateParseError: errs.CertificateParseError,
  };
});

// node_modules/http-signature/lib/utils.js
var require_utils5 = __commonJS((exports2, module2) => {
  var assert = require_assert();
  var sshpk = require_lib2();
  var util = require('util');
  var HASH_ALGOS = {
    sha1: true,
    sha256: true,
    sha512: true,
  };
  var PK_ALGOS = {
    rsa: true,
    dsa: true,
    ecdsa: true,
  };
  function HttpSignatureError(message, caller) {
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, caller || HttpSignatureError);
    this.message = message;
    this.name = caller.name;
  }
  util.inherits(HttpSignatureError, Error);
  function InvalidAlgorithmError(message) {
    HttpSignatureError.call(this, message, InvalidAlgorithmError);
  }
  util.inherits(InvalidAlgorithmError, HttpSignatureError);
  function validateAlgorithm(algorithm) {
    var alg = algorithm.toLowerCase().split('-');
    if (alg.length !== 2) {
      throw new InvalidAlgorithmError(
        alg[0].toUpperCase() + ' is not a valid algorithm',
      );
    }
    if (alg[0] !== 'hmac' && !PK_ALGOS[alg[0]]) {
      throw new InvalidAlgorithmError(
        alg[0].toUpperCase() + ' type keys are not supported',
      );
    }
    if (!HASH_ALGOS[alg[1]]) {
      throw new InvalidAlgorithmError(
        alg[1].toUpperCase() + ' is not a supported hash algorithm',
      );
    }
    return alg;
  }
  module2.exports = {
    HASH_ALGOS,
    PK_ALGOS,
    HttpSignatureError,
    InvalidAlgorithmError,
    validateAlgorithm,
    sshKeyToPEM: function sshKeyToPEM(key) {
      assert.string(key, 'ssh_key');
      var k = sshpk.parseKey(key, 'ssh');
      return k.toString('pem');
    },
    fingerprint: function fingerprint(key) {
      assert.string(key, 'ssh_key');
      var k = sshpk.parseKey(key, 'ssh');
      return k.fingerprint('md5').toString('hex');
    },
    pemToRsaSSHKey: function pemToRsaSSHKey(pem, comment) {
      assert.equal('string', typeof pem, 'typeof pem');
      var k = sshpk.parseKey(pem, 'pem');
      k.comment = comment;
      return k.toString('ssh');
    },
  };
});

// node_modules/http-signature/lib/parser.js
var require_parser = __commonJS((exports2, module2) => {
  var assert = require_assert();
  var util = require('util');
  var utils = require_utils5();
  var HASH_ALGOS = utils.HASH_ALGOS;
  var PK_ALGOS = utils.PK_ALGOS;
  var HttpSignatureError = utils.HttpSignatureError;
  var InvalidAlgorithmError = utils.InvalidAlgorithmError;
  var validateAlgorithm = utils.validateAlgorithm;
  var State = {
    New: 0,
    Params: 1,
  };
  var ParamsState = {
    Name: 0,
    Quote: 1,
    Value: 2,
    Comma: 3,
  };
  function ExpiredRequestError(message) {
    HttpSignatureError.call(this, message, ExpiredRequestError);
  }
  util.inherits(ExpiredRequestError, HttpSignatureError);
  function InvalidHeaderError(message) {
    HttpSignatureError.call(this, message, InvalidHeaderError);
  }
  util.inherits(InvalidHeaderError, HttpSignatureError);
  function InvalidParamsError(message) {
    HttpSignatureError.call(this, message, InvalidParamsError);
  }
  util.inherits(InvalidParamsError, HttpSignatureError);
  function MissingHeaderError(message) {
    HttpSignatureError.call(this, message, MissingHeaderError);
  }
  util.inherits(MissingHeaderError, HttpSignatureError);
  function StrictParsingError(message) {
    HttpSignatureError.call(this, message, StrictParsingError);
  }
  util.inherits(StrictParsingError, HttpSignatureError);
  module2.exports = {
    parseRequest: function parseRequest(request, options) {
      assert.object(request, 'request');
      assert.object(request.headers, 'request.headers');
      if (options === void 0) {
        options = {};
      }
      if (options.headers === void 0) {
        options.headers = [request.headers['x-date'] ? 'x-date' : 'date'];
      }
      assert.object(options, 'options');
      assert.arrayOfString(options.headers, 'options.headers');
      assert.optionalFinite(options.clockSkew, 'options.clockSkew');
      var authzHeaderName = options.authorizationHeaderName || 'authorization';
      if (!request.headers[authzHeaderName]) {
        throw new MissingHeaderError(
          'no ' + authzHeaderName + ' header present in the request',
        );
      }
      options.clockSkew = options.clockSkew || 300;
      var i = 0;
      var state = State.New;
      var substate = ParamsState.Name;
      var tmpName = '';
      var tmpValue = '';
      var parsed = {
        scheme: '',
        params: {},
        signingString: '',
      };
      var authz = request.headers[authzHeaderName];
      for (i = 0; i < authz.length; i++) {
        var c = authz.charAt(i);
        switch (Number(state)) {
          case State.New:
            if (c !== ' ') parsed.scheme += c;
            else state = State.Params;
            break;
          case State.Params:
            switch (Number(substate)) {
              case ParamsState.Name:
                var code = c.charCodeAt(0);
                if ((code >= 65 && code <= 90) || (code >= 97 && code <= 122)) {
                  tmpName += c;
                } else if (c === '=') {
                  if (tmpName.length === 0)
                    throw new InvalidHeaderError('bad param format');
                  substate = ParamsState.Quote;
                } else {
                  throw new InvalidHeaderError('bad param format');
                }
                break;
              case ParamsState.Quote:
                if (c === '"') {
                  tmpValue = '';
                  substate = ParamsState.Value;
                } else {
                  throw new InvalidHeaderError('bad param format');
                }
                break;
              case ParamsState.Value:
                if (c === '"') {
                  parsed.params[tmpName] = tmpValue;
                  substate = ParamsState.Comma;
                } else {
                  tmpValue += c;
                }
                break;
              case ParamsState.Comma:
                if (c === ',') {
                  tmpName = '';
                  substate = ParamsState.Name;
                } else {
                  throw new InvalidHeaderError('bad param format');
                }
                break;
              default:
                throw new Error('Invalid substate');
            }
            break;
          default:
            throw new Error('Invalid substate');
        }
      }
      if (!parsed.params.headers || parsed.params.headers === '') {
        if (request.headers['x-date']) {
          parsed.params.headers = ['x-date'];
        } else {
          parsed.params.headers = ['date'];
        }
      } else {
        parsed.params.headers = parsed.params.headers.split(' ');
      }
      if (!parsed.scheme || parsed.scheme !== 'Signature')
        throw new InvalidHeaderError('scheme was not "Signature"');
      if (!parsed.params.keyId)
        throw new InvalidHeaderError('keyId was not specified');
      if (!parsed.params.algorithm)
        throw new InvalidHeaderError('algorithm was not specified');
      if (!parsed.params.signature)
        throw new InvalidHeaderError('signature was not specified');
      parsed.params.algorithm = parsed.params.algorithm.toLowerCase();
      try {
        validateAlgorithm(parsed.params.algorithm);
      } catch (e) {
        if (e instanceof InvalidAlgorithmError)
          throw new InvalidParamsError(
            parsed.params.algorithm + ' is not supported',
          );
        else throw e;
      }
      for (i = 0; i < parsed.params.headers.length; i++) {
        var h = parsed.params.headers[i].toLowerCase();
        parsed.params.headers[i] = h;
        if (h === 'request-line') {
          if (!options.strict) {
            parsed.signingString +=
              request.method +
              ' ' +
              request.url +
              ' HTTP/' +
              request.httpVersion;
          } else {
            throw new StrictParsingError(
              'request-line is not a valid header with strict parsing enabled.',
            );
          }
        } else if (h === '(request-target)') {
          parsed.signingString +=
            '(request-target): ' +
            request.method.toLowerCase() +
            ' ' +
            request.url;
        } else {
          var value = request.headers[h];
          if (value === void 0)
            throw new MissingHeaderError(h + ' was not in the request');
          parsed.signingString += h + ': ' + value;
        }
        if (i + 1 < parsed.params.headers.length) parsed.signingString += '\n';
      }
      var date;
      if (request.headers.date || request.headers['x-date']) {
        if (request.headers['x-date']) {
          date = new Date(request.headers['x-date']);
        } else {
          date = new Date(request.headers.date);
        }
        var now2 = new Date();
        var skew = Math.abs(now2.getTime() - date.getTime());
        if (skew > options.clockSkew * 1e3) {
          throw new ExpiredRequestError(
            'clock skew of ' +
              skew / 1e3 +
              's was greater than ' +
              options.clockSkew +
              's',
          );
        }
      }
      options.headers.forEach(function (hdr) {
        if (parsed.params.headers.indexOf(hdr.toLowerCase()) < 0)
          throw new MissingHeaderError(hdr + ' was not a signed header');
      });
      if (options.algorithms) {
        if (options.algorithms.indexOf(parsed.params.algorithm) === -1)
          throw new InvalidParamsError(
            parsed.params.algorithm + ' is not a supported algorithm',
          );
      }
      parsed.algorithm = parsed.params.algorithm.toUpperCase();
      parsed.keyId = parsed.params.keyId;
      return parsed;
    },
  };
});

// node_modules/extsprintf/lib/extsprintf.js
var require_extsprintf = __commonJS((exports2) => {
  var mod_assert = require('assert');
  var mod_util = require('util');
  exports2.sprintf = jsSprintf;
  exports2.printf = jsPrintf;
  exports2.fprintf = jsFprintf;
  function jsSprintf(fmt) {
    var regex = [
      '([^%]*)',
      '%',
      "(['\\-+ #0]*?)",
      '([1-9]\\d*)?',
      '(\\.([1-9]\\d*))?',
      '[lhjztL]*?',
      '([diouxXfFeEgGaAcCsSp%jr])',
    ].join('');
    var re = new RegExp(regex);
    var args = Array.prototype.slice.call(arguments, 1);
    var flags, width, precision, conversion;
    var left, pad, sign, arg, match;
    var ret = '';
    var argn = 1;
    mod_assert.equal('string', typeof fmt);
    while ((match = re.exec(fmt)) !== null) {
      ret += match[1];
      fmt = fmt.substring(match[0].length);
      flags = match[2] || '';
      width = match[3] || 0;
      precision = match[4] || '';
      conversion = match[6];
      left = false;
      sign = false;
      pad = ' ';
      if (conversion == '%') {
        ret += '%';
        continue;
      }
      if (args.length === 0) throw new Error('too few args to sprintf');
      arg = args.shift();
      argn++;
      if (flags.match(/[\' #]/)) throw new Error('unsupported flags: ' + flags);
      if (precision.length > 0)
        throw new Error('non-zero precision not supported');
      if (flags.match(/-/)) left = true;
      if (flags.match(/0/)) pad = '0';
      if (flags.match(/\+/)) sign = true;
      switch (conversion) {
        case 's':
          if (arg === void 0 || arg === null)
            throw new Error(
              'argument ' +
                argn +
                ': attempted to print undefined or null as a string',
            );
          ret += doPad(pad, width, left, arg.toString());
          break;
        case 'd':
          arg = Math.floor(arg);
        case 'f':
          sign = sign && arg > 0 ? '+' : '';
          ret += sign + doPad(pad, width, left, arg.toString());
          break;
        case 'x':
          ret += doPad(pad, width, left, arg.toString(16));
          break;
        case 'j':
          if (width === 0) width = 10;
          ret += mod_util.inspect(arg, false, width);
          break;
        case 'r':
          ret += dumpException(arg);
          break;
        default:
          throw new Error('unsupported conversion: ' + conversion);
      }
    }
    ret += fmt;
    return ret;
  }
  function jsPrintf() {
    var args = Array.prototype.slice.call(arguments);
    args.unshift(process.stdout);
    jsFprintf.apply(null, args);
  }
  function jsFprintf(stream) {
    var args = Array.prototype.slice.call(arguments, 1);
    return stream.write(jsSprintf.apply(this, args));
  }
  function doPad(chr, width, left, str) {
    var ret = str;
    while (ret.length < width) {
      if (left) ret += chr;
      else ret = chr + ret;
    }
    return ret;
  }
  function dumpException(ex) {
    var ret;
    if (!(ex instanceof Error))
      throw new Error(jsSprintf('invalid type for %%r: %j', ex));
    ret = 'EXCEPTION: ' + ex.constructor.name + ': ' + ex.stack;
    if (ex.cause && typeof ex.cause === 'function') {
      var cex = ex.cause();
      if (cex) {
        ret += '\nCaused by: ' + dumpException(cex);
      }
    }
    return ret;
  }
});

// node_modules/verror/node_modules/extsprintf/lib/extsprintf.js
var require_extsprintf2 = __commonJS((exports2) => {
  var mod_assert = require('assert');
  var mod_util = require('util');
  exports2.sprintf = jsSprintf;
  exports2.printf = jsPrintf;
  exports2.fprintf = jsFprintf;
  function jsSprintf(ofmt) {
    var regex = [
      '([^%]*)',
      '%',
      "(['\\-+ #0]*?)",
      '([1-9]\\d*)?',
      '(\\.([1-9]\\d*))?',
      '[lhjztL]*?',
      '([diouxXfFeEgGaAcCsSp%jr])',
    ].join('');
    var re = new RegExp(regex);
    var args = Array.prototype.slice.call(arguments, 1);
    var fmt = ofmt;
    var flags, width, precision, conversion;
    var left, pad, sign, arg, match;
    var ret = '';
    var argn = 1;
    var posn = 0;
    var convposn;
    var curconv;
    mod_assert.equal(
      'string',
      typeof fmt,
      'first argument must be a format string',
    );
    while ((match = re.exec(fmt)) !== null) {
      ret += match[1];
      fmt = fmt.substring(match[0].length);
      curconv = match[0].substring(match[1].length);
      convposn = posn + match[1].length + 1;
      posn += match[0].length;
      flags = match[2] || '';
      width = match[3] || 0;
      precision = match[4] || '';
      conversion = match[6];
      left = false;
      sign = false;
      pad = ' ';
      if (conversion == '%') {
        ret += '%';
        continue;
      }
      if (args.length === 0) {
        throw jsError(
          ofmt,
          convposn,
          curconv,
          'has no matching argument (too few arguments passed)',
        );
      }
      arg = args.shift();
      argn++;
      if (flags.match(/[\' #]/)) {
        throw jsError(ofmt, convposn, curconv, 'uses unsupported flags');
      }
      if (precision.length > 0) {
        throw jsError(
          ofmt,
          convposn,
          curconv,
          'uses non-zero precision (not supported)',
        );
      }
      if (flags.match(/-/)) left = true;
      if (flags.match(/0/)) pad = '0';
      if (flags.match(/\+/)) sign = true;
      switch (conversion) {
        case 's':
          if (arg === void 0 || arg === null) {
            throw jsError(
              ofmt,
              convposn,
              curconv,
              'attempted to print undefined or null as a string (argument ' +
                argn +
                ' to sprintf)',
            );
          }
          ret += doPad(pad, width, left, arg.toString());
          break;
        case 'd':
          arg = Math.floor(arg);
        case 'f':
          sign = sign && arg > 0 ? '+' : '';
          ret += sign + doPad(pad, width, left, arg.toString());
          break;
        case 'x':
          ret += doPad(pad, width, left, arg.toString(16));
          break;
        case 'j':
          if (width === 0) width = 10;
          ret += mod_util.inspect(arg, false, width);
          break;
        case 'r':
          ret += dumpException(arg);
          break;
        default:
          throw jsError(ofmt, convposn, curconv, 'is not supported');
      }
    }
    ret += fmt;
    return ret;
  }
  function jsError(fmtstr, convposn, curconv, reason) {
    mod_assert.equal(typeof fmtstr, 'string');
    mod_assert.equal(typeof curconv, 'string');
    mod_assert.equal(typeof convposn, 'number');
    mod_assert.equal(typeof reason, 'string');
    return new Error(
      'format string "' +
        fmtstr +
        '": conversion specifier "' +
        curconv +
        '" at character ' +
        convposn +
        ' ' +
        reason,
    );
  }
  function jsPrintf() {
    var args = Array.prototype.slice.call(arguments);
    args.unshift(process.stdout);
    jsFprintf.apply(null, args);
  }
  function jsFprintf(stream) {
    var args = Array.prototype.slice.call(arguments, 1);
    return stream.write(jsSprintf.apply(this, args));
  }
  function doPad(chr, width, left, str) {
    var ret = str;
    while (ret.length < width) {
      if (left) ret += chr;
      else ret = chr + ret;
    }
    return ret;
  }
  function dumpException(ex) {
    var ret;
    if (!(ex instanceof Error))
      throw new Error(jsSprintf('invalid type for %%r: %j', ex));
    ret = 'EXCEPTION: ' + ex.constructor.name + ': ' + ex.stack;
    if (ex.cause && typeof ex.cause === 'function') {
      var cex = ex.cause();
      if (cex) {
        ret += '\nCaused by: ' + dumpException(cex);
      }
    }
    return ret;
  }
});

// node_modules/core-util-is/lib/util.js
var require_util2 = __commonJS((exports2) => {
  function isArray(arg) {
    if (Array.isArray) {
      return Array.isArray(arg);
    }
    return objectToString(arg) === '[object Array]';
  }
  exports2.isArray = isArray;
  function isBoolean(arg) {
    return typeof arg === 'boolean';
  }
  exports2.isBoolean = isBoolean;
  function isNull(arg) {
    return arg === null;
  }
  exports2.isNull = isNull;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  exports2.isNullOrUndefined = isNullOrUndefined;
  function isNumber(arg) {
    return typeof arg === 'number';
  }
  exports2.isNumber = isNumber;
  function isString(arg) {
    return typeof arg === 'string';
  }
  exports2.isString = isString;
  function isSymbol(arg) {
    return typeof arg === 'symbol';
  }
  exports2.isSymbol = isSymbol;
  function isUndefined(arg) {
    return arg === void 0;
  }
  exports2.isUndefined = isUndefined;
  function isRegExp(re) {
    return objectToString(re) === '[object RegExp]';
  }
  exports2.isRegExp = isRegExp;
  function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
  }
  exports2.isObject = isObject;
  function isDate(d) {
    return objectToString(d) === '[object Date]';
  }
  exports2.isDate = isDate;
  function isError(e) {
    return objectToString(e) === '[object Error]' || e instanceof Error;
  }
  exports2.isError = isError;
  function isFunction(arg) {
    return typeof arg === 'function';
  }
  exports2.isFunction = isFunction;
  function isPrimitive(arg) {
    return (
      arg === null ||
      typeof arg === 'boolean' ||
      typeof arg === 'number' ||
      typeof arg === 'string' ||
      typeof arg === 'symbol' ||
      typeof arg === 'undefined'
    );
  }
  exports2.isPrimitive = isPrimitive;
  exports2.isBuffer = Buffer.isBuffer;
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
});

// node_modules/verror/lib/verror.js
var require_verror = __commonJS((exports2, module2) => {
  var mod_assertplus = require_assert();
  var mod_util = require('util');
  var mod_extsprintf = require_extsprintf2();
  var mod_isError = require_util2().isError;
  var sprintf = mod_extsprintf.sprintf;
  module2.exports = VError;
  VError.VError = VError;
  VError.SError = SError;
  VError.WError = WError;
  VError.MultiError = MultiError;
  function parseConstructorArguments(args) {
    var argv, options, sprintf_args, shortmessage, k;
    mod_assertplus.object(args, 'args');
    mod_assertplus.bool(args.strict, 'args.strict');
    mod_assertplus.array(args.argv, 'args.argv');
    argv = args.argv;
    if (argv.length === 0) {
      options = {};
      sprintf_args = [];
    } else if (mod_isError(argv[0])) {
      options = { cause: argv[0] };
      sprintf_args = argv.slice(1);
    } else if (typeof argv[0] === 'object') {
      options = {};
      for (k in argv[0]) {
        options[k] = argv[0][k];
      }
      sprintf_args = argv.slice(1);
    } else {
      mod_assertplus.string(
        argv[0],
        'first argument to VError, SError, or WError constructor must be a string, object, or Error',
      );
      options = {};
      sprintf_args = argv;
    }
    mod_assertplus.object(options);
    if (!options.strict && !args.strict) {
      sprintf_args = sprintf_args.map(function (a) {
        return a === null ? 'null' : a === void 0 ? 'undefined' : a;
      });
    }
    if (sprintf_args.length === 0) {
      shortmessage = '';
    } else {
      shortmessage = sprintf.apply(null, sprintf_args);
    }
    return {
      options,
      shortmessage,
    };
  }
  function VError() {
    var args, obj, parsed, cause, ctor, message, k;
    args = Array.prototype.slice.call(arguments, 0);
    if (!(this instanceof VError)) {
      obj = Object.create(VError.prototype);
      VError.apply(obj, arguments);
      return obj;
    }
    parsed = parseConstructorArguments({
      argv: args,
      strict: false,
    });
    if (parsed.options.name) {
      mod_assertplus.string(
        parsed.options.name,
        `error's "name" must be a string`,
      );
      this.name = parsed.options.name;
    }
    this.jse_shortmsg = parsed.shortmessage;
    message = parsed.shortmessage;
    cause = parsed.options.cause;
    if (cause) {
      mod_assertplus.ok(mod_isError(cause), 'cause is not an Error');
      this.jse_cause = cause;
      if (!parsed.options.skipCauseMessage) {
        message += ': ' + cause.message;
      }
    }
    this.jse_info = {};
    if (parsed.options.info) {
      for (k in parsed.options.info) {
        this.jse_info[k] = parsed.options.info[k];
      }
    }
    this.message = message;
    Error.call(this, message);
    if (Error.captureStackTrace) {
      ctor = parsed.options.constructorOpt || this.constructor;
      Error.captureStackTrace(this, ctor);
    }
    return this;
  }
  mod_util.inherits(VError, Error);
  VError.prototype.name = 'VError';
  VError.prototype.toString = function ve_toString() {
    var str =
      (this.hasOwnProperty('name') && this.name) ||
      this.constructor.name ||
      this.constructor.prototype.name;
    if (this.message) str += ': ' + this.message;
    return str;
  };
  VError.prototype.cause = function ve_cause() {
    var cause = VError.cause(this);
    return cause === null ? void 0 : cause;
  };
  VError.cause = function (err) {
    mod_assertplus.ok(mod_isError(err), 'err must be an Error');
    return mod_isError(err.jse_cause) ? err.jse_cause : null;
  };
  VError.info = function (err) {
    var rv, cause, k;
    mod_assertplus.ok(mod_isError(err), 'err must be an Error');
    cause = VError.cause(err);
    if (cause !== null) {
      rv = VError.info(cause);
    } else {
      rv = {};
    }
    if (typeof err.jse_info == 'object' && err.jse_info !== null) {
      for (k in err.jse_info) {
        rv[k] = err.jse_info[k];
      }
    }
    return rv;
  };
  VError.findCauseByName = function (err, name) {
    var cause;
    mod_assertplus.ok(mod_isError(err), 'err must be an Error');
    mod_assertplus.string(name, 'name');
    mod_assertplus.ok(name.length > 0, 'name cannot be empty');
    for (cause = err; cause !== null; cause = VError.cause(cause)) {
      mod_assertplus.ok(mod_isError(cause));
      if (cause.name == name) {
        return cause;
      }
    }
    return null;
  };
  VError.hasCauseWithName = function (err, name) {
    return VError.findCauseByName(err, name) !== null;
  };
  VError.fullStack = function (err) {
    mod_assertplus.ok(mod_isError(err), 'err must be an Error');
    var cause = VError.cause(err);
    if (cause) {
      return err.stack + '\ncaused by: ' + VError.fullStack(cause);
    }
    return err.stack;
  };
  VError.errorFromList = function (errors) {
    mod_assertplus.arrayOfObject(errors, 'errors');
    if (errors.length === 0) {
      return null;
    }
    errors.forEach(function (e) {
      mod_assertplus.ok(mod_isError(e));
    });
    if (errors.length == 1) {
      return errors[0];
    }
    return new MultiError(errors);
  };
  VError.errorForEach = function (err, func) {
    mod_assertplus.ok(mod_isError(err), 'err must be an Error');
    mod_assertplus.func(func, 'func');
    if (err instanceof MultiError) {
      err.errors().forEach(function iterError(e) {
        func(e);
      });
    } else {
      func(err);
    }
  };
  function SError() {
    var args, obj, parsed, options;
    args = Array.prototype.slice.call(arguments, 0);
    if (!(this instanceof SError)) {
      obj = Object.create(SError.prototype);
      SError.apply(obj, arguments);
      return obj;
    }
    parsed = parseConstructorArguments({
      argv: args,
      strict: true,
    });
    options = parsed.options;
    VError.call(this, options, '%s', parsed.shortmessage);
    return this;
  }
  mod_util.inherits(SError, VError);
  function MultiError(errors) {
    mod_assertplus.array(errors, 'list of errors');
    mod_assertplus.ok(errors.length > 0, 'must be at least one error');
    this.ase_errors = errors;
    VError.call(
      this,
      {
        cause: errors[0],
      },
      'first of %d error%s',
      errors.length,
      errors.length == 1 ? '' : 's',
    );
  }
  mod_util.inherits(MultiError, VError);
  MultiError.prototype.name = 'MultiError';
  MultiError.prototype.errors = function me_errors() {
    return this.ase_errors.slice(0);
  };
  function WError() {
    var args, obj, parsed, options;
    args = Array.prototype.slice.call(arguments, 0);
    if (!(this instanceof WError)) {
      obj = Object.create(WError.prototype);
      WError.apply(obj, args);
      return obj;
    }
    parsed = parseConstructorArguments({
      argv: args,
      strict: false,
    });
    options = parsed.options;
    options['skipCauseMessage'] = true;
    VError.call(this, options, '%s', parsed.shortmessage);
    return this;
  }
  mod_util.inherits(WError, VError);
  WError.prototype.name = 'WError';
  WError.prototype.toString = function we_toString() {
    var str =
      (this.hasOwnProperty('name') && this.name) ||
      this.constructor.name ||
      this.constructor.prototype.name;
    if (this.message) str += ': ' + this.message;
    if (this.jse_cause && this.jse_cause.message)
      str += '; caused by ' + this.jse_cause.toString();
    return str;
  };
  WError.prototype.cause = function we_cause(c) {
    if (mod_isError(c)) this.jse_cause = c;
    return this.jse_cause;
  };
});

// node_modules/json-schema/lib/validate.js
var require_validate2 = __commonJS((exports2, module2) => {
  (function (root, factory) {
    if (typeof define === 'function' && define.amd) {
      define([], function () {
        return factory();
      });
    } else if (typeof module2 === 'object' && module2.exports) {
      module2.exports = factory();
    } else {
      root.jsonSchema = factory();
    }
  })(exports2, function () {
    var exports3 = validate;
    exports3.Integer = { type: 'integer' };
    var primitiveConstructors = {
      String,
      Boolean,
      Number,
      Object,
      Array,
      Date,
    };
    exports3.validate = validate;
    function validate(instance, schema) {
      return validate(instance, schema, { changing: false });
    }
    exports3.checkPropertyChange = function (value, schema, property) {
      return validate(value, schema, { changing: property || 'property' });
    };
    var validate = (exports3._validate = function (instance, schema, options) {
      if (!options) options = {};
      var _changing = options.changing;
      function getType(schema2) {
        return (
          schema2.type ||
          (primitiveConstructors[schema2.name] == schema2 &&
            schema2.name.toLowerCase())
        );
      }
      var errors = [];
      function checkProp(value, schema2, path, i) {
        var l;
        path += path
          ? typeof i == 'number'
            ? '[' + i + ']'
            : typeof i == 'undefined'
            ? ''
            : '.' + i
          : i;
        function addError(message) {
          errors.push({ property: path, message });
        }
        if (
          (typeof schema2 != 'object' || schema2 instanceof Array) &&
          (path || typeof schema2 != 'function') &&
          !(schema2 && getType(schema2))
        ) {
          if (typeof schema2 == 'function') {
            if (!(value instanceof schema2)) {
              addError(
                'is not an instance of the class/constructor ' + schema2.name,
              );
            }
          } else if (schema2) {
            addError('Invalid schema/property definition ' + schema2);
          }
          return null;
        }
        if (_changing && schema2.readonly) {
          addError('is a readonly field, it can not be changed');
        }
        if (schema2['extends']) {
          checkProp(value, schema2['extends'], path, i);
        }
        function checkType(type, value2) {
          if (type) {
            if (
              typeof type == 'string' &&
              type != 'any' &&
              (type == 'null' ? value2 !== null : typeof value2 != type) &&
              !(value2 instanceof Array && type == 'array') &&
              !(value2 instanceof Date && type == 'date') &&
              !(type == 'integer' && value2 % 1 === 0)
            ) {
              return [
                {
                  property: path,
                  message:
                    typeof value2 +
                    ' value found, but a ' +
                    type +
                    ' is required',
                },
              ];
            }
            if (type instanceof Array) {
              var unionErrors = [];
              for (var j2 = 0; j2 < type.length; j2++) {
                if (!(unionErrors = checkType(type[j2], value2)).length) {
                  break;
                }
              }
              if (unionErrors.length) {
                return unionErrors;
              }
            } else if (typeof type == 'object') {
              var priorErrors = errors;
              errors = [];
              checkProp(value2, type, path);
              var theseErrors = errors;
              errors = priorErrors;
              return theseErrors;
            }
          }
          return [];
        }
        if (value === void 0) {
          if (schema2.required) {
            addError('is missing and it is required');
          }
        } else {
          errors = errors.concat(checkType(getType(schema2), value));
          if (schema2.disallow && !checkType(schema2.disallow, value).length) {
            addError(' disallowed value was matched');
          }
          if (value !== null) {
            if (value instanceof Array) {
              if (schema2.items) {
                var itemsIsArray = schema2.items instanceof Array;
                var propDef = schema2.items;
                for (i = 0, l = value.length; i < l; i += 1) {
                  if (itemsIsArray) propDef = schema2.items[i];
                  if (options.coerce)
                    value[i] = options.coerce(value[i], propDef);
                  errors.concat(checkProp(value[i], propDef, path, i));
                }
              }
              if (schema2.minItems && value.length < schema2.minItems) {
                addError(
                  'There must be a minimum of ' +
                    schema2.minItems +
                    ' in the array',
                );
              }
              if (schema2.maxItems && value.length > schema2.maxItems) {
                addError(
                  'There must be a maximum of ' +
                    schema2.maxItems +
                    ' in the array',
                );
              }
            } else if (schema2.properties || schema2.additionalProperties) {
              errors.concat(
                checkObj(
                  value,
                  schema2.properties,
                  path,
                  schema2.additionalProperties,
                ),
              );
            }
            if (
              schema2.pattern &&
              typeof value == 'string' &&
              !value.match(schema2.pattern)
            ) {
              addError('does not match the regex pattern ' + schema2.pattern);
            }
            if (
              schema2.maxLength &&
              typeof value == 'string' &&
              value.length > schema2.maxLength
            ) {
              addError('may only be ' + schema2.maxLength + ' characters long');
            }
            if (
              schema2.minLength &&
              typeof value == 'string' &&
              value.length < schema2.minLength
            ) {
              addError(
                'must be at least ' + schema2.minLength + ' characters long',
              );
            }
            if (
              typeof schema2.minimum !== void 0 &&
              typeof value == typeof schema2.minimum &&
              schema2.minimum > value
            ) {
              addError('must have a minimum value of ' + schema2.minimum);
            }
            if (
              typeof schema2.maximum !== void 0 &&
              typeof value == typeof schema2.maximum &&
              schema2.maximum < value
            ) {
              addError('must have a maximum value of ' + schema2.maximum);
            }
            if (schema2['enum']) {
              var enumer = schema2['enum'];
              l = enumer.length;
              var found;
              for (var j = 0; j < l; j++) {
                if (enumer[j] === value) {
                  found = 1;
                  break;
                }
              }
              if (!found) {
                addError(
                  'does not have a value in the enumeration ' +
                    enumer.join(', '),
                );
              }
            }
            if (
              typeof schema2.maxDecimal == 'number' &&
              value
                .toString()
                .match(
                  new RegExp('\\.[0-9]{' + (schema2.maxDecimal + 1) + ',}'),
                )
            ) {
              addError(
                'may only have ' +
                  schema2.maxDecimal +
                  ' digits of decimal places',
              );
            }
          }
        }
        return null;
      }
      function checkObj(instance2, objTypeDef, path, additionalProp) {
        if (typeof objTypeDef == 'object') {
          if (typeof instance2 != 'object' || instance2 instanceof Array) {
            errors.push({ property: path, message: 'an object is required' });
          }
          for (var i in objTypeDef) {
            if (objTypeDef.hasOwnProperty(i)) {
              var value = instance2[i];
              if (value === void 0 && options.existingOnly) continue;
              var propDef = objTypeDef[i];
              if (value === void 0 && propDef['default']) {
                value = instance2[i] = propDef['default'];
              }
              if (options.coerce && i in instance2) {
                value = instance2[i] = options.coerce(value, propDef);
              }
              checkProp(value, propDef, path, i);
            }
          }
        }
        for (i in instance2) {
          if (
            instance2.hasOwnProperty(i) &&
            !(i.charAt(0) == '_' && i.charAt(1) == '_') &&
            objTypeDef &&
            !objTypeDef[i] &&
            additionalProp === false
          ) {
            if (options.filter) {
              delete instance2[i];
              continue;
            } else {
              errors.push({
                property: path,
                message:
                  typeof value +
                  'The property ' +
                  i +
                  ' is not defined in the schema and the schema does not allow additional properties',
              });
            }
          }
          var requires = objTypeDef && objTypeDef[i] && objTypeDef[i].requires;
          if (requires && !(requires in instance2)) {
            errors.push({
              property: path,
              message:
                'the presence of the property ' +
                i +
                ' requires that ' +
                requires +
                ' also be present',
            });
          }
          value = instance2[i];
          if (
            additionalProp &&
            (!(objTypeDef && typeof objTypeDef == 'object') ||
              !(i in objTypeDef))
          ) {
            if (options.coerce) {
              value = instance2[i] = options.coerce(value, additionalProp);
            }
            checkProp(value, additionalProp, path, i);
          }
          if (!_changing && value && value.$schema) {
            errors = errors.concat(checkProp(value, value.$schema, path, i));
          }
        }
        return errors;
      }
      if (schema) {
        checkProp(instance, schema, '', _changing || '');
      }
      if (!_changing && instance && instance.$schema) {
        checkProp(instance, instance.$schema, '', '');
      }
      return { valid: !errors.length, errors };
    });
    exports3.mustBeValid = function (result) {
      if (!result.valid) {
        throw new TypeError(
          result.errors
            .map(function (error) {
              return 'for property ' + error.property + ': ' + error.message;
            })
            .join(', \n'),
        );
      }
    };
    return exports3;
  });
});

// node_modules/jsprim/lib/jsprim.js
var require_jsprim = __commonJS((exports2) => {
  var mod_assert = require_assert();
  var mod_util = require('util');
  var mod_extsprintf = require_extsprintf();
  var mod_verror = require_verror();
  var mod_jsonschema = require_validate2();
  exports2.deepCopy = deepCopy;
  exports2.deepEqual = deepEqual;
  exports2.isEmpty = isEmpty;
  exports2.hasKey = hasKey;
  exports2.forEachKey = forEachKey;
  exports2.pluck = pluck;
  exports2.flattenObject = flattenObject;
  exports2.flattenIter = flattenIter;
  exports2.validateJsonObject = validateJsonObjectJS;
  exports2.validateJsonObjectJS = validateJsonObjectJS;
  exports2.randElt = randElt;
  exports2.extraProperties = extraProperties;
  exports2.mergeObjects = mergeObjects;
  exports2.startsWith = startsWith;
  exports2.endsWith = endsWith;
  exports2.parseInteger = parseInteger;
  exports2.iso8601 = iso8601;
  exports2.rfc1123 = rfc1123;
  exports2.parseDateTime = parseDateTime;
  exports2.hrtimediff = hrtimeDiff;
  exports2.hrtimeDiff = hrtimeDiff;
  exports2.hrtimeAccum = hrtimeAccum;
  exports2.hrtimeAdd = hrtimeAdd;
  exports2.hrtimeNanosec = hrtimeNanosec;
  exports2.hrtimeMicrosec = hrtimeMicrosec;
  exports2.hrtimeMillisec = hrtimeMillisec;
  function deepCopy(obj) {
    var ret, key;
    var marker = '__deepCopy';
    if (obj && obj[marker])
      throw new Error('attempted deep copy of cyclic object');
    if (obj && obj.constructor == Object) {
      ret = {};
      obj[marker] = true;
      for (key in obj) {
        if (key == marker) continue;
        ret[key] = deepCopy(obj[key]);
      }
      delete obj[marker];
      return ret;
    }
    if (obj && obj.constructor == Array) {
      ret = [];
      obj[marker] = true;
      for (key = 0; key < obj.length; key++) ret.push(deepCopy(obj[key]));
      delete obj[marker];
      return ret;
    }
    return obj;
  }
  function deepEqual(obj1, obj2) {
    if (typeof obj1 != typeof obj2) return false;
    if (obj1 === null || obj2 === null || typeof obj1 != 'object')
      return obj1 === obj2;
    if (obj1.constructor != obj2.constructor) return false;
    var k;
    for (k in obj1) {
      if (!obj2.hasOwnProperty(k)) return false;
      if (!deepEqual(obj1[k], obj2[k])) return false;
    }
    for (k in obj2) {
      if (!obj1.hasOwnProperty(k)) return false;
    }
    return true;
  }
  function isEmpty(obj) {
    var key;
    for (key in obj) return false;
    return true;
  }
  function hasKey(obj, key) {
    mod_assert.equal(typeof key, 'string');
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  function forEachKey(obj, callback) {
    for (var key in obj) {
      if (hasKey(obj, key)) {
        callback(key, obj[key]);
      }
    }
  }
  function pluck(obj, key) {
    mod_assert.equal(typeof key, 'string');
    return pluckv(obj, key);
  }
  function pluckv(obj, key) {
    if (obj === null || typeof obj !== 'object') return void 0;
    if (obj.hasOwnProperty(key)) return obj[key];
    var i = key.indexOf('.');
    if (i == -1) return void 0;
    var key1 = key.substr(0, i);
    if (!obj.hasOwnProperty(key1)) return void 0;
    return pluckv(obj[key1], key.substr(i + 1));
  }
  function flattenIter(data, depth, callback) {
    doFlattenIter(data, depth, [], callback);
  }
  function doFlattenIter(data, depth, accum, callback) {
    var each;
    var key;
    if (depth === 0) {
      each = accum.slice(0);
      each.push(data);
      callback(each);
      return;
    }
    mod_assert.ok(data !== null);
    mod_assert.equal(typeof data, 'object');
    mod_assert.equal(typeof depth, 'number');
    mod_assert.ok(depth >= 0);
    for (key in data) {
      each = accum.slice(0);
      each.push(key);
      doFlattenIter(data[key], depth - 1, each, callback);
    }
  }
  function flattenObject(data, depth) {
    if (depth === 0) return [data];
    mod_assert.ok(data !== null);
    mod_assert.equal(typeof data, 'object');
    mod_assert.equal(typeof depth, 'number');
    mod_assert.ok(depth >= 0);
    var rv = [];
    var key;
    for (key in data) {
      flattenObject(data[key], depth - 1).forEach(function (p) {
        rv.push([key].concat(p));
      });
    }
    return rv;
  }
  function startsWith(str, prefix) {
    return str.substr(0, prefix.length) == prefix;
  }
  function endsWith(str, suffix) {
    return str.substr(str.length - suffix.length, suffix.length) == suffix;
  }
  function iso8601(d) {
    if (typeof d == 'number') d = new Date(d);
    mod_assert.ok(d.constructor === Date);
    return mod_extsprintf.sprintf(
      '%4d-%02d-%02dT%02d:%02d:%02d.%03dZ',
      d.getUTCFullYear(),
      d.getUTCMonth() + 1,
      d.getUTCDate(),
      d.getUTCHours(),
      d.getUTCMinutes(),
      d.getUTCSeconds(),
      d.getUTCMilliseconds(),
    );
  }
  var RFC1123_MONTHS = [
    'Jan',
    'Feb',
    'Mar',
    'Apr',
    'May',
    'Jun',
    'Jul',
    'Aug',
    'Sep',
    'Oct',
    'Nov',
    'Dec',
  ];
  var RFC1123_DAYS = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
  function rfc1123(date) {
    return mod_extsprintf.sprintf(
      '%s, %02d %s %04d %02d:%02d:%02d GMT',
      RFC1123_DAYS[date.getUTCDay()],
      date.getUTCDate(),
      RFC1123_MONTHS[date.getUTCMonth()],
      date.getUTCFullYear(),
      date.getUTCHours(),
      date.getUTCMinutes(),
      date.getUTCSeconds(),
    );
  }
  function parseDateTime(str) {
    var numeric = +str;
    if (!isNaN(numeric)) {
      return new Date(numeric);
    } else {
      return new Date(str);
    }
  }
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
  var PI_DEFAULTS = {
    base: 10,
    allowSign: true,
    allowPrefix: false,
    allowTrailing: false,
    allowImprecise: false,
    trimWhitespace: false,
    leadingZeroIsOctal: false,
  };
  var CP_0 = 48;
  var CP_9 = 57;
  var CP_A = 65;
  var CP_B = 66;
  var CP_O = 79;
  var CP_T = 84;
  var CP_X = 88;
  var CP_Z = 90;
  var CP_a = 97;
  var CP_b = 98;
  var CP_o = 111;
  var CP_t = 116;
  var CP_x = 120;
  var CP_z = 122;
  var PI_CONV_DEC = 48;
  var PI_CONV_UC = 55;
  var PI_CONV_LC = 87;
  function parseInteger(str, uopts) {
    mod_assert.string(str, 'str');
    mod_assert.optionalObject(uopts, 'options');
    var baseOverride = false;
    var options = PI_DEFAULTS;
    if (uopts) {
      baseOverride = hasKey(uopts, 'base');
      options = mergeObjects(options, uopts);
      mod_assert.number(options.base, 'options.base');
      mod_assert.ok(options.base >= 2, 'options.base >= 2');
      mod_assert.ok(options.base <= 36, 'options.base <= 36');
      mod_assert.bool(options.allowSign, 'options.allowSign');
      mod_assert.bool(options.allowPrefix, 'options.allowPrefix');
      mod_assert.bool(options.allowTrailing, 'options.allowTrailing');
      mod_assert.bool(options.allowImprecise, 'options.allowImprecise');
      mod_assert.bool(options.trimWhitespace, 'options.trimWhitespace');
      mod_assert.bool(options.leadingZeroIsOctal, 'options.leadingZeroIsOctal');
      if (options.leadingZeroIsOctal) {
        mod_assert.ok(
          !baseOverride,
          '"base" and "leadingZeroIsOctal" are mutually exclusive',
        );
      }
    }
    var c;
    var pbase = -1;
    var base = options.base;
    var start;
    var mult = 1;
    var value = 0;
    var idx = 0;
    var len = str.length;
    if (options.trimWhitespace) {
      while (idx < len && isSpace(str.charCodeAt(idx))) {
        ++idx;
      }
    }
    if (options.allowSign) {
      if (str[idx] === '-') {
        idx += 1;
        mult = -1;
      } else if (str[idx] === '+') {
        idx += 1;
      }
    }
    if (str[idx] === '0') {
      if (options.allowPrefix) {
        pbase = prefixToBase(str.charCodeAt(idx + 1));
        if (pbase !== -1 && (!baseOverride || pbase === base)) {
          base = pbase;
          idx += 2;
        }
      }
      if (pbase === -1 && options.leadingZeroIsOctal) {
        base = 8;
      }
    }
    for (start = idx; idx < len; ++idx) {
      c = translateDigit(str.charCodeAt(idx));
      if (c !== -1 && c < base) {
        value *= base;
        value += c;
      } else {
        break;
      }
    }
    if (start === idx) {
      return new Error('invalid number: ' + JSON.stringify(str));
    }
    if (options.trimWhitespace) {
      while (idx < len && isSpace(str.charCodeAt(idx))) {
        ++idx;
      }
    }
    if (idx < len && !options.allowTrailing) {
      return new Error(
        'trailing characters after number: ' + JSON.stringify(str.slice(idx)),
      );
    }
    if (value === 0) {
      return 0;
    }
    var result = value * mult;
    if (
      !options.allowImprecise &&
      (value > MAX_SAFE_INTEGER || result < MIN_SAFE_INTEGER)
    ) {
      return new Error(
        'number is outside of the supported range: ' +
          JSON.stringify(str.slice(start, idx)),
      );
    }
    return result;
  }
  function translateDigit(d) {
    if (d >= CP_0 && d <= CP_9) {
      return d - PI_CONV_DEC;
    } else if (d >= CP_A && d <= CP_Z) {
      return d - PI_CONV_UC;
    } else if (d >= CP_a && d <= CP_z) {
      return d - PI_CONV_LC;
    } else {
      return -1;
    }
  }
  function isSpace(c) {
    return (
      c === 32 ||
      (c >= 9 && c <= 13) ||
      c === 160 ||
      c === 5760 ||
      c === 6158 ||
      (c >= 8192 && c <= 8202) ||
      c === 8232 ||
      c === 8233 ||
      c === 8239 ||
      c === 8287 ||
      c === 12288 ||
      c === 65279
    );
  }
  function prefixToBase(c) {
    if (c === CP_b || c === CP_B) {
      return 2;
    } else if (c === CP_o || c === CP_O) {
      return 8;
    } else if (c === CP_t || c === CP_T) {
      return 10;
    } else if (c === CP_x || c === CP_X) {
      return 16;
    } else {
      return -1;
    }
  }
  function validateJsonObjectJS(schema, input) {
    var report = mod_jsonschema.validate(input, schema);
    if (report.errors.length === 0) return null;
    var error = report.errors[0];
    var propname = error['property'];
    var reason = error['message'].toLowerCase();
    var i, j;
    if (
      (i = reason.indexOf('the property ')) != -1 &&
      (j = reason.indexOf(
        ' is not defined in the schema and the schema does not allow additional properties',
      )) != -1
    ) {
      i += 'the property '.length;
      if (propname === '') propname = reason.substr(i, j - i);
      else propname = propname + '.' + reason.substr(i, j - i);
      reason = 'unsupported property';
    }
    var rv = new mod_verror.VError('property "%s": %s', propname, reason);
    rv.jsv_details = error;
    return rv;
  }
  function randElt(arr) {
    mod_assert.ok(
      Array.isArray(arr) && arr.length > 0,
      'randElt argument must be a non-empty array',
    );
    return arr[Math.floor(Math.random() * arr.length)];
  }
  function assertHrtime(a) {
    mod_assert.ok(
      a[0] >= 0 && a[1] >= 0,
      'negative numbers not allowed in hrtimes',
    );
    mod_assert.ok(a[1] < 1e9, 'nanoseconds column overflow');
  }
  function hrtimeDiff(a, b) {
    assertHrtime(a);
    assertHrtime(b);
    mod_assert.ok(
      a[0] > b[0] || (a[0] == b[0] && a[1] >= b[1]),
      'negative differences not allowed',
    );
    var rv = [a[0] - b[0], 0];
    if (a[1] >= b[1]) {
      rv[1] = a[1] - b[1];
    } else {
      rv[0]--;
      rv[1] = 1e9 - (b[1] - a[1]);
    }
    return rv;
  }
  function hrtimeNanosec(a) {
    assertHrtime(a);
    return Math.floor(a[0] * 1e9 + a[1]);
  }
  function hrtimeMicrosec(a) {
    assertHrtime(a);
    return Math.floor(a[0] * 1e6 + a[1] / 1e3);
  }
  function hrtimeMillisec(a) {
    assertHrtime(a);
    return Math.floor(a[0] * 1e3 + a[1] / 1e6);
  }
  function hrtimeAccum(a, b) {
    assertHrtime(a);
    assertHrtime(b);
    a[1] += b[1];
    if (a[1] >= 1e9) {
      a[0]++;
      a[1] -= 1e9;
    }
    a[0] += b[0];
    return a;
  }
  function hrtimeAdd(a, b) {
    assertHrtime(a);
    var rv = [a[0], a[1]];
    return hrtimeAccum(rv, b);
  }
  function extraProperties(obj, allowed) {
    mod_assert.ok(
      typeof obj === 'object' && obj !== null,
      'obj argument must be a non-null object',
    );
    mod_assert.ok(
      Array.isArray(allowed),
      'allowed argument must be an array of strings',
    );
    for (var i = 0; i < allowed.length; i++) {
      mod_assert.ok(
        typeof allowed[i] === 'string',
        'allowed argument must be an array of strings',
      );
    }
    return Object.keys(obj).filter(function (key) {
      return allowed.indexOf(key) === -1;
    });
  }
  function mergeObjects(provided, overrides, defaults) {
    var rv, k;
    rv = {};
    if (defaults) {
      for (k in defaults) rv[k] = defaults[k];
    }
    if (provided) {
      for (k in provided) rv[k] = provided[k];
    }
    if (overrides) {
      for (k in overrides) rv[k] = overrides[k];
    }
    return rv;
  }
});

// node_modules/http-signature/lib/signer.js
var require_signer = __commonJS((exports2, module2) => {
  var assert = require_assert();
  var crypto = require('crypto');
  var http = require('http');
  var util = require('util');
  var sshpk = require_lib2();
  var jsprim = require_jsprim();
  var utils = require_utils5();
  var sprintf = require('util').format;
  var HASH_ALGOS = utils.HASH_ALGOS;
  var PK_ALGOS = utils.PK_ALGOS;
  var InvalidAlgorithmError = utils.InvalidAlgorithmError;
  var HttpSignatureError = utils.HttpSignatureError;
  var validateAlgorithm = utils.validateAlgorithm;
  var AUTHZ_FMT =
    'Signature keyId="%s",algorithm="%s",headers="%s",signature="%s"';
  function MissingHeaderError(message) {
    HttpSignatureError.call(this, message, MissingHeaderError);
  }
  util.inherits(MissingHeaderError, HttpSignatureError);
  function StrictParsingError(message) {
    HttpSignatureError.call(this, message, StrictParsingError);
  }
  util.inherits(StrictParsingError, HttpSignatureError);
  function RequestSigner(options) {
    assert.object(options, 'options');
    var alg = [];
    if (options.algorithm !== void 0) {
      assert.string(options.algorithm, 'options.algorithm');
      alg = validateAlgorithm(options.algorithm);
    }
    this.rs_alg = alg;
    if (options.sign !== void 0) {
      assert.func(options.sign, 'options.sign');
      this.rs_signFunc = options.sign;
    } else if (alg[0] === 'hmac' && options.key !== void 0) {
      assert.string(options.keyId, 'options.keyId');
      this.rs_keyId = options.keyId;
      if (typeof options.key !== 'string' && !Buffer.isBuffer(options.key))
        throw new TypeError('options.key for HMAC must be a string or Buffer');
      this.rs_signer = crypto.createHmac(alg[1].toUpperCase(), options.key);
      this.rs_signer.sign = function () {
        var digest = this.digest('base64');
        return {
          hashAlgorithm: alg[1],
          toString: function () {
            return digest;
          },
        };
      };
    } else if (options.key !== void 0) {
      var key = options.key;
      if (typeof key === 'string' || Buffer.isBuffer(key))
        key = sshpk.parsePrivateKey(key);
      assert.ok(
        sshpk.PrivateKey.isPrivateKey(key, [1, 2]),
        'options.key must be a sshpk.PrivateKey',
      );
      this.rs_key = key;
      assert.string(options.keyId, 'options.keyId');
      this.rs_keyId = options.keyId;
      if (!PK_ALGOS[key.type]) {
        throw new InvalidAlgorithmError(
          key.type.toUpperCase() + ' type keys are not supported',
        );
      }
      if (alg[0] !== void 0 && key.type !== alg[0]) {
        throw new InvalidAlgorithmError(
          'options.key must be a ' +
            alg[0].toUpperCase() +
            ' key, was given a ' +
            key.type.toUpperCase() +
            ' key instead',
        );
      }
      this.rs_signer = key.createSign(alg[1]);
    } else {
      throw new TypeError('options.sign (func) or options.key is required');
    }
    this.rs_headers = [];
    this.rs_lines = [];
  }
  RequestSigner.prototype.writeHeader = function (header, value) {
    assert.string(header, 'header');
    header = header.toLowerCase();
    assert.string(value, 'value');
    this.rs_headers.push(header);
    if (this.rs_signFunc) {
      this.rs_lines.push(header + ': ' + value);
    } else {
      var line = header + ': ' + value;
      if (this.rs_headers.length > 0) line = '\n' + line;
      this.rs_signer.update(line);
    }
    return value;
  };
  RequestSigner.prototype.writeDateHeader = function () {
    return this.writeHeader('date', jsprim.rfc1123(new Date()));
  };
  RequestSigner.prototype.writeTarget = function (method, path) {
    assert.string(method, 'method');
    assert.string(path, 'path');
    method = method.toLowerCase();
    this.writeHeader('(request-target)', method + ' ' + path);
  };
  RequestSigner.prototype.sign = function (cb) {
    assert.func(cb, 'callback');
    if (this.rs_headers.length < 1)
      throw new Error('At least one header must be signed');
    var alg, authz;
    if (this.rs_signFunc) {
      var data = this.rs_lines.join('\n');
      var self2 = this;
      this.rs_signFunc(data, function (err, sig) {
        if (err) {
          cb(err);
          return;
        }
        try {
          assert.object(sig, 'signature');
          assert.string(sig.keyId, 'signature.keyId');
          assert.string(sig.algorithm, 'signature.algorithm');
          assert.string(sig.signature, 'signature.signature');
          alg = validateAlgorithm(sig.algorithm);
          authz = sprintf(
            AUTHZ_FMT,
            sig.keyId,
            sig.algorithm,
            self2.rs_headers.join(' '),
            sig.signature,
          );
        } catch (e) {
          cb(e);
          return;
        }
        cb(null, authz);
      });
    } else {
      try {
        var sigObj = this.rs_signer.sign();
      } catch (e) {
        cb(e);
        return;
      }
      alg = (this.rs_alg[0] || this.rs_key.type) + '-' + sigObj.hashAlgorithm;
      var signature = sigObj.toString();
      authz = sprintf(
        AUTHZ_FMT,
        this.rs_keyId,
        alg,
        this.rs_headers.join(' '),
        signature,
      );
      cb(null, authz);
    }
  };
  module2.exports = {
    isSigner: function (obj) {
      if (typeof obj === 'object' && obj instanceof RequestSigner) return true;
      return false;
    },
    createSigner: function createSigner(options) {
      return new RequestSigner(options);
    },
    signRequest: function signRequest(request, options) {
      assert.object(request, 'request');
      assert.object(options, 'options');
      assert.optionalString(options.algorithm, 'options.algorithm');
      assert.string(options.keyId, 'options.keyId');
      assert.optionalArrayOfString(options.headers, 'options.headers');
      assert.optionalString(options.httpVersion, 'options.httpVersion');
      if (!request.getHeader('Date'))
        request.setHeader('Date', jsprim.rfc1123(new Date()));
      if (!options.headers) options.headers = ['date'];
      if (!options.httpVersion) options.httpVersion = '1.1';
      var alg = [];
      if (options.algorithm) {
        options.algorithm = options.algorithm.toLowerCase();
        alg = validateAlgorithm(options.algorithm);
      }
      var i;
      var stringToSign = '';
      for (i = 0; i < options.headers.length; i++) {
        if (typeof options.headers[i] !== 'string')
          throw new TypeError('options.headers must be an array of Strings');
        var h = options.headers[i].toLowerCase();
        if (h === 'request-line') {
          if (!options.strict) {
            stringToSign +=
              request.method +
              ' ' +
              request.path +
              ' HTTP/' +
              options.httpVersion;
          } else {
            throw new StrictParsingError(
              'request-line is not a valid header with strict parsing enabled.',
            );
          }
        } else if (h === '(request-target)') {
          stringToSign +=
            '(request-target): ' +
            request.method.toLowerCase() +
            ' ' +
            request.path;
        } else {
          var value = request.getHeader(h);
          if (value === void 0 || value === '') {
            throw new MissingHeaderError(h + ' was not in the request');
          }
          stringToSign += h + ': ' + value;
        }
        if (i + 1 < options.headers.length) stringToSign += '\n';
      }
      if (request.hasOwnProperty('_stringToSign')) {
        request._stringToSign = stringToSign;
      }
      var signature;
      if (alg[0] === 'hmac') {
        if (typeof options.key !== 'string' && !Buffer.isBuffer(options.key))
          throw new TypeError('options.key must be a string or Buffer');
        var hmac = crypto.createHmac(alg[1].toUpperCase(), options.key);
        hmac.update(stringToSign);
        signature = hmac.digest('base64');
      } else {
        var key = options.key;
        if (typeof key === 'string' || Buffer.isBuffer(key))
          key = sshpk.parsePrivateKey(options.key);
        assert.ok(
          sshpk.PrivateKey.isPrivateKey(key, [1, 2]),
          'options.key must be a sshpk.PrivateKey',
        );
        if (!PK_ALGOS[key.type]) {
          throw new InvalidAlgorithmError(
            key.type.toUpperCase() + ' type keys are not supported',
          );
        }
        if (alg[0] !== void 0 && key.type !== alg[0]) {
          throw new InvalidAlgorithmError(
            'options.key must be a ' +
              alg[0].toUpperCase() +
              ' key, was given a ' +
              key.type.toUpperCase() +
              ' key instead',
          );
        }
        var signer = key.createSign(alg[1]);
        signer.update(stringToSign);
        var sigObj = signer.sign();
        if (!HASH_ALGOS[sigObj.hashAlgorithm]) {
          throw new InvalidAlgorithmError(
            sigObj.hashAlgorithm.toUpperCase() +
              ' is not a supported hash algorithm',
          );
        }
        options.algorithm = key.type + '-' + sigObj.hashAlgorithm;
        signature = sigObj.toString();
        assert.notStrictEqual(signature, '', 'empty signature produced');
      }
      var authzHeaderName = options.authorizationHeaderName || 'Authorization';
      request.setHeader(
        authzHeaderName,
        sprintf(
          AUTHZ_FMT,
          options.keyId,
          options.algorithm,
          options.headers.join(' '),
          signature,
        ),
      );
      return true;
    },
  };
});

// node_modules/http-signature/lib/verify.js
var require_verify = __commonJS((exports2, module2) => {
  var assert = require_assert();
  var crypto = require('crypto');
  var sshpk = require_lib2();
  var utils = require_utils5();
  var HASH_ALGOS = utils.HASH_ALGOS;
  var PK_ALGOS = utils.PK_ALGOS;
  var InvalidAlgorithmError = utils.InvalidAlgorithmError;
  var HttpSignatureError = utils.HttpSignatureError;
  var validateAlgorithm = utils.validateAlgorithm;
  module2.exports = {
    verifySignature: function verifySignature(parsedSignature, pubkey) {
      assert.object(parsedSignature, 'parsedSignature');
      if (typeof pubkey === 'string' || Buffer.isBuffer(pubkey))
        pubkey = sshpk.parseKey(pubkey);
      assert.ok(sshpk.Key.isKey(pubkey, [1, 1]), 'pubkey must be a sshpk.Key');
      var alg = validateAlgorithm(parsedSignature.algorithm);
      if (alg[0] === 'hmac' || alg[0] !== pubkey.type) return false;
      var v = pubkey.createVerify(alg[1]);
      v.update(parsedSignature.signingString);
      return v.verify(parsedSignature.params.signature, 'base64');
    },
    verifyHMAC: function verifyHMAC(parsedSignature, secret) {
      assert.object(parsedSignature, 'parsedHMAC');
      assert.string(secret, 'secret');
      var alg = validateAlgorithm(parsedSignature.algorithm);
      if (alg[0] !== 'hmac') return false;
      var hashAlg = alg[1].toUpperCase();
      var hmac = crypto.createHmac(hashAlg, secret);
      hmac.update(parsedSignature.signingString);
      var h1 = crypto.createHmac(hashAlg, secret);
      h1.update(hmac.digest());
      h1 = h1.digest();
      var h2 = crypto.createHmac(hashAlg, secret);
      h2.update(new Buffer(parsedSignature.params.signature, 'base64'));
      h2 = h2.digest();
      if (typeof h1 === 'string') return h1 === h2;
      if (Buffer.isBuffer(h1) && !h1.equals)
        return h1.toString('binary') === h2.toString('binary');
      return h1.equals(h2);
    },
  };
});

// node_modules/http-signature/lib/index.js
var require_lib3 = __commonJS((exports2, module2) => {
  var parser = require_parser();
  var signer = require_signer();
  var verify = require_verify();
  var utils = require_utils5();
  module2.exports = {
    parse: parser.parseRequest,
    parseRequest: parser.parseRequest,
    sign: signer.signRequest,
    signRequest: signer.signRequest,
    createSigner: signer.createSigner,
    isSigner: signer.isSigner,
    sshKeyToPEM: utils.sshKeyToPEM,
    sshKeyFingerprint: utils.fingerprint,
    pemToRsaSSHKey: utils.pemToRsaSSHKey,
    verify: verify.verifySignature,
    verifySignature: verify.verifySignature,
    verifyHMAC: verify.verifyHMAC,
  };
});

// node_modules/mime-db/db.json
var require_db = __commonJS((exports2, module2) => {
  module2.exports = {
    'application/1d-interleaved-parityfec': {
      source: 'iana',
    },
    'application/3gpdash-qoe-report+xml': {
      source: 'iana',
      charset: 'UTF-8',
      compressible: true,
    },
    'application/3gpp-ims+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/a2l': {
      source: 'iana',
    },
    'application/activemessage': {
      source: 'iana',
    },
    'application/activity+json': {
      source: 'iana',
      compressible: true,
    },
    'application/alto-costmap+json': {
      source: 'iana',
      compressible: true,
    },
    'application/alto-costmapfilter+json': {
      source: 'iana',
      compressible: true,
    },
    'application/alto-directory+json': {
      source: 'iana',
      compressible: true,
    },
    'application/alto-endpointcost+json': {
      source: 'iana',
      compressible: true,
    },
    'application/alto-endpointcostparams+json': {
      source: 'iana',
      compressible: true,
    },
    'application/alto-endpointprop+json': {
      source: 'iana',
      compressible: true,
    },
    'application/alto-endpointpropparams+json': {
      source: 'iana',
      compressible: true,
    },
    'application/alto-error+json': {
      source: 'iana',
      compressible: true,
    },
    'application/alto-networkmap+json': {
      source: 'iana',
      compressible: true,
    },
    'application/alto-networkmapfilter+json': {
      source: 'iana',
      compressible: true,
    },
    'application/alto-updatestreamcontrol+json': {
      source: 'iana',
      compressible: true,
    },
    'application/alto-updatestreamparams+json': {
      source: 'iana',
      compressible: true,
    },
    'application/aml': {
      source: 'iana',
    },
    'application/andrew-inset': {
      source: 'iana',
      extensions: ['ez'],
    },
    'application/applefile': {
      source: 'iana',
    },
    'application/applixware': {
      source: 'apache',
      extensions: ['aw'],
    },
    'application/atf': {
      source: 'iana',
    },
    'application/atfx': {
      source: 'iana',
    },
    'application/atom+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['atom'],
    },
    'application/atomcat+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['atomcat'],
    },
    'application/atomdeleted+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['atomdeleted'],
    },
    'application/atomicmail': {
      source: 'iana',
    },
    'application/atomsvc+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['atomsvc'],
    },
    'application/atsc-dwd+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['dwd'],
    },
    'application/atsc-dynamic-event-message': {
      source: 'iana',
    },
    'application/atsc-held+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['held'],
    },
    'application/atsc-rdt+json': {
      source: 'iana',
      compressible: true,
    },
    'application/atsc-rsat+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['rsat'],
    },
    'application/atxml': {
      source: 'iana',
    },
    'application/auth-policy+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/bacnet-xdd+zip': {
      source: 'iana',
      compressible: false,
    },
    'application/batch-smtp': {
      source: 'iana',
    },
    'application/bdoc': {
      compressible: false,
      extensions: ['bdoc'],
    },
    'application/beep+xml': {
      source: 'iana',
      charset: 'UTF-8',
      compressible: true,
    },
    'application/calendar+json': {
      source: 'iana',
      compressible: true,
    },
    'application/calendar+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['xcs'],
    },
    'application/call-completion': {
      source: 'iana',
    },
    'application/cals-1840': {
      source: 'iana',
    },
    'application/captive+json': {
      source: 'iana',
      compressible: true,
    },
    'application/cbor': {
      source: 'iana',
    },
    'application/cbor-seq': {
      source: 'iana',
    },
    'application/cccex': {
      source: 'iana',
    },
    'application/ccmp+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/ccxml+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['ccxml'],
    },
    'application/cdfx+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['cdfx'],
    },
    'application/cdmi-capability': {
      source: 'iana',
      extensions: ['cdmia'],
    },
    'application/cdmi-container': {
      source: 'iana',
      extensions: ['cdmic'],
    },
    'application/cdmi-domain': {
      source: 'iana',
      extensions: ['cdmid'],
    },
    'application/cdmi-object': {
      source: 'iana',
      extensions: ['cdmio'],
    },
    'application/cdmi-queue': {
      source: 'iana',
      extensions: ['cdmiq'],
    },
    'application/cdni': {
      source: 'iana',
    },
    'application/cea': {
      source: 'iana',
    },
    'application/cea-2018+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/cellml+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/cfw': {
      source: 'iana',
    },
    'application/clr': {
      source: 'iana',
    },
    'application/clue+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/clue_info+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/cms': {
      source: 'iana',
    },
    'application/cnrp+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/coap-group+json': {
      source: 'iana',
      compressible: true,
    },
    'application/coap-payload': {
      source: 'iana',
    },
    'application/commonground': {
      source: 'iana',
    },
    'application/conference-info+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/cose': {
      source: 'iana',
    },
    'application/cose-key': {
      source: 'iana',
    },
    'application/cose-key-set': {
      source: 'iana',
    },
    'application/cpl+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/csrattrs': {
      source: 'iana',
    },
    'application/csta+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/cstadata+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/csvm+json': {
      source: 'iana',
      compressible: true,
    },
    'application/cu-seeme': {
      source: 'apache',
      extensions: ['cu'],
    },
    'application/cwt': {
      source: 'iana',
    },
    'application/cybercash': {
      source: 'iana',
    },
    'application/dart': {
      compressible: true,
    },
    'application/dash+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['mpd'],
    },
    'application/dashdelta': {
      source: 'iana',
    },
    'application/davmount+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['davmount'],
    },
    'application/dca-rft': {
      source: 'iana',
    },
    'application/dcd': {
      source: 'iana',
    },
    'application/dec-dx': {
      source: 'iana',
    },
    'application/dialog-info+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/dicom': {
      source: 'iana',
    },
    'application/dicom+json': {
      source: 'iana',
      compressible: true,
    },
    'application/dicom+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/dii': {
      source: 'iana',
    },
    'application/dit': {
      source: 'iana',
    },
    'application/dns': {
      source: 'iana',
    },
    'application/dns+json': {
      source: 'iana',
      compressible: true,
    },
    'application/dns-message': {
      source: 'iana',
    },
    'application/docbook+xml': {
      source: 'apache',
      compressible: true,
      extensions: ['dbk'],
    },
    'application/dots+cbor': {
      source: 'iana',
    },
    'application/dskpp+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/dssc+der': {
      source: 'iana',
      extensions: ['dssc'],
    },
    'application/dssc+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['xdssc'],
    },
    'application/dvcs': {
      source: 'iana',
    },
    'application/ecmascript': {
      source: 'iana',
      compressible: true,
      extensions: ['ecma', 'es'],
    },
    'application/edi-consent': {
      source: 'iana',
    },
    'application/edi-x12': {
      source: 'iana',
      compressible: false,
    },
    'application/edifact': {
      source: 'iana',
      compressible: false,
    },
    'application/efi': {
      source: 'iana',
    },
    'application/elm+json': {
      source: 'iana',
      charset: 'UTF-8',
      compressible: true,
    },
    'application/elm+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/emergencycalldata.cap+xml': {
      source: 'iana',
      charset: 'UTF-8',
      compressible: true,
    },
    'application/emergencycalldata.comment+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/emergencycalldata.control+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/emergencycalldata.deviceinfo+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/emergencycalldata.ecall.msd': {
      source: 'iana',
    },
    'application/emergencycalldata.providerinfo+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/emergencycalldata.serviceinfo+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/emergencycalldata.subscriberinfo+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/emergencycalldata.veds+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/emma+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['emma'],
    },
    'application/emotionml+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['emotionml'],
    },
    'application/encaprtp': {
      source: 'iana',
    },
    'application/epp+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/epub+zip': {
      source: 'iana',
      compressible: false,
      extensions: ['epub'],
    },
    'application/eshop': {
      source: 'iana',
    },
    'application/exi': {
      source: 'iana',
      extensions: ['exi'],
    },
    'application/expect-ct-report+json': {
      source: 'iana',
      compressible: true,
    },
    'application/fastinfoset': {
      source: 'iana',
    },
    'application/fastsoap': {
      source: 'iana',
    },
    'application/fdt+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['fdt'],
    },
    'application/fhir+json': {
      source: 'iana',
      charset: 'UTF-8',
      compressible: true,
    },
    'application/fhir+xml': {
      source: 'iana',
      charset: 'UTF-8',
      compressible: true,
    },
    'application/fido.trusted-apps+json': {
      compressible: true,
    },
    'application/fits': {
      source: 'iana',
    },
    'application/flexfec': {
      source: 'iana',
    },
    'application/font-sfnt': {
      source: 'iana',
    },
    'application/font-tdpfr': {
      source: 'iana',
      extensions: ['pfr'],
    },
    'application/font-woff': {
      source: 'iana',
      compressible: false,
    },
    'application/framework-attributes+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/geo+json': {
      source: 'iana',
      compressible: true,
      extensions: ['geojson'],
    },
    'application/geo+json-seq': {
      source: 'iana',
    },
    'application/geopackage+sqlite3': {
      source: 'iana',
    },
    'application/geoxacml+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/gltf-buffer': {
      source: 'iana',
    },
    'application/gml+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['gml'],
    },
    'application/gpx+xml': {
      source: 'apache',
      compressible: true,
      extensions: ['gpx'],
    },
    'application/gxf': {
      source: 'apache',
      extensions: ['gxf'],
    },
    'application/gzip': {
      source: 'iana',
      compressible: false,
      extensions: ['gz'],
    },
    'application/h224': {
      source: 'iana',
    },
    'application/held+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/hjson': {
      extensions: ['hjson'],
    },
    'application/http': {
      source: 'iana',
    },
    'application/hyperstudio': {
      source: 'iana',
      extensions: ['stk'],
    },
    'application/ibe-key-request+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/ibe-pkg-reply+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/ibe-pp-data': {
      source: 'iana',
    },
    'application/iges': {
      source: 'iana',
    },
    'application/im-iscomposing+xml': {
      source: 'iana',
      charset: 'UTF-8',
      compressible: true,
    },
    'application/index': {
      source: 'iana',
    },
    'application/index.cmd': {
      source: 'iana',
    },
    'application/index.obj': {
      source: 'iana',
    },
    'application/index.response': {
      source: 'iana',
    },
    'application/index.vnd': {
      source: 'iana',
    },
    'application/inkml+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['ink', 'inkml'],
    },
    'application/iotp': {
      source: 'iana',
    },
    'application/ipfix': {
      source: 'iana',
      extensions: ['ipfix'],
    },
    'application/ipp': {
      source: 'iana',
    },
    'application/isup': {
      source: 'iana',
    },
    'application/its+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['its'],
    },
    'application/java-archive': {
      source: 'apache',
      compressible: false,
      extensions: ['jar', 'war', 'ear'],
    },
    'application/java-serialized-object': {
      source: 'apache',
      compressible: false,
      extensions: ['ser'],
    },
    'application/java-vm': {
      source: 'apache',
      compressible: false,
      extensions: ['class'],
    },
    'application/javascript': {
      source: 'iana',
      charset: 'UTF-8',
      compressible: true,
      extensions: ['js', 'mjs'],
    },
    'application/jf2feed+json': {
      source: 'iana',
      compressible: true,
    },
    'application/jose': {
      source: 'iana',
    },
    'application/jose+json': {
      source: 'iana',
      compressible: true,
    },
    'application/jrd+json': {
      source: 'iana',
      compressible: true,
    },
    'application/jscalendar+json': {
      source: 'iana',
      compressible: true,
    },
    'application/json': {
      source: 'iana',
      charset: 'UTF-8',
      compressible: true,
      extensions: ['json', 'map'],
    },
    'application/json-patch+json': {
      source: 'iana',
      compressible: true,
    },
    'application/json-seq': {
      source: 'iana',
    },
    'application/json5': {
      extensions: ['json5'],
    },
    'application/jsonml+json': {
      source: 'apache',
      compressible: true,
      extensions: ['jsonml'],
    },
    'application/jwk+json': {
      source: 'iana',
      compressible: true,
    },
    'application/jwk-set+json': {
      source: 'iana',
      compressible: true,
    },
    'application/jwt': {
      source: 'iana',
    },
    'application/kpml-request+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/kpml-response+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/ld+json': {
      source: 'iana',
      compressible: true,
      extensions: ['jsonld'],
    },
    'application/lgr+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['lgr'],
    },
    'application/link-format': {
      source: 'iana',
    },
    'application/load-control+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/lost+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['lostxml'],
    },
    'application/lostsync+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/lpf+zip': {
      source: 'iana',
      compressible: false,
    },
    'application/lxf': {
      source: 'iana',
    },
    'application/mac-binhex40': {
      source: 'iana',
      extensions: ['hqx'],
    },
    'application/mac-compactpro': {
      source: 'apache',
      extensions: ['cpt'],
    },
    'application/macwriteii': {
      source: 'iana',
    },
    'application/mads+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['mads'],
    },
    'application/manifest+json': {
      charset: 'UTF-8',
      compressible: true,
      extensions: ['webmanifest'],
    },
    'application/marc': {
      source: 'iana',
      extensions: ['mrc'],
    },
    'application/marcxml+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['mrcx'],
    },
    'application/mathematica': {
      source: 'iana',
      extensions: ['ma', 'nb', 'mb'],
    },
    'application/mathml+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['mathml'],
    },
    'application/mathml-content+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/mathml-presentation+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/mbms-associated-procedure-description+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/mbms-deregister+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/mbms-envelope+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/mbms-msk+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/mbms-msk-response+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/mbms-protection-description+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/mbms-reception-report+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/mbms-register+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/mbms-register-response+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/mbms-schedule+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/mbms-user-service-description+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/mbox': {
      source: 'iana',
      extensions: ['mbox'],
    },
    'application/media-policy-dataset+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/media_control+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/mediaservercontrol+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['mscml'],
    },
    'application/merge-patch+json': {
      source: 'iana',
      compressible: true,
    },
    'application/metalink+xml': {
      source: 'apache',
      compressible: true,
      extensions: ['metalink'],
    },
    'application/metalink4+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['meta4'],
    },
    'application/mets+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['mets'],
    },
    'application/mf4': {
      source: 'iana',
    },
    'application/mikey': {
      source: 'iana',
    },
    'application/mipc': {
      source: 'iana',
    },
    'application/mmt-aei+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['maei'],
    },
    'application/mmt-usd+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['musd'],
    },
    'application/mods+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['mods'],
    },
    'application/moss-keys': {
      source: 'iana',
    },
    'application/moss-signature': {
      source: 'iana',
    },
    'application/mosskey-data': {
      source: 'iana',
    },
    'application/mosskey-request': {
      source: 'iana',
    },
    'application/mp21': {
      source: 'iana',
      extensions: ['m21', 'mp21'],
    },
    'application/mp4': {
      source: 'iana',
      extensions: ['mp4s', 'm4p'],
    },
    'application/mpeg4-generic': {
      source: 'iana',
    },
    'application/mpeg4-iod': {
      source: 'iana',
    },
    'application/mpeg4-iod-xmt': {
      source: 'iana',
    },
    'application/mrb-consumer+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['xdf'],
    },
    'application/mrb-publish+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['xdf'],
    },
    'application/msc-ivr+xml': {
      source: 'iana',
      charset: 'UTF-8',
      compressible: true,
    },
    'application/msc-mixer+xml': {
      source: 'iana',
      charset: 'UTF-8',
      compressible: true,
    },
    'application/msword': {
      source: 'iana',
      compressible: false,
      extensions: ['doc', 'dot'],
    },
    'application/mud+json': {
      source: 'iana',
      compressible: true,
    },
    'application/multipart-core': {
      source: 'iana',
    },
    'application/mxf': {
      source: 'iana',
      extensions: ['mxf'],
    },
    'application/n-quads': {
      source: 'iana',
      extensions: ['nq'],
    },
    'application/n-triples': {
      source: 'iana',
      extensions: ['nt'],
    },
    'application/nasdata': {
      source: 'iana',
    },
    'application/news-checkgroups': {
      source: 'iana',
      charset: 'US-ASCII',
    },
    'application/news-groupinfo': {
      source: 'iana',
      charset: 'US-ASCII',
    },
    'application/news-transmission': {
      source: 'iana',
    },
    'application/nlsml+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/node': {
      source: 'iana',
      extensions: ['cjs'],
    },
    'application/nss': {
      source: 'iana',
    },
    'application/ocsp-request': {
      source: 'iana',
    },
    'application/ocsp-response': {
      source: 'iana',
    },
    'application/octet-stream': {
      source: 'iana',
      compressible: false,
      extensions: [
        'bin',
        'dms',
        'lrf',
        'mar',
        'so',
        'dist',
        'distz',
        'pkg',
        'bpk',
        'dump',
        'elc',
        'deploy',
        'exe',
        'dll',
        'deb',
        'dmg',
        'iso',
        'img',
        'msi',
        'msp',
        'msm',
        'buffer',
      ],
    },
    'application/oda': {
      source: 'iana',
      extensions: ['oda'],
    },
    'application/odm+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/odx': {
      source: 'iana',
    },
    'application/oebps-package+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['opf'],
    },
    'application/ogg': {
      source: 'iana',
      compressible: false,
      extensions: ['ogx'],
    },
    'application/omdoc+xml': {
      source: 'apache',
      compressible: true,
      extensions: ['omdoc'],
    },
    'application/onenote': {
      source: 'apache',
      extensions: ['onetoc', 'onetoc2', 'onetmp', 'onepkg'],
    },
    'application/opc-nodeset+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/oscore': {
      source: 'iana',
    },
    'application/oxps': {
      source: 'iana',
      extensions: ['oxps'],
    },
    'application/p2p-overlay+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['relo'],
    },
    'application/parityfec': {
      source: 'iana',
    },
    'application/passport': {
      source: 'iana',
    },
    'application/patch-ops-error+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['xer'],
    },
    'application/pdf': {
      source: 'iana',
      compressible: false,
      extensions: ['pdf'],
    },
    'application/pdx': {
      source: 'iana',
    },
    'application/pem-certificate-chain': {
      source: 'iana',
    },
    'application/pgp-encrypted': {
      source: 'iana',
      compressible: false,
      extensions: ['pgp'],
    },
    'application/pgp-keys': {
      source: 'iana',
    },
    'application/pgp-signature': {
      source: 'iana',
      extensions: ['asc', 'sig'],
    },
    'application/pics-rules': {
      source: 'apache',
      extensions: ['prf'],
    },
    'application/pidf+xml': {
      source: 'iana',
      charset: 'UTF-8',
      compressible: true,
    },
    'application/pidf-diff+xml': {
      source: 'iana',
      charset: 'UTF-8',
      compressible: true,
    },
    'application/pkcs10': {
      source: 'iana',
      extensions: ['p10'],
    },
    'application/pkcs12': {
      source: 'iana',
    },
    'application/pkcs7-mime': {
      source: 'iana',
      extensions: ['p7m', 'p7c'],
    },
    'application/pkcs7-signature': {
      source: 'iana',
      extensions: ['p7s'],
    },
    'application/pkcs8': {
      source: 'iana',
      extensions: ['p8'],
    },
    'application/pkcs8-encrypted': {
      source: 'iana',
    },
    'application/pkix-attr-cert': {
      source: 'iana',
      extensions: ['ac'],
    },
    'application/pkix-cert': {
      source: 'iana',
      extensions: ['cer'],
    },
    'application/pkix-crl': {
      source: 'iana',
      extensions: ['crl'],
    },
    'application/pkix-pkipath': {
      source: 'iana',
      extensions: ['pkipath'],
    },
    'application/pkixcmp': {
      source: 'iana',
      extensions: ['pki'],
    },
    'application/pls+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['pls'],
    },
    'application/poc-settings+xml': {
      source: 'iana',
      charset: 'UTF-8',
      compressible: true,
    },
    'application/postscript': {
      source: 'iana',
      compressible: true,
      extensions: ['ai', 'eps', 'ps'],
    },
    'application/ppsp-tracker+json': {
      source: 'iana',
      compressible: true,
    },
    'application/problem+json': {
      source: 'iana',
      compressible: true,
    },
    'application/problem+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/provenance+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['provx'],
    },
    'application/prs.alvestrand.titrax-sheet': {
      source: 'iana',
    },
    'application/prs.cww': {
      source: 'iana',
      extensions: ['cww'],
    },
    'application/prs.cyn': {
      source: 'iana',
      charset: '7-BIT',
    },
    'application/prs.hpub+zip': {
      source: 'iana',
      compressible: false,
    },
    'application/prs.nprend': {
      source: 'iana',
    },
    'application/prs.plucker': {
      source: 'iana',
    },
    'application/prs.rdf-xml-crypt': {
      source: 'iana',
    },
    'application/prs.xsf+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/pskc+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['pskcxml'],
    },
    'application/pvd+json': {
      source: 'iana',
      compressible: true,
    },
    'application/qsig': {
      source: 'iana',
    },
    'application/raml+yaml': {
      compressible: true,
      extensions: ['raml'],
    },
    'application/raptorfec': {
      source: 'iana',
    },
    'application/rdap+json': {
      source: 'iana',
      compressible: true,
    },
    'application/rdf+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['rdf', 'owl'],
    },
    'application/reginfo+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['rif'],
    },
    'application/relax-ng-compact-syntax': {
      source: 'iana',
      extensions: ['rnc'],
    },
    'application/remote-printing': {
      source: 'iana',
    },
    'application/reputon+json': {
      source: 'iana',
      compressible: true,
    },
    'application/resource-lists+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['rl'],
    },
    'application/resource-lists-diff+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['rld'],
    },
    'application/rfc+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/riscos': {
      source: 'iana',
    },
    'application/rlmi+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/rls-services+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['rs'],
    },
    'application/route-apd+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['rapd'],
    },
    'application/route-s-tsid+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['sls'],
    },
    'application/route-usd+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['rusd'],
    },
    'application/rpki-ghostbusters': {
      source: 'iana',
      extensions: ['gbr'],
    },
    'application/rpki-manifest': {
      source: 'iana',
      extensions: ['mft'],
    },
    'application/rpki-publication': {
      source: 'iana',
    },
    'application/rpki-roa': {
      source: 'iana',
      extensions: ['roa'],
    },
    'application/rpki-updown': {
      source: 'iana',
    },
    'application/rsd+xml': {
      source: 'apache',
      compressible: true,
      extensions: ['rsd'],
    },
    'application/rss+xml': {
      source: 'apache',
      compressible: true,
      extensions: ['rss'],
    },
    'application/rtf': {
      source: 'iana',
      compressible: true,
      extensions: ['rtf'],
    },
    'application/rtploopback': {
      source: 'iana',
    },
    'application/rtx': {
      source: 'iana',
    },
    'application/samlassertion+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/samlmetadata+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/sarif+json': {
      source: 'iana',
      compressible: true,
    },
    'application/sbe': {
      source: 'iana',
    },
    'application/sbml+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['sbml'],
    },
    'application/scaip+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/scim+json': {
      source: 'iana',
      compressible: true,
    },
    'application/scvp-cv-request': {
      source: 'iana',
      extensions: ['scq'],
    },
    'application/scvp-cv-response': {
      source: 'iana',
      extensions: ['scs'],
    },
    'application/scvp-vp-request': {
      source: 'iana',
      extensions: ['spq'],
    },
    'application/scvp-vp-response': {
      source: 'iana',
      extensions: ['spp'],
    },
    'application/sdp': {
      source: 'iana',
      extensions: ['sdp'],
    },
    'application/secevent+jwt': {
      source: 'iana',
    },
    'application/senml+cbor': {
      source: 'iana',
    },
    'application/senml+json': {
      source: 'iana',
      compressible: true,
    },
    'application/senml+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['senmlx'],
    },
    'application/senml-etch+cbor': {
      source: 'iana',
    },
    'application/senml-etch+json': {
      source: 'iana',
      compressible: true,
    },
    'application/senml-exi': {
      source: 'iana',
    },
    'application/sensml+cbor': {
      source: 'iana',
    },
    'application/sensml+json': {
      source: 'iana',
      compressible: true,
    },
    'application/sensml+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['sensmlx'],
    },
    'application/sensml-exi': {
      source: 'iana',
    },
    'application/sep+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/sep-exi': {
      source: 'iana',
    },
    'application/session-info': {
      source: 'iana',
    },
    'application/set-payment': {
      source: 'iana',
    },
    'application/set-payment-initiation': {
      source: 'iana',
      extensions: ['setpay'],
    },
    'application/set-registration': {
      source: 'iana',
    },
    'application/set-registration-initiation': {
      source: 'iana',
      extensions: ['setreg'],
    },
    'application/sgml': {
      source: 'iana',
    },
    'application/sgml-open-catalog': {
      source: 'iana',
    },
    'application/shf+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['shf'],
    },
    'application/sieve': {
      source: 'iana',
      extensions: ['siv', 'sieve'],
    },
    'application/simple-filter+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/simple-message-summary': {
      source: 'iana',
    },
    'application/simplesymbolcontainer': {
      source: 'iana',
    },
    'application/sipc': {
      source: 'iana',
    },
    'application/slate': {
      source: 'iana',
    },
    'application/smil': {
      source: 'iana',
    },
    'application/smil+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['smi', 'smil'],
    },
    'application/smpte336m': {
      source: 'iana',
    },
    'application/soap+fastinfoset': {
      source: 'iana',
    },
    'application/soap+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/sparql-query': {
      source: 'iana',
      extensions: ['rq'],
    },
    'application/sparql-results+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['srx'],
    },
    'application/spirits-event+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/sql': {
      source: 'iana',
    },
    'application/srgs': {
      source: 'iana',
      extensions: ['gram'],
    },
    'application/srgs+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['grxml'],
    },
    'application/sru+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['sru'],
    },
    'application/ssdl+xml': {
      source: 'apache',
      compressible: true,
      extensions: ['ssdl'],
    },
    'application/ssml+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['ssml'],
    },
    'application/stix+json': {
      source: 'iana',
      compressible: true,
    },
    'application/swid+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['swidtag'],
    },
    'application/tamp-apex-update': {
      source: 'iana',
    },
    'application/tamp-apex-update-confirm': {
      source: 'iana',
    },
    'application/tamp-community-update': {
      source: 'iana',
    },
    'application/tamp-community-update-confirm': {
      source: 'iana',
    },
    'application/tamp-error': {
      source: 'iana',
    },
    'application/tamp-sequence-adjust': {
      source: 'iana',
    },
    'application/tamp-sequence-adjust-confirm': {
      source: 'iana',
    },
    'application/tamp-status-query': {
      source: 'iana',
    },
    'application/tamp-status-response': {
      source: 'iana',
    },
    'application/tamp-update': {
      source: 'iana',
    },
    'application/tamp-update-confirm': {
      source: 'iana',
    },
    'application/tar': {
      compressible: true,
    },
    'application/taxii+json': {
      source: 'iana',
      compressible: true,
    },
    'application/td+json': {
      source: 'iana',
      compressible: true,
    },
    'application/tei+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['tei', 'teicorpus'],
    },
    'application/tetra_isi': {
      source: 'iana',
    },
    'application/thraud+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['tfi'],
    },
    'application/timestamp-query': {
      source: 'iana',
    },
    'application/timestamp-reply': {
      source: 'iana',
    },
    'application/timestamped-data': {
      source: 'iana',
      extensions: ['tsd'],
    },
    'application/tlsrpt+gzip': {
      source: 'iana',
    },
    'application/tlsrpt+json': {
      source: 'iana',
      compressible: true,
    },
    'application/tnauthlist': {
      source: 'iana',
    },
    'application/toml': {
      compressible: true,
      extensions: ['toml'],
    },
    'application/trickle-ice-sdpfrag': {
      source: 'iana',
    },
    'application/trig': {
      source: 'iana',
    },
    'application/ttml+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['ttml'],
    },
    'application/tve-trigger': {
      source: 'iana',
    },
    'application/tzif': {
      source: 'iana',
    },
    'application/tzif-leap': {
      source: 'iana',
    },
    'application/ubjson': {
      compressible: false,
      extensions: ['ubj'],
    },
    'application/ulpfec': {
      source: 'iana',
    },
    'application/urc-grpsheet+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/urc-ressheet+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['rsheet'],
    },
    'application/urc-targetdesc+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['td'],
    },
    'application/urc-uisocketdesc+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vcard+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vcard+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vemmi': {
      source: 'iana',
    },
    'application/vividence.scriptfile': {
      source: 'apache',
    },
    'application/vnd.1000minds.decision-model+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['1km'],
    },
    'application/vnd.3gpp-prose+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp-prose-pc3ch+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp-v2x-local-service-information': {
      source: 'iana',
    },
    'application/vnd.3gpp.access-transfer-events+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp.bsf+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp.gmop+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp.interworking-data': {
      source: 'iana',
    },
    'application/vnd.3gpp.mc-signalling-ear': {
      source: 'iana',
    },
    'application/vnd.3gpp.mcdata-affiliation-command+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp.mcdata-info+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp.mcdata-payload': {
      source: 'iana',
    },
    'application/vnd.3gpp.mcdata-service-config+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp.mcdata-signalling': {
      source: 'iana',
    },
    'application/vnd.3gpp.mcdata-ue-config+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp.mcdata-user-profile+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp.mcptt-affiliation-command+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp.mcptt-floor-request+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp.mcptt-info+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp.mcptt-location-info+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp.mcptt-mbms-usage-info+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp.mcptt-service-config+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp.mcptt-signed+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp.mcptt-ue-config+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp.mcptt-ue-init-config+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp.mcptt-user-profile+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp.mcvideo-affiliation-command+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp.mcvideo-affiliation-info+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp.mcvideo-info+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp.mcvideo-location-info+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp.mcvideo-mbms-usage-info+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp.mcvideo-service-config+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp.mcvideo-transmission-request+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp.mcvideo-ue-config+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp.mcvideo-user-profile+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp.mid-call+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp.pic-bw-large': {
      source: 'iana',
      extensions: ['plb'],
    },
    'application/vnd.3gpp.pic-bw-small': {
      source: 'iana',
      extensions: ['psb'],
    },
    'application/vnd.3gpp.pic-bw-var': {
      source: 'iana',
      extensions: ['pvb'],
    },
    'application/vnd.3gpp.sms': {
      source: 'iana',
    },
    'application/vnd.3gpp.sms+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp.srvcc-ext+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp.srvcc-info+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp.state-and-event-info+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp.ussd+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp2.bcmcsinfo+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.3gpp2.sms': {
      source: 'iana',
    },
    'application/vnd.3gpp2.tcap': {
      source: 'iana',
      extensions: ['tcap'],
    },
    'application/vnd.3lightssoftware.imagescal': {
      source: 'iana',
    },
    'application/vnd.3m.post-it-notes': {
      source: 'iana',
      extensions: ['pwn'],
    },
    'application/vnd.accpac.simply.aso': {
      source: 'iana',
      extensions: ['aso'],
    },
    'application/vnd.accpac.simply.imp': {
      source: 'iana',
      extensions: ['imp'],
    },
    'application/vnd.acucobol': {
      source: 'iana',
      extensions: ['acu'],
    },
    'application/vnd.acucorp': {
      source: 'iana',
      extensions: ['atc', 'acutc'],
    },
    'application/vnd.adobe.air-application-installer-package+zip': {
      source: 'apache',
      compressible: false,
      extensions: ['air'],
    },
    'application/vnd.adobe.flash.movie': {
      source: 'iana',
    },
    'application/vnd.adobe.formscentral.fcdt': {
      source: 'iana',
      extensions: ['fcdt'],
    },
    'application/vnd.adobe.fxp': {
      source: 'iana',
      extensions: ['fxp', 'fxpl'],
    },
    'application/vnd.adobe.partial-upload': {
      source: 'iana',
    },
    'application/vnd.adobe.xdp+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['xdp'],
    },
    'application/vnd.adobe.xfdf': {
      source: 'iana',
      extensions: ['xfdf'],
    },
    'application/vnd.aether.imp': {
      source: 'iana',
    },
    'application/vnd.afpc.afplinedata': {
      source: 'iana',
    },
    'application/vnd.afpc.afplinedata-pagedef': {
      source: 'iana',
    },
    'application/vnd.afpc.cmoca-cmresource': {
      source: 'iana',
    },
    'application/vnd.afpc.foca-charset': {
      source: 'iana',
    },
    'application/vnd.afpc.foca-codedfont': {
      source: 'iana',
    },
    'application/vnd.afpc.foca-codepage': {
      source: 'iana',
    },
    'application/vnd.afpc.modca': {
      source: 'iana',
    },
    'application/vnd.afpc.modca-cmtable': {
      source: 'iana',
    },
    'application/vnd.afpc.modca-formdef': {
      source: 'iana',
    },
    'application/vnd.afpc.modca-mediummap': {
      source: 'iana',
    },
    'application/vnd.afpc.modca-objectcontainer': {
      source: 'iana',
    },
    'application/vnd.afpc.modca-overlay': {
      source: 'iana',
    },
    'application/vnd.afpc.modca-pagesegment': {
      source: 'iana',
    },
    'application/vnd.ah-barcode': {
      source: 'iana',
    },
    'application/vnd.ahead.space': {
      source: 'iana',
      extensions: ['ahead'],
    },
    'application/vnd.airzip.filesecure.azf': {
      source: 'iana',
      extensions: ['azf'],
    },
    'application/vnd.airzip.filesecure.azs': {
      source: 'iana',
      extensions: ['azs'],
    },
    'application/vnd.amadeus+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.amazon.ebook': {
      source: 'apache',
      extensions: ['azw'],
    },
    'application/vnd.amazon.mobi8-ebook': {
      source: 'iana',
    },
    'application/vnd.americandynamics.acc': {
      source: 'iana',
      extensions: ['acc'],
    },
    'application/vnd.amiga.ami': {
      source: 'iana',
      extensions: ['ami'],
    },
    'application/vnd.amundsen.maze+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.android.ota': {
      source: 'iana',
    },
    'application/vnd.android.package-archive': {
      source: 'apache',
      compressible: false,
      extensions: ['apk'],
    },
    'application/vnd.anki': {
      source: 'iana',
    },
    'application/vnd.anser-web-certificate-issue-initiation': {
      source: 'iana',
      extensions: ['cii'],
    },
    'application/vnd.anser-web-funds-transfer-initiation': {
      source: 'apache',
      extensions: ['fti'],
    },
    'application/vnd.antix.game-component': {
      source: 'iana',
      extensions: ['atx'],
    },
    'application/vnd.apache.thrift.binary': {
      source: 'iana',
    },
    'application/vnd.apache.thrift.compact': {
      source: 'iana',
    },
    'application/vnd.apache.thrift.json': {
      source: 'iana',
    },
    'application/vnd.api+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.aplextor.warrp+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.apothekende.reservation+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.apple.installer+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['mpkg'],
    },
    'application/vnd.apple.keynote': {
      source: 'iana',
      extensions: ['key'],
    },
    'application/vnd.apple.mpegurl': {
      source: 'iana',
      extensions: ['m3u8'],
    },
    'application/vnd.apple.numbers': {
      source: 'iana',
      extensions: ['numbers'],
    },
    'application/vnd.apple.pages': {
      source: 'iana',
      extensions: ['pages'],
    },
    'application/vnd.apple.pkpass': {
      compressible: false,
      extensions: ['pkpass'],
    },
    'application/vnd.arastra.swi': {
      source: 'iana',
    },
    'application/vnd.aristanetworks.swi': {
      source: 'iana',
      extensions: ['swi'],
    },
    'application/vnd.artisan+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.artsquare': {
      source: 'iana',
    },
    'application/vnd.astraea-software.iota': {
      source: 'iana',
      extensions: ['iota'],
    },
    'application/vnd.audiograph': {
      source: 'iana',
      extensions: ['aep'],
    },
    'application/vnd.autopackage': {
      source: 'iana',
    },
    'application/vnd.avalon+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.avistar+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.balsamiq.bmml+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['bmml'],
    },
    'application/vnd.balsamiq.bmpr': {
      source: 'iana',
    },
    'application/vnd.banana-accounting': {
      source: 'iana',
    },
    'application/vnd.bbf.usp.error': {
      source: 'iana',
    },
    'application/vnd.bbf.usp.msg': {
      source: 'iana',
    },
    'application/vnd.bbf.usp.msg+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.bekitzur-stech+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.bint.med-content': {
      source: 'iana',
    },
    'application/vnd.biopax.rdf+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.blink-idb-value-wrapper': {
      source: 'iana',
    },
    'application/vnd.blueice.multipass': {
      source: 'iana',
      extensions: ['mpm'],
    },
    'application/vnd.bluetooth.ep.oob': {
      source: 'iana',
    },
    'application/vnd.bluetooth.le.oob': {
      source: 'iana',
    },
    'application/vnd.bmi': {
      source: 'iana',
      extensions: ['bmi'],
    },
    'application/vnd.bpf': {
      source: 'iana',
    },
    'application/vnd.bpf3': {
      source: 'iana',
    },
    'application/vnd.businessobjects': {
      source: 'iana',
      extensions: ['rep'],
    },
    'application/vnd.byu.uapi+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.cab-jscript': {
      source: 'iana',
    },
    'application/vnd.canon-cpdl': {
      source: 'iana',
    },
    'application/vnd.canon-lips': {
      source: 'iana',
    },
    'application/vnd.capasystems-pg+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.cendio.thinlinc.clientconf': {
      source: 'iana',
    },
    'application/vnd.century-systems.tcp_stream': {
      source: 'iana',
    },
    'application/vnd.chemdraw+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['cdxml'],
    },
    'application/vnd.chess-pgn': {
      source: 'iana',
    },
    'application/vnd.chipnuts.karaoke-mmd': {
      source: 'iana',
      extensions: ['mmd'],
    },
    'application/vnd.ciedi': {
      source: 'iana',
    },
    'application/vnd.cinderella': {
      source: 'iana',
      extensions: ['cdy'],
    },
    'application/vnd.cirpack.isdn-ext': {
      source: 'iana',
    },
    'application/vnd.citationstyles.style+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['csl'],
    },
    'application/vnd.claymore': {
      source: 'iana',
      extensions: ['cla'],
    },
    'application/vnd.cloanto.rp9': {
      source: 'iana',
      extensions: ['rp9'],
    },
    'application/vnd.clonk.c4group': {
      source: 'iana',
      extensions: ['c4g', 'c4d', 'c4f', 'c4p', 'c4u'],
    },
    'application/vnd.cluetrust.cartomobile-config': {
      source: 'iana',
      extensions: ['c11amc'],
    },
    'application/vnd.cluetrust.cartomobile-config-pkg': {
      source: 'iana',
      extensions: ['c11amz'],
    },
    'application/vnd.coffeescript': {
      source: 'iana',
    },
    'application/vnd.collabio.xodocuments.document': {
      source: 'iana',
    },
    'application/vnd.collabio.xodocuments.document-template': {
      source: 'iana',
    },
    'application/vnd.collabio.xodocuments.presentation': {
      source: 'iana',
    },
    'application/vnd.collabio.xodocuments.presentation-template': {
      source: 'iana',
    },
    'application/vnd.collabio.xodocuments.spreadsheet': {
      source: 'iana',
    },
    'application/vnd.collabio.xodocuments.spreadsheet-template': {
      source: 'iana',
    },
    'application/vnd.collection+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.collection.doc+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.collection.next+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.comicbook+zip': {
      source: 'iana',
      compressible: false,
    },
    'application/vnd.comicbook-rar': {
      source: 'iana',
    },
    'application/vnd.commerce-battelle': {
      source: 'iana',
    },
    'application/vnd.commonspace': {
      source: 'iana',
      extensions: ['csp'],
    },
    'application/vnd.contact.cmsg': {
      source: 'iana',
      extensions: ['cdbcmsg'],
    },
    'application/vnd.coreos.ignition+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.cosmocaller': {
      source: 'iana',
      extensions: ['cmc'],
    },
    'application/vnd.crick.clicker': {
      source: 'iana',
      extensions: ['clkx'],
    },
    'application/vnd.crick.clicker.keyboard': {
      source: 'iana',
      extensions: ['clkk'],
    },
    'application/vnd.crick.clicker.palette': {
      source: 'iana',
      extensions: ['clkp'],
    },
    'application/vnd.crick.clicker.template': {
      source: 'iana',
      extensions: ['clkt'],
    },
    'application/vnd.crick.clicker.wordbank': {
      source: 'iana',
      extensions: ['clkw'],
    },
    'application/vnd.criticaltools.wbs+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['wbs'],
    },
    'application/vnd.cryptii.pipe+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.crypto-shade-file': {
      source: 'iana',
    },
    'application/vnd.ctc-posml': {
      source: 'iana',
      extensions: ['pml'],
    },
    'application/vnd.ctct.ws+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.cups-pdf': {
      source: 'iana',
    },
    'application/vnd.cups-postscript': {
      source: 'iana',
    },
    'application/vnd.cups-ppd': {
      source: 'iana',
      extensions: ['ppd'],
    },
    'application/vnd.cups-raster': {
      source: 'iana',
    },
    'application/vnd.cups-raw': {
      source: 'iana',
    },
    'application/vnd.curl': {
      source: 'iana',
    },
    'application/vnd.curl.car': {
      source: 'apache',
      extensions: ['car'],
    },
    'application/vnd.curl.pcurl': {
      source: 'apache',
      extensions: ['pcurl'],
    },
    'application/vnd.cyan.dean.root+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.cybank': {
      source: 'iana',
    },
    'application/vnd.cyclonedx+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.cyclonedx+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.d2l.coursepackage1p0+zip': {
      source: 'iana',
      compressible: false,
    },
    'application/vnd.d3m-dataset': {
      source: 'iana',
    },
    'application/vnd.d3m-problem': {
      source: 'iana',
    },
    'application/vnd.dart': {
      source: 'iana',
      compressible: true,
      extensions: ['dart'],
    },
    'application/vnd.data-vision.rdz': {
      source: 'iana',
      extensions: ['rdz'],
    },
    'application/vnd.datapackage+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.dataresource+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.dbf': {
      source: 'iana',
      extensions: ['dbf'],
    },
    'application/vnd.debian.binary-package': {
      source: 'iana',
    },
    'application/vnd.dece.data': {
      source: 'iana',
      extensions: ['uvf', 'uvvf', 'uvd', 'uvvd'],
    },
    'application/vnd.dece.ttml+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['uvt', 'uvvt'],
    },
    'application/vnd.dece.unspecified': {
      source: 'iana',
      extensions: ['uvx', 'uvvx'],
    },
    'application/vnd.dece.zip': {
      source: 'iana',
      extensions: ['uvz', 'uvvz'],
    },
    'application/vnd.denovo.fcselayout-link': {
      source: 'iana',
      extensions: ['fe_launch'],
    },
    'application/vnd.desmume.movie': {
      source: 'iana',
    },
    'application/vnd.dir-bi.plate-dl-nosuffix': {
      source: 'iana',
    },
    'application/vnd.dm.delegation+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.dna': {
      source: 'iana',
      extensions: ['dna'],
    },
    'application/vnd.document+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.dolby.mlp': {
      source: 'apache',
      extensions: ['mlp'],
    },
    'application/vnd.dolby.mobile.1': {
      source: 'iana',
    },
    'application/vnd.dolby.mobile.2': {
      source: 'iana',
    },
    'application/vnd.doremir.scorecloud-binary-document': {
      source: 'iana',
    },
    'application/vnd.dpgraph': {
      source: 'iana',
      extensions: ['dpg'],
    },
    'application/vnd.dreamfactory': {
      source: 'iana',
      extensions: ['dfac'],
    },
    'application/vnd.drive+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.ds-keypoint': {
      source: 'apache',
      extensions: ['kpxx'],
    },
    'application/vnd.dtg.local': {
      source: 'iana',
    },
    'application/vnd.dtg.local.flash': {
      source: 'iana',
    },
    'application/vnd.dtg.local.html': {
      source: 'iana',
    },
    'application/vnd.dvb.ait': {
      source: 'iana',
      extensions: ['ait'],
    },
    'application/vnd.dvb.dvbisl+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.dvb.dvbj': {
      source: 'iana',
    },
    'application/vnd.dvb.esgcontainer': {
      source: 'iana',
    },
    'application/vnd.dvb.ipdcdftnotifaccess': {
      source: 'iana',
    },
    'application/vnd.dvb.ipdcesgaccess': {
      source: 'iana',
    },
    'application/vnd.dvb.ipdcesgaccess2': {
      source: 'iana',
    },
    'application/vnd.dvb.ipdcesgpdd': {
      source: 'iana',
    },
    'application/vnd.dvb.ipdcroaming': {
      source: 'iana',
    },
    'application/vnd.dvb.iptv.alfec-base': {
      source: 'iana',
    },
    'application/vnd.dvb.iptv.alfec-enhancement': {
      source: 'iana',
    },
    'application/vnd.dvb.notif-aggregate-root+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.dvb.notif-container+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.dvb.notif-generic+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.dvb.notif-ia-msglist+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.dvb.notif-ia-registration-request+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.dvb.notif-ia-registration-response+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.dvb.notif-init+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.dvb.pfr': {
      source: 'iana',
    },
    'application/vnd.dvb.service': {
      source: 'iana',
      extensions: ['svc'],
    },
    'application/vnd.dxr': {
      source: 'iana',
    },
    'application/vnd.dynageo': {
      source: 'iana',
      extensions: ['geo'],
    },
    'application/vnd.dzr': {
      source: 'iana',
    },
    'application/vnd.easykaraoke.cdgdownload': {
      source: 'iana',
    },
    'application/vnd.ecdis-update': {
      source: 'iana',
    },
    'application/vnd.ecip.rlp': {
      source: 'iana',
    },
    'application/vnd.ecowin.chart': {
      source: 'iana',
      extensions: ['mag'],
    },
    'application/vnd.ecowin.filerequest': {
      source: 'iana',
    },
    'application/vnd.ecowin.fileupdate': {
      source: 'iana',
    },
    'application/vnd.ecowin.series': {
      source: 'iana',
    },
    'application/vnd.ecowin.seriesrequest': {
      source: 'iana',
    },
    'application/vnd.ecowin.seriesupdate': {
      source: 'iana',
    },
    'application/vnd.efi.img': {
      source: 'iana',
    },
    'application/vnd.efi.iso': {
      source: 'iana',
    },
    'application/vnd.emclient.accessrequest+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.enliven': {
      source: 'iana',
      extensions: ['nml'],
    },
    'application/vnd.enphase.envoy': {
      source: 'iana',
    },
    'application/vnd.eprints.data+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.epson.esf': {
      source: 'iana',
      extensions: ['esf'],
    },
    'application/vnd.epson.msf': {
      source: 'iana',
      extensions: ['msf'],
    },
    'application/vnd.epson.quickanime': {
      source: 'iana',
      extensions: ['qam'],
    },
    'application/vnd.epson.salt': {
      source: 'iana',
      extensions: ['slt'],
    },
    'application/vnd.epson.ssf': {
      source: 'iana',
      extensions: ['ssf'],
    },
    'application/vnd.ericsson.quickcall': {
      source: 'iana',
    },
    'application/vnd.espass-espass+zip': {
      source: 'iana',
      compressible: false,
    },
    'application/vnd.eszigno3+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['es3', 'et3'],
    },
    'application/vnd.etsi.aoc+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.etsi.asic-e+zip': {
      source: 'iana',
      compressible: false,
    },
    'application/vnd.etsi.asic-s+zip': {
      source: 'iana',
      compressible: false,
    },
    'application/vnd.etsi.cug+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.etsi.iptvcommand+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.etsi.iptvdiscovery+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.etsi.iptvprofile+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.etsi.iptvsad-bc+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.etsi.iptvsad-cod+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.etsi.iptvsad-npvr+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.etsi.iptvservice+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.etsi.iptvsync+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.etsi.iptvueprofile+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.etsi.mcid+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.etsi.mheg5': {
      source: 'iana',
    },
    'application/vnd.etsi.overload-control-policy-dataset+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.etsi.pstn+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.etsi.sci+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.etsi.simservs+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.etsi.timestamp-token': {
      source: 'iana',
    },
    'application/vnd.etsi.tsl+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.etsi.tsl.der': {
      source: 'iana',
    },
    'application/vnd.eudora.data': {
      source: 'iana',
    },
    'application/vnd.evolv.ecig.profile': {
      source: 'iana',
    },
    'application/vnd.evolv.ecig.settings': {
      source: 'iana',
    },
    'application/vnd.evolv.ecig.theme': {
      source: 'iana',
    },
    'application/vnd.exstream-empower+zip': {
      source: 'iana',
      compressible: false,
    },
    'application/vnd.exstream-package': {
      source: 'iana',
    },
    'application/vnd.ezpix-album': {
      source: 'iana',
      extensions: ['ez2'],
    },
    'application/vnd.ezpix-package': {
      source: 'iana',
      extensions: ['ez3'],
    },
    'application/vnd.f-secure.mobile': {
      source: 'iana',
    },
    'application/vnd.fastcopy-disk-image': {
      source: 'iana',
    },
    'application/vnd.fdf': {
      source: 'iana',
      extensions: ['fdf'],
    },
    'application/vnd.fdsn.mseed': {
      source: 'iana',
      extensions: ['mseed'],
    },
    'application/vnd.fdsn.seed': {
      source: 'iana',
      extensions: ['seed', 'dataless'],
    },
    'application/vnd.ffsns': {
      source: 'iana',
    },
    'application/vnd.ficlab.flb+zip': {
      source: 'iana',
      compressible: false,
    },
    'application/vnd.filmit.zfc': {
      source: 'iana',
    },
    'application/vnd.fints': {
      source: 'iana',
    },
    'application/vnd.firemonkeys.cloudcell': {
      source: 'iana',
    },
    'application/vnd.flographit': {
      source: 'iana',
      extensions: ['gph'],
    },
    'application/vnd.fluxtime.clip': {
      source: 'iana',
      extensions: ['ftc'],
    },
    'application/vnd.font-fontforge-sfd': {
      source: 'iana',
    },
    'application/vnd.framemaker': {
      source: 'iana',
      extensions: ['fm', 'frame', 'maker', 'book'],
    },
    'application/vnd.frogans.fnc': {
      source: 'iana',
      extensions: ['fnc'],
    },
    'application/vnd.frogans.ltf': {
      source: 'iana',
      extensions: ['ltf'],
    },
    'application/vnd.fsc.weblaunch': {
      source: 'iana',
      extensions: ['fsc'],
    },
    'application/vnd.fujitsu.oasys': {
      source: 'iana',
      extensions: ['oas'],
    },
    'application/vnd.fujitsu.oasys2': {
      source: 'iana',
      extensions: ['oa2'],
    },
    'application/vnd.fujitsu.oasys3': {
      source: 'iana',
      extensions: ['oa3'],
    },
    'application/vnd.fujitsu.oasysgp': {
      source: 'iana',
      extensions: ['fg5'],
    },
    'application/vnd.fujitsu.oasysprs': {
      source: 'iana',
      extensions: ['bh2'],
    },
    'application/vnd.fujixerox.art-ex': {
      source: 'iana',
    },
    'application/vnd.fujixerox.art4': {
      source: 'iana',
    },
    'application/vnd.fujixerox.ddd': {
      source: 'iana',
      extensions: ['ddd'],
    },
    'application/vnd.fujixerox.docuworks': {
      source: 'iana',
      extensions: ['xdw'],
    },
    'application/vnd.fujixerox.docuworks.binder': {
      source: 'iana',
      extensions: ['xbd'],
    },
    'application/vnd.fujixerox.docuworks.container': {
      source: 'iana',
    },
    'application/vnd.fujixerox.hbpl': {
      source: 'iana',
    },
    'application/vnd.fut-misnet': {
      source: 'iana',
    },
    'application/vnd.futoin+cbor': {
      source: 'iana',
    },
    'application/vnd.futoin+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.fuzzysheet': {
      source: 'iana',
      extensions: ['fzs'],
    },
    'application/vnd.genomatix.tuxedo': {
      source: 'iana',
      extensions: ['txd'],
    },
    'application/vnd.gentics.grd+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.geo+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.geocube+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.geogebra.file': {
      source: 'iana',
      extensions: ['ggb'],
    },
    'application/vnd.geogebra.slides': {
      source: 'iana',
    },
    'application/vnd.geogebra.tool': {
      source: 'iana',
      extensions: ['ggt'],
    },
    'application/vnd.geometry-explorer': {
      source: 'iana',
      extensions: ['gex', 'gre'],
    },
    'application/vnd.geonext': {
      source: 'iana',
      extensions: ['gxt'],
    },
    'application/vnd.geoplan': {
      source: 'iana',
      extensions: ['g2w'],
    },
    'application/vnd.geospace': {
      source: 'iana',
      extensions: ['g3w'],
    },
    'application/vnd.gerber': {
      source: 'iana',
    },
    'application/vnd.globalplatform.card-content-mgt': {
      source: 'iana',
    },
    'application/vnd.globalplatform.card-content-mgt-response': {
      source: 'iana',
    },
    'application/vnd.gmx': {
      source: 'iana',
      extensions: ['gmx'],
    },
    'application/vnd.google-apps.document': {
      compressible: false,
      extensions: ['gdoc'],
    },
    'application/vnd.google-apps.presentation': {
      compressible: false,
      extensions: ['gslides'],
    },
    'application/vnd.google-apps.spreadsheet': {
      compressible: false,
      extensions: ['gsheet'],
    },
    'application/vnd.google-earth.kml+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['kml'],
    },
    'application/vnd.google-earth.kmz': {
      source: 'iana',
      compressible: false,
      extensions: ['kmz'],
    },
    'application/vnd.gov.sk.e-form+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.gov.sk.e-form+zip': {
      source: 'iana',
      compressible: false,
    },
    'application/vnd.gov.sk.xmldatacontainer+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.grafeq': {
      source: 'iana',
      extensions: ['gqf', 'gqs'],
    },
    'application/vnd.gridmp': {
      source: 'iana',
    },
    'application/vnd.groove-account': {
      source: 'iana',
      extensions: ['gac'],
    },
    'application/vnd.groove-help': {
      source: 'iana',
      extensions: ['ghf'],
    },
    'application/vnd.groove-identity-message': {
      source: 'iana',
      extensions: ['gim'],
    },
    'application/vnd.groove-injector': {
      source: 'iana',
      extensions: ['grv'],
    },
    'application/vnd.groove-tool-message': {
      source: 'iana',
      extensions: ['gtm'],
    },
    'application/vnd.groove-tool-template': {
      source: 'iana',
      extensions: ['tpl'],
    },
    'application/vnd.groove-vcard': {
      source: 'iana',
      extensions: ['vcg'],
    },
    'application/vnd.hal+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.hal+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['hal'],
    },
    'application/vnd.handheld-entertainment+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['zmm'],
    },
    'application/vnd.hbci': {
      source: 'iana',
      extensions: ['hbci'],
    },
    'application/vnd.hc+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.hcl-bireports': {
      source: 'iana',
    },
    'application/vnd.hdt': {
      source: 'iana',
    },
    'application/vnd.heroku+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.hhe.lesson-player': {
      source: 'iana',
      extensions: ['les'],
    },
    'application/vnd.hp-hpgl': {
      source: 'iana',
      extensions: ['hpgl'],
    },
    'application/vnd.hp-hpid': {
      source: 'iana',
      extensions: ['hpid'],
    },
    'application/vnd.hp-hps': {
      source: 'iana',
      extensions: ['hps'],
    },
    'application/vnd.hp-jlyt': {
      source: 'iana',
      extensions: ['jlt'],
    },
    'application/vnd.hp-pcl': {
      source: 'iana',
      extensions: ['pcl'],
    },
    'application/vnd.hp-pclxl': {
      source: 'iana',
      extensions: ['pclxl'],
    },
    'application/vnd.httphone': {
      source: 'iana',
    },
    'application/vnd.hydrostatix.sof-data': {
      source: 'iana',
      extensions: ['sfd-hdstx'],
    },
    'application/vnd.hyper+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.hyper-item+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.hyperdrive+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.hzn-3d-crossword': {
      source: 'iana',
    },
    'application/vnd.ibm.afplinedata': {
      source: 'iana',
    },
    'application/vnd.ibm.electronic-media': {
      source: 'iana',
    },
    'application/vnd.ibm.minipay': {
      source: 'iana',
      extensions: ['mpy'],
    },
    'application/vnd.ibm.modcap': {
      source: 'iana',
      extensions: ['afp', 'listafp', 'list3820'],
    },
    'application/vnd.ibm.rights-management': {
      source: 'iana',
      extensions: ['irm'],
    },
    'application/vnd.ibm.secure-container': {
      source: 'iana',
      extensions: ['sc'],
    },
    'application/vnd.iccprofile': {
      source: 'iana',
      extensions: ['icc', 'icm'],
    },
    'application/vnd.ieee.1905': {
      source: 'iana',
    },
    'application/vnd.igloader': {
      source: 'iana',
      extensions: ['igl'],
    },
    'application/vnd.imagemeter.folder+zip': {
      source: 'iana',
      compressible: false,
    },
    'application/vnd.imagemeter.image+zip': {
      source: 'iana',
      compressible: false,
    },
    'application/vnd.immervision-ivp': {
      source: 'iana',
      extensions: ['ivp'],
    },
    'application/vnd.immervision-ivu': {
      source: 'iana',
      extensions: ['ivu'],
    },
    'application/vnd.ims.imsccv1p1': {
      source: 'iana',
    },
    'application/vnd.ims.imsccv1p2': {
      source: 'iana',
    },
    'application/vnd.ims.imsccv1p3': {
      source: 'iana',
    },
    'application/vnd.ims.lis.v2.result+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.ims.lti.v2.toolconsumerprofile+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.ims.lti.v2.toolproxy+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.ims.lti.v2.toolproxy.id+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.ims.lti.v2.toolsettings+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.ims.lti.v2.toolsettings.simple+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.informedcontrol.rms+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.informix-visionary': {
      source: 'iana',
    },
    'application/vnd.infotech.project': {
      source: 'iana',
    },
    'application/vnd.infotech.project+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.innopath.wamp.notification': {
      source: 'iana',
    },
    'application/vnd.insors.igm': {
      source: 'iana',
      extensions: ['igm'],
    },
    'application/vnd.intercon.formnet': {
      source: 'iana',
      extensions: ['xpw', 'xpx'],
    },
    'application/vnd.intergeo': {
      source: 'iana',
      extensions: ['i2g'],
    },
    'application/vnd.intertrust.digibox': {
      source: 'iana',
    },
    'application/vnd.intertrust.nncp': {
      source: 'iana',
    },
    'application/vnd.intu.qbo': {
      source: 'iana',
      extensions: ['qbo'],
    },
    'application/vnd.intu.qfx': {
      source: 'iana',
      extensions: ['qfx'],
    },
    'application/vnd.iptc.g2.catalogitem+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.iptc.g2.conceptitem+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.iptc.g2.knowledgeitem+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.iptc.g2.newsitem+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.iptc.g2.newsmessage+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.iptc.g2.packageitem+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.iptc.g2.planningitem+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.ipunplugged.rcprofile': {
      source: 'iana',
      extensions: ['rcprofile'],
    },
    'application/vnd.irepository.package+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['irp'],
    },
    'application/vnd.is-xpr': {
      source: 'iana',
      extensions: ['xpr'],
    },
    'application/vnd.isac.fcs': {
      source: 'iana',
      extensions: ['fcs'],
    },
    'application/vnd.iso11783-10+zip': {
      source: 'iana',
      compressible: false,
    },
    'application/vnd.jam': {
      source: 'iana',
      extensions: ['jam'],
    },
    'application/vnd.japannet-directory-service': {
      source: 'iana',
    },
    'application/vnd.japannet-jpnstore-wakeup': {
      source: 'iana',
    },
    'application/vnd.japannet-payment-wakeup': {
      source: 'iana',
    },
    'application/vnd.japannet-registration': {
      source: 'iana',
    },
    'application/vnd.japannet-registration-wakeup': {
      source: 'iana',
    },
    'application/vnd.japannet-setstore-wakeup': {
      source: 'iana',
    },
    'application/vnd.japannet-verification': {
      source: 'iana',
    },
    'application/vnd.japannet-verification-wakeup': {
      source: 'iana',
    },
    'application/vnd.jcp.javame.midlet-rms': {
      source: 'iana',
      extensions: ['rms'],
    },
    'application/vnd.jisp': {
      source: 'iana',
      extensions: ['jisp'],
    },
    'application/vnd.joost.joda-archive': {
      source: 'iana',
      extensions: ['joda'],
    },
    'application/vnd.jsk.isdn-ngn': {
      source: 'iana',
    },
    'application/vnd.kahootz': {
      source: 'iana',
      extensions: ['ktz', 'ktr'],
    },
    'application/vnd.kde.karbon': {
      source: 'iana',
      extensions: ['karbon'],
    },
    'application/vnd.kde.kchart': {
      source: 'iana',
      extensions: ['chrt'],
    },
    'application/vnd.kde.kformula': {
      source: 'iana',
      extensions: ['kfo'],
    },
    'application/vnd.kde.kivio': {
      source: 'iana',
      extensions: ['flw'],
    },
    'application/vnd.kde.kontour': {
      source: 'iana',
      extensions: ['kon'],
    },
    'application/vnd.kde.kpresenter': {
      source: 'iana',
      extensions: ['kpr', 'kpt'],
    },
    'application/vnd.kde.kspread': {
      source: 'iana',
      extensions: ['ksp'],
    },
    'application/vnd.kde.kword': {
      source: 'iana',
      extensions: ['kwd', 'kwt'],
    },
    'application/vnd.kenameaapp': {
      source: 'iana',
      extensions: ['htke'],
    },
    'application/vnd.kidspiration': {
      source: 'iana',
      extensions: ['kia'],
    },
    'application/vnd.kinar': {
      source: 'iana',
      extensions: ['kne', 'knp'],
    },
    'application/vnd.koan': {
      source: 'iana',
      extensions: ['skp', 'skd', 'skt', 'skm'],
    },
    'application/vnd.kodak-descriptor': {
      source: 'iana',
      extensions: ['sse'],
    },
    'application/vnd.las': {
      source: 'iana',
    },
    'application/vnd.las.las+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.las.las+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['lasxml'],
    },
    'application/vnd.laszip': {
      source: 'iana',
    },
    'application/vnd.leap+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.liberty-request+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.llamagraphics.life-balance.desktop': {
      source: 'iana',
      extensions: ['lbd'],
    },
    'application/vnd.llamagraphics.life-balance.exchange+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['lbe'],
    },
    'application/vnd.logipipe.circuit+zip': {
      source: 'iana',
      compressible: false,
    },
    'application/vnd.loom': {
      source: 'iana',
    },
    'application/vnd.lotus-1-2-3': {
      source: 'iana',
      extensions: ['123'],
    },
    'application/vnd.lotus-approach': {
      source: 'iana',
      extensions: ['apr'],
    },
    'application/vnd.lotus-freelance': {
      source: 'iana',
      extensions: ['pre'],
    },
    'application/vnd.lotus-notes': {
      source: 'iana',
      extensions: ['nsf'],
    },
    'application/vnd.lotus-organizer': {
      source: 'iana',
      extensions: ['org'],
    },
    'application/vnd.lotus-screencam': {
      source: 'iana',
      extensions: ['scm'],
    },
    'application/vnd.lotus-wordpro': {
      source: 'iana',
      extensions: ['lwp'],
    },
    'application/vnd.macports.portpkg': {
      source: 'iana',
      extensions: ['portpkg'],
    },
    'application/vnd.mapbox-vector-tile': {
      source: 'iana',
    },
    'application/vnd.marlin.drm.actiontoken+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.marlin.drm.conftoken+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.marlin.drm.license+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.marlin.drm.mdcf': {
      source: 'iana',
    },
    'application/vnd.mason+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.maxmind.maxmind-db': {
      source: 'iana',
    },
    'application/vnd.mcd': {
      source: 'iana',
      extensions: ['mcd'],
    },
    'application/vnd.medcalcdata': {
      source: 'iana',
      extensions: ['mc1'],
    },
    'application/vnd.mediastation.cdkey': {
      source: 'iana',
      extensions: ['cdkey'],
    },
    'application/vnd.meridian-slingshot': {
      source: 'iana',
    },
    'application/vnd.mfer': {
      source: 'iana',
      extensions: ['mwf'],
    },
    'application/vnd.mfmp': {
      source: 'iana',
      extensions: ['mfm'],
    },
    'application/vnd.micro+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.micrografx.flo': {
      source: 'iana',
      extensions: ['flo'],
    },
    'application/vnd.micrografx.igx': {
      source: 'iana',
      extensions: ['igx'],
    },
    'application/vnd.microsoft.portable-executable': {
      source: 'iana',
    },
    'application/vnd.microsoft.windows.thumbnail-cache': {
      source: 'iana',
    },
    'application/vnd.miele+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.mif': {
      source: 'iana',
      extensions: ['mif'],
    },
    'application/vnd.minisoft-hp3000-save': {
      source: 'iana',
    },
    'application/vnd.mitsubishi.misty-guard.trustweb': {
      source: 'iana',
    },
    'application/vnd.mobius.daf': {
      source: 'iana',
      extensions: ['daf'],
    },
    'application/vnd.mobius.dis': {
      source: 'iana',
      extensions: ['dis'],
    },
    'application/vnd.mobius.mbk': {
      source: 'iana',
      extensions: ['mbk'],
    },
    'application/vnd.mobius.mqy': {
      source: 'iana',
      extensions: ['mqy'],
    },
    'application/vnd.mobius.msl': {
      source: 'iana',
      extensions: ['msl'],
    },
    'application/vnd.mobius.plc': {
      source: 'iana',
      extensions: ['plc'],
    },
    'application/vnd.mobius.txf': {
      source: 'iana',
      extensions: ['txf'],
    },
    'application/vnd.mophun.application': {
      source: 'iana',
      extensions: ['mpn'],
    },
    'application/vnd.mophun.certificate': {
      source: 'iana',
      extensions: ['mpc'],
    },
    'application/vnd.motorola.flexsuite': {
      source: 'iana',
    },
    'application/vnd.motorola.flexsuite.adsi': {
      source: 'iana',
    },
    'application/vnd.motorola.flexsuite.fis': {
      source: 'iana',
    },
    'application/vnd.motorola.flexsuite.gotap': {
      source: 'iana',
    },
    'application/vnd.motorola.flexsuite.kmr': {
      source: 'iana',
    },
    'application/vnd.motorola.flexsuite.ttc': {
      source: 'iana',
    },
    'application/vnd.motorola.flexsuite.wem': {
      source: 'iana',
    },
    'application/vnd.motorola.iprm': {
      source: 'iana',
    },
    'application/vnd.mozilla.xul+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['xul'],
    },
    'application/vnd.ms-3mfdocument': {
      source: 'iana',
    },
    'application/vnd.ms-artgalry': {
      source: 'iana',
      extensions: ['cil'],
    },
    'application/vnd.ms-asf': {
      source: 'iana',
    },
    'application/vnd.ms-cab-compressed': {
      source: 'iana',
      extensions: ['cab'],
    },
    'application/vnd.ms-color.iccprofile': {
      source: 'apache',
    },
    'application/vnd.ms-excel': {
      source: 'iana',
      compressible: false,
      extensions: ['xls', 'xlm', 'xla', 'xlc', 'xlt', 'xlw'],
    },
    'application/vnd.ms-excel.addin.macroenabled.12': {
      source: 'iana',
      extensions: ['xlam'],
    },
    'application/vnd.ms-excel.sheet.binary.macroenabled.12': {
      source: 'iana',
      extensions: ['xlsb'],
    },
    'application/vnd.ms-excel.sheet.macroenabled.12': {
      source: 'iana',
      extensions: ['xlsm'],
    },
    'application/vnd.ms-excel.template.macroenabled.12': {
      source: 'iana',
      extensions: ['xltm'],
    },
    'application/vnd.ms-fontobject': {
      source: 'iana',
      compressible: true,
      extensions: ['eot'],
    },
    'application/vnd.ms-htmlhelp': {
      source: 'iana',
      extensions: ['chm'],
    },
    'application/vnd.ms-ims': {
      source: 'iana',
      extensions: ['ims'],
    },
    'application/vnd.ms-lrm': {
      source: 'iana',
      extensions: ['lrm'],
    },
    'application/vnd.ms-office.activex+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.ms-officetheme': {
      source: 'iana',
      extensions: ['thmx'],
    },
    'application/vnd.ms-opentype': {
      source: 'apache',
      compressible: true,
    },
    'application/vnd.ms-outlook': {
      compressible: false,
      extensions: ['msg'],
    },
    'application/vnd.ms-package.obfuscated-opentype': {
      source: 'apache',
    },
    'application/vnd.ms-pki.seccat': {
      source: 'apache',
      extensions: ['cat'],
    },
    'application/vnd.ms-pki.stl': {
      source: 'apache',
      extensions: ['stl'],
    },
    'application/vnd.ms-playready.initiator+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.ms-powerpoint': {
      source: 'iana',
      compressible: false,
      extensions: ['ppt', 'pps', 'pot'],
    },
    'application/vnd.ms-powerpoint.addin.macroenabled.12': {
      source: 'iana',
      extensions: ['ppam'],
    },
    'application/vnd.ms-powerpoint.presentation.macroenabled.12': {
      source: 'iana',
      extensions: ['pptm'],
    },
    'application/vnd.ms-powerpoint.slide.macroenabled.12': {
      source: 'iana',
      extensions: ['sldm'],
    },
    'application/vnd.ms-powerpoint.slideshow.macroenabled.12': {
      source: 'iana',
      extensions: ['ppsm'],
    },
    'application/vnd.ms-powerpoint.template.macroenabled.12': {
      source: 'iana',
      extensions: ['potm'],
    },
    'application/vnd.ms-printdevicecapabilities+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.ms-printing.printticket+xml': {
      source: 'apache',
      compressible: true,
    },
    'application/vnd.ms-printschematicket+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.ms-project': {
      source: 'iana',
      extensions: ['mpp', 'mpt'],
    },
    'application/vnd.ms-tnef': {
      source: 'iana',
    },
    'application/vnd.ms-windows.devicepairing': {
      source: 'iana',
    },
    'application/vnd.ms-windows.nwprinting.oob': {
      source: 'iana',
    },
    'application/vnd.ms-windows.printerpairing': {
      source: 'iana',
    },
    'application/vnd.ms-windows.wsd.oob': {
      source: 'iana',
    },
    'application/vnd.ms-wmdrm.lic-chlg-req': {
      source: 'iana',
    },
    'application/vnd.ms-wmdrm.lic-resp': {
      source: 'iana',
    },
    'application/vnd.ms-wmdrm.meter-chlg-req': {
      source: 'iana',
    },
    'application/vnd.ms-wmdrm.meter-resp': {
      source: 'iana',
    },
    'application/vnd.ms-word.document.macroenabled.12': {
      source: 'iana',
      extensions: ['docm'],
    },
    'application/vnd.ms-word.template.macroenabled.12': {
      source: 'iana',
      extensions: ['dotm'],
    },
    'application/vnd.ms-works': {
      source: 'iana',
      extensions: ['wps', 'wks', 'wcm', 'wdb'],
    },
    'application/vnd.ms-wpl': {
      source: 'iana',
      extensions: ['wpl'],
    },
    'application/vnd.ms-xpsdocument': {
      source: 'iana',
      compressible: false,
      extensions: ['xps'],
    },
    'application/vnd.msa-disk-image': {
      source: 'iana',
    },
    'application/vnd.mseq': {
      source: 'iana',
      extensions: ['mseq'],
    },
    'application/vnd.msign': {
      source: 'iana',
    },
    'application/vnd.multiad.creator': {
      source: 'iana',
    },
    'application/vnd.multiad.creator.cif': {
      source: 'iana',
    },
    'application/vnd.music-niff': {
      source: 'iana',
    },
    'application/vnd.musician': {
      source: 'iana',
      extensions: ['mus'],
    },
    'application/vnd.muvee.style': {
      source: 'iana',
      extensions: ['msty'],
    },
    'application/vnd.mynfc': {
      source: 'iana',
      extensions: ['taglet'],
    },
    'application/vnd.ncd.control': {
      source: 'iana',
    },
    'application/vnd.ncd.reference': {
      source: 'iana',
    },
    'application/vnd.nearst.inv+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.nervana': {
      source: 'iana',
    },
    'application/vnd.netfpx': {
      source: 'iana',
    },
    'application/vnd.neurolanguage.nlu': {
      source: 'iana',
      extensions: ['nlu'],
    },
    'application/vnd.nimn': {
      source: 'iana',
    },
    'application/vnd.nintendo.nitro.rom': {
      source: 'iana',
    },
    'application/vnd.nintendo.snes.rom': {
      source: 'iana',
    },
    'application/vnd.nitf': {
      source: 'iana',
      extensions: ['ntf', 'nitf'],
    },
    'application/vnd.noblenet-directory': {
      source: 'iana',
      extensions: ['nnd'],
    },
    'application/vnd.noblenet-sealer': {
      source: 'iana',
      extensions: ['nns'],
    },
    'application/vnd.noblenet-web': {
      source: 'iana',
      extensions: ['nnw'],
    },
    'application/vnd.nokia.catalogs': {
      source: 'iana',
    },
    'application/vnd.nokia.conml+wbxml': {
      source: 'iana',
    },
    'application/vnd.nokia.conml+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.nokia.iptv.config+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.nokia.isds-radio-presets': {
      source: 'iana',
    },
    'application/vnd.nokia.landmark+wbxml': {
      source: 'iana',
    },
    'application/vnd.nokia.landmark+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.nokia.landmarkcollection+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.nokia.n-gage.ac+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['ac'],
    },
    'application/vnd.nokia.n-gage.data': {
      source: 'iana',
      extensions: ['ngdat'],
    },
    'application/vnd.nokia.n-gage.symbian.install': {
      source: 'iana',
      extensions: ['n-gage'],
    },
    'application/vnd.nokia.ncd': {
      source: 'iana',
    },
    'application/vnd.nokia.pcd+wbxml': {
      source: 'iana',
    },
    'application/vnd.nokia.pcd+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.nokia.radio-preset': {
      source: 'iana',
      extensions: ['rpst'],
    },
    'application/vnd.nokia.radio-presets': {
      source: 'iana',
      extensions: ['rpss'],
    },
    'application/vnd.novadigm.edm': {
      source: 'iana',
      extensions: ['edm'],
    },
    'application/vnd.novadigm.edx': {
      source: 'iana',
      extensions: ['edx'],
    },
    'application/vnd.novadigm.ext': {
      source: 'iana',
      extensions: ['ext'],
    },
    'application/vnd.ntt-local.content-share': {
      source: 'iana',
    },
    'application/vnd.ntt-local.file-transfer': {
      source: 'iana',
    },
    'application/vnd.ntt-local.ogw_remote-access': {
      source: 'iana',
    },
    'application/vnd.ntt-local.sip-ta_remote': {
      source: 'iana',
    },
    'application/vnd.ntt-local.sip-ta_tcp_stream': {
      source: 'iana',
    },
    'application/vnd.oasis.opendocument.chart': {
      source: 'iana',
      extensions: ['odc'],
    },
    'application/vnd.oasis.opendocument.chart-template': {
      source: 'iana',
      extensions: ['otc'],
    },
    'application/vnd.oasis.opendocument.database': {
      source: 'iana',
      extensions: ['odb'],
    },
    'application/vnd.oasis.opendocument.formula': {
      source: 'iana',
      extensions: ['odf'],
    },
    'application/vnd.oasis.opendocument.formula-template': {
      source: 'iana',
      extensions: ['odft'],
    },
    'application/vnd.oasis.opendocument.graphics': {
      source: 'iana',
      compressible: false,
      extensions: ['odg'],
    },
    'application/vnd.oasis.opendocument.graphics-template': {
      source: 'iana',
      extensions: ['otg'],
    },
    'application/vnd.oasis.opendocument.image': {
      source: 'iana',
      extensions: ['odi'],
    },
    'application/vnd.oasis.opendocument.image-template': {
      source: 'iana',
      extensions: ['oti'],
    },
    'application/vnd.oasis.opendocument.presentation': {
      source: 'iana',
      compressible: false,
      extensions: ['odp'],
    },
    'application/vnd.oasis.opendocument.presentation-template': {
      source: 'iana',
      extensions: ['otp'],
    },
    'application/vnd.oasis.opendocument.spreadsheet': {
      source: 'iana',
      compressible: false,
      extensions: ['ods'],
    },
    'application/vnd.oasis.opendocument.spreadsheet-template': {
      source: 'iana',
      extensions: ['ots'],
    },
    'application/vnd.oasis.opendocument.text': {
      source: 'iana',
      compressible: false,
      extensions: ['odt'],
    },
    'application/vnd.oasis.opendocument.text-master': {
      source: 'iana',
      extensions: ['odm'],
    },
    'application/vnd.oasis.opendocument.text-template': {
      source: 'iana',
      extensions: ['ott'],
    },
    'application/vnd.oasis.opendocument.text-web': {
      source: 'iana',
      extensions: ['oth'],
    },
    'application/vnd.obn': {
      source: 'iana',
    },
    'application/vnd.ocf+cbor': {
      source: 'iana',
    },
    'application/vnd.oci.image.manifest.v1+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oftn.l10n+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oipf.contentaccessdownload+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oipf.contentaccessstreaming+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oipf.cspg-hexbinary': {
      source: 'iana',
    },
    'application/vnd.oipf.dae.svg+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oipf.dae.xhtml+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oipf.mippvcontrolmessage+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oipf.pae.gem': {
      source: 'iana',
    },
    'application/vnd.oipf.spdiscovery+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oipf.spdlist+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oipf.ueprofile+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oipf.userprofile+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.olpc-sugar': {
      source: 'iana',
      extensions: ['xo'],
    },
    'application/vnd.oma-scws-config': {
      source: 'iana',
    },
    'application/vnd.oma-scws-http-request': {
      source: 'iana',
    },
    'application/vnd.oma-scws-http-response': {
      source: 'iana',
    },
    'application/vnd.oma.bcast.associated-procedure-parameter+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oma.bcast.drm-trigger+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oma.bcast.imd+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oma.bcast.ltkm': {
      source: 'iana',
    },
    'application/vnd.oma.bcast.notification+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oma.bcast.provisioningtrigger': {
      source: 'iana',
    },
    'application/vnd.oma.bcast.sgboot': {
      source: 'iana',
    },
    'application/vnd.oma.bcast.sgdd+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oma.bcast.sgdu': {
      source: 'iana',
    },
    'application/vnd.oma.bcast.simple-symbol-container': {
      source: 'iana',
    },
    'application/vnd.oma.bcast.smartcard-trigger+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oma.bcast.sprov+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oma.bcast.stkm': {
      source: 'iana',
    },
    'application/vnd.oma.cab-address-book+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oma.cab-feature-handler+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oma.cab-pcc+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oma.cab-subs-invite+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oma.cab-user-prefs+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oma.dcd': {
      source: 'iana',
    },
    'application/vnd.oma.dcdc': {
      source: 'iana',
    },
    'application/vnd.oma.dd2+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['dd2'],
    },
    'application/vnd.oma.drm.risd+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oma.group-usage-list+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oma.lwm2m+cbor': {
      source: 'iana',
    },
    'application/vnd.oma.lwm2m+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oma.lwm2m+tlv': {
      source: 'iana',
    },
    'application/vnd.oma.pal+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oma.poc.detailed-progress-report+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oma.poc.final-report+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oma.poc.groups+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oma.poc.invocation-descriptor+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oma.poc.optimized-progress-report+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oma.push': {
      source: 'iana',
    },
    'application/vnd.oma.scidm.messages+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oma.xcap-directory+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.omads-email+xml': {
      source: 'iana',
      charset: 'UTF-8',
      compressible: true,
    },
    'application/vnd.omads-file+xml': {
      source: 'iana',
      charset: 'UTF-8',
      compressible: true,
    },
    'application/vnd.omads-folder+xml': {
      source: 'iana',
      charset: 'UTF-8',
      compressible: true,
    },
    'application/vnd.omaloc-supl-init': {
      source: 'iana',
    },
    'application/vnd.onepager': {
      source: 'iana',
    },
    'application/vnd.onepagertamp': {
      source: 'iana',
    },
    'application/vnd.onepagertamx': {
      source: 'iana',
    },
    'application/vnd.onepagertat': {
      source: 'iana',
    },
    'application/vnd.onepagertatp': {
      source: 'iana',
    },
    'application/vnd.onepagertatx': {
      source: 'iana',
    },
    'application/vnd.openblox.game+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['obgx'],
    },
    'application/vnd.openblox.game-binary': {
      source: 'iana',
    },
    'application/vnd.openeye.oeb': {
      source: 'iana',
    },
    'application/vnd.openofficeorg.extension': {
      source: 'apache',
      extensions: ['oxt'],
    },
    'application/vnd.openstreetmap.data+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['osm'],
    },
    'application/vnd.openxmlformats-officedocument.custom-properties+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.customxmlproperties+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.drawing+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.drawingml.chart+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.extended-properties+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.comments+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.presentation': {
      source: 'iana',
      compressible: false,
      extensions: ['pptx'],
    },
    'application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.presprops+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.slide': {
      source: 'iana',
      extensions: ['sldx'],
    },
    'application/vnd.openxmlformats-officedocument.presentationml.slide+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.slideshow': {
      source: 'iana',
      extensions: ['ppsx'],
    },
    'application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.tags+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.template': {
      source: 'iana',
      extensions: ['potx'],
    },
    'application/vnd.openxmlformats-officedocument.presentationml.template.main+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': {
      source: 'iana',
      compressible: false,
      extensions: ['xlsx'],
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.template': {
      source: 'iana',
      extensions: ['xltx'],
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.theme+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.themeoverride+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.vmldrawing': {
      source: 'iana',
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document': {
      source: 'iana',
      compressible: false,
      extensions: ['docx'],
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.template': {
      source: 'iana',
      extensions: ['dotx'],
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-package.core-properties+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.openxmlformats-package.relationships+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oracle.resource+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.orange.indata': {
      source: 'iana',
    },
    'application/vnd.osa.netdeploy': {
      source: 'iana',
    },
    'application/vnd.osgeo.mapguide.package': {
      source: 'iana',
      extensions: ['mgp'],
    },
    'application/vnd.osgi.bundle': {
      source: 'iana',
    },
    'application/vnd.osgi.dp': {
      source: 'iana',
      extensions: ['dp'],
    },
    'application/vnd.osgi.subsystem': {
      source: 'iana',
      extensions: ['esa'],
    },
    'application/vnd.otps.ct-kip+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.oxli.countgraph': {
      source: 'iana',
    },
    'application/vnd.pagerduty+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.palm': {
      source: 'iana',
      extensions: ['pdb', 'pqa', 'oprc'],
    },
    'application/vnd.panoply': {
      source: 'iana',
    },
    'application/vnd.paos.xml': {
      source: 'iana',
    },
    'application/vnd.patentdive': {
      source: 'iana',
    },
    'application/vnd.patientecommsdoc': {
      source: 'iana',
    },
    'application/vnd.pawaafile': {
      source: 'iana',
      extensions: ['paw'],
    },
    'application/vnd.pcos': {
      source: 'iana',
    },
    'application/vnd.pg.format': {
      source: 'iana',
      extensions: ['str'],
    },
    'application/vnd.pg.osasli': {
      source: 'iana',
      extensions: ['ei6'],
    },
    'application/vnd.piaccess.application-licence': {
      source: 'iana',
    },
    'application/vnd.picsel': {
      source: 'iana',
      extensions: ['efif'],
    },
    'application/vnd.pmi.widget': {
      source: 'iana',
      extensions: ['wg'],
    },
    'application/vnd.poc.group-advertisement+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.pocketlearn': {
      source: 'iana',
      extensions: ['plf'],
    },
    'application/vnd.powerbuilder6': {
      source: 'iana',
      extensions: ['pbd'],
    },
    'application/vnd.powerbuilder6-s': {
      source: 'iana',
    },
    'application/vnd.powerbuilder7': {
      source: 'iana',
    },
    'application/vnd.powerbuilder7-s': {
      source: 'iana',
    },
    'application/vnd.powerbuilder75': {
      source: 'iana',
    },
    'application/vnd.powerbuilder75-s': {
      source: 'iana',
    },
    'application/vnd.preminet': {
      source: 'iana',
    },
    'application/vnd.previewsystems.box': {
      source: 'iana',
      extensions: ['box'],
    },
    'application/vnd.proteus.magazine': {
      source: 'iana',
      extensions: ['mgz'],
    },
    'application/vnd.psfs': {
      source: 'iana',
    },
    'application/vnd.publishare-delta-tree': {
      source: 'iana',
      extensions: ['qps'],
    },
    'application/vnd.pvi.ptid1': {
      source: 'iana',
      extensions: ['ptid'],
    },
    'application/vnd.pwg-multiplexed': {
      source: 'iana',
    },
    'application/vnd.pwg-xhtml-print+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.qualcomm.brew-app-res': {
      source: 'iana',
    },
    'application/vnd.quarantainenet': {
      source: 'iana',
    },
    'application/vnd.quark.quarkxpress': {
      source: 'iana',
      extensions: ['qxd', 'qxt', 'qwd', 'qwt', 'qxl', 'qxb'],
    },
    'application/vnd.quobject-quoxdocument': {
      source: 'iana',
    },
    'application/vnd.radisys.moml+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.radisys.msml+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.radisys.msml-audit+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.radisys.msml-audit-conf+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.radisys.msml-audit-conn+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.radisys.msml-audit-dialog+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.radisys.msml-audit-stream+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.radisys.msml-conf+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.radisys.msml-dialog+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.radisys.msml-dialog-base+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.radisys.msml-dialog-fax-detect+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.radisys.msml-dialog-fax-sendrecv+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.radisys.msml-dialog-group+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.radisys.msml-dialog-speech+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.radisys.msml-dialog-transform+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.rainstor.data': {
      source: 'iana',
    },
    'application/vnd.rapid': {
      source: 'iana',
    },
    'application/vnd.rar': {
      source: 'iana',
      extensions: ['rar'],
    },
    'application/vnd.realvnc.bed': {
      source: 'iana',
      extensions: ['bed'],
    },
    'application/vnd.recordare.musicxml': {
      source: 'iana',
      extensions: ['mxl'],
    },
    'application/vnd.recordare.musicxml+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['musicxml'],
    },
    'application/vnd.renlearn.rlprint': {
      source: 'iana',
    },
    'application/vnd.restful+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.rig.cryptonote': {
      source: 'iana',
      extensions: ['cryptonote'],
    },
    'application/vnd.rim.cod': {
      source: 'apache',
      extensions: ['cod'],
    },
    'application/vnd.rn-realmedia': {
      source: 'apache',
      extensions: ['rm'],
    },
    'application/vnd.rn-realmedia-vbr': {
      source: 'apache',
      extensions: ['rmvb'],
    },
    'application/vnd.route66.link66+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['link66'],
    },
    'application/vnd.rs-274x': {
      source: 'iana',
    },
    'application/vnd.ruckus.download': {
      source: 'iana',
    },
    'application/vnd.s3sms': {
      source: 'iana',
    },
    'application/vnd.sailingtracker.track': {
      source: 'iana',
      extensions: ['st'],
    },
    'application/vnd.sar': {
      source: 'iana',
    },
    'application/vnd.sbm.cid': {
      source: 'iana',
    },
    'application/vnd.sbm.mid2': {
      source: 'iana',
    },
    'application/vnd.scribus': {
      source: 'iana',
    },
    'application/vnd.sealed.3df': {
      source: 'iana',
    },
    'application/vnd.sealed.csf': {
      source: 'iana',
    },
    'application/vnd.sealed.doc': {
      source: 'iana',
    },
    'application/vnd.sealed.eml': {
      source: 'iana',
    },
    'application/vnd.sealed.mht': {
      source: 'iana',
    },
    'application/vnd.sealed.net': {
      source: 'iana',
    },
    'application/vnd.sealed.ppt': {
      source: 'iana',
    },
    'application/vnd.sealed.tiff': {
      source: 'iana',
    },
    'application/vnd.sealed.xls': {
      source: 'iana',
    },
    'application/vnd.sealedmedia.softseal.html': {
      source: 'iana',
    },
    'application/vnd.sealedmedia.softseal.pdf': {
      source: 'iana',
    },
    'application/vnd.seemail': {
      source: 'iana',
      extensions: ['see'],
    },
    'application/vnd.seis+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.sema': {
      source: 'iana',
      extensions: ['sema'],
    },
    'application/vnd.semd': {
      source: 'iana',
      extensions: ['semd'],
    },
    'application/vnd.semf': {
      source: 'iana',
      extensions: ['semf'],
    },
    'application/vnd.shade-save-file': {
      source: 'iana',
    },
    'application/vnd.shana.informed.formdata': {
      source: 'iana',
      extensions: ['ifm'],
    },
    'application/vnd.shana.informed.formtemplate': {
      source: 'iana',
      extensions: ['itp'],
    },
    'application/vnd.shana.informed.interchange': {
      source: 'iana',
      extensions: ['iif'],
    },
    'application/vnd.shana.informed.package': {
      source: 'iana',
      extensions: ['ipk'],
    },
    'application/vnd.shootproof+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.shopkick+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.shp': {
      source: 'iana',
    },
    'application/vnd.shx': {
      source: 'iana',
    },
    'application/vnd.sigrok.session': {
      source: 'iana',
    },
    'application/vnd.simtech-mindmapper': {
      source: 'iana',
      extensions: ['twd', 'twds'],
    },
    'application/vnd.siren+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.smaf': {
      source: 'iana',
      extensions: ['mmf'],
    },
    'application/vnd.smart.notebook': {
      source: 'iana',
    },
    'application/vnd.smart.teacher': {
      source: 'iana',
      extensions: ['teacher'],
    },
    'application/vnd.snesdev-page-table': {
      source: 'iana',
    },
    'application/vnd.software602.filler.form+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['fo'],
    },
    'application/vnd.software602.filler.form-xml-zip': {
      source: 'iana',
    },
    'application/vnd.solent.sdkm+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['sdkm', 'sdkd'],
    },
    'application/vnd.spotfire.dxp': {
      source: 'iana',
      extensions: ['dxp'],
    },
    'application/vnd.spotfire.sfs': {
      source: 'iana',
      extensions: ['sfs'],
    },
    'application/vnd.sqlite3': {
      source: 'iana',
    },
    'application/vnd.sss-cod': {
      source: 'iana',
    },
    'application/vnd.sss-dtf': {
      source: 'iana',
    },
    'application/vnd.sss-ntf': {
      source: 'iana',
    },
    'application/vnd.stardivision.calc': {
      source: 'apache',
      extensions: ['sdc'],
    },
    'application/vnd.stardivision.draw': {
      source: 'apache',
      extensions: ['sda'],
    },
    'application/vnd.stardivision.impress': {
      source: 'apache',
      extensions: ['sdd'],
    },
    'application/vnd.stardivision.math': {
      source: 'apache',
      extensions: ['smf'],
    },
    'application/vnd.stardivision.writer': {
      source: 'apache',
      extensions: ['sdw', 'vor'],
    },
    'application/vnd.stardivision.writer-global': {
      source: 'apache',
      extensions: ['sgl'],
    },
    'application/vnd.stepmania.package': {
      source: 'iana',
      extensions: ['smzip'],
    },
    'application/vnd.stepmania.stepchart': {
      source: 'iana',
      extensions: ['sm'],
    },
    'application/vnd.street-stream': {
      source: 'iana',
    },
    'application/vnd.sun.wadl+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['wadl'],
    },
    'application/vnd.sun.xml.calc': {
      source: 'apache',
      extensions: ['sxc'],
    },
    'application/vnd.sun.xml.calc.template': {
      source: 'apache',
      extensions: ['stc'],
    },
    'application/vnd.sun.xml.draw': {
      source: 'apache',
      extensions: ['sxd'],
    },
    'application/vnd.sun.xml.draw.template': {
      source: 'apache',
      extensions: ['std'],
    },
    'application/vnd.sun.xml.impress': {
      source: 'apache',
      extensions: ['sxi'],
    },
    'application/vnd.sun.xml.impress.template': {
      source: 'apache',
      extensions: ['sti'],
    },
    'application/vnd.sun.xml.math': {
      source: 'apache',
      extensions: ['sxm'],
    },
    'application/vnd.sun.xml.writer': {
      source: 'apache',
      extensions: ['sxw'],
    },
    'application/vnd.sun.xml.writer.global': {
      source: 'apache',
      extensions: ['sxg'],
    },
    'application/vnd.sun.xml.writer.template': {
      source: 'apache',
      extensions: ['stw'],
    },
    'application/vnd.sus-calendar': {
      source: 'iana',
      extensions: ['sus', 'susp'],
    },
    'application/vnd.svd': {
      source: 'iana',
      extensions: ['svd'],
    },
    'application/vnd.swiftview-ics': {
      source: 'iana',
    },
    'application/vnd.sycle+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.symbian.install': {
      source: 'apache',
      extensions: ['sis', 'sisx'],
    },
    'application/vnd.syncml+xml': {
      source: 'iana',
      charset: 'UTF-8',
      compressible: true,
      extensions: ['xsm'],
    },
    'application/vnd.syncml.dm+wbxml': {
      source: 'iana',
      charset: 'UTF-8',
      extensions: ['bdm'],
    },
    'application/vnd.syncml.dm+xml': {
      source: 'iana',
      charset: 'UTF-8',
      compressible: true,
      extensions: ['xdm'],
    },
    'application/vnd.syncml.dm.notification': {
      source: 'iana',
    },
    'application/vnd.syncml.dmddf+wbxml': {
      source: 'iana',
    },
    'application/vnd.syncml.dmddf+xml': {
      source: 'iana',
      charset: 'UTF-8',
      compressible: true,
      extensions: ['ddf'],
    },
    'application/vnd.syncml.dmtnds+wbxml': {
      source: 'iana',
    },
    'application/vnd.syncml.dmtnds+xml': {
      source: 'iana',
      charset: 'UTF-8',
      compressible: true,
    },
    'application/vnd.syncml.ds.notification': {
      source: 'iana',
    },
    'application/vnd.tableschema+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.tao.intent-module-archive': {
      source: 'iana',
      extensions: ['tao'],
    },
    'application/vnd.tcpdump.pcap': {
      source: 'iana',
      extensions: ['pcap', 'cap', 'dmp'],
    },
    'application/vnd.think-cell.ppttc+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.tmd.mediaflex.api+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.tml': {
      source: 'iana',
    },
    'application/vnd.tmobile-livetv': {
      source: 'iana',
      extensions: ['tmo'],
    },
    'application/vnd.tri.onesource': {
      source: 'iana',
    },
    'application/vnd.trid.tpt': {
      source: 'iana',
      extensions: ['tpt'],
    },
    'application/vnd.triscape.mxs': {
      source: 'iana',
      extensions: ['mxs'],
    },
    'application/vnd.trueapp': {
      source: 'iana',
      extensions: ['tra'],
    },
    'application/vnd.truedoc': {
      source: 'iana',
    },
    'application/vnd.ubisoft.webplayer': {
      source: 'iana',
    },
    'application/vnd.ufdl': {
      source: 'iana',
      extensions: ['ufd', 'ufdl'],
    },
    'application/vnd.uiq.theme': {
      source: 'iana',
      extensions: ['utz'],
    },
    'application/vnd.umajin': {
      source: 'iana',
      extensions: ['umj'],
    },
    'application/vnd.unity': {
      source: 'iana',
      extensions: ['unityweb'],
    },
    'application/vnd.uoml+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['uoml'],
    },
    'application/vnd.uplanet.alert': {
      source: 'iana',
    },
    'application/vnd.uplanet.alert-wbxml': {
      source: 'iana',
    },
    'application/vnd.uplanet.bearer-choice': {
      source: 'iana',
    },
    'application/vnd.uplanet.bearer-choice-wbxml': {
      source: 'iana',
    },
    'application/vnd.uplanet.cacheop': {
      source: 'iana',
    },
    'application/vnd.uplanet.cacheop-wbxml': {
      source: 'iana',
    },
    'application/vnd.uplanet.channel': {
      source: 'iana',
    },
    'application/vnd.uplanet.channel-wbxml': {
      source: 'iana',
    },
    'application/vnd.uplanet.list': {
      source: 'iana',
    },
    'application/vnd.uplanet.list-wbxml': {
      source: 'iana',
    },
    'application/vnd.uplanet.listcmd': {
      source: 'iana',
    },
    'application/vnd.uplanet.listcmd-wbxml': {
      source: 'iana',
    },
    'application/vnd.uplanet.signal': {
      source: 'iana',
    },
    'application/vnd.uri-map': {
      source: 'iana',
    },
    'application/vnd.valve.source.material': {
      source: 'iana',
    },
    'application/vnd.vcx': {
      source: 'iana',
      extensions: ['vcx'],
    },
    'application/vnd.vd-study': {
      source: 'iana',
    },
    'application/vnd.vectorworks': {
      source: 'iana',
    },
    'application/vnd.vel+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.verimatrix.vcas': {
      source: 'iana',
    },
    'application/vnd.veryant.thin': {
      source: 'iana',
    },
    'application/vnd.ves.encrypted': {
      source: 'iana',
    },
    'application/vnd.vidsoft.vidconference': {
      source: 'iana',
    },
    'application/vnd.visio': {
      source: 'iana',
      extensions: ['vsd', 'vst', 'vss', 'vsw'],
    },
    'application/vnd.visionary': {
      source: 'iana',
      extensions: ['vis'],
    },
    'application/vnd.vividence.scriptfile': {
      source: 'iana',
    },
    'application/vnd.vsf': {
      source: 'iana',
      extensions: ['vsf'],
    },
    'application/vnd.wap.sic': {
      source: 'iana',
    },
    'application/vnd.wap.slc': {
      source: 'iana',
    },
    'application/vnd.wap.wbxml': {
      source: 'iana',
      charset: 'UTF-8',
      extensions: ['wbxml'],
    },
    'application/vnd.wap.wmlc': {
      source: 'iana',
      extensions: ['wmlc'],
    },
    'application/vnd.wap.wmlscriptc': {
      source: 'iana',
      extensions: ['wmlsc'],
    },
    'application/vnd.webturbo': {
      source: 'iana',
      extensions: ['wtb'],
    },
    'application/vnd.wfa.dpp': {
      source: 'iana',
    },
    'application/vnd.wfa.p2p': {
      source: 'iana',
    },
    'application/vnd.wfa.wsc': {
      source: 'iana',
    },
    'application/vnd.windows.devicepairing': {
      source: 'iana',
    },
    'application/vnd.wmc': {
      source: 'iana',
    },
    'application/vnd.wmf.bootstrap': {
      source: 'iana',
    },
    'application/vnd.wolfram.mathematica': {
      source: 'iana',
    },
    'application/vnd.wolfram.mathematica.package': {
      source: 'iana',
    },
    'application/vnd.wolfram.player': {
      source: 'iana',
      extensions: ['nbp'],
    },
    'application/vnd.wordperfect': {
      source: 'iana',
      extensions: ['wpd'],
    },
    'application/vnd.wqd': {
      source: 'iana',
      extensions: ['wqd'],
    },
    'application/vnd.wrq-hp3000-labelled': {
      source: 'iana',
    },
    'application/vnd.wt.stf': {
      source: 'iana',
      extensions: ['stf'],
    },
    'application/vnd.wv.csp+wbxml': {
      source: 'iana',
    },
    'application/vnd.wv.csp+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.wv.ssp+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.xacml+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.xara': {
      source: 'iana',
      extensions: ['xar'],
    },
    'application/vnd.xfdl': {
      source: 'iana',
      extensions: ['xfdl'],
    },
    'application/vnd.xfdl.webform': {
      source: 'iana',
    },
    'application/vnd.xmi+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/vnd.xmpie.cpkg': {
      source: 'iana',
    },
    'application/vnd.xmpie.dpkg': {
      source: 'iana',
    },
    'application/vnd.xmpie.plan': {
      source: 'iana',
    },
    'application/vnd.xmpie.ppkg': {
      source: 'iana',
    },
    'application/vnd.xmpie.xlim': {
      source: 'iana',
    },
    'application/vnd.yamaha.hv-dic': {
      source: 'iana',
      extensions: ['hvd'],
    },
    'application/vnd.yamaha.hv-script': {
      source: 'iana',
      extensions: ['hvs'],
    },
    'application/vnd.yamaha.hv-voice': {
      source: 'iana',
      extensions: ['hvp'],
    },
    'application/vnd.yamaha.openscoreformat': {
      source: 'iana',
      extensions: ['osf'],
    },
    'application/vnd.yamaha.openscoreformat.osfpvg+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['osfpvg'],
    },
    'application/vnd.yamaha.remote-setup': {
      source: 'iana',
    },
    'application/vnd.yamaha.smaf-audio': {
      source: 'iana',
      extensions: ['saf'],
    },
    'application/vnd.yamaha.smaf-phrase': {
      source: 'iana',
      extensions: ['spf'],
    },
    'application/vnd.yamaha.through-ngn': {
      source: 'iana',
    },
    'application/vnd.yamaha.tunnel-udpencap': {
      source: 'iana',
    },
    'application/vnd.yaoweme': {
      source: 'iana',
    },
    'application/vnd.yellowriver-custom-menu': {
      source: 'iana',
      extensions: ['cmp'],
    },
    'application/vnd.youtube.yt': {
      source: 'iana',
    },
    'application/vnd.zul': {
      source: 'iana',
      extensions: ['zir', 'zirz'],
    },
    'application/vnd.zzazz.deck+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['zaz'],
    },
    'application/voicexml+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['vxml'],
    },
    'application/voucher-cms+json': {
      source: 'iana',
      compressible: true,
    },
    'application/vq-rtcpxr': {
      source: 'iana',
    },
    'application/wasm': {
      compressible: true,
      extensions: ['wasm'],
    },
    'application/watcherinfo+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/webpush-options+json': {
      source: 'iana',
      compressible: true,
    },
    'application/whoispp-query': {
      source: 'iana',
    },
    'application/whoispp-response': {
      source: 'iana',
    },
    'application/widget': {
      source: 'iana',
      extensions: ['wgt'],
    },
    'application/winhlp': {
      source: 'apache',
      extensions: ['hlp'],
    },
    'application/wita': {
      source: 'iana',
    },
    'application/wordperfect5.1': {
      source: 'iana',
    },
    'application/wsdl+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['wsdl'],
    },
    'application/wspolicy+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['wspolicy'],
    },
    'application/x-7z-compressed': {
      source: 'apache',
      compressible: false,
      extensions: ['7z'],
    },
    'application/x-abiword': {
      source: 'apache',
      extensions: ['abw'],
    },
    'application/x-ace-compressed': {
      source: 'apache',
      extensions: ['ace'],
    },
    'application/x-amf': {
      source: 'apache',
    },
    'application/x-apple-diskimage': {
      source: 'apache',
      extensions: ['dmg'],
    },
    'application/x-arj': {
      compressible: false,
      extensions: ['arj'],
    },
    'application/x-authorware-bin': {
      source: 'apache',
      extensions: ['aab', 'x32', 'u32', 'vox'],
    },
    'application/x-authorware-map': {
      source: 'apache',
      extensions: ['aam'],
    },
    'application/x-authorware-seg': {
      source: 'apache',
      extensions: ['aas'],
    },
    'application/x-bcpio': {
      source: 'apache',
      extensions: ['bcpio'],
    },
    'application/x-bdoc': {
      compressible: false,
      extensions: ['bdoc'],
    },
    'application/x-bittorrent': {
      source: 'apache',
      extensions: ['torrent'],
    },
    'application/x-blorb': {
      source: 'apache',
      extensions: ['blb', 'blorb'],
    },
    'application/x-bzip': {
      source: 'apache',
      compressible: false,
      extensions: ['bz'],
    },
    'application/x-bzip2': {
      source: 'apache',
      compressible: false,
      extensions: ['bz2', 'boz'],
    },
    'application/x-cbr': {
      source: 'apache',
      extensions: ['cbr', 'cba', 'cbt', 'cbz', 'cb7'],
    },
    'application/x-cdlink': {
      source: 'apache',
      extensions: ['vcd'],
    },
    'application/x-cfs-compressed': {
      source: 'apache',
      extensions: ['cfs'],
    },
    'application/x-chat': {
      source: 'apache',
      extensions: ['chat'],
    },
    'application/x-chess-pgn': {
      source: 'apache',
      extensions: ['pgn'],
    },
    'application/x-chrome-extension': {
      extensions: ['crx'],
    },
    'application/x-cocoa': {
      source: 'nginx',
      extensions: ['cco'],
    },
    'application/x-compress': {
      source: 'apache',
    },
    'application/x-conference': {
      source: 'apache',
      extensions: ['nsc'],
    },
    'application/x-cpio': {
      source: 'apache',
      extensions: ['cpio'],
    },
    'application/x-csh': {
      source: 'apache',
      extensions: ['csh'],
    },
    'application/x-deb': {
      compressible: false,
    },
    'application/x-debian-package': {
      source: 'apache',
      extensions: ['deb', 'udeb'],
    },
    'application/x-dgc-compressed': {
      source: 'apache',
      extensions: ['dgc'],
    },
    'application/x-director': {
      source: 'apache',
      extensions: [
        'dir',
        'dcr',
        'dxr',
        'cst',
        'cct',
        'cxt',
        'w3d',
        'fgd',
        'swa',
      ],
    },
    'application/x-doom': {
      source: 'apache',
      extensions: ['wad'],
    },
    'application/x-dtbncx+xml': {
      source: 'apache',
      compressible: true,
      extensions: ['ncx'],
    },
    'application/x-dtbook+xml': {
      source: 'apache',
      compressible: true,
      extensions: ['dtb'],
    },
    'application/x-dtbresource+xml': {
      source: 'apache',
      compressible: true,
      extensions: ['res'],
    },
    'application/x-dvi': {
      source: 'apache',
      compressible: false,
      extensions: ['dvi'],
    },
    'application/x-envoy': {
      source: 'apache',
      extensions: ['evy'],
    },
    'application/x-eva': {
      source: 'apache',
      extensions: ['eva'],
    },
    'application/x-font-bdf': {
      source: 'apache',
      extensions: ['bdf'],
    },
    'application/x-font-dos': {
      source: 'apache',
    },
    'application/x-font-framemaker': {
      source: 'apache',
    },
    'application/x-font-ghostscript': {
      source: 'apache',
      extensions: ['gsf'],
    },
    'application/x-font-libgrx': {
      source: 'apache',
    },
    'application/x-font-linux-psf': {
      source: 'apache',
      extensions: ['psf'],
    },
    'application/x-font-pcf': {
      source: 'apache',
      extensions: ['pcf'],
    },
    'application/x-font-snf': {
      source: 'apache',
      extensions: ['snf'],
    },
    'application/x-font-speedo': {
      source: 'apache',
    },
    'application/x-font-sunos-news': {
      source: 'apache',
    },
    'application/x-font-type1': {
      source: 'apache',
      extensions: ['pfa', 'pfb', 'pfm', 'afm'],
    },
    'application/x-font-vfont': {
      source: 'apache',
    },
    'application/x-freearc': {
      source: 'apache',
      extensions: ['arc'],
    },
    'application/x-futuresplash': {
      source: 'apache',
      extensions: ['spl'],
    },
    'application/x-gca-compressed': {
      source: 'apache',
      extensions: ['gca'],
    },
    'application/x-glulx': {
      source: 'apache',
      extensions: ['ulx'],
    },
    'application/x-gnumeric': {
      source: 'apache',
      extensions: ['gnumeric'],
    },
    'application/x-gramps-xml': {
      source: 'apache',
      extensions: ['gramps'],
    },
    'application/x-gtar': {
      source: 'apache',
      extensions: ['gtar'],
    },
    'application/x-gzip': {
      source: 'apache',
    },
    'application/x-hdf': {
      source: 'apache',
      extensions: ['hdf'],
    },
    'application/x-httpd-php': {
      compressible: true,
      extensions: ['php'],
    },
    'application/x-install-instructions': {
      source: 'apache',
      extensions: ['install'],
    },
    'application/x-iso9660-image': {
      source: 'apache',
      extensions: ['iso'],
    },
    'application/x-java-archive-diff': {
      source: 'nginx',
      extensions: ['jardiff'],
    },
    'application/x-java-jnlp-file': {
      source: 'apache',
      compressible: false,
      extensions: ['jnlp'],
    },
    'application/x-javascript': {
      compressible: true,
    },
    'application/x-keepass2': {
      extensions: ['kdbx'],
    },
    'application/x-latex': {
      source: 'apache',
      compressible: false,
      extensions: ['latex'],
    },
    'application/x-lua-bytecode': {
      extensions: ['luac'],
    },
    'application/x-lzh-compressed': {
      source: 'apache',
      extensions: ['lzh', 'lha'],
    },
    'application/x-makeself': {
      source: 'nginx',
      extensions: ['run'],
    },
    'application/x-mie': {
      source: 'apache',
      extensions: ['mie'],
    },
    'application/x-mobipocket-ebook': {
      source: 'apache',
      extensions: ['prc', 'mobi'],
    },
    'application/x-mpegurl': {
      compressible: false,
    },
    'application/x-ms-application': {
      source: 'apache',
      extensions: ['application'],
    },
    'application/x-ms-shortcut': {
      source: 'apache',
      extensions: ['lnk'],
    },
    'application/x-ms-wmd': {
      source: 'apache',
      extensions: ['wmd'],
    },
    'application/x-ms-wmz': {
      source: 'apache',
      extensions: ['wmz'],
    },
    'application/x-ms-xbap': {
      source: 'apache',
      extensions: ['xbap'],
    },
    'application/x-msaccess': {
      source: 'apache',
      extensions: ['mdb'],
    },
    'application/x-msbinder': {
      source: 'apache',
      extensions: ['obd'],
    },
    'application/x-mscardfile': {
      source: 'apache',
      extensions: ['crd'],
    },
    'application/x-msclip': {
      source: 'apache',
      extensions: ['clp'],
    },
    'application/x-msdos-program': {
      extensions: ['exe'],
    },
    'application/x-msdownload': {
      source: 'apache',
      extensions: ['exe', 'dll', 'com', 'bat', 'msi'],
    },
    'application/x-msmediaview': {
      source: 'apache',
      extensions: ['mvb', 'm13', 'm14'],
    },
    'application/x-msmetafile': {
      source: 'apache',
      extensions: ['wmf', 'wmz', 'emf', 'emz'],
    },
    'application/x-msmoney': {
      source: 'apache',
      extensions: ['mny'],
    },
    'application/x-mspublisher': {
      source: 'apache',
      extensions: ['pub'],
    },
    'application/x-msschedule': {
      source: 'apache',
      extensions: ['scd'],
    },
    'application/x-msterminal': {
      source: 'apache',
      extensions: ['trm'],
    },
    'application/x-mswrite': {
      source: 'apache',
      extensions: ['wri'],
    },
    'application/x-netcdf': {
      source: 'apache',
      extensions: ['nc', 'cdf'],
    },
    'application/x-ns-proxy-autoconfig': {
      compressible: true,
      extensions: ['pac'],
    },
    'application/x-nzb': {
      source: 'apache',
      extensions: ['nzb'],
    },
    'application/x-perl': {
      source: 'nginx',
      extensions: ['pl', 'pm'],
    },
    'application/x-pilot': {
      source: 'nginx',
      extensions: ['prc', 'pdb'],
    },
    'application/x-pkcs12': {
      source: 'apache',
      compressible: false,
      extensions: ['p12', 'pfx'],
    },
    'application/x-pkcs7-certificates': {
      source: 'apache',
      extensions: ['p7b', 'spc'],
    },
    'application/x-pkcs7-certreqresp': {
      source: 'apache',
      extensions: ['p7r'],
    },
    'application/x-pki-message': {
      source: 'iana',
    },
    'application/x-rar-compressed': {
      source: 'apache',
      compressible: false,
      extensions: ['rar'],
    },
    'application/x-redhat-package-manager': {
      source: 'nginx',
      extensions: ['rpm'],
    },
    'application/x-research-info-systems': {
      source: 'apache',
      extensions: ['ris'],
    },
    'application/x-sea': {
      source: 'nginx',
      extensions: ['sea'],
    },
    'application/x-sh': {
      source: 'apache',
      compressible: true,
      extensions: ['sh'],
    },
    'application/x-shar': {
      source: 'apache',
      extensions: ['shar'],
    },
    'application/x-shockwave-flash': {
      source: 'apache',
      compressible: false,
      extensions: ['swf'],
    },
    'application/x-silverlight-app': {
      source: 'apache',
      extensions: ['xap'],
    },
    'application/x-sql': {
      source: 'apache',
      extensions: ['sql'],
    },
    'application/x-stuffit': {
      source: 'apache',
      compressible: false,
      extensions: ['sit'],
    },
    'application/x-stuffitx': {
      source: 'apache',
      extensions: ['sitx'],
    },
    'application/x-subrip': {
      source: 'apache',
      extensions: ['srt'],
    },
    'application/x-sv4cpio': {
      source: 'apache',
      extensions: ['sv4cpio'],
    },
    'application/x-sv4crc': {
      source: 'apache',
      extensions: ['sv4crc'],
    },
    'application/x-t3vm-image': {
      source: 'apache',
      extensions: ['t3'],
    },
    'application/x-tads': {
      source: 'apache',
      extensions: ['gam'],
    },
    'application/x-tar': {
      source: 'apache',
      compressible: true,
      extensions: ['tar'],
    },
    'application/x-tcl': {
      source: 'apache',
      extensions: ['tcl', 'tk'],
    },
    'application/x-tex': {
      source: 'apache',
      extensions: ['tex'],
    },
    'application/x-tex-tfm': {
      source: 'apache',
      extensions: ['tfm'],
    },
    'application/x-texinfo': {
      source: 'apache',
      extensions: ['texinfo', 'texi'],
    },
    'application/x-tgif': {
      source: 'apache',
      extensions: ['obj'],
    },
    'application/x-ustar': {
      source: 'apache',
      extensions: ['ustar'],
    },
    'application/x-virtualbox-hdd': {
      compressible: true,
      extensions: ['hdd'],
    },
    'application/x-virtualbox-ova': {
      compressible: true,
      extensions: ['ova'],
    },
    'application/x-virtualbox-ovf': {
      compressible: true,
      extensions: ['ovf'],
    },
    'application/x-virtualbox-vbox': {
      compressible: true,
      extensions: ['vbox'],
    },
    'application/x-virtualbox-vbox-extpack': {
      compressible: false,
      extensions: ['vbox-extpack'],
    },
    'application/x-virtualbox-vdi': {
      compressible: true,
      extensions: ['vdi'],
    },
    'application/x-virtualbox-vhd': {
      compressible: true,
      extensions: ['vhd'],
    },
    'application/x-virtualbox-vmdk': {
      compressible: true,
      extensions: ['vmdk'],
    },
    'application/x-wais-source': {
      source: 'apache',
      extensions: ['src'],
    },
    'application/x-web-app-manifest+json': {
      compressible: true,
      extensions: ['webapp'],
    },
    'application/x-www-form-urlencoded': {
      source: 'iana',
      compressible: true,
    },
    'application/x-x509-ca-cert': {
      source: 'iana',
      extensions: ['der', 'crt', 'pem'],
    },
    'application/x-x509-ca-ra-cert': {
      source: 'iana',
    },
    'application/x-x509-next-ca-cert': {
      source: 'iana',
    },
    'application/x-xfig': {
      source: 'apache',
      extensions: ['fig'],
    },
    'application/x-xliff+xml': {
      source: 'apache',
      compressible: true,
      extensions: ['xlf'],
    },
    'application/x-xpinstall': {
      source: 'apache',
      compressible: false,
      extensions: ['xpi'],
    },
    'application/x-xz': {
      source: 'apache',
      extensions: ['xz'],
    },
    'application/x-zmachine': {
      source: 'apache',
      extensions: ['z1', 'z2', 'z3', 'z4', 'z5', 'z6', 'z7', 'z8'],
    },
    'application/x400-bp': {
      source: 'iana',
    },
    'application/xacml+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/xaml+xml': {
      source: 'apache',
      compressible: true,
      extensions: ['xaml'],
    },
    'application/xcap-att+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['xav'],
    },
    'application/xcap-caps+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['xca'],
    },
    'application/xcap-diff+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['xdf'],
    },
    'application/xcap-el+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['xel'],
    },
    'application/xcap-error+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['xer'],
    },
    'application/xcap-ns+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['xns'],
    },
    'application/xcon-conference-info+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/xcon-conference-info-diff+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/xenc+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['xenc'],
    },
    'application/xhtml+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['xhtml', 'xht'],
    },
    'application/xhtml-voice+xml': {
      source: 'apache',
      compressible: true,
    },
    'application/xliff+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['xlf'],
    },
    'application/xml': {
      source: 'iana',
      compressible: true,
      extensions: ['xml', 'xsl', 'xsd', 'rng'],
    },
    'application/xml-dtd': {
      source: 'iana',
      compressible: true,
      extensions: ['dtd'],
    },
    'application/xml-external-parsed-entity': {
      source: 'iana',
    },
    'application/xml-patch+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/xmpp+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/xop+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['xop'],
    },
    'application/xproc+xml': {
      source: 'apache',
      compressible: true,
      extensions: ['xpl'],
    },
    'application/xslt+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['xsl', 'xslt'],
    },
    'application/xspf+xml': {
      source: 'apache',
      compressible: true,
      extensions: ['xspf'],
    },
    'application/xv+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['mxml', 'xhvml', 'xvml', 'xvm'],
    },
    'application/yang': {
      source: 'iana',
      extensions: ['yang'],
    },
    'application/yang-data+json': {
      source: 'iana',
      compressible: true,
    },
    'application/yang-data+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/yang-patch+json': {
      source: 'iana',
      compressible: true,
    },
    'application/yang-patch+xml': {
      source: 'iana',
      compressible: true,
    },
    'application/yin+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['yin'],
    },
    'application/zip': {
      source: 'iana',
      compressible: false,
      extensions: ['zip'],
    },
    'application/zlib': {
      source: 'iana',
    },
    'application/zstd': {
      source: 'iana',
    },
    'audio/1d-interleaved-parityfec': {
      source: 'iana',
    },
    'audio/32kadpcm': {
      source: 'iana',
    },
    'audio/3gpp': {
      source: 'iana',
      compressible: false,
      extensions: ['3gpp'],
    },
    'audio/3gpp2': {
      source: 'iana',
    },
    'audio/aac': {
      source: 'iana',
    },
    'audio/ac3': {
      source: 'iana',
    },
    'audio/adpcm': {
      source: 'apache',
      extensions: ['adp'],
    },
    'audio/amr': {
      source: 'iana',
      extensions: ['amr'],
    },
    'audio/amr-wb': {
      source: 'iana',
    },
    'audio/amr-wb+': {
      source: 'iana',
    },
    'audio/aptx': {
      source: 'iana',
    },
    'audio/asc': {
      source: 'iana',
    },
    'audio/atrac-advanced-lossless': {
      source: 'iana',
    },
    'audio/atrac-x': {
      source: 'iana',
    },
    'audio/atrac3': {
      source: 'iana',
    },
    'audio/basic': {
      source: 'iana',
      compressible: false,
      extensions: ['au', 'snd'],
    },
    'audio/bv16': {
      source: 'iana',
    },
    'audio/bv32': {
      source: 'iana',
    },
    'audio/clearmode': {
      source: 'iana',
    },
    'audio/cn': {
      source: 'iana',
    },
    'audio/dat12': {
      source: 'iana',
    },
    'audio/dls': {
      source: 'iana',
    },
    'audio/dsr-es201108': {
      source: 'iana',
    },
    'audio/dsr-es202050': {
      source: 'iana',
    },
    'audio/dsr-es202211': {
      source: 'iana',
    },
    'audio/dsr-es202212': {
      source: 'iana',
    },
    'audio/dv': {
      source: 'iana',
    },
    'audio/dvi4': {
      source: 'iana',
    },
    'audio/eac3': {
      source: 'iana',
    },
    'audio/encaprtp': {
      source: 'iana',
    },
    'audio/evrc': {
      source: 'iana',
    },
    'audio/evrc-qcp': {
      source: 'iana',
    },
    'audio/evrc0': {
      source: 'iana',
    },
    'audio/evrc1': {
      source: 'iana',
    },
    'audio/evrcb': {
      source: 'iana',
    },
    'audio/evrcb0': {
      source: 'iana',
    },
    'audio/evrcb1': {
      source: 'iana',
    },
    'audio/evrcnw': {
      source: 'iana',
    },
    'audio/evrcnw0': {
      source: 'iana',
    },
    'audio/evrcnw1': {
      source: 'iana',
    },
    'audio/evrcwb': {
      source: 'iana',
    },
    'audio/evrcwb0': {
      source: 'iana',
    },
    'audio/evrcwb1': {
      source: 'iana',
    },
    'audio/evs': {
      source: 'iana',
    },
    'audio/flexfec': {
      source: 'iana',
    },
    'audio/fwdred': {
      source: 'iana',
    },
    'audio/g711-0': {
      source: 'iana',
    },
    'audio/g719': {
      source: 'iana',
    },
    'audio/g722': {
      source: 'iana',
    },
    'audio/g7221': {
      source: 'iana',
    },
    'audio/g723': {
      source: 'iana',
    },
    'audio/g726-16': {
      source: 'iana',
    },
    'audio/g726-24': {
      source: 'iana',
    },
    'audio/g726-32': {
      source: 'iana',
    },
    'audio/g726-40': {
      source: 'iana',
    },
    'audio/g728': {
      source: 'iana',
    },
    'audio/g729': {
      source: 'iana',
    },
    'audio/g7291': {
      source: 'iana',
    },
    'audio/g729d': {
      source: 'iana',
    },
    'audio/g729e': {
      source: 'iana',
    },
    'audio/gsm': {
      source: 'iana',
    },
    'audio/gsm-efr': {
      source: 'iana',
    },
    'audio/gsm-hr-08': {
      source: 'iana',
    },
    'audio/ilbc': {
      source: 'iana',
    },
    'audio/ip-mr_v2.5': {
      source: 'iana',
    },
    'audio/isac': {
      source: 'apache',
    },
    'audio/l16': {
      source: 'iana',
    },
    'audio/l20': {
      source: 'iana',
    },
    'audio/l24': {
      source: 'iana',
      compressible: false,
    },
    'audio/l8': {
      source: 'iana',
    },
    'audio/lpc': {
      source: 'iana',
    },
    'audio/melp': {
      source: 'iana',
    },
    'audio/melp1200': {
      source: 'iana',
    },
    'audio/melp2400': {
      source: 'iana',
    },
    'audio/melp600': {
      source: 'iana',
    },
    'audio/mhas': {
      source: 'iana',
    },
    'audio/midi': {
      source: 'apache',
      extensions: ['mid', 'midi', 'kar', 'rmi'],
    },
    'audio/mobile-xmf': {
      source: 'iana',
      extensions: ['mxmf'],
    },
    'audio/mp3': {
      compressible: false,
      extensions: ['mp3'],
    },
    'audio/mp4': {
      source: 'iana',
      compressible: false,
      extensions: ['m4a', 'mp4a'],
    },
    'audio/mp4a-latm': {
      source: 'iana',
    },
    'audio/mpa': {
      source: 'iana',
    },
    'audio/mpa-robust': {
      source: 'iana',
    },
    'audio/mpeg': {
      source: 'iana',
      compressible: false,
      extensions: ['mpga', 'mp2', 'mp2a', 'mp3', 'm2a', 'm3a'],
    },
    'audio/mpeg4-generic': {
      source: 'iana',
    },
    'audio/musepack': {
      source: 'apache',
    },
    'audio/ogg': {
      source: 'iana',
      compressible: false,
      extensions: ['oga', 'ogg', 'spx', 'opus'],
    },
    'audio/opus': {
      source: 'iana',
    },
    'audio/parityfec': {
      source: 'iana',
    },
    'audio/pcma': {
      source: 'iana',
    },
    'audio/pcma-wb': {
      source: 'iana',
    },
    'audio/pcmu': {
      source: 'iana',
    },
    'audio/pcmu-wb': {
      source: 'iana',
    },
    'audio/prs.sid': {
      source: 'iana',
    },
    'audio/qcelp': {
      source: 'iana',
    },
    'audio/raptorfec': {
      source: 'iana',
    },
    'audio/red': {
      source: 'iana',
    },
    'audio/rtp-enc-aescm128': {
      source: 'iana',
    },
    'audio/rtp-midi': {
      source: 'iana',
    },
    'audio/rtploopback': {
      source: 'iana',
    },
    'audio/rtx': {
      source: 'iana',
    },
    'audio/s3m': {
      source: 'apache',
      extensions: ['s3m'],
    },
    'audio/scip': {
      source: 'iana',
    },
    'audio/silk': {
      source: 'apache',
      extensions: ['sil'],
    },
    'audio/smv': {
      source: 'iana',
    },
    'audio/smv-qcp': {
      source: 'iana',
    },
    'audio/smv0': {
      source: 'iana',
    },
    'audio/sofa': {
      source: 'iana',
    },
    'audio/sp-midi': {
      source: 'iana',
    },
    'audio/speex': {
      source: 'iana',
    },
    'audio/t140c': {
      source: 'iana',
    },
    'audio/t38': {
      source: 'iana',
    },
    'audio/telephone-event': {
      source: 'iana',
    },
    'audio/tetra_acelp': {
      source: 'iana',
    },
    'audio/tetra_acelp_bb': {
      source: 'iana',
    },
    'audio/tone': {
      source: 'iana',
    },
    'audio/tsvcis': {
      source: 'iana',
    },
    'audio/uemclip': {
      source: 'iana',
    },
    'audio/ulpfec': {
      source: 'iana',
    },
    'audio/usac': {
      source: 'iana',
    },
    'audio/vdvi': {
      source: 'iana',
    },
    'audio/vmr-wb': {
      source: 'iana',
    },
    'audio/vnd.3gpp.iufp': {
      source: 'iana',
    },
    'audio/vnd.4sb': {
      source: 'iana',
    },
    'audio/vnd.audiokoz': {
      source: 'iana',
    },
    'audio/vnd.celp': {
      source: 'iana',
    },
    'audio/vnd.cisco.nse': {
      source: 'iana',
    },
    'audio/vnd.cmles.radio-events': {
      source: 'iana',
    },
    'audio/vnd.cns.anp1': {
      source: 'iana',
    },
    'audio/vnd.cns.inf1': {
      source: 'iana',
    },
    'audio/vnd.dece.audio': {
      source: 'iana',
      extensions: ['uva', 'uvva'],
    },
    'audio/vnd.digital-winds': {
      source: 'iana',
      extensions: ['eol'],
    },
    'audio/vnd.dlna.adts': {
      source: 'iana',
    },
    'audio/vnd.dolby.heaac.1': {
      source: 'iana',
    },
    'audio/vnd.dolby.heaac.2': {
      source: 'iana',
    },
    'audio/vnd.dolby.mlp': {
      source: 'iana',
    },
    'audio/vnd.dolby.mps': {
      source: 'iana',
    },
    'audio/vnd.dolby.pl2': {
      source: 'iana',
    },
    'audio/vnd.dolby.pl2x': {
      source: 'iana',
    },
    'audio/vnd.dolby.pl2z': {
      source: 'iana',
    },
    'audio/vnd.dolby.pulse.1': {
      source: 'iana',
    },
    'audio/vnd.dra': {
      source: 'iana',
      extensions: ['dra'],
    },
    'audio/vnd.dts': {
      source: 'iana',
      extensions: ['dts'],
    },
    'audio/vnd.dts.hd': {
      source: 'iana',
      extensions: ['dtshd'],
    },
    'audio/vnd.dts.uhd': {
      source: 'iana',
    },
    'audio/vnd.dvb.file': {
      source: 'iana',
    },
    'audio/vnd.everad.plj': {
      source: 'iana',
    },
    'audio/vnd.hns.audio': {
      source: 'iana',
    },
    'audio/vnd.lucent.voice': {
      source: 'iana',
      extensions: ['lvp'],
    },
    'audio/vnd.ms-playready.media.pya': {
      source: 'iana',
      extensions: ['pya'],
    },
    'audio/vnd.nokia.mobile-xmf': {
      source: 'iana',
    },
    'audio/vnd.nortel.vbk': {
      source: 'iana',
    },
    'audio/vnd.nuera.ecelp4800': {
      source: 'iana',
      extensions: ['ecelp4800'],
    },
    'audio/vnd.nuera.ecelp7470': {
      source: 'iana',
      extensions: ['ecelp7470'],
    },
    'audio/vnd.nuera.ecelp9600': {
      source: 'iana',
      extensions: ['ecelp9600'],
    },
    'audio/vnd.octel.sbc': {
      source: 'iana',
    },
    'audio/vnd.presonus.multitrack': {
      source: 'iana',
    },
    'audio/vnd.qcelp': {
      source: 'iana',
    },
    'audio/vnd.rhetorex.32kadpcm': {
      source: 'iana',
    },
    'audio/vnd.rip': {
      source: 'iana',
      extensions: ['rip'],
    },
    'audio/vnd.rn-realaudio': {
      compressible: false,
    },
    'audio/vnd.sealedmedia.softseal.mpeg': {
      source: 'iana',
    },
    'audio/vnd.vmx.cvsd': {
      source: 'iana',
    },
    'audio/vnd.wave': {
      compressible: false,
    },
    'audio/vorbis': {
      source: 'iana',
      compressible: false,
    },
    'audio/vorbis-config': {
      source: 'iana',
    },
    'audio/wav': {
      compressible: false,
      extensions: ['wav'],
    },
    'audio/wave': {
      compressible: false,
      extensions: ['wav'],
    },
    'audio/webm': {
      source: 'apache',
      compressible: false,
      extensions: ['weba'],
    },
    'audio/x-aac': {
      source: 'apache',
      compressible: false,
      extensions: ['aac'],
    },
    'audio/x-aiff': {
      source: 'apache',
      extensions: ['aif', 'aiff', 'aifc'],
    },
    'audio/x-caf': {
      source: 'apache',
      compressible: false,
      extensions: ['caf'],
    },
    'audio/x-flac': {
      source: 'apache',
      extensions: ['flac'],
    },
    'audio/x-m4a': {
      source: 'nginx',
      extensions: ['m4a'],
    },
    'audio/x-matroska': {
      source: 'apache',
      extensions: ['mka'],
    },
    'audio/x-mpegurl': {
      source: 'apache',
      extensions: ['m3u'],
    },
    'audio/x-ms-wax': {
      source: 'apache',
      extensions: ['wax'],
    },
    'audio/x-ms-wma': {
      source: 'apache',
      extensions: ['wma'],
    },
    'audio/x-pn-realaudio': {
      source: 'apache',
      extensions: ['ram', 'ra'],
    },
    'audio/x-pn-realaudio-plugin': {
      source: 'apache',
      extensions: ['rmp'],
    },
    'audio/x-realaudio': {
      source: 'nginx',
      extensions: ['ra'],
    },
    'audio/x-tta': {
      source: 'apache',
    },
    'audio/x-wav': {
      source: 'apache',
      extensions: ['wav'],
    },
    'audio/xm': {
      source: 'apache',
      extensions: ['xm'],
    },
    'chemical/x-cdx': {
      source: 'apache',
      extensions: ['cdx'],
    },
    'chemical/x-cif': {
      source: 'apache',
      extensions: ['cif'],
    },
    'chemical/x-cmdf': {
      source: 'apache',
      extensions: ['cmdf'],
    },
    'chemical/x-cml': {
      source: 'apache',
      extensions: ['cml'],
    },
    'chemical/x-csml': {
      source: 'apache',
      extensions: ['csml'],
    },
    'chemical/x-pdb': {
      source: 'apache',
    },
    'chemical/x-xyz': {
      source: 'apache',
      extensions: ['xyz'],
    },
    'font/collection': {
      source: 'iana',
      extensions: ['ttc'],
    },
    'font/otf': {
      source: 'iana',
      compressible: true,
      extensions: ['otf'],
    },
    'font/sfnt': {
      source: 'iana',
    },
    'font/ttf': {
      source: 'iana',
      compressible: true,
      extensions: ['ttf'],
    },
    'font/woff': {
      source: 'iana',
      extensions: ['woff'],
    },
    'font/woff2': {
      source: 'iana',
      extensions: ['woff2'],
    },
    'image/aces': {
      source: 'iana',
      extensions: ['exr'],
    },
    'image/apng': {
      compressible: false,
      extensions: ['apng'],
    },
    'image/avci': {
      source: 'iana',
    },
    'image/avcs': {
      source: 'iana',
    },
    'image/avif': {
      source: 'iana',
      compressible: false,
      extensions: ['avif'],
    },
    'image/bmp': {
      source: 'iana',
      compressible: true,
      extensions: ['bmp'],
    },
    'image/cgm': {
      source: 'iana',
      extensions: ['cgm'],
    },
    'image/dicom-rle': {
      source: 'iana',
      extensions: ['drle'],
    },
    'image/emf': {
      source: 'iana',
      extensions: ['emf'],
    },
    'image/fits': {
      source: 'iana',
      extensions: ['fits'],
    },
    'image/g3fax': {
      source: 'iana',
      extensions: ['g3'],
    },
    'image/gif': {
      source: 'iana',
      compressible: false,
      extensions: ['gif'],
    },
    'image/heic': {
      source: 'iana',
      extensions: ['heic'],
    },
    'image/heic-sequence': {
      source: 'iana',
      extensions: ['heics'],
    },
    'image/heif': {
      source: 'iana',
      extensions: ['heif'],
    },
    'image/heif-sequence': {
      source: 'iana',
      extensions: ['heifs'],
    },
    'image/hej2k': {
      source: 'iana',
      extensions: ['hej2'],
    },
    'image/hsj2': {
      source: 'iana',
      extensions: ['hsj2'],
    },
    'image/ief': {
      source: 'iana',
      extensions: ['ief'],
    },
    'image/jls': {
      source: 'iana',
      extensions: ['jls'],
    },
    'image/jp2': {
      source: 'iana',
      compressible: false,
      extensions: ['jp2', 'jpg2'],
    },
    'image/jpeg': {
      source: 'iana',
      compressible: false,
      extensions: ['jpeg', 'jpg', 'jpe'],
    },
    'image/jph': {
      source: 'iana',
      extensions: ['jph'],
    },
    'image/jphc': {
      source: 'iana',
      extensions: ['jhc'],
    },
    'image/jpm': {
      source: 'iana',
      compressible: false,
      extensions: ['jpm'],
    },
    'image/jpx': {
      source: 'iana',
      compressible: false,
      extensions: ['jpx', 'jpf'],
    },
    'image/jxr': {
      source: 'iana',
      extensions: ['jxr'],
    },
    'image/jxra': {
      source: 'iana',
      extensions: ['jxra'],
    },
    'image/jxrs': {
      source: 'iana',
      extensions: ['jxrs'],
    },
    'image/jxs': {
      source: 'iana',
      extensions: ['jxs'],
    },
    'image/jxsc': {
      source: 'iana',
      extensions: ['jxsc'],
    },
    'image/jxsi': {
      source: 'iana',
      extensions: ['jxsi'],
    },
    'image/jxss': {
      source: 'iana',
      extensions: ['jxss'],
    },
    'image/ktx': {
      source: 'iana',
      extensions: ['ktx'],
    },
    'image/ktx2': {
      source: 'iana',
      extensions: ['ktx2'],
    },
    'image/naplps': {
      source: 'iana',
    },
    'image/pjpeg': {
      compressible: false,
    },
    'image/png': {
      source: 'iana',
      compressible: false,
      extensions: ['png'],
    },
    'image/prs.btif': {
      source: 'iana',
      extensions: ['btif'],
    },
    'image/prs.pti': {
      source: 'iana',
      extensions: ['pti'],
    },
    'image/pwg-raster': {
      source: 'iana',
    },
    'image/sgi': {
      source: 'apache',
      extensions: ['sgi'],
    },
    'image/svg+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['svg', 'svgz'],
    },
    'image/t38': {
      source: 'iana',
      extensions: ['t38'],
    },
    'image/tiff': {
      source: 'iana',
      compressible: false,
      extensions: ['tif', 'tiff'],
    },
    'image/tiff-fx': {
      source: 'iana',
      extensions: ['tfx'],
    },
    'image/vnd.adobe.photoshop': {
      source: 'iana',
      compressible: true,
      extensions: ['psd'],
    },
    'image/vnd.airzip.accelerator.azv': {
      source: 'iana',
      extensions: ['azv'],
    },
    'image/vnd.cns.inf2': {
      source: 'iana',
    },
    'image/vnd.dece.graphic': {
      source: 'iana',
      extensions: ['uvi', 'uvvi', 'uvg', 'uvvg'],
    },
    'image/vnd.djvu': {
      source: 'iana',
      extensions: ['djvu', 'djv'],
    },
    'image/vnd.dvb.subtitle': {
      source: 'iana',
      extensions: ['sub'],
    },
    'image/vnd.dwg': {
      source: 'iana',
      extensions: ['dwg'],
    },
    'image/vnd.dxf': {
      source: 'iana',
      extensions: ['dxf'],
    },
    'image/vnd.fastbidsheet': {
      source: 'iana',
      extensions: ['fbs'],
    },
    'image/vnd.fpx': {
      source: 'iana',
      extensions: ['fpx'],
    },
    'image/vnd.fst': {
      source: 'iana',
      extensions: ['fst'],
    },
    'image/vnd.fujixerox.edmics-mmr': {
      source: 'iana',
      extensions: ['mmr'],
    },
    'image/vnd.fujixerox.edmics-rlc': {
      source: 'iana',
      extensions: ['rlc'],
    },
    'image/vnd.globalgraphics.pgb': {
      source: 'iana',
    },
    'image/vnd.microsoft.icon': {
      source: 'iana',
      extensions: ['ico'],
    },
    'image/vnd.mix': {
      source: 'iana',
    },
    'image/vnd.mozilla.apng': {
      source: 'iana',
    },
    'image/vnd.ms-dds': {
      extensions: ['dds'],
    },
    'image/vnd.ms-modi': {
      source: 'iana',
      extensions: ['mdi'],
    },
    'image/vnd.ms-photo': {
      source: 'apache',
      extensions: ['wdp'],
    },
    'image/vnd.net-fpx': {
      source: 'iana',
      extensions: ['npx'],
    },
    'image/vnd.pco.b16': {
      source: 'iana',
      extensions: ['b16'],
    },
    'image/vnd.radiance': {
      source: 'iana',
    },
    'image/vnd.sealed.png': {
      source: 'iana',
    },
    'image/vnd.sealedmedia.softseal.gif': {
      source: 'iana',
    },
    'image/vnd.sealedmedia.softseal.jpg': {
      source: 'iana',
    },
    'image/vnd.svf': {
      source: 'iana',
    },
    'image/vnd.tencent.tap': {
      source: 'iana',
      extensions: ['tap'],
    },
    'image/vnd.valve.source.texture': {
      source: 'iana',
      extensions: ['vtf'],
    },
    'image/vnd.wap.wbmp': {
      source: 'iana',
      extensions: ['wbmp'],
    },
    'image/vnd.xiff': {
      source: 'iana',
      extensions: ['xif'],
    },
    'image/vnd.zbrush.pcx': {
      source: 'iana',
      extensions: ['pcx'],
    },
    'image/webp': {
      source: 'apache',
      extensions: ['webp'],
    },
    'image/wmf': {
      source: 'iana',
      extensions: ['wmf'],
    },
    'image/x-3ds': {
      source: 'apache',
      extensions: ['3ds'],
    },
    'image/x-cmu-raster': {
      source: 'apache',
      extensions: ['ras'],
    },
    'image/x-cmx': {
      source: 'apache',
      extensions: ['cmx'],
    },
    'image/x-freehand': {
      source: 'apache',
      extensions: ['fh', 'fhc', 'fh4', 'fh5', 'fh7'],
    },
    'image/x-icon': {
      source: 'apache',
      compressible: true,
      extensions: ['ico'],
    },
    'image/x-jng': {
      source: 'nginx',
      extensions: ['jng'],
    },
    'image/x-mrsid-image': {
      source: 'apache',
      extensions: ['sid'],
    },
    'image/x-ms-bmp': {
      source: 'nginx',
      compressible: true,
      extensions: ['bmp'],
    },
    'image/x-pcx': {
      source: 'apache',
      extensions: ['pcx'],
    },
    'image/x-pict': {
      source: 'apache',
      extensions: ['pic', 'pct'],
    },
    'image/x-portable-anymap': {
      source: 'apache',
      extensions: ['pnm'],
    },
    'image/x-portable-bitmap': {
      source: 'apache',
      extensions: ['pbm'],
    },
    'image/x-portable-graymap': {
      source: 'apache',
      extensions: ['pgm'],
    },
    'image/x-portable-pixmap': {
      source: 'apache',
      extensions: ['ppm'],
    },
    'image/x-rgb': {
      source: 'apache',
      extensions: ['rgb'],
    },
    'image/x-tga': {
      source: 'apache',
      extensions: ['tga'],
    },
    'image/x-xbitmap': {
      source: 'apache',
      extensions: ['xbm'],
    },
    'image/x-xcf': {
      compressible: false,
    },
    'image/x-xpixmap': {
      source: 'apache',
      extensions: ['xpm'],
    },
    'image/x-xwindowdump': {
      source: 'apache',
      extensions: ['xwd'],
    },
    'message/cpim': {
      source: 'iana',
    },
    'message/delivery-status': {
      source: 'iana',
    },
    'message/disposition-notification': {
      source: 'iana',
      extensions: ['disposition-notification'],
    },
    'message/external-body': {
      source: 'iana',
    },
    'message/feedback-report': {
      source: 'iana',
    },
    'message/global': {
      source: 'iana',
      extensions: ['u8msg'],
    },
    'message/global-delivery-status': {
      source: 'iana',
      extensions: ['u8dsn'],
    },
    'message/global-disposition-notification': {
      source: 'iana',
      extensions: ['u8mdn'],
    },
    'message/global-headers': {
      source: 'iana',
      extensions: ['u8hdr'],
    },
    'message/http': {
      source: 'iana',
      compressible: false,
    },
    'message/imdn+xml': {
      source: 'iana',
      compressible: true,
    },
    'message/news': {
      source: 'iana',
    },
    'message/partial': {
      source: 'iana',
      compressible: false,
    },
    'message/rfc822': {
      source: 'iana',
      compressible: true,
      extensions: ['eml', 'mime'],
    },
    'message/s-http': {
      source: 'iana',
    },
    'message/sip': {
      source: 'iana',
    },
    'message/sipfrag': {
      source: 'iana',
    },
    'message/tracking-status': {
      source: 'iana',
    },
    'message/vnd.si.simp': {
      source: 'iana',
    },
    'message/vnd.wfa.wsc': {
      source: 'iana',
      extensions: ['wsc'],
    },
    'model/3mf': {
      source: 'iana',
      extensions: ['3mf'],
    },
    'model/e57': {
      source: 'iana',
    },
    'model/gltf+json': {
      source: 'iana',
      compressible: true,
      extensions: ['gltf'],
    },
    'model/gltf-binary': {
      source: 'iana',
      compressible: true,
      extensions: ['glb'],
    },
    'model/iges': {
      source: 'iana',
      compressible: false,
      extensions: ['igs', 'iges'],
    },
    'model/mesh': {
      source: 'iana',
      compressible: false,
      extensions: ['msh', 'mesh', 'silo'],
    },
    'model/mtl': {
      source: 'iana',
      extensions: ['mtl'],
    },
    'model/obj': {
      source: 'iana',
      extensions: ['obj'],
    },
    'model/stl': {
      source: 'iana',
      extensions: ['stl'],
    },
    'model/vnd.collada+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['dae'],
    },
    'model/vnd.dwf': {
      source: 'iana',
      extensions: ['dwf'],
    },
    'model/vnd.flatland.3dml': {
      source: 'iana',
    },
    'model/vnd.gdl': {
      source: 'iana',
      extensions: ['gdl'],
    },
    'model/vnd.gs-gdl': {
      source: 'apache',
    },
    'model/vnd.gs.gdl': {
      source: 'iana',
    },
    'model/vnd.gtw': {
      source: 'iana',
      extensions: ['gtw'],
    },
    'model/vnd.moml+xml': {
      source: 'iana',
      compressible: true,
    },
    'model/vnd.mts': {
      source: 'iana',
      extensions: ['mts'],
    },
    'model/vnd.opengex': {
      source: 'iana',
      extensions: ['ogex'],
    },
    'model/vnd.parasolid.transmit.binary': {
      source: 'iana',
      extensions: ['x_b'],
    },
    'model/vnd.parasolid.transmit.text': {
      source: 'iana',
      extensions: ['x_t'],
    },
    'model/vnd.rosette.annotated-data-model': {
      source: 'iana',
    },
    'model/vnd.usdz+zip': {
      source: 'iana',
      compressible: false,
      extensions: ['usdz'],
    },
    'model/vnd.valve.source.compiled-map': {
      source: 'iana',
      extensions: ['bsp'],
    },
    'model/vnd.vtu': {
      source: 'iana',
      extensions: ['vtu'],
    },
    'model/vrml': {
      source: 'iana',
      compressible: false,
      extensions: ['wrl', 'vrml'],
    },
    'model/x3d+binary': {
      source: 'apache',
      compressible: false,
      extensions: ['x3db', 'x3dbz'],
    },
    'model/x3d+fastinfoset': {
      source: 'iana',
      extensions: ['x3db'],
    },
    'model/x3d+vrml': {
      source: 'apache',
      compressible: false,
      extensions: ['x3dv', 'x3dvz'],
    },
    'model/x3d+xml': {
      source: 'iana',
      compressible: true,
      extensions: ['x3d', 'x3dz'],
    },
    'model/x3d-vrml': {
      source: 'iana',
      extensions: ['x3dv'],
    },
    'multipart/alternative': {
      source: 'iana',
      compressible: false,
    },
    'multipart/appledouble': {
      source: 'iana',
    },
    'multipart/byteranges': {
      source: 'iana',
    },
    'multipart/digest': {
      source: 'iana',
    },
    'multipart/encrypted': {
      source: 'iana',
      compressible: false,
    },
    'multipart/form-data': {
      source: 'iana',
      compressible: false,
    },
    'multipart/header-set': {
      source: 'iana',
    },
    'multipart/mixed': {
      source: 'iana',
    },
    'multipart/multilingual': {
      source: 'iana',
    },
    'multipart/parallel': {
      source: 'iana',
    },
    'multipart/related': {
      source: 'iana',
      compressible: false,
    },
    'multipart/report': {
      source: 'iana',
    },
    'multipart/signed': {
      source: 'iana',
      compressible: false,
    },
    'multipart/vnd.bint.med-plus': {
      source: 'iana',
    },
    'multipart/voice-message': {
      source: 'iana',
    },
    'multipart/x-mixed-replace': {
      source: 'iana',
    },
    'text/1d-interleaved-parityfec': {
      source: 'iana',
    },
    'text/cache-manifest': {
      source: 'iana',
      compressible: true,
      extensions: ['appcache', 'manifest'],
    },
    'text/calendar': {
      source: 'iana',
      extensions: ['ics', 'ifb'],
    },
    'text/calender': {
      compressible: true,
    },
    'text/cmd': {
      compressible: true,
    },
    'text/coffeescript': {
      extensions: ['coffee', 'litcoffee'],
    },
    'text/cql': {
      source: 'iana',
    },
    'text/cql-expression': {
      source: 'iana',
    },
    'text/cql-identifier': {
      source: 'iana',
    },
    'text/css': {
      source: 'iana',
      charset: 'UTF-8',
      compressible: true,
      extensions: ['css'],
    },
    'text/csv': {
      source: 'iana',
      compressible: true,
      extensions: ['csv'],
    },
    'text/csv-schema': {
      source: 'iana',
    },
    'text/directory': {
      source: 'iana',
    },
    'text/dns': {
      source: 'iana',
    },
    'text/ecmascript': {
      source: 'iana',
    },
    'text/encaprtp': {
      source: 'iana',
    },
    'text/enriched': {
      source: 'iana',
    },
    'text/fhirpath': {
      source: 'iana',
    },
    'text/flexfec': {
      source: 'iana',
    },
    'text/fwdred': {
      source: 'iana',
    },
    'text/gff3': {
      source: 'iana',
    },
    'text/grammar-ref-list': {
      source: 'iana',
    },
    'text/html': {
      source: 'iana',
      compressible: true,
      extensions: ['html', 'htm', 'shtml'],
    },
    'text/jade': {
      extensions: ['jade'],
    },
    'text/javascript': {
      source: 'iana',
      compressible: true,
    },
    'text/jcr-cnd': {
      source: 'iana',
    },
    'text/jsx': {
      compressible: true,
      extensions: ['jsx'],
    },
    'text/less': {
      compressible: true,
      extensions: ['less'],
    },
    'text/markdown': {
      source: 'iana',
      compressible: true,
      extensions: ['markdown', 'md'],
    },
    'text/mathml': {
      source: 'nginx',
      extensions: ['mml'],
    },
    'text/mdx': {
      compressible: true,
      extensions: ['mdx'],
    },
    'text/mizar': {
      source: 'iana',
    },
    'text/n3': {
      source: 'iana',
      charset: 'UTF-8',
      compressible: true,
      extensions: ['n3'],
    },
    'text/parameters': {
      source: 'iana',
      charset: 'UTF-8',
    },
    'text/parityfec': {
      source: 'iana',
    },
    'text/plain': {
      source: 'iana',
      compressible: true,
      extensions: ['txt', 'text', 'conf', 'def', 'list', 'log', 'in', 'ini'],
    },
    'text/provenance-notation': {
      source: 'iana',
      charset: 'UTF-8',
    },
    'text/prs.fallenstein.rst': {
      source: 'iana',
    },
    'text/prs.lines.tag': {
      source: 'iana',
      extensions: ['dsc'],
    },
    'text/prs.prop.logic': {
      source: 'iana',
    },
    'text/raptorfec': {
      source: 'iana',
    },
    'text/red': {
      source: 'iana',
    },
    'text/rfc822-headers': {
      source: 'iana',
    },
    'text/richtext': {
      source: 'iana',
      compressible: true,
      extensions: ['rtx'],
    },
    'text/rtf': {
      source: 'iana',
      compressible: true,
      extensions: ['rtf'],
    },
    'text/rtp-enc-aescm128': {
      source: 'iana',
    },
    'text/rtploopback': {
      source: 'iana',
    },
    'text/rtx': {
      source: 'iana',
    },
    'text/sgml': {
      source: 'iana',
      extensions: ['sgml', 'sgm'],
    },
    'text/shaclc': {
      source: 'iana',
    },
    'text/shex': {
      extensions: ['shex'],
    },
    'text/slim': {
      extensions: ['slim', 'slm'],
    },
    'text/spdx': {
      source: 'iana',
      extensions: ['spdx'],
    },
    'text/strings': {
      source: 'iana',
    },
    'text/stylus': {
      extensions: ['stylus', 'styl'],
    },
    'text/t140': {
      source: 'iana',
    },
    'text/tab-separated-values': {
      source: 'iana',
      compressible: true,
      extensions: ['tsv'],
    },
    'text/troff': {
      source: 'iana',
      extensions: ['t', 'tr', 'roff', 'man', 'me', 'ms'],
    },
    'text/turtle': {
      source: 'iana',
      charset: 'UTF-8',
      extensions: ['ttl'],
    },
    'text/ulpfec': {
      source: 'iana',
    },
    'text/uri-list': {
      source: 'iana',
      compressible: true,
      extensions: ['uri', 'uris', 'urls'],
    },
    'text/vcard': {
      source: 'iana',
      compressible: true,
      extensions: ['vcard'],
    },
    'text/vnd.a': {
      source: 'iana',
    },
    'text/vnd.abc': {
      source: 'iana',
    },
    'text/vnd.ascii-art': {
      source: 'iana',
    },
    'text/vnd.curl': {
      source: 'iana',
      extensions: ['curl'],
    },
    'text/vnd.curl.dcurl': {
      source: 'apache',
      extensions: ['dcurl'],
    },
    'text/vnd.curl.mcurl': {
      source: 'apache',
      extensions: ['mcurl'],
    },
    'text/vnd.curl.scurl': {
      source: 'apache',
      extensions: ['scurl'],
    },
    'text/vnd.debian.copyright': {
      source: 'iana',
      charset: 'UTF-8',
    },
    'text/vnd.dmclientscript': {
      source: 'iana',
    },
    'text/vnd.dvb.subtitle': {
      source: 'iana',
      extensions: ['sub'],
    },
    'text/vnd.esmertec.theme-descriptor': {
      source: 'iana',
      charset: 'UTF-8',
    },
    'text/vnd.ficlab.flt': {
      source: 'iana',
    },
    'text/vnd.fly': {
      source: 'iana',
      extensions: ['fly'],
    },
    'text/vnd.fmi.flexstor': {
      source: 'iana',
      extensions: ['flx'],
    },
    'text/vnd.gml': {
      source: 'iana',
    },
    'text/vnd.graphviz': {
      source: 'iana',
      extensions: ['gv'],
    },
    'text/vnd.hans': {
      source: 'iana',
    },
    'text/vnd.hgl': {
      source: 'iana',
    },
    'text/vnd.in3d.3dml': {
      source: 'iana',
      extensions: ['3dml'],
    },
    'text/vnd.in3d.spot': {
      source: 'iana',
      extensions: ['spot'],
    },
    'text/vnd.iptc.newsml': {
      source: 'iana',
    },
    'text/vnd.iptc.nitf': {
      source: 'iana',
    },
    'text/vnd.latex-z': {
      source: 'iana',
    },
    'text/vnd.motorola.reflex': {
      source: 'iana',
    },
    'text/vnd.ms-mediapackage': {
      source: 'iana',
    },
    'text/vnd.net2phone.commcenter.command': {
      source: 'iana',
    },
    'text/vnd.radisys.msml-basic-layout': {
      source: 'iana',
    },
    'text/vnd.senx.warpscript': {
      source: 'iana',
    },
    'text/vnd.si.uricatalogue': {
      source: 'iana',
    },
    'text/vnd.sosi': {
      source: 'iana',
    },
    'text/vnd.sun.j2me.app-descriptor': {
      source: 'iana',
      charset: 'UTF-8',
      extensions: ['jad'],
    },
    'text/vnd.trolltech.linguist': {
      source: 'iana',
      charset: 'UTF-8',
    },
    'text/vnd.wap.si': {
      source: 'iana',
    },
    'text/vnd.wap.sl': {
      source: 'iana',
    },
    'text/vnd.wap.wml': {
      source: 'iana',
      extensions: ['wml'],
    },
    'text/vnd.wap.wmlscript': {
      source: 'iana',
      extensions: ['wmls'],
    },
    'text/vtt': {
      source: 'iana',
      charset: 'UTF-8',
      compressible: true,
      extensions: ['vtt'],
    },
    'text/x-asm': {
      source: 'apache',
      extensions: ['s', 'asm'],
    },
    'text/x-c': {
      source: 'apache',
      extensions: ['c', 'cc', 'cxx', 'cpp', 'h', 'hh', 'dic'],
    },
    'text/x-component': {
      source: 'nginx',
      extensions: ['htc'],
    },
    'text/x-fortran': {
      source: 'apache',
      extensions: ['f', 'for', 'f77', 'f90'],
    },
    'text/x-gwt-rpc': {
      compressible: true,
    },
    'text/x-handlebars-template': {
      extensions: ['hbs'],
    },
    'text/x-java-source': {
      source: 'apache',
      extensions: ['java'],
    },
    'text/x-jquery-tmpl': {
      compressible: true,
    },
    'text/x-lua': {
      extensions: ['lua'],
    },
    'text/x-markdown': {
      compressible: true,
      extensions: ['mkd'],
    },
    'text/x-nfo': {
      source: 'apache',
      extensions: ['nfo'],
    },
    'text/x-opml': {
      source: 'apache',
      extensions: ['opml'],
    },
    'text/x-org': {
      compressible: true,
      extensions: ['org'],
    },
    'text/x-pascal': {
      source: 'apache',
      extensions: ['p', 'pas'],
    },
    'text/x-processing': {
      compressible: true,
      extensions: ['pde'],
    },
    'text/x-sass': {
      extensions: ['sass'],
    },
    'text/x-scss': {
      extensions: ['scss'],
    },
    'text/x-setext': {
      source: 'apache',
      extensions: ['etx'],
    },
    'text/x-sfv': {
      source: 'apache',
      extensions: ['sfv'],
    },
    'text/x-suse-ymp': {
      compressible: true,
      extensions: ['ymp'],
    },
    'text/x-uuencode': {
      source: 'apache',
      extensions: ['uu'],
    },
    'text/x-vcalendar': {
      source: 'apache',
      extensions: ['vcs'],
    },
    'text/x-vcard': {
      source: 'apache',
      extensions: ['vcf'],
    },
    'text/xml': {
      source: 'iana',
      compressible: true,
      extensions: ['xml'],
    },
    'text/xml-external-parsed-entity': {
      source: 'iana',
    },
    'text/yaml': {
      extensions: ['yaml', 'yml'],
    },
    'video/1d-interleaved-parityfec': {
      source: 'iana',
    },
    'video/3gpp': {
      source: 'iana',
      extensions: ['3gp', '3gpp'],
    },
    'video/3gpp-tt': {
      source: 'iana',
    },
    'video/3gpp2': {
      source: 'iana',
      extensions: ['3g2'],
    },
    'video/av1': {
      source: 'iana',
    },
    'video/bmpeg': {
      source: 'iana',
    },
    'video/bt656': {
      source: 'iana',
    },
    'video/celb': {
      source: 'iana',
    },
    'video/dv': {
      source: 'iana',
    },
    'video/encaprtp': {
      source: 'iana',
    },
    'video/flexfec': {
      source: 'iana',
    },
    'video/h261': {
      source: 'iana',
      extensions: ['h261'],
    },
    'video/h263': {
      source: 'iana',
      extensions: ['h263'],
    },
    'video/h263-1998': {
      source: 'iana',
    },
    'video/h263-2000': {
      source: 'iana',
    },
    'video/h264': {
      source: 'iana',
      extensions: ['h264'],
    },
    'video/h264-rcdo': {
      source: 'iana',
    },
    'video/h264-svc': {
      source: 'iana',
    },
    'video/h265': {
      source: 'iana',
    },
    'video/iso.segment': {
      source: 'iana',
      extensions: ['m4s'],
    },
    'video/jpeg': {
      source: 'iana',
      extensions: ['jpgv'],
    },
    'video/jpeg2000': {
      source: 'iana',
    },
    'video/jpm': {
      source: 'apache',
      extensions: ['jpm', 'jpgm'],
    },
    'video/mj2': {
      source: 'iana',
      extensions: ['mj2', 'mjp2'],
    },
    'video/mp1s': {
      source: 'iana',
    },
    'video/mp2p': {
      source: 'iana',
    },
    'video/mp2t': {
      source: 'iana',
      extensions: ['ts'],
    },
    'video/mp4': {
      source: 'iana',
      compressible: false,
      extensions: ['mp4', 'mp4v', 'mpg4'],
    },
    'video/mp4v-es': {
      source: 'iana',
    },
    'video/mpeg': {
      source: 'iana',
      compressible: false,
      extensions: ['mpeg', 'mpg', 'mpe', 'm1v', 'm2v'],
    },
    'video/mpeg4-generic': {
      source: 'iana',
    },
    'video/mpv': {
      source: 'iana',
    },
    'video/nv': {
      source: 'iana',
    },
    'video/ogg': {
      source: 'iana',
      compressible: false,
      extensions: ['ogv'],
    },
    'video/parityfec': {
      source: 'iana',
    },
    'video/pointer': {
      source: 'iana',
    },
    'video/quicktime': {
      source: 'iana',
      compressible: false,
      extensions: ['qt', 'mov'],
    },
    'video/raptorfec': {
      source: 'iana',
    },
    'video/raw': {
      source: 'iana',
    },
    'video/rtp-enc-aescm128': {
      source: 'iana',
    },
    'video/rtploopback': {
      source: 'iana',
    },
    'video/rtx': {
      source: 'iana',
    },
    'video/scip': {
      source: 'iana',
    },
    'video/smpte291': {
      source: 'iana',
    },
    'video/smpte292m': {
      source: 'iana',
    },
    'video/ulpfec': {
      source: 'iana',
    },
    'video/vc1': {
      source: 'iana',
    },
    'video/vc2': {
      source: 'iana',
    },
    'video/vnd.cctv': {
      source: 'iana',
    },
    'video/vnd.dece.hd': {
      source: 'iana',
      extensions: ['uvh', 'uvvh'],
    },
    'video/vnd.dece.mobile': {
      source: 'iana',
      extensions: ['uvm', 'uvvm'],
    },
    'video/vnd.dece.mp4': {
      source: 'iana',
    },
    'video/vnd.dece.pd': {
      source: 'iana',
      extensions: ['uvp', 'uvvp'],
    },
    'video/vnd.dece.sd': {
      source: 'iana',
      extensions: ['uvs', 'uvvs'],
    },
    'video/vnd.dece.video': {
      source: 'iana',
      extensions: ['uvv', 'uvvv'],
    },
    'video/vnd.directv.mpeg': {
      source: 'iana',
    },
    'video/vnd.directv.mpeg-tts': {
      source: 'iana',
    },
    'video/vnd.dlna.mpeg-tts': {
      source: 'iana',
    },
    'video/vnd.dvb.file': {
      source: 'iana',
      extensions: ['dvb'],
    },
    'video/vnd.fvt': {
      source: 'iana',
      extensions: ['fvt'],
    },
    'video/vnd.hns.video': {
      source: 'iana',
    },
    'video/vnd.iptvforum.1dparityfec-1010': {
      source: 'iana',
    },
    'video/vnd.iptvforum.1dparityfec-2005': {
      source: 'iana',
    },
    'video/vnd.iptvforum.2dparityfec-1010': {
      source: 'iana',
    },
    'video/vnd.iptvforum.2dparityfec-2005': {
      source: 'iana',
    },
    'video/vnd.iptvforum.ttsavc': {
      source: 'iana',
    },
    'video/vnd.iptvforum.ttsmpeg2': {
      source: 'iana',
    },
    'video/vnd.motorola.video': {
      source: 'iana',
    },
    'video/vnd.motorola.videop': {
      source: 'iana',
    },
    'video/vnd.mpegurl': {
      source: 'iana',
      extensions: ['mxu', 'm4u'],
    },
    'video/vnd.ms-playready.media.pyv': {
      source: 'iana',
      extensions: ['pyv'],
    },
    'video/vnd.nokia.interleaved-multimedia': {
      source: 'iana',
    },
    'video/vnd.nokia.mp4vr': {
      source: 'iana',
    },
    'video/vnd.nokia.videovoip': {
      source: 'iana',
    },
    'video/vnd.objectvideo': {
      source: 'iana',
    },
    'video/vnd.radgamettools.bink': {
      source: 'iana',
    },
    'video/vnd.radgamettools.smacker': {
      source: 'iana',
    },
    'video/vnd.sealed.mpeg1': {
      source: 'iana',
    },
    'video/vnd.sealed.mpeg4': {
      source: 'iana',
    },
    'video/vnd.sealed.swf': {
      source: 'iana',
    },
    'video/vnd.sealedmedia.softseal.mov': {
      source: 'iana',
    },
    'video/vnd.uvvu.mp4': {
      source: 'iana',
      extensions: ['uvu', 'uvvu'],
    },
    'video/vnd.vivo': {
      source: 'iana',
      extensions: ['viv'],
    },
    'video/vnd.youtube.yt': {
      source: 'iana',
    },
    'video/vp8': {
      source: 'iana',
    },
    'video/webm': {
      source: 'apache',
      compressible: false,
      extensions: ['webm'],
    },
    'video/x-f4v': {
      source: 'apache',
      extensions: ['f4v'],
    },
    'video/x-fli': {
      source: 'apache',
      extensions: ['fli'],
    },
    'video/x-flv': {
      source: 'apache',
      compressible: false,
      extensions: ['flv'],
    },
    'video/x-m4v': {
      source: 'apache',
      extensions: ['m4v'],
    },
    'video/x-matroska': {
      source: 'apache',
      compressible: false,
      extensions: ['mkv', 'mk3d', 'mks'],
    },
    'video/x-mng': {
      source: 'apache',
      extensions: ['mng'],
    },
    'video/x-ms-asf': {
      source: 'apache',
      extensions: ['asf', 'asx'],
    },
    'video/x-ms-vob': {
      source: 'apache',
      extensions: ['vob'],
    },
    'video/x-ms-wm': {
      source: 'apache',
      extensions: ['wm'],
    },
    'video/x-ms-wmv': {
      source: 'apache',
      compressible: false,
      extensions: ['wmv'],
    },
    'video/x-ms-wmx': {
      source: 'apache',
      extensions: ['wmx'],
    },
    'video/x-ms-wvx': {
      source: 'apache',
      extensions: ['wvx'],
    },
    'video/x-msvideo': {
      source: 'apache',
      extensions: ['avi'],
    },
    'video/x-sgi-movie': {
      source: 'apache',
      extensions: ['movie'],
    },
    'video/x-smv': {
      source: 'apache',
      extensions: ['smv'],
    },
    'x-conference/x-cooltalk': {
      source: 'apache',
      extensions: ['ice'],
    },
    'x-shader/x-fragment': {
      compressible: true,
    },
    'x-shader/x-vertex': {
      compressible: true,
    },
  };
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS((exports2, module2) => {
  /*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * MIT Licensed
   */
  module2.exports = require_db();
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS((exports2) => {
  /*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  'use strict';
  var db2 = require_mime_db();
  var extname = require('path').extname;
  var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
  var TEXT_TYPE_REGEXP = /^text\//i;
  exports2.charset = charset;
  exports2.charsets = { lookup: charset };
  exports2.contentType = contentType;
  exports2.extension = extension;
  exports2.extensions = Object.create(null);
  exports2.lookup = lookup;
  exports2.types = Object.create(null);
  populateMaps(exports2.extensions, exports2.types);
  function charset(type) {
    if (!type || typeof type !== 'string') {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var mime = match && db2[match[1].toLowerCase()];
    if (mime && mime.charset) {
      return mime.charset;
    }
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
      return 'UTF-8';
    }
    return false;
  }
  function contentType(str) {
    if (!str || typeof str !== 'string') {
      return false;
    }
    var mime = str.indexOf('/') === -1 ? exports2.lookup(str) : str;
    if (!mime) {
      return false;
    }
    if (mime.indexOf('charset') === -1) {
      var charset2 = exports2.charset(mime);
      if (charset2) mime += '; charset=' + charset2.toLowerCase();
    }
    return mime;
  }
  function extension(type) {
    if (!type || typeof type !== 'string') {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var exts = match && exports2.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
      return false;
    }
    return exts[0];
  }
  function lookup(path) {
    if (!path || typeof path !== 'string') {
      return false;
    }
    var extension2 = extname('x.' + path)
      .toLowerCase()
      .substr(1);
    if (!extension2) {
      return false;
    }
    return exports2.types[extension2] || false;
  }
  function populateMaps(extensions, types) {
    var preference = ['nginx', 'apache', void 0, 'iana'];
    Object.keys(db2).forEach(function forEachMimeType(type) {
      var mime = db2[type];
      var exts = mime.extensions;
      if (!exts || !exts.length) {
        return;
      }
      extensions[type] = exts;
      for (var i = 0; i < exts.length; i++) {
        var extension2 = exts[i];
        if (types[extension2]) {
          var from = preference.indexOf(db2[types[extension2]].source);
          var to = preference.indexOf(mime.source);
          if (
            types[extension2] !== 'application/octet-stream' &&
            (from > to ||
              (from === to &&
                types[extension2].substr(0, 12) === 'application/'))
          ) {
            continue;
          }
        }
        types[extension2] = type;
      }
    });
  }
});

// node_modules/caseless/index.js
var require_caseless = __commonJS((exports2, module2) => {
  function Caseless(dict) {
    this.dict = dict || {};
  }
  Caseless.prototype.set = function (name, value, clobber) {
    if (typeof name === 'object') {
      for (var i in name) {
        this.set(i, name[i], value);
      }
    } else {
      if (typeof clobber === 'undefined') clobber = true;
      var has = this.has(name);
      if (!clobber && has) this.dict[has] = this.dict[has] + ',' + value;
      else this.dict[has || name] = value;
      return has;
    }
  };
  Caseless.prototype.has = function (name) {
    var keys = Object.keys(this.dict),
      name = name.toLowerCase();
    for (var i = 0; i < keys.length; i++) {
      if (keys[i].toLowerCase() === name) return keys[i];
    }
    return false;
  };
  Caseless.prototype.get = function (name) {
    name = name.toLowerCase();
    var result, _key;
    var headers = this.dict;
    Object.keys(headers).forEach(function (key) {
      _key = key.toLowerCase();
      if (name === _key) result = headers[key];
    });
    return result;
  };
  Caseless.prototype.swap = function (name) {
    var has = this.has(name);
    if (has === name) return;
    if (!has) throw new Error('There is no header than matches "' + name + '"');
    this.dict[name] = this.dict[has];
    delete this.dict[has];
  };
  Caseless.prototype.del = function (name) {
    var has = this.has(name);
    return delete this.dict[has || name];
  };
  module2.exports = function (dict) {
    return new Caseless(dict);
  };
  module2.exports.httpify = function (resp, headers) {
    var c = new Caseless(headers);
    resp.setHeader = function (key, value, clobber) {
      if (typeof value === 'undefined') return;
      return c.set(key, value, clobber);
    };
    resp.hasHeader = function (key) {
      return c.has(key);
    };
    resp.getHeader = function (key) {
      return c.get(key);
    };
    resp.removeHeader = function (key) {
      return c.del(key);
    };
    resp.headers = c.dict;
    return c;
  };
});

// node_modules/forever-agent/index.js
var require_forever_agent = __commonJS((exports2, module2) => {
  module2.exports = ForeverAgent;
  ForeverAgent.SSL = ForeverAgentSSL;
  var util = require('util');
  var Agent = require('http').Agent;
  var net = require('net');
  var tls = require('tls');
  var AgentSSL = require('https').Agent;
  function getConnectionName(host, port) {
    var name = '';
    if (typeof host === 'string') {
      name = host + ':' + port;
    } else {
      name =
        host.host +
        ':' +
        host.port +
        ':' +
        (host.localAddress ? host.localAddress + ':' : ':');
    }
    return name;
  }
  function ForeverAgent(options) {
    var self2 = this;
    self2.options = options || {};
    self2.requests = {};
    self2.sockets = {};
    self2.freeSockets = {};
    self2.maxSockets = self2.options.maxSockets || Agent.defaultMaxSockets;
    self2.minSockets =
      self2.options.minSockets || ForeverAgent.defaultMinSockets;
    self2.on('free', function (socket, host, port) {
      var name = getConnectionName(host, port);
      if (self2.requests[name] && self2.requests[name].length) {
        self2.requests[name].shift().onSocket(socket);
      } else if (self2.sockets[name].length < self2.minSockets) {
        if (!self2.freeSockets[name]) self2.freeSockets[name] = [];
        self2.freeSockets[name].push(socket);
        var onIdleError = function () {
          socket.destroy();
        };
        socket._onIdleError = onIdleError;
        socket.on('error', onIdleError);
      } else {
        socket.destroy();
      }
    });
  }
  util.inherits(ForeverAgent, Agent);
  ForeverAgent.defaultMinSockets = 5;
  ForeverAgent.prototype.createConnection = net.createConnection;
  ForeverAgent.prototype.addRequestNoreuse = Agent.prototype.addRequest;
  ForeverAgent.prototype.addRequest = function (req, host, port) {
    var name = getConnectionName(host, port);
    if (typeof host !== 'string') {
      var options = host;
      port = options.port;
      host = options.host;
    }
    if (
      this.freeSockets[name] &&
      this.freeSockets[name].length > 0 &&
      !req.useChunkedEncodingByDefault
    ) {
      var idleSocket = this.freeSockets[name].pop();
      idleSocket.removeListener('error', idleSocket._onIdleError);
      delete idleSocket._onIdleError;
      req._reusedSocket = true;
      req.onSocket(idleSocket);
    } else {
      this.addRequestNoreuse(req, host, port);
    }
  };
  ForeverAgent.prototype.removeSocket = function (s, name, host, port) {
    if (this.sockets[name]) {
      var index = this.sockets[name].indexOf(s);
      if (index !== -1) {
        this.sockets[name].splice(index, 1);
      }
    } else if (this.sockets[name] && this.sockets[name].length === 0) {
      delete this.sockets[name];
      delete this.requests[name];
    }
    if (this.freeSockets[name]) {
      var index = this.freeSockets[name].indexOf(s);
      if (index !== -1) {
        this.freeSockets[name].splice(index, 1);
        if (this.freeSockets[name].length === 0) {
          delete this.freeSockets[name];
        }
      }
    }
    if (this.requests[name] && this.requests[name].length) {
      this.createSocket(name, host, port).emit('free');
    }
  };
  function ForeverAgentSSL(options) {
    ForeverAgent.call(this, options);
  }
  util.inherits(ForeverAgentSSL, ForeverAgent);
  ForeverAgentSSL.prototype.createConnection = createConnectionSSL;
  ForeverAgentSSL.prototype.addRequestNoreuse = AgentSSL.prototype.addRequest;
  function createConnectionSSL(port, host, options) {
    if (typeof port === 'object') {
      options = port;
    } else if (typeof host === 'object') {
      options = host;
    } else if (typeof options === 'object') {
      options = options;
    } else {
      options = {};
    }
    if (typeof port === 'number') {
      options.port = port;
    }
    if (typeof host === 'string') {
      options.host = host;
    }
    return tls.connect(options);
  }
});

// node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS((exports2, module2) => {
  var Stream = require('stream').Stream;
  var util = require('util');
  module2.exports = DelayedStream;
  function DelayedStream() {
    this.source = null;
    this.dataSize = 0;
    this.maxDataSize = 1024 * 1024;
    this.pauseStream = true;
    this._maxDataSizeExceeded = false;
    this._released = false;
    this._bufferedEvents = [];
  }
  util.inherits(DelayedStream, Stream);
  DelayedStream.create = function (source, options) {
    var delayedStream = new this();
    options = options || {};
    for (var option in options) {
      delayedStream[option] = options[option];
    }
    delayedStream.source = source;
    var realEmit = source.emit;
    source.emit = function () {
      delayedStream._handleEmit(arguments);
      return realEmit.apply(source, arguments);
    };
    source.on('error', function () {});
    if (delayedStream.pauseStream) {
      source.pause();
    }
    return delayedStream;
  };
  Object.defineProperty(DelayedStream.prototype, 'readable', {
    configurable: true,
    enumerable: true,
    get: function () {
      return this.source.readable;
    },
  });
  DelayedStream.prototype.setEncoding = function () {
    return this.source.setEncoding.apply(this.source, arguments);
  };
  DelayedStream.prototype.resume = function () {
    if (!this._released) {
      this.release();
    }
    this.source.resume();
  };
  DelayedStream.prototype.pause = function () {
    this.source.pause();
  };
  DelayedStream.prototype.release = function () {
    this._released = true;
    this._bufferedEvents.forEach(
      function (args) {
        this.emit.apply(this, args);
      }.bind(this),
    );
    this._bufferedEvents = [];
  };
  DelayedStream.prototype.pipe = function () {
    var r = Stream.prototype.pipe.apply(this, arguments);
    this.resume();
    return r;
  };
  DelayedStream.prototype._handleEmit = function (args) {
    if (this._released) {
      this.emit.apply(this, args);
      return;
    }
    if (args[0] === 'data') {
      this.dataSize += args[1].length;
      this._checkIfMaxDataSizeExceeded();
    }
    this._bufferedEvents.push(args);
  };
  DelayedStream.prototype._checkIfMaxDataSizeExceeded = function () {
    if (this._maxDataSizeExceeded) {
      return;
    }
    if (this.dataSize <= this.maxDataSize) {
      return;
    }
    this._maxDataSizeExceeded = true;
    var message =
      'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
    this.emit('error', new Error(message));
  };
});

// node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS((exports2, module2) => {
  var util = require('util');
  var Stream = require('stream').Stream;
  var DelayedStream = require_delayed_stream();
  module2.exports = CombinedStream;
  function CombinedStream() {
    this.writable = false;
    this.readable = true;
    this.dataSize = 0;
    this.maxDataSize = 2 * 1024 * 1024;
    this.pauseStreams = true;
    this._released = false;
    this._streams = [];
    this._currentStream = null;
    this._insideLoop = false;
    this._pendingNext = false;
  }
  util.inherits(CombinedStream, Stream);
  CombinedStream.create = function (options) {
    var combinedStream = new this();
    options = options || {};
    for (var option in options) {
      combinedStream[option] = options[option];
    }
    return combinedStream;
  };
  CombinedStream.isStreamLike = function (stream) {
    return (
      typeof stream !== 'function' &&
      typeof stream !== 'string' &&
      typeof stream !== 'boolean' &&
      typeof stream !== 'number' &&
      !Buffer.isBuffer(stream)
    );
  };
  CombinedStream.prototype.append = function (stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      if (!(stream instanceof DelayedStream)) {
        var newStream = DelayedStream.create(stream, {
          maxDataSize: Infinity,
          pauseStream: this.pauseStreams,
        });
        stream.on('data', this._checkDataSize.bind(this));
        stream = newStream;
      }
      this._handleErrors(stream);
      if (this.pauseStreams) {
        stream.pause();
      }
    }
    this._streams.push(stream);
    return this;
  };
  CombinedStream.prototype.pipe = function (dest, options) {
    Stream.prototype.pipe.call(this, dest, options);
    this.resume();
    return dest;
  };
  CombinedStream.prototype._getNext = function () {
    this._currentStream = null;
    if (this._insideLoop) {
      this._pendingNext = true;
      return;
    }
    this._insideLoop = true;
    try {
      do {
        this._pendingNext = false;
        this._realGetNext();
      } while (this._pendingNext);
    } finally {
      this._insideLoop = false;
    }
  };
  CombinedStream.prototype._realGetNext = function () {
    var stream = this._streams.shift();
    if (typeof stream == 'undefined') {
      this.end();
      return;
    }
    if (typeof stream !== 'function') {
      this._pipeNext(stream);
      return;
    }
    var getStream = stream;
    getStream(
      function (stream2) {
        var isStreamLike = CombinedStream.isStreamLike(stream2);
        if (isStreamLike) {
          stream2.on('data', this._checkDataSize.bind(this));
          this._handleErrors(stream2);
        }
        this._pipeNext(stream2);
      }.bind(this),
    );
  };
  CombinedStream.prototype._pipeNext = function (stream) {
    this._currentStream = stream;
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on('end', this._getNext.bind(this));
      stream.pipe(this, { end: false });
      return;
    }
    var value = stream;
    this.write(value);
    this._getNext();
  };
  CombinedStream.prototype._handleErrors = function (stream) {
    var self2 = this;
    stream.on('error', function (err) {
      self2._emitError(err);
    });
  };
  CombinedStream.prototype.write = function (data) {
    this.emit('data', data);
  };
  CombinedStream.prototype.pause = function () {
    if (!this.pauseStreams) {
      return;
    }
    if (
      this.pauseStreams &&
      this._currentStream &&
      typeof this._currentStream.pause == 'function'
    )
      this._currentStream.pause();
    this.emit('pause');
  };
  CombinedStream.prototype.resume = function () {
    if (!this._released) {
      this._released = true;
      this.writable = true;
      this._getNext();
    }
    if (
      this.pauseStreams &&
      this._currentStream &&
      typeof this._currentStream.resume == 'function'
    )
      this._currentStream.resume();
    this.emit('resume');
  };
  CombinedStream.prototype.end = function () {
    this._reset();
    this.emit('end');
  };
  CombinedStream.prototype.destroy = function () {
    this._reset();
    this.emit('close');
  };
  CombinedStream.prototype._reset = function () {
    this.writable = false;
    this._streams = [];
    this._currentStream = null;
  };
  CombinedStream.prototype._checkDataSize = function () {
    this._updateDataSize();
    if (this.dataSize <= this.maxDataSize) {
      return;
    }
    var message =
      'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
    this._emitError(new Error(message));
  };
  CombinedStream.prototype._updateDataSize = function () {
    this.dataSize = 0;
    var self2 = this;
    this._streams.forEach(function (stream) {
      if (!stream.dataSize) {
        return;
      }
      self2.dataSize += stream.dataSize;
    });
    if (this._currentStream && this._currentStream.dataSize) {
      this.dataSize += this._currentStream.dataSize;
    }
  };
  CombinedStream.prototype._emitError = function (err) {
    this._reset();
    this.emit('error', err);
  };
});

// node_modules/asynckit/lib/defer.js
var require_defer = __commonJS((exports2, module2) => {
  module2.exports = defer;
  function defer(fn) {
    var nextTick =
      typeof setImmediate == 'function'
        ? setImmediate
        : typeof process == 'object' && typeof process.nextTick == 'function'
        ? process.nextTick
        : null;
    if (nextTick) {
      nextTick(fn);
    } else {
      setTimeout(fn, 0);
    }
  }
});

// node_modules/asynckit/lib/async.js
var require_async = __commonJS((exports2, module2) => {
  var defer = require_defer();
  module2.exports = async;
  function async(callback) {
    var isAsync = false;
    defer(function () {
      isAsync = true;
    });
    return function async_callback(err, result) {
      if (isAsync) {
        callback(err, result);
      } else {
        defer(function nextTick_callback() {
          callback(err, result);
        });
      }
    };
  }
});

// node_modules/asynckit/lib/abort.js
var require_abort = __commonJS((exports2, module2) => {
  module2.exports = abort;
  function abort(state) {
    Object.keys(state.jobs).forEach(clean.bind(state));
    state.jobs = {};
  }
  function clean(key) {
    if (typeof this.jobs[key] == 'function') {
      this.jobs[key]();
    }
  }
});

// node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS((exports2, module2) => {
  var async = require_async();
  var abort = require_abort();
  module2.exports = iterate;
  function iterate(list, iterator, state, callback) {
    var key = state['keyedList']
      ? state['keyedList'][state.index]
      : state.index;
    state.jobs[key] = runJob(
      iterator,
      key,
      list[key],
      function (error, output) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error) {
          abort(state);
        } else {
          state.results[key] = output;
        }
        callback(error, state.results);
      },
    );
  }
  function runJob(iterator, key, item, callback) {
    var aborter;
    if (iterator.length == 2) {
      aborter = iterator(item, async(callback));
    } else {
      aborter = iterator(item, key, async(callback));
    }
    return aborter;
  }
});

// node_modules/asynckit/lib/state.js
var require_state = __commonJS((exports2, module2) => {
  module2.exports = state;
  function state(list, sortMethod) {
    var isNamedList = !Array.isArray(list),
      initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length,
      };
    if (sortMethod) {
      initState.keyedList.sort(
        isNamedList
          ? sortMethod
          : function (a, b) {
              return sortMethod(list[a], list[b]);
            },
      );
    }
    return initState;
  }
});

// node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS((exports2, module2) => {
  var abort = require_abort();
  var async = require_async();
  module2.exports = terminator;
  function terminator(callback) {
    if (!Object.keys(this.jobs).length) {
      return;
    }
    this.index = this.size;
    abort(this);
    async(callback)(null, this.results);
  }
});

// node_modules/asynckit/parallel.js
var require_parallel = __commonJS((exports2, module2) => {
  var iterate = require_iterate();
  var initState = require_state();
  var terminator = require_terminator();
  module2.exports = parallel;
  function parallel(list, iterator, callback) {
    var state = initState(list);
    while (state.index < (state['keyedList'] || list).length) {
      iterate(list, iterator, state, function (error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        if (Object.keys(state.jobs).length === 0) {
          callback(null, state.results);
          return;
        }
      });
      state.index++;
    }
    return terminator.bind(state, callback);
  }
});

// node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS((exports2, module2) => {
  var iterate = require_iterate();
  var initState = require_state();
  var terminator = require_terminator();
  module2.exports = serialOrdered;
  module2.exports.ascending = ascending;
  module2.exports.descending = descending;
  function serialOrdered(list, iterator, sortMethod, callback) {
    var state = initState(list, sortMethod);
    iterate(list, iterator, state, function iteratorHandler(error, result) {
      if (error) {
        callback(error, result);
        return;
      }
      state.index++;
      if (state.index < (state['keyedList'] || list).length) {
        iterate(list, iterator, state, iteratorHandler);
        return;
      }
      callback(null, state.results);
    });
    return terminator.bind(state, callback);
  }
  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }
  function descending(a, b) {
    return -1 * ascending(a, b);
  }
});

// node_modules/asynckit/serial.js
var require_serial = __commonJS((exports2, module2) => {
  var serialOrdered = require_serialOrdered();
  module2.exports = serial;
  function serial(list, iterator, callback) {
    return serialOrdered(list, iterator, null, callback);
  }
});

// node_modules/asynckit/index.js
var require_asynckit = __commonJS((exports2, module2) => {
  module2.exports = {
    parallel: require_parallel(),
    serial: require_serial(),
    serialOrdered: require_serialOrdered(),
  };
});

// node_modules/form-data/lib/populate.js
var require_populate = __commonJS((exports2, module2) => {
  module2.exports = function (dst, src) {
    Object.keys(src).forEach(function (prop) {
      dst[prop] = dst[prop] || src[prop];
    });
    return dst;
  };
});

// node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS((exports2, module2) => {
  var CombinedStream = require_combined_stream();
  var util = require('util');
  var path = require('path');
  var http = require('http');
  var https = require('https');
  var parseUrl = require('url').parse;
  var fs = require('fs');
  var mime = require_mime_types();
  var asynckit = require_asynckit();
  var populate = require_populate();
  module2.exports = FormData;
  util.inherits(FormData, CombinedStream);
  function FormData(options) {
    if (!(this instanceof FormData)) {
      return new FormData();
    }
    this._overheadLength = 0;
    this._valueLength = 0;
    this._valuesToMeasure = [];
    CombinedStream.call(this);
    options = options || {};
    for (var option in options) {
      this[option] = options[option];
    }
  }
  FormData.LINE_BREAK = '\r\n';
  FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';
  FormData.prototype.append = function (field, value, options) {
    options = options || {};
    if (typeof options == 'string') {
      options = { filename: options };
    }
    var append = CombinedStream.prototype.append.bind(this);
    if (typeof value == 'number') {
      value = '' + value;
    }
    if (util.isArray(value)) {
      this._error(new Error('Arrays are not supported.'));
      return;
    }
    var header = this._multiPartHeader(field, value, options);
    var footer = this._multiPartFooter();
    append(header);
    append(value);
    append(footer);
    this._trackLength(header, value, options);
  };
  FormData.prototype._trackLength = function (header, value, options) {
    var valueLength = 0;
    if (options.knownLength != null) {
      valueLength += +options.knownLength;
    } else if (Buffer.isBuffer(value)) {
      valueLength = value.length;
    } else if (typeof value === 'string') {
      valueLength = Buffer.byteLength(value);
    }
    this._valueLength += valueLength;
    this._overheadLength +=
      Buffer.byteLength(header) + FormData.LINE_BREAK.length;
    if (
      !value ||
      (!value.path && !(value.readable && value.hasOwnProperty('httpVersion')))
    ) {
      return;
    }
    if (!options.knownLength) {
      this._valuesToMeasure.push(value);
    }
  };
  FormData.prototype._lengthRetriever = function (value, callback) {
    if (value.hasOwnProperty('fd')) {
      if (
        value.end != void 0 &&
        value.end != Infinity &&
        value.start != void 0
      ) {
        callback(null, value.end + 1 - (value.start ? value.start : 0));
      } else {
        fs.stat(value.path, function (err, stat) {
          var fileSize;
          if (err) {
            callback(err);
            return;
          }
          fileSize = stat.size - (value.start ? value.start : 0);
          callback(null, fileSize);
        });
      }
    } else if (value.hasOwnProperty('httpVersion')) {
      callback(null, +value.headers['content-length']);
    } else if (value.hasOwnProperty('httpModule')) {
      value.on('response', function (response) {
        value.pause();
        callback(null, +response.headers['content-length']);
      });
      value.resume();
    } else {
      callback('Unknown stream');
    }
  };
  FormData.prototype._multiPartHeader = function (field, value, options) {
    if (typeof options.header == 'string') {
      return options.header;
    }
    var contentDisposition = this._getContentDisposition(value, options);
    var contentType = this._getContentType(value, options);
    var contents = '';
    var headers = {
      'Content-Disposition': ['form-data', 'name="' + field + '"'].concat(
        contentDisposition || [],
      ),
      'Content-Type': [].concat(contentType || []),
    };
    if (typeof options.header == 'object') {
      populate(headers, options.header);
    }
    var header;
    for (var prop in headers) {
      if (!headers.hasOwnProperty(prop)) continue;
      header = headers[prop];
      if (header == null) {
        continue;
      }
      if (!Array.isArray(header)) {
        header = [header];
      }
      if (header.length) {
        contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
      }
    }
    return (
      '--' +
      this.getBoundary() +
      FormData.LINE_BREAK +
      contents +
      FormData.LINE_BREAK
    );
  };
  FormData.prototype._getContentDisposition = function (value, options) {
    var filename, contentDisposition;
    if (typeof options.filepath === 'string') {
      filename = path.normalize(options.filepath).replace(/\\/g, '/');
    } else if (options.filename || value.name || value.path) {
      filename = path.basename(options.filename || value.name || value.path);
    } else if (value.readable && value.hasOwnProperty('httpVersion')) {
      filename = path.basename(value.client._httpMessage.path);
    }
    if (filename) {
      contentDisposition = 'filename="' + filename + '"';
    }
    return contentDisposition;
  };
  FormData.prototype._getContentType = function (value, options) {
    var contentType = options.contentType;
    if (!contentType && value.name) {
      contentType = mime.lookup(value.name);
    }
    if (!contentType && value.path) {
      contentType = mime.lookup(value.path);
    }
    if (!contentType && value.readable && value.hasOwnProperty('httpVersion')) {
      contentType = value.headers['content-type'];
    }
    if (!contentType && (options.filepath || options.filename)) {
      contentType = mime.lookup(options.filepath || options.filename);
    }
    if (!contentType && typeof value == 'object') {
      contentType = FormData.DEFAULT_CONTENT_TYPE;
    }
    return contentType;
  };
  FormData.prototype._multiPartFooter = function () {
    return function (next) {
      var footer = FormData.LINE_BREAK;
      var lastPart = this._streams.length === 0;
      if (lastPart) {
        footer += this._lastBoundary();
      }
      next(footer);
    }.bind(this);
  };
  FormData.prototype._lastBoundary = function () {
    return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
  };
  FormData.prototype.getHeaders = function (userHeaders) {
    var header;
    var formHeaders = {
      'content-type': 'multipart/form-data; boundary=' + this.getBoundary(),
    };
    for (header in userHeaders) {
      if (userHeaders.hasOwnProperty(header)) {
        formHeaders[header.toLowerCase()] = userHeaders[header];
      }
    }
    return formHeaders;
  };
  FormData.prototype.getBoundary = function () {
    if (!this._boundary) {
      this._generateBoundary();
    }
    return this._boundary;
  };
  FormData.prototype._generateBoundary = function () {
    var boundary = '--------------------------';
    for (var i = 0; i < 24; i++) {
      boundary += Math.floor(Math.random() * 10).toString(16);
    }
    this._boundary = boundary;
  };
  FormData.prototype.getLengthSync = function () {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
      knownLength += this._lastBoundary().length;
    }
    if (!this.hasKnownLength()) {
      this._error(
        new Error('Cannot calculate proper length in synchronous way.'),
      );
    }
    return knownLength;
  };
  FormData.prototype.hasKnownLength = function () {
    var hasKnownLength = true;
    if (this._valuesToMeasure.length) {
      hasKnownLength = false;
    }
    return hasKnownLength;
  };
  FormData.prototype.getLength = function (cb) {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
      knownLength += this._lastBoundary().length;
    }
    if (!this._valuesToMeasure.length) {
      process.nextTick(cb.bind(this, null, knownLength));
      return;
    }
    asynckit.parallel(
      this._valuesToMeasure,
      this._lengthRetriever,
      function (err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function (length) {
          knownLength += length;
        });
        cb(null, knownLength);
      },
    );
  };
  FormData.prototype.submit = function (params, cb) {
    var request,
      options,
      defaults = { method: 'post' };
    if (typeof params == 'string') {
      params = parseUrl(params);
      options = populate(
        {
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol,
        },
        defaults,
      );
    } else {
      options = populate(params, defaults);
      if (!options.port) {
        options.port = options.protocol == 'https:' ? 443 : 80;
      }
    }
    options.headers = this.getHeaders(params.headers);
    if (options.protocol == 'https:') {
      request = https.request(options);
    } else {
      request = http.request(options);
    }
    this.getLength(
      function (err, length) {
        if (err) {
          this._error(err);
          return;
        }
        request.setHeader('Content-Length', length);
        this.pipe(request);
        if (cb) {
          request.on('error', cb);
          request.on('response', cb.bind(this, null));
        }
      }.bind(this),
    );
    return request;
  };
  FormData.prototype._error = function (err) {
    if (!this.error) {
      this.error = err;
      this.pause();
      this.emit('error', err);
    }
  };
  FormData.prototype.toString = function () {
    return '[object FormData]';
  };
});

// node_modules/isstream/isstream.js
var require_isstream = __commonJS((exports2, module2) => {
  var stream = require('stream');
  function isStream(obj) {
    return obj instanceof stream.Stream;
  }
  function isReadable(obj) {
    return (
      isStream(obj) &&
      typeof obj._read == 'function' &&
      typeof obj._readableState == 'object'
    );
  }
  function isWritable(obj) {
    return (
      isStream(obj) &&
      typeof obj._write == 'function' &&
      typeof obj._writableState == 'object'
    );
  }
  function isDuplex(obj) {
    return isReadable(obj) && isWritable(obj);
  }
  module2.exports = isStream;
  module2.exports.isReadable = isReadable;
  module2.exports.isWritable = isWritable;
  module2.exports.isDuplex = isDuplex;
});

// node_modules/is-typedarray/index.js
var require_is_typedarray = __commonJS((exports2, module2) => {
  module2.exports = isTypedArray;
  isTypedArray.strict = isStrictTypedArray;
  isTypedArray.loose = isLooseTypedArray;
  var toString = Object.prototype.toString;
  var names = {
    '[object Int8Array]': true,
    '[object Int16Array]': true,
    '[object Int32Array]': true,
    '[object Uint8Array]': true,
    '[object Uint8ClampedArray]': true,
    '[object Uint16Array]': true,
    '[object Uint32Array]': true,
    '[object Float32Array]': true,
    '[object Float64Array]': true,
  };
  function isTypedArray(arr) {
    return isStrictTypedArray(arr) || isLooseTypedArray(arr);
  }
  function isStrictTypedArray(arr) {
    return (
      arr instanceof Int8Array ||
      arr instanceof Int16Array ||
      arr instanceof Int32Array ||
      arr instanceof Uint8Array ||
      arr instanceof Uint8ClampedArray ||
      arr instanceof Uint16Array ||
      arr instanceof Uint32Array ||
      arr instanceof Float32Array ||
      arr instanceof Float64Array
    );
  }
  function isLooseTypedArray(arr) {
    return names[toString.call(arr)];
  }
});

// node_modules/request/lib/getProxyFromURI.js
var require_getProxyFromURI = __commonJS((exports2, module2) => {
  'use strict';
  function formatHostname(hostname) {
    return hostname.replace(/^\.*/, '.').toLowerCase();
  }
  function parseNoProxyZone(zone) {
    zone = zone.trim().toLowerCase();
    var zoneParts = zone.split(':', 2);
    var zoneHost = formatHostname(zoneParts[0]);
    var zonePort = zoneParts[1];
    var hasPort = zone.indexOf(':') > -1;
    return { hostname: zoneHost, port: zonePort, hasPort };
  }
  function uriInNoProxy(uri, noProxy) {
    var port = uri.port || (uri.protocol === 'https:' ? '443' : '80');
    var hostname = formatHostname(uri.hostname);
    var noProxyList = noProxy.split(',');
    return noProxyList.map(parseNoProxyZone).some(function (noProxyZone) {
      var isMatchedAt = hostname.indexOf(noProxyZone.hostname);
      var hostnameMatched =
        isMatchedAt > -1 &&
        isMatchedAt === hostname.length - noProxyZone.hostname.length;
      if (noProxyZone.hasPort) {
        return port === noProxyZone.port && hostnameMatched;
      }
      return hostnameMatched;
    });
  }
  function getProxyFromURI(uri) {
    var noProxy = process.env.NO_PROXY || process.env.no_proxy || '';
    if (noProxy === '*') {
      return null;
    }
    if (noProxy !== '' && uriInNoProxy(uri, noProxy)) {
      return null;
    }
    if (uri.protocol === 'http:') {
      return process.env.HTTP_PROXY || process.env.http_proxy || null;
    }
    if (uri.protocol === 'https:') {
      return (
        process.env.HTTPS_PROXY ||
        process.env.https_proxy ||
        process.env.HTTP_PROXY ||
        process.env.http_proxy ||
        null
      );
    }
    return null;
  }
  module2.exports = getProxyFromURI;
});

// node_modules/request/node_modules/qs/lib/utils.js
var require_utils6 = __commonJS((exports2, module2) => {
  'use strict';
  var has = Object.prototype.hasOwnProperty;
  var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
      array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }
    return array;
  })();
  var compactQueue = function compactQueue2(queue) {
    var obj;
    while (queue.length) {
      var item = queue.pop();
      obj = item.obj[item.prop];
      if (Array.isArray(obj)) {
        var compacted = [];
        for (var j = 0; j < obj.length; ++j) {
          if (typeof obj[j] !== 'undefined') {
            compacted.push(obj[j]);
          }
        }
        item.obj[item.prop] = compacted;
      }
    }
    return obj;
  };
  var arrayToObject = function arrayToObject2(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
      if (typeof source[i] !== 'undefined') {
        obj[i] = source[i];
      }
    }
    return obj;
  };
  var merge = function merge2(target, source, options) {
    if (!source) {
      return target;
    }
    if (typeof source !== 'object') {
      if (Array.isArray(target)) {
        target.push(source);
      } else if (typeof target === 'object') {
        if (
          options.plainObjects ||
          options.allowPrototypes ||
          !has.call(Object.prototype, source)
        ) {
          target[source] = true;
        }
      } else {
        return [target, source];
      }
      return target;
    }
    if (typeof target !== 'object') {
      return [target].concat(source);
    }
    var mergeTarget = target;
    if (Array.isArray(target) && !Array.isArray(source)) {
      mergeTarget = arrayToObject(target, options);
    }
    if (Array.isArray(target) && Array.isArray(source)) {
      source.forEach(function (item, i) {
        if (has.call(target, i)) {
          if (target[i] && typeof target[i] === 'object') {
            target[i] = merge2(target[i], item, options);
          } else {
            target.push(item);
          }
        } else {
          target[i] = item;
        }
      });
      return target;
    }
    return Object.keys(source).reduce(function (acc, key) {
      var value = source[key];
      if (has.call(acc, key)) {
        acc[key] = merge2(acc[key], value, options);
      } else {
        acc[key] = value;
      }
      return acc;
    }, mergeTarget);
  };
  var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
      acc[key] = source[key];
      return acc;
    }, target);
  };
  var decode = function (str) {
    try {
      return decodeURIComponent(str.replace(/\+/g, ' '));
    } catch (e) {
      return str;
    }
  };
  var encode = function encode2(str) {
    if (str.length === 0) {
      return str;
    }
    var string = typeof str === 'string' ? str : String(str);
    var out = '';
    for (var i = 0; i < string.length; ++i) {
      var c = string.charCodeAt(i);
      if (
        c === 45 ||
        c === 46 ||
        c === 95 ||
        c === 126 ||
        (c >= 48 && c <= 57) ||
        (c >= 65 && c <= 90) ||
        (c >= 97 && c <= 122)
      ) {
        out += string.charAt(i);
        continue;
      }
      if (c < 128) {
        out = out + hexTable[c];
        continue;
      }
      if (c < 2048) {
        out = out + (hexTable[192 | (c >> 6)] + hexTable[128 | (c & 63)]);
        continue;
      }
      if (c < 55296 || c >= 57344) {
        out =
          out +
          (hexTable[224 | (c >> 12)] +
            hexTable[128 | ((c >> 6) & 63)] +
            hexTable[128 | (c & 63)]);
        continue;
      }
      i += 1;
      c = 65536 + (((c & 1023) << 10) | (string.charCodeAt(i) & 1023));
      out +=
        hexTable[240 | (c >> 18)] +
        hexTable[128 | ((c >> 12) & 63)] +
        hexTable[128 | ((c >> 6) & 63)] +
        hexTable[128 | (c & 63)];
    }
    return out;
  };
  var compact = function compact2(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];
    for (var i = 0; i < queue.length; ++i) {
      var item = queue[i];
      var obj = item.obj[item.prop];
      var keys = Object.keys(obj);
      for (var j = 0; j < keys.length; ++j) {
        var key = keys[j];
        var val = obj[key];
        if (
          typeof val === 'object' &&
          val !== null &&
          refs.indexOf(val) === -1
        ) {
          queue.push({ obj, prop: key });
          refs.push(val);
        }
      }
    }
    return compactQueue(queue);
  };
  var isRegExp = function isRegExp2(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
  };
  var isBuffer = function isBuffer2(obj) {
    if (obj === null || typeof obj === 'undefined') {
      return false;
    }
    return !!(
      obj.constructor &&
      obj.constructor.isBuffer &&
      obj.constructor.isBuffer(obj)
    );
  };
  module2.exports = {
    arrayToObject,
    assign,
    compact,
    decode,
    encode,
    isBuffer,
    isRegExp,
    merge,
  };
});

// node_modules/request/node_modules/qs/lib/formats.js
var require_formats = __commonJS((exports2, module2) => {
  'use strict';
  var replace = String.prototype.replace;
  var percentTwenties = /%20/g;
  module2.exports = {
    default: 'RFC3986',
    formatters: {
      RFC1738: function (value) {
        return replace.call(value, percentTwenties, '+');
      },
      RFC3986: function (value) {
        return value;
      },
    },
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986',
  };
});

// node_modules/request/node_modules/qs/lib/stringify.js
var require_stringify2 = __commonJS((exports2, module2) => {
  'use strict';
  var utils = require_utils6();
  var formats = require_formats();
  var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
      return prefix + '[]';
    },
    indices: function indices(prefix, key) {
      return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
      return prefix;
    },
  };
  var toISO = Date.prototype.toISOString;
  var defaults = {
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    serializeDate: function serializeDate(date) {
      return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false,
  };
  var stringify = function stringify2(
    object,
    prefix,
    generateArrayPrefix,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    formatter,
    encodeValuesOnly,
  ) {
    var obj = object;
    if (typeof filter === 'function') {
      obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
      obj = serializeDate(obj);
    } else if (obj === null) {
      if (strictNullHandling) {
        return encoder && !encodeValuesOnly
          ? encoder(prefix, defaults.encoder)
          : prefix;
      }
      obj = '';
    }
    if (
      typeof obj === 'string' ||
      typeof obj === 'number' ||
      typeof obj === 'boolean' ||
      utils.isBuffer(obj)
    ) {
      if (encoder) {
        var keyValue = encodeValuesOnly
          ? prefix
          : encoder(prefix, defaults.encoder);
        return [
          formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder)),
        ];
      }
      return [formatter(prefix) + '=' + formatter(String(obj))];
    }
    var values = [];
    if (typeof obj === 'undefined') {
      return values;
    }
    var objKeys;
    if (Array.isArray(filter)) {
      objKeys = filter;
    } else {
      var keys = Object.keys(obj);
      objKeys = sort ? keys.sort(sort) : keys;
    }
    for (var i = 0; i < objKeys.length; ++i) {
      var key = objKeys[i];
      if (skipNulls && obj[key] === null) {
        continue;
      }
      if (Array.isArray(obj)) {
        values = values.concat(
          stringify2(
            obj[key],
            generateArrayPrefix(prefix, key),
            generateArrayPrefix,
            strictNullHandling,
            skipNulls,
            encoder,
            filter,
            sort,
            allowDots,
            serializeDate,
            formatter,
            encodeValuesOnly,
          ),
        );
      } else {
        values = values.concat(
          stringify2(
            obj[key],
            prefix + (allowDots ? '.' + key : '[' + key + ']'),
            generateArrayPrefix,
            strictNullHandling,
            skipNulls,
            encoder,
            filter,
            sort,
            allowDots,
            serializeDate,
            formatter,
            encodeValuesOnly,
          ),
        );
      }
    }
    return values;
  };
  module2.exports = function (object, opts) {
    var obj = object;
    var options = opts ? utils.assign({}, opts) : {};
    if (
      options.encoder !== null &&
      options.encoder !== void 0 &&
      typeof options.encoder !== 'function'
    ) {
      throw new TypeError('Encoder has to be a function.');
    }
    var delimiter =
      typeof options.delimiter === 'undefined'
        ? defaults.delimiter
        : options.delimiter;
    var strictNullHandling =
      typeof options.strictNullHandling === 'boolean'
        ? options.strictNullHandling
        : defaults.strictNullHandling;
    var skipNulls =
      typeof options.skipNulls === 'boolean'
        ? options.skipNulls
        : defaults.skipNulls;
    var encode =
      typeof options.encode === 'boolean' ? options.encode : defaults.encode;
    var encoder =
      typeof options.encoder === 'function'
        ? options.encoder
        : defaults.encoder;
    var sort = typeof options.sort === 'function' ? options.sort : null;
    var allowDots =
      typeof options.allowDots === 'undefined' ? false : options.allowDots;
    var serializeDate =
      typeof options.serializeDate === 'function'
        ? options.serializeDate
        : defaults.serializeDate;
    var encodeValuesOnly =
      typeof options.encodeValuesOnly === 'boolean'
        ? options.encodeValuesOnly
        : defaults.encodeValuesOnly;
    if (typeof options.format === 'undefined') {
      options.format = formats['default'];
    } else if (
      !Object.prototype.hasOwnProperty.call(formats.formatters, options.format)
    ) {
      throw new TypeError('Unknown format option provided.');
    }
    var formatter = formats.formatters[options.format];
    var objKeys;
    var filter;
    if (typeof options.filter === 'function') {
      filter = options.filter;
      obj = filter('', obj);
    } else if (Array.isArray(options.filter)) {
      filter = options.filter;
      objKeys = filter;
    }
    var keys = [];
    if (typeof obj !== 'object' || obj === null) {
      return '';
    }
    var arrayFormat;
    if (options.arrayFormat in arrayPrefixGenerators) {
      arrayFormat = options.arrayFormat;
    } else if ('indices' in options) {
      arrayFormat = options.indices ? 'indices' : 'repeat';
    } else {
      arrayFormat = 'indices';
    }
    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
    if (!objKeys) {
      objKeys = Object.keys(obj);
    }
    if (sort) {
      objKeys.sort(sort);
    }
    for (var i = 0; i < objKeys.length; ++i) {
      var key = objKeys[i];
      if (skipNulls && obj[key] === null) {
        continue;
      }
      keys = keys.concat(
        stringify(
          obj[key],
          key,
          generateArrayPrefix,
          strictNullHandling,
          skipNulls,
          encode ? encoder : null,
          filter,
          sort,
          allowDots,
          serializeDate,
          formatter,
          encodeValuesOnly,
        ),
      );
    }
    var joined = keys.join(delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';
    return joined.length > 0 ? prefix + joined : '';
  };
});

// node_modules/request/node_modules/qs/lib/parse.js
var require_parse = __commonJS((exports2, module2) => {
  'use strict';
  var utils = require_utils6();
  var has = Object.prototype.hasOwnProperty;
  var defaults = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    parameterLimit: 1e3,
    plainObjects: false,
    strictNullHandling: false,
  };
  var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit =
      options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    for (var i = 0; i < parts.length; ++i) {
      var part = parts[i];
      var bracketEqualsPos = part.indexOf(']=');
      var pos =
        bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;
      var key, val;
      if (pos === -1) {
        key = options.decoder(part, defaults.decoder);
        val = options.strictNullHandling ? null : '';
      } else {
        key = options.decoder(part.slice(0, pos), defaults.decoder);
        val = options.decoder(part.slice(pos + 1), defaults.decoder);
      }
      if (has.call(obj, key)) {
        obj[key] = [].concat(obj[key]).concat(val);
      } else {
        obj[key] = val;
      }
    }
    return obj;
  };
  var parseObject = function (chain, val, options) {
    var leaf = val;
    for (var i = chain.length - 1; i >= 0; --i) {
      var obj;
      var root = chain[i];
      if (root === '[]') {
        obj = [];
        obj = obj.concat(leaf);
      } else {
        obj = options.plainObjects ? Object.create(null) : {};
        var cleanRoot =
          root.charAt(0) === '[' && root.charAt(root.length - 1) === ']'
            ? root.slice(1, -1)
            : root;
        var index = parseInt(cleanRoot, 10);
        if (
          !isNaN(index) &&
          root !== cleanRoot &&
          String(index) === cleanRoot &&
          index >= 0 &&
          options.parseArrays &&
          index <= options.arrayLimit
        ) {
          obj = [];
          obj[index] = leaf;
        } else {
          obj[cleanRoot] = leaf;
        }
      }
      leaf = obj;
    }
    return leaf;
  };
  var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
    if (!givenKey) {
      return;
    }
    var key = options.allowDots
      ? givenKey.replace(/\.([^.[]+)/g, '[$1]')
      : givenKey;
    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;
    var segment = brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;
    var keys = [];
    if (parent) {
      if (!options.plainObjects && has.call(Object.prototype, parent)) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(parent);
    }
    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options.depth) {
      i += 1;
      if (
        !options.plainObjects &&
        has.call(Object.prototype, segment[1].slice(1, -1))
      ) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(segment[1]);
    }
    if (segment) {
      keys.push('[' + key.slice(segment.index) + ']');
    }
    return parseObject(keys, val, options);
  };
  module2.exports = function (str, opts) {
    var options = opts ? utils.assign({}, opts) : {};
    if (
      options.decoder !== null &&
      options.decoder !== void 0 &&
      typeof options.decoder !== 'function'
    ) {
      throw new TypeError('Decoder has to be a function.');
    }
    options.ignoreQueryPrefix = options.ignoreQueryPrefix === true;
    options.delimiter =
      typeof options.delimiter === 'string' || utils.isRegExp(options.delimiter)
        ? options.delimiter
        : defaults.delimiter;
    options.depth =
      typeof options.depth === 'number' ? options.depth : defaults.depth;
    options.arrayLimit =
      typeof options.arrayLimit === 'number'
        ? options.arrayLimit
        : defaults.arrayLimit;
    options.parseArrays = options.parseArrays !== false;
    options.decoder =
      typeof options.decoder === 'function'
        ? options.decoder
        : defaults.decoder;
    options.allowDots =
      typeof options.allowDots === 'boolean'
        ? options.allowDots
        : defaults.allowDots;
    options.plainObjects =
      typeof options.plainObjects === 'boolean'
        ? options.plainObjects
        : defaults.plainObjects;
    options.allowPrototypes =
      typeof options.allowPrototypes === 'boolean'
        ? options.allowPrototypes
        : defaults.allowPrototypes;
    options.parameterLimit =
      typeof options.parameterLimit === 'number'
        ? options.parameterLimit
        : defaults.parameterLimit;
    options.strictNullHandling =
      typeof options.strictNullHandling === 'boolean'
        ? options.strictNullHandling
        : defaults.strictNullHandling;
    if (str === '' || str === null || typeof str === 'undefined') {
      return options.plainObjects ? Object.create(null) : {};
    }
    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};
    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];
      var newObj = parseKeys(key, tempObj[key], options);
      obj = utils.merge(obj, newObj, options);
    }
    return utils.compact(obj);
  };
});

// node_modules/request/node_modules/qs/lib/index.js
var require_lib4 = __commonJS((exports2, module2) => {
  'use strict';
  var stringify = require_stringify2();
  var parse = require_parse();
  var formats = require_formats();
  module2.exports = {
    formats,
    parse,
    stringify,
  };
});

// node_modules/request/lib/querystring.js
var require_querystring = __commonJS((exports2) => {
  'use strict';
  var qs = require_lib4();
  var querystring = require('querystring');
  function Querystring(request) {
    this.request = request;
    this.lib = null;
    this.useQuerystring = null;
    this.parseOptions = null;
    this.stringifyOptions = null;
  }
  Querystring.prototype.init = function (options) {
    if (this.lib) {
      return;
    }
    this.useQuerystring = options.useQuerystring;
    this.lib = this.useQuerystring ? querystring : qs;
    this.parseOptions = options.qsParseOptions || {};
    this.stringifyOptions = options.qsStringifyOptions || {};
  };
  Querystring.prototype.stringify = function (obj) {
    return this.useQuerystring
      ? this.rfc3986(
          this.lib.stringify(
            obj,
            this.stringifyOptions.sep || null,
            this.stringifyOptions.eq || null,
            this.stringifyOptions,
          ),
        )
      : this.lib.stringify(obj, this.stringifyOptions);
  };
  Querystring.prototype.parse = function (str) {
    return this.useQuerystring
      ? this.lib.parse(
          str,
          this.parseOptions.sep || null,
          this.parseOptions.eq || null,
          this.parseOptions,
        )
      : this.lib.parse(str, this.parseOptions);
  };
  Querystring.prototype.rfc3986 = function (str) {
    return str.replace(/[!'()*]/g, function (c) {
      return '%' + c.charCodeAt(0).toString(16).toUpperCase();
    });
  };
  Querystring.prototype.unescape = querystring.unescape;
  exports2.Querystring = Querystring;
});

// node_modules/uri-js/dist/es5/uri.all.js
var require_uri_all = __commonJS((exports2, module2) => {
  /** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
  (function (global2, factory) {
    typeof exports2 === 'object' && typeof module2 !== 'undefined'
      ? factory(exports2)
      : typeof define === 'function' && define.amd
      ? define(['exports'], factory)
      : factory((global2.URI = global2.URI || {}));
  })(exports2, function (exports3) {
    'use strict';
    function merge() {
      for (
        var _len = arguments.length, sets = Array(_len), _key = 0;
        _key < _len;
        _key++
      ) {
        sets[_key] = arguments[_key];
      }
      if (sets.length > 1) {
        sets[0] = sets[0].slice(0, -1);
        var xl = sets.length - 1;
        for (var x = 1; x < xl; ++x) {
          sets[x] = sets[x].slice(1, -1);
        }
        sets[xl] = sets[xl].slice(1);
        return sets.join('');
      } else {
        return sets[0];
      }
    }
    function subexp(str) {
      return '(?:' + str + ')';
    }
    function typeOf(o) {
      return o === void 0
        ? 'undefined'
        : o === null
        ? 'null'
        : Object.prototype.toString
            .call(o)
            .split(' ')
            .pop()
            .split(']')
            .shift()
            .toLowerCase();
    }
    function toUpperCase(str) {
      return str.toUpperCase();
    }
    function toArray(obj) {
      return obj !== void 0 && obj !== null
        ? obj instanceof Array
          ? obj
          : typeof obj.length !== 'number' ||
            obj.split ||
            obj.setInterval ||
            obj.call
          ? [obj]
          : Array.prototype.slice.call(obj)
        : [];
    }
    function assign(target, source) {
      var obj = target;
      if (source) {
        for (var key in source) {
          obj[key] = source[key];
        }
      }
      return obj;
    }
    function buildExps(isIRI2) {
      var ALPHA$$ = '[A-Za-z]',
        CR$ = '[\\x0D]',
        DIGIT$$ = '[0-9]',
        DQUOTE$$ = '[\\x22]',
        HEXDIG$$2 = merge(DIGIT$$, '[A-Fa-f]'),
        LF$$ = '[\\x0A]',
        SP$$ = '[\\x20]',
        PCT_ENCODED$2 = subexp(
          subexp(
            '%[EFef]' +
              HEXDIG$$2 +
              '%' +
              HEXDIG$$2 +
              HEXDIG$$2 +
              '%' +
              HEXDIG$$2 +
              HEXDIG$$2,
          ) +
            '|' +
            subexp('%[89A-Fa-f]' + HEXDIG$$2 + '%' + HEXDIG$$2 + HEXDIG$$2) +
            '|' +
            subexp('%' + HEXDIG$$2 + HEXDIG$$2),
        ),
        GEN_DELIMS$$ = '[\\:\\/\\?\\#\\[\\]\\@]',
        SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
        UCSCHAR$$ = isIRI2
          ? '[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]'
          : '[]',
        IPRIVATE$$ = isIRI2 ? '[\\uE000-\\uF8FF]' : '[]',
        UNRESERVED$$2 = merge(ALPHA$$, DIGIT$$, '[\\-\\.\\_\\~]', UCSCHAR$$),
        SCHEME$ = subexp(
          ALPHA$$ + merge(ALPHA$$, DIGIT$$, '[\\+\\-\\.]') + '*',
        ),
        USERINFO$ = subexp(
          subexp(
            PCT_ENCODED$2 + '|' + merge(UNRESERVED$$2, SUB_DELIMS$$, '[\\:]'),
          ) + '*',
        ),
        DEC_OCTET$ = subexp(
          subexp('25[0-5]') +
            '|' +
            subexp('2[0-4]' + DIGIT$$) +
            '|' +
            subexp('1' + DIGIT$$ + DIGIT$$) +
            '|' +
            subexp('[1-9]' + DIGIT$$) +
            '|' +
            DIGIT$$,
        ),
        DEC_OCTET_RELAXED$ = subexp(
          subexp('25[0-5]') +
            '|' +
            subexp('2[0-4]' + DIGIT$$) +
            '|' +
            subexp('1' + DIGIT$$ + DIGIT$$) +
            '|' +
            subexp('0?[1-9]' + DIGIT$$) +
            '|0?0?' +
            DIGIT$$,
        ),
        IPV4ADDRESS$ = subexp(
          DEC_OCTET_RELAXED$ +
            '\\.' +
            DEC_OCTET_RELAXED$ +
            '\\.' +
            DEC_OCTET_RELAXED$ +
            '\\.' +
            DEC_OCTET_RELAXED$,
        ),
        H16$ = subexp(HEXDIG$$2 + '{1,4}'),
        LS32$ = subexp(subexp(H16$ + '\\:' + H16$) + '|' + IPV4ADDRESS$),
        IPV6ADDRESS1$ = subexp(subexp(H16$ + '\\:') + '{6}' + LS32$),
        IPV6ADDRESS2$ = subexp('\\:\\:' + subexp(H16$ + '\\:') + '{5}' + LS32$),
        IPV6ADDRESS3$ = subexp(
          subexp(H16$) + '?\\:\\:' + subexp(H16$ + '\\:') + '{4}' + LS32$,
        ),
        IPV6ADDRESS4$ = subexp(
          subexp(subexp(H16$ + '\\:') + '{0,1}' + H16$) +
            '?\\:\\:' +
            subexp(H16$ + '\\:') +
            '{3}' +
            LS32$,
        ),
        IPV6ADDRESS5$ = subexp(
          subexp(subexp(H16$ + '\\:') + '{0,2}' + H16$) +
            '?\\:\\:' +
            subexp(H16$ + '\\:') +
            '{2}' +
            LS32$,
        ),
        IPV6ADDRESS6$ = subexp(
          subexp(subexp(H16$ + '\\:') + '{0,3}' + H16$) +
            '?\\:\\:' +
            H16$ +
            '\\:' +
            LS32$,
        ),
        IPV6ADDRESS7$ = subexp(
          subexp(subexp(H16$ + '\\:') + '{0,4}' + H16$) + '?\\:\\:' + LS32$,
        ),
        IPV6ADDRESS8$ = subexp(
          subexp(subexp(H16$ + '\\:') + '{0,5}' + H16$) + '?\\:\\:' + H16$,
        ),
        IPV6ADDRESS9$ = subexp(
          subexp(subexp(H16$ + '\\:') + '{0,6}' + H16$) + '?\\:\\:',
        ),
        IPV6ADDRESS$ = subexp(
          [
            IPV6ADDRESS1$,
            IPV6ADDRESS2$,
            IPV6ADDRESS3$,
            IPV6ADDRESS4$,
            IPV6ADDRESS5$,
            IPV6ADDRESS6$,
            IPV6ADDRESS7$,
            IPV6ADDRESS8$,
            IPV6ADDRESS9$,
          ].join('|'),
        ),
        ZONEID$ = subexp(subexp(UNRESERVED$$2 + '|' + PCT_ENCODED$2) + '+'),
        IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + '\\%25' + ZONEID$),
        IPV6ADDRZ_RELAXED$ = subexp(
          IPV6ADDRESS$ + subexp('\\%25|\\%(?!' + HEXDIG$$2 + '{2})') + ZONEID$,
        ),
        IPVFUTURE$ = subexp(
          '[vV]' +
            HEXDIG$$2 +
            '+\\.' +
            merge(UNRESERVED$$2, SUB_DELIMS$$, '[\\:]') +
            '+',
        ),
        IP_LITERAL$ = subexp(
          '\\[' +
            subexp(IPV6ADDRZ_RELAXED$ + '|' + IPV6ADDRESS$ + '|' + IPVFUTURE$) +
            '\\]',
        ),
        REG_NAME$ = subexp(
          subexp(PCT_ENCODED$2 + '|' + merge(UNRESERVED$$2, SUB_DELIMS$$)) +
            '*',
        ),
        HOST$ = subexp(
          IP_LITERAL$ +
            '|' +
            IPV4ADDRESS$ +
            '(?!' +
            REG_NAME$ +
            ')|' +
            REG_NAME$,
        ),
        PORT$ = subexp(DIGIT$$ + '*'),
        AUTHORITY$ = subexp(
          subexp(USERINFO$ + '@') + '?' + HOST$ + subexp('\\:' + PORT$) + '?',
        ),
        PCHAR$ = subexp(
          PCT_ENCODED$2 + '|' + merge(UNRESERVED$$2, SUB_DELIMS$$, '[\\:\\@]'),
        ),
        SEGMENT$ = subexp(PCHAR$ + '*'),
        SEGMENT_NZ$ = subexp(PCHAR$ + '+'),
        SEGMENT_NZ_NC$ = subexp(
          subexp(
            PCT_ENCODED$2 + '|' + merge(UNRESERVED$$2, SUB_DELIMS$$, '[\\@]'),
          ) + '+',
        ),
        PATH_ABEMPTY$ = subexp(subexp('\\/' + SEGMENT$) + '*'),
        PATH_ABSOLUTE$ = subexp(
          '\\/' + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + '?',
        ),
        PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),
        PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),
        PATH_EMPTY$ = '(?!' + PCHAR$ + ')',
        PATH$ = subexp(
          PATH_ABEMPTY$ +
            '|' +
            PATH_ABSOLUTE$ +
            '|' +
            PATH_NOSCHEME$ +
            '|' +
            PATH_ROOTLESS$ +
            '|' +
            PATH_EMPTY$,
        ),
        QUERY$ = subexp(
          subexp(PCHAR$ + '|' + merge('[\\/\\?]', IPRIVATE$$)) + '*',
        ),
        FRAGMENT$ = subexp(subexp(PCHAR$ + '|[\\/\\?]') + '*'),
        HIER_PART$ = subexp(
          subexp('\\/\\/' + AUTHORITY$ + PATH_ABEMPTY$) +
            '|' +
            PATH_ABSOLUTE$ +
            '|' +
            PATH_ROOTLESS$ +
            '|' +
            PATH_EMPTY$,
        ),
        URI$ = subexp(
          SCHEME$ +
            '\\:' +
            HIER_PART$ +
            subexp('\\?' + QUERY$) +
            '?' +
            subexp('\\#' + FRAGMENT$) +
            '?',
        ),
        RELATIVE_PART$ = subexp(
          subexp('\\/\\/' + AUTHORITY$ + PATH_ABEMPTY$) +
            '|' +
            PATH_ABSOLUTE$ +
            '|' +
            PATH_NOSCHEME$ +
            '|' +
            PATH_EMPTY$,
        ),
        RELATIVE$ = subexp(
          RELATIVE_PART$ +
            subexp('\\?' + QUERY$) +
            '?' +
            subexp('\\#' + FRAGMENT$) +
            '?',
        ),
        URI_REFERENCE$ = subexp(URI$ + '|' + RELATIVE$),
        ABSOLUTE_URI$ = subexp(
          SCHEME$ + '\\:' + HIER_PART$ + subexp('\\?' + QUERY$) + '?',
        ),
        GENERIC_REF$ =
          '^(' +
          SCHEME$ +
          ')\\:' +
          subexp(
            subexp(
              '\\/\\/(' +
                subexp('(' + USERINFO$ + ')@') +
                '?(' +
                HOST$ +
                ')' +
                subexp('\\:(' + PORT$ + ')') +
                '?)',
            ) +
              '?(' +
              PATH_ABEMPTY$ +
              '|' +
              PATH_ABSOLUTE$ +
              '|' +
              PATH_ROOTLESS$ +
              '|' +
              PATH_EMPTY$ +
              ')',
          ) +
          subexp('\\?(' + QUERY$ + ')') +
          '?' +
          subexp('\\#(' + FRAGMENT$ + ')') +
          '?$',
        RELATIVE_REF$ =
          '^(){0}' +
          subexp(
            subexp(
              '\\/\\/(' +
                subexp('(' + USERINFO$ + ')@') +
                '?(' +
                HOST$ +
                ')' +
                subexp('\\:(' + PORT$ + ')') +
                '?)',
            ) +
              '?(' +
              PATH_ABEMPTY$ +
              '|' +
              PATH_ABSOLUTE$ +
              '|' +
              PATH_NOSCHEME$ +
              '|' +
              PATH_EMPTY$ +
              ')',
          ) +
          subexp('\\?(' + QUERY$ + ')') +
          '?' +
          subexp('\\#(' + FRAGMENT$ + ')') +
          '?$',
        ABSOLUTE_REF$ =
          '^(' +
          SCHEME$ +
          ')\\:' +
          subexp(
            subexp(
              '\\/\\/(' +
                subexp('(' + USERINFO$ + ')@') +
                '?(' +
                HOST$ +
                ')' +
                subexp('\\:(' + PORT$ + ')') +
                '?)',
            ) +
              '?(' +
              PATH_ABEMPTY$ +
              '|' +
              PATH_ABSOLUTE$ +
              '|' +
              PATH_ROOTLESS$ +
              '|' +
              PATH_EMPTY$ +
              ')',
          ) +
          subexp('\\?(' + QUERY$ + ')') +
          '?$',
        SAMEDOC_REF$ = '^' + subexp('\\#(' + FRAGMENT$ + ')') + '?$',
        AUTHORITY_REF$ =
          '^' +
          subexp('(' + USERINFO$ + ')@') +
          '?(' +
          HOST$ +
          ')' +
          subexp('\\:(' + PORT$ + ')') +
          '?$';
      return {
        NOT_SCHEME: new RegExp(
          merge('[^]', ALPHA$$, DIGIT$$, '[\\+\\-\\.]'),
          'g',
        ),
        NOT_USERINFO: new RegExp(
          merge('[^\\%\\:]', UNRESERVED$$2, SUB_DELIMS$$),
          'g',
        ),
        NOT_HOST: new RegExp(
          merge('[^\\%\\[\\]\\:]', UNRESERVED$$2, SUB_DELIMS$$),
          'g',
        ),
        NOT_PATH: new RegExp(
          merge('[^\\%\\/\\:\\@]', UNRESERVED$$2, SUB_DELIMS$$),
          'g',
        ),
        NOT_PATH_NOSCHEME: new RegExp(
          merge('[^\\%\\/\\@]', UNRESERVED$$2, SUB_DELIMS$$),
          'g',
        ),
        NOT_QUERY: new RegExp(
          merge(
            '[^\\%]',
            UNRESERVED$$2,
            SUB_DELIMS$$,
            '[\\:\\@\\/\\?]',
            IPRIVATE$$,
          ),
          'g',
        ),
        NOT_FRAGMENT: new RegExp(
          merge('[^\\%]', UNRESERVED$$2, SUB_DELIMS$$, '[\\:\\@\\/\\?]'),
          'g',
        ),
        ESCAPE: new RegExp(merge('[^]', UNRESERVED$$2, SUB_DELIMS$$), 'g'),
        UNRESERVED: new RegExp(UNRESERVED$$2, 'g'),
        OTHER_CHARS: new RegExp(
          merge('[^\\%]', UNRESERVED$$2, RESERVED$$),
          'g',
        ),
        PCT_ENCODED: new RegExp(PCT_ENCODED$2, 'g'),
        IPV4ADDRESS: new RegExp('^(' + IPV4ADDRESS$ + ')$'),
        IPV6ADDRESS: new RegExp(
          '^\\[?(' +
            IPV6ADDRESS$ +
            ')' +
            subexp(
              subexp('\\%25|\\%(?!' + HEXDIG$$2 + '{2})') + '(' + ZONEID$ + ')',
            ) +
            '?\\]?$',
        ),
      };
    }
    var URI_PROTOCOL = buildExps(false);
    var IRI_PROTOCOL = buildExps(true);
    var slicedToArray = (function () {
      function sliceIterator(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (
            var _i = arr[Symbol.iterator](), _s;
            !(_n = (_s = _i.next()).done);
            _n = true
          ) {
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i['return']) _i['return']();
          } finally {
            if (_d) throw _e;
          }
        }
        return _arr;
      }
      return function (arr, i) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i);
        } else {
          throw new TypeError(
            'Invalid attempt to destructure non-iterable instance',
          );
        }
      };
    })();
    var toConsumableArray = function (arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
          arr2[i] = arr[i];
        return arr2;
      } else {
        return Array.from(arr);
      }
    };
    var maxInt = 2147483647;
    var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128;
    var delimiter = '-';
    var regexPunycode = /^xn--/;
    var regexNonASCII = /[^\0-\x7E]/;
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    var errors = {
      overflow: 'Overflow: input needs wider integers to process',
      'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
      'invalid-input': 'Invalid input',
    };
    var baseMinusTMin = base - tMin;
    var floor = Math.floor;
    var stringFromCharCode = String.fromCharCode;
    function error$1(type) {
      throw new RangeError(errors[type]);
    }
    function map(array, fn) {
      var result = [];
      var length = array.length;
      while (length--) {
        result[length] = fn(array[length]);
      }
      return result;
    }
    function mapDomain(string, fn) {
      var parts = string.split('@');
      var result = '';
      if (parts.length > 1) {
        result = parts[0] + '@';
        string = parts[1];
      }
      string = string.replace(regexSeparators, '.');
      var labels = string.split('.');
      var encoded = map(labels, fn).join('.');
      return result + encoded;
    }
    function ucs2decode(string) {
      var output = [];
      var counter = 0;
      var length = string.length;
      while (counter < length) {
        var value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          var extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    var ucs2encode = function ucs2encode2(array) {
      return String.fromCodePoint.apply(String, toConsumableArray(array));
    };
    var basicToDigit = function basicToDigit2(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    };
    var digitToBasic = function digitToBasic2(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    var adapt = function adapt2(delta, numPoints, firstTime) {
      var k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (; delta > (baseMinusTMin * tMax) >> 1; k += base) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + ((baseMinusTMin + 1) * delta) / (delta + skew));
    };
    var decode = function decode2(input) {
      var output = [];
      var inputLength = input.length;
      var i = 0;
      var n = initialN;
      var bias = initialBias;
      var basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (var j = 0; j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error$1('not-basic');
        }
        output.push(input.charCodeAt(j));
      }
      for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        var oldi = i;
        for (var w = 1, k = base; ; k += base) {
          if (index >= inputLength) {
            error$1('invalid-input');
          }
          var digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base || digit > floor((maxInt - i) / w)) {
            error$1('overflow');
          }
          i += digit * w;
          var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t) {
            break;
          }
          var baseMinusT = base - t;
          if (w > floor(maxInt / baseMinusT)) {
            error$1('overflow');
          }
          w *= baseMinusT;
        }
        var out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);
        if (floor(i / out) > maxInt - n) {
          error$1('overflow');
        }
        n += floor(i / out);
        i %= out;
        output.splice(i++, 0, n);
      }
      return String.fromCodePoint.apply(String, output);
    };
    var encode = function encode2(input) {
      var output = [];
      input = ucs2decode(input);
      var inputLength = input.length;
      var n = initialN;
      var delta = 0;
      var bias = initialBias;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = void 0;
      try {
        for (
          var _iterator = input[Symbol.iterator](), _step;
          !(_iteratorNormalCompletion = (_step = _iterator.next()).done);
          _iteratorNormalCompletion = true
        ) {
          var _currentValue2 = _step.value;
          if (_currentValue2 < 128) {
            output.push(stringFromCharCode(_currentValue2));
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      var basicLength = output.length;
      var handledCPCount = basicLength;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        var m = maxInt;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = void 0;
        try {
          for (
            var _iterator2 = input[Symbol.iterator](), _step2;
            !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done);
            _iteratorNormalCompletion2 = true
          ) {
            var currentValue = _step2.value;
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
        var handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error$1('overflow');
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = void 0;
        try {
          for (
            var _iterator3 = input[Symbol.iterator](), _step3;
            !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done);
            _iteratorNormalCompletion3 = true
          ) {
            var _currentValue = _step3.value;
            if (_currentValue < n && ++delta > maxInt) {
              error$1('overflow');
            }
            if (_currentValue == n) {
              var q2 = delta;
              for (var k = base; ; k += base) {
                var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q2 < t) {
                  break;
                }
                var qMinusT = q2 - t;
                var baseMinusT = base - t;
                output.push(
                  stringFromCharCode(
                    digitToBasic(t + (qMinusT % baseMinusT), 0),
                  ),
                );
                q2 = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q2, 0)));
              bias = adapt(
                delta,
                handledCPCountPlusOne,
                handledCPCount == basicLength,
              );
              delta = 0;
              ++handledCPCount;
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
        ++delta;
        ++n;
      }
      return output.join('');
    };
    var toUnicode = function toUnicode2(input) {
      return mapDomain(input, function (string) {
        return regexPunycode.test(string)
          ? decode(string.slice(4).toLowerCase())
          : string;
      });
    };
    var toASCII = function toASCII2(input) {
      return mapDomain(input, function (string) {
        return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
      });
    };
    var punycode = {
      version: '2.1.0',
      ucs2: {
        decode: ucs2decode,
        encode: ucs2encode,
      },
      decode,
      encode,
      toASCII,
      toUnicode,
    };
    var SCHEMES = {};
    function pctEncChar(chr) {
      var c = chr.charCodeAt(0);
      var e = void 0;
      if (c < 16) e = '%0' + c.toString(16).toUpperCase();
      else if (c < 128) e = '%' + c.toString(16).toUpperCase();
      else if (c < 2048)
        e =
          '%' +
          ((c >> 6) | 192).toString(16).toUpperCase() +
          '%' +
          ((c & 63) | 128).toString(16).toUpperCase();
      else
        e =
          '%' +
          ((c >> 12) | 224).toString(16).toUpperCase() +
          '%' +
          (((c >> 6) & 63) | 128).toString(16).toUpperCase() +
          '%' +
          ((c & 63) | 128).toString(16).toUpperCase();
      return e;
    }
    function pctDecChars(str) {
      var newStr = '';
      var i = 0;
      var il = str.length;
      while (i < il) {
        var c = parseInt(str.substr(i + 1, 2), 16);
        if (c < 128) {
          newStr += String.fromCharCode(c);
          i += 3;
        } else if (c >= 194 && c < 224) {
          if (il - i >= 6) {
            var c2 = parseInt(str.substr(i + 4, 2), 16);
            newStr += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
          } else {
            newStr += str.substr(i, 6);
          }
          i += 6;
        } else if (c >= 224) {
          if (il - i >= 9) {
            var _c = parseInt(str.substr(i + 4, 2), 16);
            var c3 = parseInt(str.substr(i + 7, 2), 16);
            newStr += String.fromCharCode(
              ((c & 15) << 12) | ((_c & 63) << 6) | (c3 & 63),
            );
          } else {
            newStr += str.substr(i, 9);
          }
          i += 9;
        } else {
          newStr += str.substr(i, 3);
          i += 3;
        }
      }
      return newStr;
    }
    function _normalizeComponentEncoding(components, protocol) {
      function decodeUnreserved2(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
      }
      if (components.scheme)
        components.scheme = String(components.scheme)
          .replace(protocol.PCT_ENCODED, decodeUnreserved2)
          .toLowerCase()
          .replace(protocol.NOT_SCHEME, '');
      if (components.userinfo !== void 0)
        components.userinfo = String(components.userinfo)
          .replace(protocol.PCT_ENCODED, decodeUnreserved2)
          .replace(protocol.NOT_USERINFO, pctEncChar)
          .replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.host !== void 0)
        components.host = String(components.host)
          .replace(protocol.PCT_ENCODED, decodeUnreserved2)
          .toLowerCase()
          .replace(protocol.NOT_HOST, pctEncChar)
          .replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.path !== void 0)
        components.path = String(components.path)
          .replace(protocol.PCT_ENCODED, decodeUnreserved2)
          .replace(
            components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME,
            pctEncChar,
          )
          .replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.query !== void 0)
        components.query = String(components.query)
          .replace(protocol.PCT_ENCODED, decodeUnreserved2)
          .replace(protocol.NOT_QUERY, pctEncChar)
          .replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.fragment !== void 0)
        components.fragment = String(components.fragment)
          .replace(protocol.PCT_ENCODED, decodeUnreserved2)
          .replace(protocol.NOT_FRAGMENT, pctEncChar)
          .replace(protocol.PCT_ENCODED, toUpperCase);
      return components;
    }
    function _stripLeadingZeros(str) {
      return str.replace(/^0*(.*)/, '$1') || '0';
    }
    function _normalizeIPv4(host, protocol) {
      var matches = host.match(protocol.IPV4ADDRESS) || [];
      var _matches = slicedToArray(matches, 2),
        address = _matches[1];
      if (address) {
        return address.split('.').map(_stripLeadingZeros).join('.');
      } else {
        return host;
      }
    }
    function _normalizeIPv6(host, protocol) {
      var matches = host.match(protocol.IPV6ADDRESS) || [];
      var _matches2 = slicedToArray(matches, 3),
        address = _matches2[1],
        zone = _matches2[2];
      if (address) {
        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),
          _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
          last = _address$toLowerCase$2[0],
          first = _address$toLowerCase$2[1];
        var firstFields = first ? first.split(':').map(_stripLeadingZeros) : [];
        var lastFields = last.split(':').map(_stripLeadingZeros);
        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(
          lastFields[lastFields.length - 1],
        );
        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
        var lastFieldsStart = lastFields.length - fieldCount;
        var fields = Array(fieldCount);
        for (var x = 0; x < fieldCount; ++x) {
          fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
        }
        if (isLastFieldIPv4Address) {
          fields[fieldCount - 1] = _normalizeIPv4(
            fields[fieldCount - 1],
            protocol,
          );
        }
        var allZeroFields = fields.reduce(function (acc, field, index) {
          if (!field || field === '0') {
            var lastLongest = acc[acc.length - 1];
            if (
              lastLongest &&
              lastLongest.index + lastLongest.length === index
            ) {
              lastLongest.length++;
            } else {
              acc.push({ index, length: 1 });
            }
          }
          return acc;
        }, []);
        var longestZeroFields = allZeroFields.sort(function (a, b) {
          return b.length - a.length;
        })[0];
        var newHost = void 0;
        if (longestZeroFields && longestZeroFields.length > 1) {
          var newFirst = fields.slice(0, longestZeroFields.index);
          var newLast = fields.slice(
            longestZeroFields.index + longestZeroFields.length,
          );
          newHost = newFirst.join(':') + '::' + newLast.join(':');
        } else {
          newHost = fields.join(':');
        }
        if (zone) {
          newHost += '%' + zone;
        }
        return newHost;
      } else {
        return host;
      }
    }
    var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
    var NO_MATCH_IS_UNDEFINED = ''.match(/(){0}/)[1] === void 0;
    function parse(uriString) {
      var options =
        arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var components = {};
      var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
      if (options.reference === 'suffix')
        uriString =
          (options.scheme ? options.scheme + ':' : '') + '//' + uriString;
      var matches = uriString.match(URI_PARSE);
      if (matches) {
        if (NO_MATCH_IS_UNDEFINED) {
          components.scheme = matches[1];
          components.userinfo = matches[3];
          components.host = matches[4];
          components.port = parseInt(matches[5], 10);
          components.path = matches[6] || '';
          components.query = matches[7];
          components.fragment = matches[8];
          if (isNaN(components.port)) {
            components.port = matches[5];
          }
        } else {
          components.scheme = matches[1] || void 0;
          components.userinfo =
            uriString.indexOf('@') !== -1 ? matches[3] : void 0;
          components.host =
            uriString.indexOf('//') !== -1 ? matches[4] : void 0;
          components.port = parseInt(matches[5], 10);
          components.path = matches[6] || '';
          components.query =
            uriString.indexOf('?') !== -1 ? matches[7] : void 0;
          components.fragment =
            uriString.indexOf('#') !== -1 ? matches[8] : void 0;
          if (isNaN(components.port)) {
            components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/)
              ? matches[4]
              : void 0;
          }
        }
        if (components.host) {
          components.host = _normalizeIPv6(
            _normalizeIPv4(components.host, protocol),
            protocol,
          );
        }
        if (
          components.scheme === void 0 &&
          components.userinfo === void 0 &&
          components.host === void 0 &&
          components.port === void 0 &&
          !components.path &&
          components.query === void 0
        ) {
          components.reference = 'same-document';
        } else if (components.scheme === void 0) {
          components.reference = 'relative';
        } else if (components.fragment === void 0) {
          components.reference = 'absolute';
        } else {
          components.reference = 'uri';
        }
        if (
          options.reference &&
          options.reference !== 'suffix' &&
          options.reference !== components.reference
        ) {
          components.error =
            components.error ||
            'URI is not a ' + options.reference + ' reference.';
        }
        var schemeHandler =
          SCHEMES[(options.scheme || components.scheme || '').toLowerCase()];
        if (
          !options.unicodeSupport &&
          (!schemeHandler || !schemeHandler.unicodeSupport)
        ) {
          if (
            components.host &&
            (options.domainHost || (schemeHandler && schemeHandler.domainHost))
          ) {
            try {
              components.host = punycode.toASCII(
                components.host
                  .replace(protocol.PCT_ENCODED, pctDecChars)
                  .toLowerCase(),
              );
            } catch (e) {
              components.error =
                components.error ||
                "Host's domain name can not be converted to ASCII via punycode: " +
                  e;
            }
          }
          _normalizeComponentEncoding(components, URI_PROTOCOL);
        } else {
          _normalizeComponentEncoding(components, protocol);
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(components, options);
        }
      } else {
        components.error = components.error || 'URI can not be parsed.';
      }
      return components;
    }
    function _recomposeAuthority(components, options) {
      var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
      var uriTokens = [];
      if (components.userinfo !== void 0) {
        uriTokens.push(components.userinfo);
        uriTokens.push('@');
      }
      if (components.host !== void 0) {
        uriTokens.push(
          _normalizeIPv6(
            _normalizeIPv4(String(components.host), protocol),
            protocol,
          ).replace(protocol.IPV6ADDRESS, function (_2, $1, $2) {
            return '[' + $1 + ($2 ? '%25' + $2 : '') + ']';
          }),
        );
      }
      if (
        typeof components.port === 'number' ||
        typeof components.port === 'string'
      ) {
        uriTokens.push(':');
        uriTokens.push(String(components.port));
      }
      return uriTokens.length ? uriTokens.join('') : void 0;
    }
    var RDS1 = /^\.\.?\//;
    var RDS2 = /^\/\.(\/|$)/;
    var RDS3 = /^\/\.\.(\/|$)/;
    var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
    function removeDotSegments(input) {
      var output = [];
      while (input.length) {
        if (input.match(RDS1)) {
          input = input.replace(RDS1, '');
        } else if (input.match(RDS2)) {
          input = input.replace(RDS2, '/');
        } else if (input.match(RDS3)) {
          input = input.replace(RDS3, '/');
          output.pop();
        } else if (input === '.' || input === '..') {
          input = '';
        } else {
          var im = input.match(RDS5);
          if (im) {
            var s = im[0];
            input = input.slice(s.length);
            output.push(s);
          } else {
            throw new Error('Unexpected dot segment condition');
          }
        }
      }
      return output.join('');
    }
    function serialize(components) {
      var options =
        arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
      var uriTokens = [];
      var schemeHandler =
        SCHEMES[(options.scheme || components.scheme || '').toLowerCase()];
      if (schemeHandler && schemeHandler.serialize)
        schemeHandler.serialize(components, options);
      if (components.host) {
        if (protocol.IPV6ADDRESS.test(components.host)) {
        } else if (
          options.domainHost ||
          (schemeHandler && schemeHandler.domainHost)
        ) {
          try {
            components.host = !options.iri
              ? punycode.toASCII(
                  components.host
                    .replace(protocol.PCT_ENCODED, pctDecChars)
                    .toLowerCase(),
                )
              : punycode.toUnicode(components.host);
          } catch (e) {
            components.error =
              components.error ||
              "Host's domain name can not be converted to " +
                (!options.iri ? 'ASCII' : 'Unicode') +
                ' via punycode: ' +
                e;
          }
        }
      }
      _normalizeComponentEncoding(components, protocol);
      if (options.reference !== 'suffix' && components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(':');
      }
      var authority = _recomposeAuthority(components, options);
      if (authority !== void 0) {
        if (options.reference !== 'suffix') {
          uriTokens.push('//');
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== '/') {
          uriTokens.push('/');
        }
      }
      if (components.path !== void 0) {
        var s = components.path;
        if (
          !options.absolutePath &&
          (!schemeHandler || !schemeHandler.absolutePath)
        ) {
          s = removeDotSegments(s);
        }
        if (authority === void 0) {
          s = s.replace(/^\/\//, '/%2F');
        }
        uriTokens.push(s);
      }
      if (components.query !== void 0) {
        uriTokens.push('?');
        uriTokens.push(components.query);
      }
      if (components.fragment !== void 0) {
        uriTokens.push('#');
        uriTokens.push(components.fragment);
      }
      return uriTokens.join('');
    }
    function resolveComponents(base2, relative2) {
      var options =
        arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var skipNormalization = arguments[3];
      var target = {};
      if (!skipNormalization) {
        base2 = parse(serialize(base2, options), options);
        relative2 = parse(serialize(relative2, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative2.scheme) {
        target.scheme = relative2.scheme;
        target.userinfo = relative2.userinfo;
        target.host = relative2.host;
        target.port = relative2.port;
        target.path = removeDotSegments(relative2.path || '');
        target.query = relative2.query;
      } else {
        if (
          relative2.userinfo !== void 0 ||
          relative2.host !== void 0 ||
          relative2.port !== void 0
        ) {
          target.userinfo = relative2.userinfo;
          target.host = relative2.host;
          target.port = relative2.port;
          target.path = removeDotSegments(relative2.path || '');
          target.query = relative2.query;
        } else {
          if (!relative2.path) {
            target.path = base2.path;
            if (relative2.query !== void 0) {
              target.query = relative2.query;
            } else {
              target.query = base2.query;
            }
          } else {
            if (relative2.path.charAt(0) === '/') {
              target.path = removeDotSegments(relative2.path);
            } else {
              if (
                (base2.userinfo !== void 0 ||
                  base2.host !== void 0 ||
                  base2.port !== void 0) &&
                !base2.path
              ) {
                target.path = '/' + relative2.path;
              } else if (!base2.path) {
                target.path = relative2.path;
              } else {
                target.path =
                  base2.path.slice(0, base2.path.lastIndexOf('/') + 1) +
                  relative2.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative2.query;
          }
          target.userinfo = base2.userinfo;
          target.host = base2.host;
          target.port = base2.port;
        }
        target.scheme = base2.scheme;
      }
      target.fragment = relative2.fragment;
      return target;
    }
    function resolve(baseURI, relativeURI, options) {
      var schemelessOptions = assign({ scheme: 'null' }, options);
      return serialize(
        resolveComponents(
          parse(baseURI, schemelessOptions),
          parse(relativeURI, schemelessOptions),
          schemelessOptions,
          true,
        ),
        schemelessOptions,
      );
    }
    function normalize(uri, options) {
      if (typeof uri === 'string') {
        uri = serialize(parse(uri, options), options);
      } else if (typeOf(uri) === 'object') {
        uri = parse(serialize(uri, options), options);
      }
      return uri;
    }
    function equal(uriA, uriB, options) {
      if (typeof uriA === 'string') {
        uriA = serialize(parse(uriA, options), options);
      } else if (typeOf(uriA) === 'object') {
        uriA = serialize(uriA, options);
      }
      if (typeof uriB === 'string') {
        uriB = serialize(parse(uriB, options), options);
      } else if (typeOf(uriB) === 'object') {
        uriB = serialize(uriB, options);
      }
      return uriA === uriB;
    }
    function escapeComponent(str, options) {
      return (
        str &&
        str
          .toString()
          .replace(
            !options || !options.iri
              ? URI_PROTOCOL.ESCAPE
              : IRI_PROTOCOL.ESCAPE,
            pctEncChar,
          )
      );
    }
    function unescapeComponent(str, options) {
      return (
        str &&
        str
          .toString()
          .replace(
            !options || !options.iri
              ? URI_PROTOCOL.PCT_ENCODED
              : IRI_PROTOCOL.PCT_ENCODED,
            pctDecChars,
          )
      );
    }
    var handler = {
      scheme: 'http',
      domainHost: true,
      parse: function parse2(components, options) {
        if (!components.host) {
          components.error = components.error || 'HTTP URIs must have a host.';
        }
        return components;
      },
      serialize: function serialize2(components, options) {
        var secure = String(components.scheme).toLowerCase() === 'https';
        if (components.port === (secure ? 443 : 80) || components.port === '') {
          components.port = void 0;
        }
        if (!components.path) {
          components.path = '/';
        }
        return components;
      },
    };
    var handler$1 = {
      scheme: 'https',
      domainHost: handler.domainHost,
      parse: handler.parse,
      serialize: handler.serialize,
    };
    function isSecure(wsComponents) {
      return typeof wsComponents.secure === 'boolean'
        ? wsComponents.secure
        : String(wsComponents.scheme).toLowerCase() === 'wss';
    }
    var handler$2 = {
      scheme: 'ws',
      domainHost: true,
      parse: function parse2(components, options) {
        var wsComponents = components;
        wsComponents.secure = isSecure(wsComponents);
        wsComponents.resourceName =
          (wsComponents.path || '/') +
          (wsComponents.query ? '?' + wsComponents.query : '');
        wsComponents.path = void 0;
        wsComponents.query = void 0;
        return wsComponents;
      },
      serialize: function serialize2(wsComponents, options) {
        if (
          wsComponents.port === (isSecure(wsComponents) ? 443 : 80) ||
          wsComponents.port === ''
        ) {
          wsComponents.port = void 0;
        }
        if (typeof wsComponents.secure === 'boolean') {
          wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';
          wsComponents.secure = void 0;
        }
        if (wsComponents.resourceName) {
          var _wsComponents$resourc = wsComponents.resourceName.split('?'),
            _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),
            path = _wsComponents$resourc2[0],
            query = _wsComponents$resourc2[1];
          wsComponents.path = path && path !== '/' ? path : void 0;
          wsComponents.query = query;
          wsComponents.resourceName = void 0;
        }
        wsComponents.fragment = void 0;
        return wsComponents;
      },
    };
    var handler$3 = {
      scheme: 'wss',
      domainHost: handler$2.domainHost,
      parse: handler$2.parse,
      serialize: handler$2.serialize,
    };
    var O = {};
    var isIRI = true;
    var UNRESERVED$$ =
      '[A-Za-z0-9\\-\\.\\_\\~' +
      (isIRI
        ? '\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF'
        : '') +
      ']';
    var HEXDIG$$ = '[0-9A-Fa-f]';
    var PCT_ENCODED$ = subexp(
      subexp(
        '%[EFef]' +
          HEXDIG$$ +
          '%' +
          HEXDIG$$ +
          HEXDIG$$ +
          '%' +
          HEXDIG$$ +
          HEXDIG$$,
      ) +
        '|' +
        subexp('%[89A-Fa-f]' + HEXDIG$$ + '%' + HEXDIG$$ + HEXDIG$$) +
        '|' +
        subexp('%' + HEXDIG$$ + HEXDIG$$),
    );
    var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
    var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
    var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]');
    var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
    var UNRESERVED = new RegExp(UNRESERVED$$, 'g');
    var PCT_ENCODED = new RegExp(PCT_ENCODED$, 'g');
    var NOT_LOCAL_PART = new RegExp(
      merge('[^]', ATEXT$$, '[\\.]', '[\\"]', VCHAR$$),
      'g',
    );
    var NOT_HFNAME = new RegExp(merge('[^]', UNRESERVED$$, SOME_DELIMS$$), 'g');
    var NOT_HFVALUE = NOT_HFNAME;
    function decodeUnreserved(str) {
      var decStr = pctDecChars(str);
      return !decStr.match(UNRESERVED) ? str : decStr;
    }
    var handler$4 = {
      scheme: 'mailto',
      parse: function parse$$1(components, options) {
        var mailtoComponents = components;
        var to = (mailtoComponents.to = mailtoComponents.path
          ? mailtoComponents.path.split(',')
          : []);
        mailtoComponents.path = void 0;
        if (mailtoComponents.query) {
          var unknownHeaders = false;
          var headers = {};
          var hfields = mailtoComponents.query.split('&');
          for (var x = 0, xl = hfields.length; x < xl; ++x) {
            var hfield = hfields[x].split('=');
            switch (hfield[0]) {
              case 'to':
                var toAddrs = hfield[1].split(',');
                for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                  to.push(toAddrs[_x]);
                }
                break;
              case 'subject':
                mailtoComponents.subject = unescapeComponent(
                  hfield[1],
                  options,
                );
                break;
              case 'body':
                mailtoComponents.body = unescapeComponent(hfield[1], options);
                break;
              default:
                unknownHeaders = true;
                headers[
                  unescapeComponent(hfield[0], options)
                ] = unescapeComponent(hfield[1], options);
                break;
            }
          }
          if (unknownHeaders) mailtoComponents.headers = headers;
        }
        mailtoComponents.query = void 0;
        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
          var addr = to[_x2].split('@');
          addr[0] = unescapeComponent(addr[0]);
          if (!options.unicodeSupport) {
            try {
              addr[1] = punycode.toASCII(
                unescapeComponent(addr[1], options).toLowerCase(),
              );
            } catch (e) {
              mailtoComponents.error =
                mailtoComponents.error ||
                "Email address's domain name can not be converted to ASCII via punycode: " +
                  e;
            }
          } else {
            addr[1] = unescapeComponent(addr[1], options).toLowerCase();
          }
          to[_x2] = addr.join('@');
        }
        return mailtoComponents;
      },
      serialize: function serialize$$1(mailtoComponents, options) {
        var components = mailtoComponents;
        var to = toArray(mailtoComponents.to);
        if (to) {
          for (var x = 0, xl = to.length; x < xl; ++x) {
            var toAddr = String(to[x]);
            var atIdx = toAddr.lastIndexOf('@');
            var localPart = toAddr
              .slice(0, atIdx)
              .replace(PCT_ENCODED, decodeUnreserved)
              .replace(PCT_ENCODED, toUpperCase)
              .replace(NOT_LOCAL_PART, pctEncChar);
            var domain = toAddr.slice(atIdx + 1);
            try {
              domain = !options.iri
                ? punycode.toASCII(
                    unescapeComponent(domain, options).toLowerCase(),
                  )
                : punycode.toUnicode(domain);
            } catch (e) {
              components.error =
                components.error ||
                "Email address's domain name can not be converted to " +
                  (!options.iri ? 'ASCII' : 'Unicode') +
                  ' via punycode: ' +
                  e;
            }
            to[x] = localPart + '@' + domain;
          }
          components.path = to.join(',');
        }
        var headers = (mailtoComponents.headers =
          mailtoComponents.headers || {});
        if (mailtoComponents.subject)
          headers['subject'] = mailtoComponents.subject;
        if (mailtoComponents.body) headers['body'] = mailtoComponents.body;
        var fields = [];
        for (var name in headers) {
          if (headers[name] !== O[name]) {
            fields.push(
              name
                .replace(PCT_ENCODED, decodeUnreserved)
                .replace(PCT_ENCODED, toUpperCase)
                .replace(NOT_HFNAME, pctEncChar) +
                '=' +
                headers[name]
                  .replace(PCT_ENCODED, decodeUnreserved)
                  .replace(PCT_ENCODED, toUpperCase)
                  .replace(NOT_HFVALUE, pctEncChar),
            );
          }
        }
        if (fields.length) {
          components.query = fields.join('&');
        }
        return components;
      },
    };
    var URN_PARSE = /^([^\:]+)\:(.*)/;
    var handler$5 = {
      scheme: 'urn',
      parse: function parse$$1(components, options) {
        var matches = components.path && components.path.match(URN_PARSE);
        var urnComponents = components;
        if (matches) {
          var scheme = options.scheme || urnComponents.scheme || 'urn';
          var nid = matches[1].toLowerCase();
          var nss = matches[2];
          var urnScheme = scheme + ':' + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          urnComponents.nid = nid;
          urnComponents.nss = nss;
          urnComponents.path = void 0;
          if (schemeHandler) {
            urnComponents = schemeHandler.parse(urnComponents, options);
          }
        } else {
          urnComponents.error = urnComponents.error || 'URN can not be parsed.';
        }
        return urnComponents;
      },
      serialize: function serialize$$1(urnComponents, options) {
        var scheme = options.scheme || urnComponents.scheme || 'urn';
        var nid = urnComponents.nid;
        var urnScheme = scheme + ':' + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
          urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        var uriComponents = urnComponents;
        var nss = urnComponents.nss;
        uriComponents.path = (nid || options.nid) + ':' + nss;
        return uriComponents;
      },
    };
    var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
    var handler$6 = {
      scheme: 'urn:uuid',
      parse: function parse2(urnComponents, options) {
        var uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = void 0;
        if (
          !options.tolerant &&
          (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))
        ) {
          uuidComponents.error = uuidComponents.error || 'UUID is not valid.';
        }
        return uuidComponents;
      },
      serialize: function serialize2(uuidComponents, options) {
        var urnComponents = uuidComponents;
        urnComponents.nss = (uuidComponents.uuid || '').toLowerCase();
        return urnComponents;
      },
    };
    SCHEMES[handler.scheme] = handler;
    SCHEMES[handler$1.scheme] = handler$1;
    SCHEMES[handler$2.scheme] = handler$2;
    SCHEMES[handler$3.scheme] = handler$3;
    SCHEMES[handler$4.scheme] = handler$4;
    SCHEMES[handler$5.scheme] = handler$5;
    SCHEMES[handler$6.scheme] = handler$6;
    exports3.SCHEMES = SCHEMES;
    exports3.pctEncChar = pctEncChar;
    exports3.pctDecChars = pctDecChars;
    exports3.parse = parse;
    exports3.removeDotSegments = removeDotSegments;
    exports3.serialize = serialize;
    exports3.resolveComponents = resolveComponents;
    exports3.resolve = resolve;
    exports3.normalize = normalize;
    exports3.equal = equal;
    exports3.escapeComponent = escapeComponent;
    exports3.unescapeComponent = unescapeComponent;
    Object.defineProperty(exports3, '__esModule', { value: true });
  });
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = function equal(a, b) {
    if (a === b) return true;
    if (a && b && typeof a == 'object' && typeof b == 'object') {
      if (a.constructor !== b.constructor) return false;
      var length, i, keys;
      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length) return false;
        for (i = length; i-- !== 0; ) if (!equal(a[i], b[i])) return false;
        return true;
      }
      if (a.constructor === RegExp)
        return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf)
        return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString)
        return a.toString() === b.toString();
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length) return false;
      for (i = length; i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
      for (i = length; i-- !== 0; ) {
        var key = keys[i];
        if (!equal(a[key], b[key])) return false;
      }
      return true;
    }
    return a !== a && b !== b;
  };
});

// node_modules/ajv/lib/compile/ucs2length.js
var require_ucs2length = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = function ucs2length(str) {
    var length = 0,
      len = str.length,
      pos = 0,
      value;
    while (pos < len) {
      length++;
      value = str.charCodeAt(pos++);
      if (value >= 55296 && value <= 56319 && pos < len) {
        value = str.charCodeAt(pos);
        if ((value & 64512) == 56320) pos++;
      }
    }
    return length;
  };
});

// node_modules/ajv/lib/compile/util.js
var require_util3 = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = {
    copy,
    checkDataType,
    checkDataTypes,
    coerceToTypes,
    toHash,
    getProperty,
    escapeQuotes,
    equal: require_fast_deep_equal(),
    ucs2length: require_ucs2length(),
    varOccurences,
    varReplace,
    schemaHasRules,
    schemaHasRulesExcept,
    schemaUnknownRules,
    toQuotedString,
    getPathExpr,
    getPath,
    getData,
    unescapeFragment,
    unescapeJsonPointer,
    escapeFragment,
    escapeJsonPointer,
  };
  function copy(o, to) {
    to = to || {};
    for (var key in o) to[key] = o[key];
    return to;
  }
  function checkDataType(dataType, data, strictNumbers, negate) {
    var EQUAL = negate ? ' !== ' : ' === ',
      AND = negate ? ' || ' : ' && ',
      OK = negate ? '!' : '',
      NOT = negate ? '' : '!';
    switch (dataType) {
      case 'null':
        return data + EQUAL + 'null';
      case 'array':
        return OK + 'Array.isArray(' + data + ')';
      case 'object':
        return (
          '(' +
          OK +
          data +
          AND +
          'typeof ' +
          data +
          EQUAL +
          '"object"' +
          AND +
          NOT +
          'Array.isArray(' +
          data +
          '))'
        );
      case 'integer':
        return (
          '(typeof ' +
          data +
          EQUAL +
          '"number"' +
          AND +
          NOT +
          '(' +
          data +
          ' % 1)' +
          AND +
          data +
          EQUAL +
          data +
          (strictNumbers ? AND + OK + 'isFinite(' + data + ')' : '') +
          ')'
        );
      case 'number':
        return (
          '(typeof ' +
          data +
          EQUAL +
          '"' +
          dataType +
          '"' +
          (strictNumbers ? AND + OK + 'isFinite(' + data + ')' : '') +
          ')'
        );
      default:
        return 'typeof ' + data + EQUAL + '"' + dataType + '"';
    }
  }
  function checkDataTypes(dataTypes, data, strictNumbers) {
    switch (dataTypes.length) {
      case 1:
        return checkDataType(dataTypes[0], data, strictNumbers, true);
      default:
        var code = '';
        var types = toHash(dataTypes);
        if (types.array && types.object) {
          code = types.null ? '(' : '(!' + data + ' || ';
          code += 'typeof ' + data + ' !== "object")';
          delete types.null;
          delete types.array;
          delete types.object;
        }
        if (types.number) delete types.integer;
        for (var t in types)
          code +=
            (code ? ' && ' : '') + checkDataType(t, data, strictNumbers, true);
        return code;
    }
  }
  var COERCE_TO_TYPES = toHash([
    'string',
    'number',
    'integer',
    'boolean',
    'null',
  ]);
  function coerceToTypes(optionCoerceTypes, dataTypes) {
    if (Array.isArray(dataTypes)) {
      var types = [];
      for (var i = 0; i < dataTypes.length; i++) {
        var t = dataTypes[i];
        if (COERCE_TO_TYPES[t]) types[types.length] = t;
        else if (optionCoerceTypes === 'array' && t === 'array')
          types[types.length] = t;
      }
      if (types.length) return types;
    } else if (COERCE_TO_TYPES[dataTypes]) {
      return [dataTypes];
    } else if (optionCoerceTypes === 'array' && dataTypes === 'array') {
      return ['array'];
    }
  }
  function toHash(arr) {
    var hash = {};
    for (var i = 0; i < arr.length; i++) hash[arr[i]] = true;
    return hash;
  }
  var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  var SINGLE_QUOTE = /'|\\/g;
  function getProperty(key) {
    return typeof key == 'number'
      ? '[' + key + ']'
      : IDENTIFIER.test(key)
      ? '.' + key
      : "['" + escapeQuotes(key) + "']";
  }
  function escapeQuotes(str) {
    return str
      .replace(SINGLE_QUOTE, '\\$&')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/\f/g, '\\f')
      .replace(/\t/g, '\\t');
  }
  function varOccurences(str, dataVar) {
    dataVar += '[^0-9]';
    var matches = str.match(new RegExp(dataVar, 'g'));
    return matches ? matches.length : 0;
  }
  function varReplace(str, dataVar, expr) {
    dataVar += '([^0-9])';
    expr = expr.replace(/\$/g, '$$$$');
    return str.replace(new RegExp(dataVar, 'g'), expr + '$1');
  }
  function schemaHasRules(schema, rules) {
    if (typeof schema == 'boolean') return !schema;
    for (var key in schema) if (rules[key]) return true;
  }
  function schemaHasRulesExcept(schema, rules, exceptKeyword) {
    if (typeof schema == 'boolean') return !schema && exceptKeyword != 'not';
    for (var key in schema) if (key != exceptKeyword && rules[key]) return true;
  }
  function schemaUnknownRules(schema, rules) {
    if (typeof schema == 'boolean') return;
    for (var key in schema) if (!rules[key]) return key;
  }
  function toQuotedString(str) {
    return "'" + escapeQuotes(str) + "'";
  }
  function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
    var path = jsonPointers
      ? "'/' + " +
        expr +
        (isNumber ? '' : ".replace(/~/g, '~0').replace(/\\//g, '~1')")
      : isNumber
      ? "'[' + " + expr + " + ']'"
      : "'[\\'' + " + expr + " + '\\']'";
    return joinPaths(currentPath, path);
  }
  function getPath(currentPath, prop, jsonPointers) {
    var path = jsonPointers
      ? toQuotedString('/' + escapeJsonPointer(prop))
      : toQuotedString(getProperty(prop));
    return joinPaths(currentPath, path);
  }
  var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
  var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function getData($data, lvl, paths) {
    var up, jsonPointer, data, matches;
    if ($data === '') return 'rootData';
    if ($data[0] == '/') {
      if (!JSON_POINTER.test($data))
        throw new Error('Invalid JSON-pointer: ' + $data);
      jsonPointer = $data;
      data = 'rootData';
    } else {
      matches = $data.match(RELATIVE_JSON_POINTER);
      if (!matches) throw new Error('Invalid JSON-pointer: ' + $data);
      up = +matches[1];
      jsonPointer = matches[2];
      if (jsonPointer == '#') {
        if (up >= lvl)
          throw new Error(
            'Cannot access property/index ' +
              up +
              ' levels up, current level is ' +
              lvl,
          );
        return paths[lvl - up];
      }
      if (up > lvl)
        throw new Error(
          'Cannot access data ' + up + ' levels up, current level is ' + lvl,
        );
      data = 'data' + (lvl - up || '');
      if (!jsonPointer) return data;
    }
    var expr = data;
    var segments = jsonPointer.split('/');
    for (var i = 0; i < segments.length; i++) {
      var segment = segments[i];
      if (segment) {
        data += getProperty(unescapeJsonPointer(segment));
        expr += ' && ' + data;
      }
    }
    return expr;
  }
  function joinPaths(a, b) {
    if (a == '""') return b;
    return (a + ' + ' + b).replace(/([^\\])' \+ '/g, '$1');
  }
  function unescapeFragment(str) {
    return unescapeJsonPointer(decodeURIComponent(str));
  }
  function escapeFragment(str) {
    return encodeURIComponent(escapeJsonPointer(str));
  }
  function escapeJsonPointer(str) {
    return str.replace(/~/g, '~0').replace(/\//g, '~1');
  }
  function unescapeJsonPointer(str) {
    return str.replace(/~1/g, '/').replace(/~0/g, '~');
  }
});

// node_modules/ajv/lib/compile/schema_obj.js
var require_schema_obj = __commonJS((exports2, module2) => {
  'use strict';
  var util = require_util3();
  module2.exports = SchemaObject;
  function SchemaObject(obj) {
    util.copy(obj, this);
  }
});

// node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS((exports2, module2) => {
  'use strict';
  var traverse = (module2.exports = function (schema, opts, cb) {
    if (typeof opts == 'function') {
      cb = opts;
      opts = {};
    }
    cb = opts.cb || cb;
    var pre = typeof cb == 'function' ? cb : cb.pre || function () {};
    var post = cb.post || function () {};
    _traverse(opts, pre, post, schema, '', schema);
  });
  traverse.keywords = {
    additionalItems: true,
    items: true,
    contains: true,
    additionalProperties: true,
    propertyNames: true,
    not: true,
  };
  traverse.arrayKeywords = {
    items: true,
    allOf: true,
    anyOf: true,
    oneOf: true,
  };
  traverse.propsKeywords = {
    definitions: true,
    properties: true,
    patternProperties: true,
    dependencies: true,
  };
  traverse.skipKeywords = {
    default: true,
    enum: true,
    const: true,
    required: true,
    maximum: true,
    minimum: true,
    exclusiveMaximum: true,
    exclusiveMinimum: true,
    multipleOf: true,
    maxLength: true,
    minLength: true,
    pattern: true,
    format: true,
    maxItems: true,
    minItems: true,
    uniqueItems: true,
    maxProperties: true,
    minProperties: true,
  };
  function _traverse(
    opts,
    pre,
    post,
    schema,
    jsonPtr,
    rootSchema,
    parentJsonPtr,
    parentKeyword,
    parentSchema,
    keyIndex,
  ) {
    if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
      pre(
        schema,
        jsonPtr,
        rootSchema,
        parentJsonPtr,
        parentKeyword,
        parentSchema,
        keyIndex,
      );
      for (var key in schema) {
        var sch = schema[key];
        if (Array.isArray(sch)) {
          if (key in traverse.arrayKeywords) {
            for (var i = 0; i < sch.length; i++)
              _traverse(
                opts,
                pre,
                post,
                sch[i],
                jsonPtr + '/' + key + '/' + i,
                rootSchema,
                jsonPtr,
                key,
                schema,
                i,
              );
          }
        } else if (key in traverse.propsKeywords) {
          if (sch && typeof sch == 'object') {
            for (var prop in sch)
              _traverse(
                opts,
                pre,
                post,
                sch[prop],
                jsonPtr + '/' + key + '/' + escapeJsonPtr(prop),
                rootSchema,
                jsonPtr,
                key,
                schema,
                prop,
              );
          }
        } else if (
          key in traverse.keywords ||
          (opts.allKeys && !(key in traverse.skipKeywords))
        ) {
          _traverse(
            opts,
            pre,
            post,
            sch,
            jsonPtr + '/' + key,
            rootSchema,
            jsonPtr,
            key,
            schema,
          );
        }
      }
      post(
        schema,
        jsonPtr,
        rootSchema,
        parentJsonPtr,
        parentKeyword,
        parentSchema,
        keyIndex,
      );
    }
  }
  function escapeJsonPtr(str) {
    return str.replace(/~/g, '~0').replace(/\//g, '~1');
  }
});

// node_modules/ajv/lib/compile/resolve.js
var require_resolve = __commonJS((exports2, module2) => {
  'use strict';
  var URI = require_uri_all();
  var equal = require_fast_deep_equal();
  var util = require_util3();
  var SchemaObject = require_schema_obj();
  var traverse = require_json_schema_traverse();
  module2.exports = resolve;
  resolve.normalizeId = normalizeId;
  resolve.fullPath = getFullPath;
  resolve.url = resolveUrl;
  resolve.ids = resolveIds;
  resolve.inlineRef = inlineRef;
  resolve.schema = resolveSchema;
  function resolve(compile, root, ref) {
    var refVal = this._refs[ref];
    if (typeof refVal == 'string') {
      if (this._refs[refVal]) refVal = this._refs[refVal];
      else return resolve.call(this, compile, root, refVal);
    }
    refVal = refVal || this._schemas[ref];
    if (refVal instanceof SchemaObject) {
      return inlineRef(refVal.schema, this._opts.inlineRefs)
        ? refVal.schema
        : refVal.validate || this._compile(refVal);
    }
    var res = resolveSchema.call(this, root, ref);
    var schema, v, baseId;
    if (res) {
      schema = res.schema;
      root = res.root;
      baseId = res.baseId;
    }
    if (schema instanceof SchemaObject) {
      v =
        schema.validate ||
        compile.call(this, schema.schema, root, void 0, baseId);
    } else if (schema !== void 0) {
      v = inlineRef(schema, this._opts.inlineRefs)
        ? schema
        : compile.call(this, schema, root, void 0, baseId);
    }
    return v;
  }
  function resolveSchema(root, ref) {
    var p = URI.parse(ref),
      refPath = _getFullPath(p),
      baseId = getFullPath(this._getId(root.schema));
    if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
      var id = normalizeId(refPath);
      var refVal = this._refs[id];
      if (typeof refVal == 'string') {
        return resolveRecursive.call(this, root, refVal, p);
      } else if (refVal instanceof SchemaObject) {
        if (!refVal.validate) this._compile(refVal);
        root = refVal;
      } else {
        refVal = this._schemas[id];
        if (refVal instanceof SchemaObject) {
          if (!refVal.validate) this._compile(refVal);
          if (id == normalizeId(ref)) return { schema: refVal, root, baseId };
          root = refVal;
        } else {
          return;
        }
      }
      if (!root.schema) return;
      baseId = getFullPath(this._getId(root.schema));
    }
    return getJsonPointer.call(this, p, baseId, root.schema, root);
  }
  function resolveRecursive(root, ref, parsedRef) {
    var res = resolveSchema.call(this, root, ref);
    if (res) {
      var schema = res.schema;
      var baseId = res.baseId;
      root = res.root;
      var id = this._getId(schema);
      if (id) baseId = resolveUrl(baseId, id);
      return getJsonPointer.call(this, parsedRef, baseId, schema, root);
    }
  }
  var PREVENT_SCOPE_CHANGE = util.toHash([
    'properties',
    'patternProperties',
    'enum',
    'dependencies',
    'definitions',
  ]);
  function getJsonPointer(parsedRef, baseId, schema, root) {
    parsedRef.fragment = parsedRef.fragment || '';
    if (parsedRef.fragment.slice(0, 1) != '/') return;
    var parts = parsedRef.fragment.split('/');
    for (var i = 1; i < parts.length; i++) {
      var part = parts[i];
      if (part) {
        part = util.unescapeFragment(part);
        schema = schema[part];
        if (schema === void 0) break;
        var id;
        if (!PREVENT_SCOPE_CHANGE[part]) {
          id = this._getId(schema);
          if (id) baseId = resolveUrl(baseId, id);
          if (schema.$ref) {
            var $ref = resolveUrl(baseId, schema.$ref);
            var res = resolveSchema.call(this, root, $ref);
            if (res) {
              schema = res.schema;
              root = res.root;
              baseId = res.baseId;
            }
          }
        }
      }
    }
    if (schema !== void 0 && schema !== root.schema)
      return { schema, root, baseId };
  }
  var SIMPLE_INLINED = util.toHash([
    'type',
    'format',
    'pattern',
    'maxLength',
    'minLength',
    'maxProperties',
    'minProperties',
    'maxItems',
    'minItems',
    'maximum',
    'minimum',
    'uniqueItems',
    'multipleOf',
    'required',
    'enum',
  ]);
  function inlineRef(schema, limit) {
    if (limit === false) return false;
    if (limit === void 0 || limit === true) return checkNoRef(schema);
    else if (limit) return countKeys(schema) <= limit;
  }
  function checkNoRef(schema) {
    var item;
    if (Array.isArray(schema)) {
      for (var i = 0; i < schema.length; i++) {
        item = schema[i];
        if (typeof item == 'object' && !checkNoRef(item)) return false;
      }
    } else {
      for (var key in schema) {
        if (key == '$ref') return false;
        item = schema[key];
        if (typeof item == 'object' && !checkNoRef(item)) return false;
      }
    }
    return true;
  }
  function countKeys(schema) {
    var count = 0,
      item;
    if (Array.isArray(schema)) {
      for (var i = 0; i < schema.length; i++) {
        item = schema[i];
        if (typeof item == 'object') count += countKeys(item);
        if (count == Infinity) return Infinity;
      }
    } else {
      for (var key in schema) {
        if (key == '$ref') return Infinity;
        if (SIMPLE_INLINED[key]) {
          count++;
        } else {
          item = schema[key];
          if (typeof item == 'object') count += countKeys(item) + 1;
          if (count == Infinity) return Infinity;
        }
      }
    }
    return count;
  }
  function getFullPath(id, normalize) {
    if (normalize !== false) id = normalizeId(id);
    var p = URI.parse(id);
    return _getFullPath(p);
  }
  function _getFullPath(p) {
    return URI.serialize(p).split('#')[0] + '#';
  }
  var TRAILING_SLASH_HASH = /#\/?$/;
  function normalizeId(id) {
    return id ? id.replace(TRAILING_SLASH_HASH, '') : '';
  }
  function resolveUrl(baseId, id) {
    id = normalizeId(id);
    return URI.resolve(baseId, id);
  }
  function resolveIds(schema) {
    var schemaId = normalizeId(this._getId(schema));
    var baseIds = { '': schemaId };
    var fullPaths = { '': getFullPath(schemaId, false) };
    var localRefs = {};
    var self2 = this;
    traverse(
      schema,
      { allKeys: true },
      function (
        sch,
        jsonPtr,
        rootSchema,
        parentJsonPtr,
        parentKeyword,
        parentSchema,
        keyIndex,
      ) {
        if (jsonPtr === '') return;
        var id = self2._getId(sch);
        var baseId = baseIds[parentJsonPtr];
        var fullPath = fullPaths[parentJsonPtr] + '/' + parentKeyword;
        if (keyIndex !== void 0)
          fullPath +=
            '/' +
            (typeof keyIndex == 'number'
              ? keyIndex
              : util.escapeFragment(keyIndex));
        if (typeof id == 'string') {
          id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);
          var refVal = self2._refs[id];
          if (typeof refVal == 'string') refVal = self2._refs[refVal];
          if (refVal && refVal.schema) {
            if (!equal(sch, refVal.schema))
              throw new Error(
                'id "' + id + '" resolves to more than one schema',
              );
          } else if (id != normalizeId(fullPath)) {
            if (id[0] == '#') {
              if (localRefs[id] && !equal(sch, localRefs[id]))
                throw new Error(
                  'id "' + id + '" resolves to more than one schema',
                );
              localRefs[id] = sch;
            } else {
              self2._refs[id] = fullPath;
            }
          }
        }
        baseIds[jsonPtr] = baseId;
        fullPaths[jsonPtr] = fullPath;
      },
    );
    return localRefs;
  }
});

// node_modules/ajv/lib/compile/error_classes.js
var require_error_classes = __commonJS((exports2, module2) => {
  'use strict';
  var resolve = require_resolve();
  module2.exports = {
    Validation: errorSubclass(ValidationError),
    MissingRef: errorSubclass(MissingRefError),
  };
  function ValidationError(errors) {
    this.message = 'validation failed';
    this.errors = errors;
    this.ajv = this.validation = true;
  }
  MissingRefError.message = function (baseId, ref) {
    return "can't resolve reference " + ref + ' from id ' + baseId;
  };
  function MissingRefError(baseId, ref, message) {
    this.message = message || MissingRefError.message(baseId, ref);
    this.missingRef = resolve.url(baseId, ref);
    this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
  }
  function errorSubclass(Subclass) {
    Subclass.prototype = Object.create(Error.prototype);
    Subclass.prototype.constructor = Subclass;
    return Subclass;
  }
});

// node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = function (data, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var cycles = typeof opts.cycles === 'boolean' ? opts.cycles : false;
    var cmp =
      opts.cmp &&
      (function (f) {
        return function (node) {
          return function (a, b) {
            var aobj = { key: a, value: node[a] };
            var bobj = { key: b, value: node[b] };
            return f(aobj, bobj);
          };
        };
      })(opts.cmp);
    var seen = [];
    return (function stringify(node) {
      if (node && node.toJSON && typeof node.toJSON === 'function') {
        node = node.toJSON();
      }
      if (node === void 0) return;
      if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
      if (typeof node !== 'object') return JSON.stringify(node);
      var i, out;
      if (Array.isArray(node)) {
        out = '[';
        for (i = 0; i < node.length; i++) {
          if (i) out += ',';
          out += stringify(node[i]) || 'null';
        }
        return out + ']';
      }
      if (node === null) return 'null';
      if (seen.indexOf(node) !== -1) {
        if (cycles) return JSON.stringify('__cycle__');
        throw new TypeError('Converting circular structure to JSON');
      }
      var seenIndex = seen.push(node) - 1;
      var keys = Object.keys(node).sort(cmp && cmp(node));
      out = '';
      for (i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = stringify(node[key]);
        if (!value) continue;
        if (out) out += ',';
        out += JSON.stringify(key) + ':' + value;
      }
      seen.splice(seenIndex, 1);
      return '{' + out + '}';
    })(data);
  };
});

// node_modules/ajv/lib/dotjs/validate.js
var require_validate3 = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = function generate_validate(it, $keyword, $ruleType) {
    var out = '';
    var $async = it.schema.$async === true,
      $refKeywords = it.util.schemaHasRulesExcept(
        it.schema,
        it.RULES.all,
        '$ref',
      ),
      $id = it.self._getId(it.schema);
    if (it.opts.strictKeywords) {
      var $unknownKwd = it.util.schemaUnknownRules(
        it.schema,
        it.RULES.keywords,
      );
      if ($unknownKwd) {
        var $keywordsMsg = 'unknown keyword: ' + $unknownKwd;
        if (it.opts.strictKeywords === 'log') it.logger.warn($keywordsMsg);
        else throw new Error($keywordsMsg);
      }
    }
    if (it.isTop) {
      out += ' var validate = ';
      if ($async) {
        it.async = true;
        out += 'async ';
      }
      out +=
        "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ";
      if ($id && (it.opts.sourceCode || it.opts.processCode)) {
        out += ' ' + ('/*# sourceURL=' + $id + ' */') + ' ';
      }
    }
    if (typeof it.schema == 'boolean' || !($refKeywords || it.schema.$ref)) {
      var $keyword = 'false schema';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      if (it.schema === false) {
        if (it.isTop) {
          $breakOnError = true;
        } else {
          out += ' var ' + $valid + ' = false; ';
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = '';
        if (it.createErrors !== false) {
          out +=
            " { keyword: '" +
            ($errorKeyword || 'false schema') +
            "' , dataPath: (dataPath || '') + " +
            it.errorPath +
            ' , schemaPath: ' +
            it.util.toQuotedString($errSchemaPath) +
            ' , params: {} ';
          if (it.opts.messages !== false) {
            out += " , message: 'boolean schema is false' ";
          }
          if (it.opts.verbose) {
            out +=
              ' , schema: false , parentSchema: validate.schema' +
              it.schemaPath +
              ' , data: ' +
              $data +
              ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += ' throw new ValidationError([' + __err + ']); ';
          } else {
            out += ' validate.errors = [' + __err + ']; return false; ';
          }
        } else {
          out +=
            ' var err = ' +
            __err +
            ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
      } else {
        if (it.isTop) {
          if ($async) {
            out += ' return data; ';
          } else {
            out += ' validate.errors = null; return true; ';
          }
        } else {
          out += ' var ' + $valid + ' = true; ';
        }
      }
      if (it.isTop) {
        out += ' }; return validate; ';
      }
      return out;
    }
    if (it.isTop) {
      var $top = it.isTop,
        $lvl = (it.level = 0),
        $dataLvl = (it.dataLevel = 0),
        $data = 'data';
      it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
      it.baseId = it.baseId || it.rootId;
      delete it.isTop;
      it.dataPathArr = [''];
      if (
        it.schema.default !== void 0 &&
        it.opts.useDefaults &&
        it.opts.strictDefaults
      ) {
        var $defaultMsg = 'default is ignored in the schema root';
        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
        else throw new Error($defaultMsg);
      }
      out += ' var vErrors = null; ';
      out += ' var errors = 0;     ';
      out += ' if (rootData === undefined) rootData = data; ';
    } else {
      var $lvl = it.level,
        $dataLvl = it.dataLevel,
        $data = 'data' + ($dataLvl || '');
      if ($id) it.baseId = it.resolve.url(it.baseId, $id);
      if ($async && !it.async) throw new Error('async schema in sync schema');
      out += ' var errs_' + $lvl + ' = errors;';
    }
    var $valid = 'valid' + $lvl,
      $breakOnError = !it.opts.allErrors,
      $closingBraces1 = '',
      $closingBraces2 = '';
    var $errorKeyword;
    var $typeSchema = it.schema.type,
      $typeIsArray = Array.isArray($typeSchema);
    if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
      if ($typeIsArray) {
        if ($typeSchema.indexOf('null') == -1)
          $typeSchema = $typeSchema.concat('null');
      } else if ($typeSchema != 'null') {
        $typeSchema = [$typeSchema, 'null'];
        $typeIsArray = true;
      }
    }
    if ($typeIsArray && $typeSchema.length == 1) {
      $typeSchema = $typeSchema[0];
      $typeIsArray = false;
    }
    if (it.schema.$ref && $refKeywords) {
      if (it.opts.extendRefs == 'fail') {
        throw new Error(
          '$ref: validation keywords used in schema at path "' +
            it.errSchemaPath +
            '" (see option extendRefs)',
        );
      } else if (it.opts.extendRefs !== true) {
        $refKeywords = false;
        it.logger.warn(
          '$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"',
        );
      }
    }
    if (it.schema.$comment && it.opts.$comment) {
      out += ' ' + it.RULES.all.$comment.code(it, '$comment');
    }
    if ($typeSchema) {
      if (it.opts.coerceTypes) {
        var $coerceToTypes = it.util.coerceToTypes(
          it.opts.coerceTypes,
          $typeSchema,
        );
      }
      var $rulesGroup = it.RULES.types[$typeSchema];
      if (
        $coerceToTypes ||
        $typeIsArray ||
        $rulesGroup === true ||
        ($rulesGroup && !$shouldUseGroup($rulesGroup))
      ) {
        var $schemaPath = it.schemaPath + '.type',
          $errSchemaPath = it.errSchemaPath + '/type';
        var $schemaPath = it.schemaPath + '.type',
          $errSchemaPath = it.errSchemaPath + '/type',
          $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';
        out +=
          ' if (' +
          it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true) +
          ') { ';
        if ($coerceToTypes) {
          var $dataType = 'dataType' + $lvl,
            $coerced = 'coerced' + $lvl;
          out +=
            ' var ' +
            $dataType +
            ' = typeof ' +
            $data +
            '; var ' +
            $coerced +
            ' = undefined; ';
          if (it.opts.coerceTypes == 'array') {
            out +=
              ' if (' +
              $dataType +
              " == 'object' && Array.isArray(" +
              $data +
              ') && ' +
              $data +
              '.length == 1) { ' +
              $data +
              ' = ' +
              $data +
              '[0]; ' +
              $dataType +
              ' = typeof ' +
              $data +
              '; if (' +
              it.util.checkDataType(
                it.schema.type,
                $data,
                it.opts.strictNumbers,
              ) +
              ') ' +
              $coerced +
              ' = ' +
              $data +
              '; } ';
          }
          out += ' if (' + $coerced + ' !== undefined) ; ';
          var arr1 = $coerceToTypes;
          if (arr1) {
            var $type,
              $i = -1,
              l1 = arr1.length - 1;
            while ($i < l1) {
              $type = arr1[($i += 1)];
              if ($type == 'string') {
                out +=
                  ' else if (' +
                  $dataType +
                  " == 'number' || " +
                  $dataType +
                  " == 'boolean') " +
                  $coerced +
                  " = '' + " +
                  $data +
                  '; else if (' +
                  $data +
                  ' === null) ' +
                  $coerced +
                  " = ''; ";
              } else if ($type == 'number' || $type == 'integer') {
                out +=
                  ' else if (' +
                  $dataType +
                  " == 'boolean' || " +
                  $data +
                  ' === null || (' +
                  $dataType +
                  " == 'string' && " +
                  $data +
                  ' && ' +
                  $data +
                  ' == +' +
                  $data +
                  ' ';
                if ($type == 'integer') {
                  out += ' && !(' + $data + ' % 1)';
                }
                out += ')) ' + $coerced + ' = +' + $data + '; ';
              } else if ($type == 'boolean') {
                out +=
                  ' else if (' +
                  $data +
                  " === 'false' || " +
                  $data +
                  ' === 0 || ' +
                  $data +
                  ' === null) ' +
                  $coerced +
                  ' = false; else if (' +
                  $data +
                  " === 'true' || " +
                  $data +
                  ' === 1) ' +
                  $coerced +
                  ' = true; ';
              } else if ($type == 'null') {
                out +=
                  ' else if (' +
                  $data +
                  " === '' || " +
                  $data +
                  ' === 0 || ' +
                  $data +
                  ' === false) ' +
                  $coerced +
                  ' = null; ';
              } else if (it.opts.coerceTypes == 'array' && $type == 'array') {
                out +=
                  ' else if (' +
                  $dataType +
                  " == 'string' || " +
                  $dataType +
                  " == 'number' || " +
                  $dataType +
                  " == 'boolean' || " +
                  $data +
                  ' == null) ' +
                  $coerced +
                  ' = [' +
                  $data +
                  ']; ';
              }
            }
          }
          out += ' else {   ';
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = '';
          if (it.createErrors !== false) {
            out +=
              " { keyword: '" +
              ($errorKeyword || 'type') +
              "' , dataPath: (dataPath || '') + " +
              it.errorPath +
              ' , schemaPath: ' +
              it.util.toQuotedString($errSchemaPath) +
              " , params: { type: '";
            if ($typeIsArray) {
              out += '' + $typeSchema.join(',');
            } else {
              out += '' + $typeSchema;
            }
            out += "' } ";
            if (it.opts.messages !== false) {
              out += " , message: 'should be ";
              if ($typeIsArray) {
                out += '' + $typeSchema.join(',');
              } else {
                out += '' + $typeSchema;
              }
              out += "' ";
            }
            if (it.opts.verbose) {
              out +=
                ' , schema: validate.schema' +
                $schemaPath +
                ' , parentSchema: validate.schema' +
                it.schemaPath +
                ' , data: ' +
                $data +
                ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += ' throw new ValidationError([' + __err + ']); ';
            } else {
              out += ' validate.errors = [' + __err + ']; return false; ';
            }
          } else {
            out +=
              ' var err = ' +
              __err +
              ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
          out += ' } if (' + $coerced + ' !== undefined) {  ';
          var $parentData = $dataLvl
              ? 'data' + ($dataLvl - 1 || '')
              : 'parentData',
            $parentDataProperty = $dataLvl
              ? it.dataPathArr[$dataLvl]
              : 'parentDataProperty';
          out += ' ' + $data + ' = ' + $coerced + '; ';
          if (!$dataLvl) {
            out += 'if (' + $parentData + ' !== undefined)';
          }
          out +=
            ' ' +
            $parentData +
            '[' +
            $parentDataProperty +
            '] = ' +
            $coerced +
            '; } ';
        } else {
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = '';
          if (it.createErrors !== false) {
            out +=
              " { keyword: '" +
              ($errorKeyword || 'type') +
              "' , dataPath: (dataPath || '') + " +
              it.errorPath +
              ' , schemaPath: ' +
              it.util.toQuotedString($errSchemaPath) +
              " , params: { type: '";
            if ($typeIsArray) {
              out += '' + $typeSchema.join(',');
            } else {
              out += '' + $typeSchema;
            }
            out += "' } ";
            if (it.opts.messages !== false) {
              out += " , message: 'should be ";
              if ($typeIsArray) {
                out += '' + $typeSchema.join(',');
              } else {
                out += '' + $typeSchema;
              }
              out += "' ";
            }
            if (it.opts.verbose) {
              out +=
                ' , schema: validate.schema' +
                $schemaPath +
                ' , parentSchema: validate.schema' +
                it.schemaPath +
                ' , data: ' +
                $data +
                ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += ' throw new ValidationError([' + __err + ']); ';
            } else {
              out += ' validate.errors = [' + __err + ']; return false; ';
            }
          } else {
            out +=
              ' var err = ' +
              __err +
              ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
        }
        out += ' } ';
      }
    }
    if (it.schema.$ref && !$refKeywords) {
      out += ' ' + it.RULES.all.$ref.code(it, '$ref') + ' ';
      if ($breakOnError) {
        out += ' } if (errors === ';
        if ($top) {
          out += '0';
        } else {
          out += 'errs_' + $lvl;
        }
        out += ') { ';
        $closingBraces2 += '}';
      }
    } else {
      var arr2 = it.RULES;
      if (arr2) {
        var $rulesGroup,
          i2 = -1,
          l2 = arr2.length - 1;
        while (i2 < l2) {
          $rulesGroup = arr2[(i2 += 1)];
          if ($shouldUseGroup($rulesGroup)) {
            if ($rulesGroup.type) {
              out +=
                ' if (' +
                it.util.checkDataType(
                  $rulesGroup.type,
                  $data,
                  it.opts.strictNumbers,
                ) +
                ') { ';
            }
            if (it.opts.useDefaults) {
              if ($rulesGroup.type == 'object' && it.schema.properties) {
                var $schema = it.schema.properties,
                  $schemaKeys = Object.keys($schema);
                var arr3 = $schemaKeys;
                if (arr3) {
                  var $propertyKey,
                    i3 = -1,
                    l3 = arr3.length - 1;
                  while (i3 < l3) {
                    $propertyKey = arr3[(i3 += 1)];
                    var $sch = $schema[$propertyKey];
                    if ($sch.default !== void 0) {
                      var $passData = $data + it.util.getProperty($propertyKey);
                      if (it.compositeRule) {
                        if (it.opts.strictDefaults) {
                          var $defaultMsg =
                            'default is ignored for: ' + $passData;
                          if (it.opts.strictDefaults === 'log')
                            it.logger.warn($defaultMsg);
                          else throw new Error($defaultMsg);
                        }
                      } else {
                        out += ' if (' + $passData + ' === undefined ';
                        if (it.opts.useDefaults == 'empty') {
                          out +=
                            ' || ' +
                            $passData +
                            ' === null || ' +
                            $passData +
                            " === '' ";
                        }
                        out += ' ) ' + $passData + ' = ';
                        if (it.opts.useDefaults == 'shared') {
                          out += ' ' + it.useDefault($sch.default) + ' ';
                        } else {
                          out += ' ' + JSON.stringify($sch.default) + ' ';
                        }
                        out += '; ';
                      }
                    }
                  }
                }
              } else if (
                $rulesGroup.type == 'array' &&
                Array.isArray(it.schema.items)
              ) {
                var arr4 = it.schema.items;
                if (arr4) {
                  var $sch,
                    $i = -1,
                    l4 = arr4.length - 1;
                  while ($i < l4) {
                    $sch = arr4[($i += 1)];
                    if ($sch.default !== void 0) {
                      var $passData = $data + '[' + $i + ']';
                      if (it.compositeRule) {
                        if (it.opts.strictDefaults) {
                          var $defaultMsg =
                            'default is ignored for: ' + $passData;
                          if (it.opts.strictDefaults === 'log')
                            it.logger.warn($defaultMsg);
                          else throw new Error($defaultMsg);
                        }
                      } else {
                        out += ' if (' + $passData + ' === undefined ';
                        if (it.opts.useDefaults == 'empty') {
                          out +=
                            ' || ' +
                            $passData +
                            ' === null || ' +
                            $passData +
                            " === '' ";
                        }
                        out += ' ) ' + $passData + ' = ';
                        if (it.opts.useDefaults == 'shared') {
                          out += ' ' + it.useDefault($sch.default) + ' ';
                        } else {
                          out += ' ' + JSON.stringify($sch.default) + ' ';
                        }
                        out += '; ';
                      }
                    }
                  }
                }
              }
            }
            var arr5 = $rulesGroup.rules;
            if (arr5) {
              var $rule,
                i5 = -1,
                l5 = arr5.length - 1;
              while (i5 < l5) {
                $rule = arr5[(i5 += 1)];
                if ($shouldUseRule($rule)) {
                  var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                  if ($code) {
                    out += ' ' + $code + ' ';
                    if ($breakOnError) {
                      $closingBraces1 += '}';
                    }
                  }
                }
              }
            }
            if ($breakOnError) {
              out += ' ' + $closingBraces1 + ' ';
              $closingBraces1 = '';
            }
            if ($rulesGroup.type) {
              out += ' } ';
              if (
                $typeSchema &&
                $typeSchema === $rulesGroup.type &&
                !$coerceToTypes
              ) {
                out += ' else { ';
                var $schemaPath = it.schemaPath + '.type',
                  $errSchemaPath = it.errSchemaPath + '/type';
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = '';
                if (it.createErrors !== false) {
                  out +=
                    " { keyword: '" +
                    ($errorKeyword || 'type') +
                    "' , dataPath: (dataPath || '') + " +
                    it.errorPath +
                    ' , schemaPath: ' +
                    it.util.toQuotedString($errSchemaPath) +
                    " , params: { type: '";
                  if ($typeIsArray) {
                    out += '' + $typeSchema.join(',');
                  } else {
                    out += '' + $typeSchema;
                  }
                  out += "' } ";
                  if (it.opts.messages !== false) {
                    out += " , message: 'should be ";
                    if ($typeIsArray) {
                      out += '' + $typeSchema.join(',');
                    } else {
                      out += '' + $typeSchema;
                    }
                    out += "' ";
                  }
                  if (it.opts.verbose) {
                    out +=
                      ' , schema: validate.schema' +
                      $schemaPath +
                      ' , parentSchema: validate.schema' +
                      it.schemaPath +
                      ' , data: ' +
                      $data +
                      ' ';
                  }
                  out += ' } ';
                } else {
                  out += ' {} ';
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                  if (it.async) {
                    out += ' throw new ValidationError([' + __err + ']); ';
                  } else {
                    out += ' validate.errors = [' + __err + ']; return false; ';
                  }
                } else {
                  out +=
                    ' var err = ' +
                    __err +
                    ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                }
                out += ' } ';
              }
            }
            if ($breakOnError) {
              out += ' if (errors === ';
              if ($top) {
                out += '0';
              } else {
                out += 'errs_' + $lvl;
              }
              out += ') { ';
              $closingBraces2 += '}';
            }
          }
        }
      }
    }
    if ($breakOnError) {
      out += ' ' + $closingBraces2 + ' ';
    }
    if ($top) {
      if ($async) {
        out += ' if (errors === 0) return data;           ';
        out += ' else throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; ';
        out += ' return errors === 0;       ';
      }
      out += ' }; return validate;';
    } else {
      out += ' var ' + $valid + ' = errors === errs_' + $lvl + ';';
    }
    function $shouldUseGroup($rulesGroup2) {
      var rules = $rulesGroup2.rules;
      for (var i = 0; i < rules.length; i++)
        if ($shouldUseRule(rules[i])) return true;
    }
    function $shouldUseRule($rule2) {
      return (
        it.schema[$rule2.keyword] !== void 0 ||
        ($rule2.implements && $ruleImplementsSomeKeyword($rule2))
      );
    }
    function $ruleImplementsSomeKeyword($rule2) {
      var impl = $rule2.implements;
      for (var i = 0; i < impl.length; i++)
        if (it.schema[impl[i]] !== void 0) return true;
    }
    return out;
  };
});

// node_modules/ajv/lib/compile/index.js
var require_compile = __commonJS((exports2, module2) => {
  'use strict';
  var resolve = require_resolve();
  var util = require_util3();
  var errorClasses = require_error_classes();
  var stableStringify = require_fast_json_stable_stringify();
  var validateGenerator = require_validate3();
  var ucs2length = util.ucs2length;
  var equal = require_fast_deep_equal();
  var ValidationError = errorClasses.Validation;
  module2.exports = compile;
  function compile(schema, root, localRefs, baseId) {
    var self2 = this,
      opts = this._opts,
      refVal = [void 0],
      refs = {},
      patterns = [],
      patternsHash = {},
      defaults = [],
      defaultsHash = {},
      customRules = [];
    root = root || { schema, refVal, refs };
    var c = checkCompiling.call(this, schema, root, baseId);
    var compilation = this._compilations[c.index];
    if (c.compiling) return (compilation.callValidate = callValidate);
    var formats = this._formats;
    var RULES = this.RULES;
    try {
      var v = localCompile(schema, root, localRefs, baseId);
      compilation.validate = v;
      var cv = compilation.callValidate;
      if (cv) {
        cv.schema = v.schema;
        cv.errors = null;
        cv.refs = v.refs;
        cv.refVal = v.refVal;
        cv.root = v.root;
        cv.$async = v.$async;
        if (opts.sourceCode) cv.source = v.source;
      }
      return v;
    } finally {
      endCompiling.call(this, schema, root, baseId);
    }
    function callValidate() {
      var validate = compilation.validate;
      var result = validate.apply(this, arguments);
      callValidate.errors = validate.errors;
      return result;
    }
    function localCompile(_schema, _root, localRefs2, baseId2) {
      var isRoot = !_root || (_root && _root.schema == _schema);
      if (_root.schema != root.schema)
        return compile.call(self2, _schema, _root, localRefs2, baseId2);
      var $async = _schema.$async === true;
      var sourceCode = validateGenerator({
        isTop: true,
        schema: _schema,
        isRoot,
        baseId: baseId2,
        root: _root,
        schemaPath: '',
        errSchemaPath: '#',
        errorPath: '""',
        MissingRefError: errorClasses.MissingRef,
        RULES,
        validate: validateGenerator,
        util,
        resolve,
        resolveRef,
        usePattern,
        useDefault,
        useCustomRule,
        opts,
        formats,
        logger: self2.logger,
        self: self2,
      });
      sourceCode =
        vars(refVal, refValCode) +
        vars(patterns, patternCode) +
        vars(defaults, defaultCode) +
        vars(customRules, customRuleCode) +
        sourceCode;
      if (opts.processCode) sourceCode = opts.processCode(sourceCode, _schema);
      var validate;
      try {
        var makeValidate = new Function(
          'self',
          'RULES',
          'formats',
          'root',
          'refVal',
          'defaults',
          'customRules',
          'equal',
          'ucs2length',
          'ValidationError',
          sourceCode,
        );
        validate = makeValidate(
          self2,
          RULES,
          formats,
          root,
          refVal,
          defaults,
          customRules,
          equal,
          ucs2length,
          ValidationError,
        );
        refVal[0] = validate;
      } catch (e) {
        self2.logger.error(
          'Error compiling schema, function code:',
          sourceCode,
        );
        throw e;
      }
      validate.schema = _schema;
      validate.errors = null;
      validate.refs = refs;
      validate.refVal = refVal;
      validate.root = isRoot ? validate : _root;
      if ($async) validate.$async = true;
      if (opts.sourceCode === true) {
        validate.source = {
          code: sourceCode,
          patterns,
          defaults,
        };
      }
      return validate;
    }
    function resolveRef(baseId2, ref, isRoot) {
      ref = resolve.url(baseId2, ref);
      var refIndex = refs[ref];
      var _refVal, refCode;
      if (refIndex !== void 0) {
        _refVal = refVal[refIndex];
        refCode = 'refVal[' + refIndex + ']';
        return resolvedRef(_refVal, refCode);
      }
      if (!isRoot && root.refs) {
        var rootRefId = root.refs[ref];
        if (rootRefId !== void 0) {
          _refVal = root.refVal[rootRefId];
          refCode = addLocalRef(ref, _refVal);
          return resolvedRef(_refVal, refCode);
        }
      }
      refCode = addLocalRef(ref);
      var v2 = resolve.call(self2, localCompile, root, ref);
      if (v2 === void 0) {
        var localSchema = localRefs && localRefs[ref];
        if (localSchema) {
          v2 = resolve.inlineRef(localSchema, opts.inlineRefs)
            ? localSchema
            : compile.call(self2, localSchema, root, localRefs, baseId2);
        }
      }
      if (v2 === void 0) {
        removeLocalRef(ref);
      } else {
        replaceLocalRef(ref, v2);
        return resolvedRef(v2, refCode);
      }
    }
    function addLocalRef(ref, v2) {
      var refId = refVal.length;
      refVal[refId] = v2;
      refs[ref] = refId;
      return 'refVal' + refId;
    }
    function removeLocalRef(ref) {
      delete refs[ref];
    }
    function replaceLocalRef(ref, v2) {
      var refId = refs[ref];
      refVal[refId] = v2;
    }
    function resolvedRef(refVal2, code) {
      return typeof refVal2 == 'object' || typeof refVal2 == 'boolean'
        ? { code, schema: refVal2, inline: true }
        : { code, $async: refVal2 && !!refVal2.$async };
    }
    function usePattern(regexStr) {
      var index = patternsHash[regexStr];
      if (index === void 0) {
        index = patternsHash[regexStr] = patterns.length;
        patterns[index] = regexStr;
      }
      return 'pattern' + index;
    }
    function useDefault(value) {
      switch (typeof value) {
        case 'boolean':
        case 'number':
          return '' + value;
        case 'string':
          return util.toQuotedString(value);
        case 'object':
          if (value === null) return 'null';
          var valueStr = stableStringify(value);
          var index = defaultsHash[valueStr];
          if (index === void 0) {
            index = defaultsHash[valueStr] = defaults.length;
            defaults[index] = value;
          }
          return 'default' + index;
      }
    }
    function useCustomRule(rule, schema2, parentSchema, it) {
      if (self2._opts.validateSchema !== false) {
        var deps = rule.definition.dependencies;
        if (
          deps &&
          !deps.every(function (keyword) {
            return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
          })
        )
          throw new Error(
            'parent schema must have all required keywords: ' + deps.join(','),
          );
        var validateSchema = rule.definition.validateSchema;
        if (validateSchema) {
          var valid = validateSchema(schema2);
          if (!valid) {
            var message =
              'keyword schema is invalid: ' +
              self2.errorsText(validateSchema.errors);
            if (self2._opts.validateSchema == 'log')
              self2.logger.error(message);
            else throw new Error(message);
          }
        }
      }
      var compile2 = rule.definition.compile,
        inline = rule.definition.inline,
        macro = rule.definition.macro;
      var validate;
      if (compile2) {
        validate = compile2.call(self2, schema2, parentSchema, it);
      } else if (macro) {
        validate = macro.call(self2, schema2, parentSchema, it);
        if (opts.validateSchema !== false) self2.validateSchema(validate, true);
      } else if (inline) {
        validate = inline.call(self2, it, rule.keyword, schema2, parentSchema);
      } else {
        validate = rule.definition.validate;
        if (!validate) return;
      }
      if (validate === void 0)
        throw new Error(
          'custom keyword "' + rule.keyword + '"failed to compile',
        );
      var index = customRules.length;
      customRules[index] = validate;
      return {
        code: 'customRule' + index,
        validate,
      };
    }
  }
  function checkCompiling(schema, root, baseId) {
    var index = compIndex.call(this, schema, root, baseId);
    if (index >= 0) return { index, compiling: true };
    index = this._compilations.length;
    this._compilations[index] = {
      schema,
      root,
      baseId,
    };
    return { index, compiling: false };
  }
  function endCompiling(schema, root, baseId) {
    var i = compIndex.call(this, schema, root, baseId);
    if (i >= 0) this._compilations.splice(i, 1);
  }
  function compIndex(schema, root, baseId) {
    for (var i = 0; i < this._compilations.length; i++) {
      var c = this._compilations[i];
      if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
    }
    return -1;
  }
  function patternCode(i, patterns) {
    return (
      'var pattern' +
      i +
      ' = new RegExp(' +
      util.toQuotedString(patterns[i]) +
      ');'
    );
  }
  function defaultCode(i) {
    return 'var default' + i + ' = defaults[' + i + '];';
  }
  function refValCode(i, refVal) {
    return refVal[i] === void 0
      ? ''
      : 'var refVal' + i + ' = refVal[' + i + '];';
  }
  function customRuleCode(i) {
    return 'var customRule' + i + ' = customRules[' + i + '];';
  }
  function vars(arr, statement) {
    if (!arr.length) return '';
    var code = '';
    for (var i = 0; i < arr.length; i++) code += statement(i, arr);
    return code;
  }
});

// node_modules/ajv/lib/cache.js
var require_cache = __commonJS((exports2, module2) => {
  'use strict';
  var Cache = (module2.exports = function Cache2() {
    this._cache = {};
  });
  Cache.prototype.put = function Cache_put(key, value) {
    this._cache[key] = value;
  };
  Cache.prototype.get = function Cache_get(key) {
    return this._cache[key];
  };
  Cache.prototype.del = function Cache_del(key) {
    delete this._cache[key];
  };
  Cache.prototype.clear = function Cache_clear() {
    this._cache = {};
  };
});

// node_modules/ajv/lib/compile/formats.js
var require_formats2 = __commonJS((exports2, module2) => {
  'use strict';
  var util = require_util3();
  var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
  var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
  var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
  var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
  var URL = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
  var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
  var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
  var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
  var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
  module2.exports = formats;
  function formats(mode) {
    mode = mode == 'full' ? 'full' : 'fast';
    return util.copy(formats[mode]);
  }
  formats.fast = {
    date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
    time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
    'date-time': /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    'uri-reference': /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    'uri-template': URITEMPLATE,
    url: URL,
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
    hostname: HOSTNAME,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
    regex,
    uuid: UUID,
    'json-pointer': JSON_POINTER,
    'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
    'relative-json-pointer': RELATIVE_JSON_POINTER,
  };
  formats.full = {
    date,
    time,
    'date-time': date_time,
    uri,
    'uri-reference': URIREF,
    'uri-template': URITEMPLATE,
    url: URL,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: HOSTNAME,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
    regex,
    uuid: UUID,
    'json-pointer': JSON_POINTER,
    'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
    'relative-json-pointer': RELATIVE_JSON_POINTER,
  };
  function isLeapYear(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }
  function date(str) {
    var matches = str.match(DATE);
    if (!matches) return false;
    var year = +matches[1];
    var month = +matches[2];
    var day = +matches[3];
    return (
      month >= 1 &&
      month <= 12 &&
      day >= 1 &&
      day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month])
    );
  }
  function time(str, full) {
    var matches = str.match(TIME);
    if (!matches) return false;
    var hour = matches[1];
    var minute = matches[2];
    var second = matches[3];
    var timeZone = matches[5];
    return (
      ((hour <= 23 && minute <= 59 && second <= 59) ||
        (hour == 23 && minute == 59 && second == 60)) &&
      (!full || timeZone)
    );
  }
  var DATE_TIME_SEPARATOR = /t|\s/i;
  function date_time(str) {
    var dateTime = str.split(DATE_TIME_SEPARATOR);
    return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
  }
  var NOT_URI_FRAGMENT = /\/|:/;
  function uri(str) {
    return NOT_URI_FRAGMENT.test(str) && URI.test(str);
  }
  var Z_ANCHOR = /[^\\]\\Z/;
  function regex(str) {
    if (Z_ANCHOR.test(str)) return false;
    try {
      new RegExp(str);
      return true;
    } catch (e) {
      return false;
    }
  }
});

// node_modules/ajv/lib/dotjs/ref.js
var require_ref = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = function generate_ref(it, $keyword, $ruleType) {
    var out = ' ';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = 'data' + ($dataLvl || '');
    var $valid = 'valid' + $lvl;
    var $async, $refCode;
    if ($schema == '#' || $schema == '#/') {
      if (it.isRoot) {
        $async = it.async;
        $refCode = 'validate';
      } else {
        $async = it.root.schema.$async === true;
        $refCode = 'root.refVal[0]';
      }
    } else {
      var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
      if ($refVal === void 0) {
        var $message = it.MissingRefError.message(it.baseId, $schema);
        if (it.opts.missingRefs == 'fail') {
          it.logger.error($message);
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = '';
          if (it.createErrors !== false) {
            out +=
              " { keyword: '$ref' , dataPath: (dataPath || '') + " +
              it.errorPath +
              ' , schemaPath: ' +
              it.util.toQuotedString($errSchemaPath) +
              " , params: { ref: '" +
              it.util.escapeQuotes($schema) +
              "' } ";
            if (it.opts.messages !== false) {
              out +=
                " , message: 'can\\'t resolve reference " +
                it.util.escapeQuotes($schema) +
                "' ";
            }
            if (it.opts.verbose) {
              out +=
                ' , schema: ' +
                it.util.toQuotedString($schema) +
                ' , parentSchema: validate.schema' +
                it.schemaPath +
                ' , data: ' +
                $data +
                ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += ' throw new ValidationError([' + __err + ']); ';
            } else {
              out += ' validate.errors = [' + __err + ']; return false; ';
            }
          } else {
            out +=
              ' var err = ' +
              __err +
              ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
          if ($breakOnError) {
            out += ' if (false) { ';
          }
        } else if (it.opts.missingRefs == 'ignore') {
          it.logger.warn($message);
          if ($breakOnError) {
            out += ' if (true) { ';
          }
        } else {
          throw new it.MissingRefError(it.baseId, $schema, $message);
        }
      } else if ($refVal.inline) {
        var $it = it.util.copy(it);
        $it.level++;
        var $nextValid = 'valid' + $it.level;
        $it.schema = $refVal.schema;
        $it.schemaPath = '';
        $it.errSchemaPath = $schema;
        var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
        out += ' ' + $code + ' ';
        if ($breakOnError) {
          out += ' if (' + $nextValid + ') { ';
        }
      } else {
        $async =
          $refVal.$async === true || (it.async && $refVal.$async !== false);
        $refCode = $refVal.code;
      }
    }
    if ($refCode) {
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = '';
      if (it.opts.passContext) {
        out += ' ' + $refCode + '.call(this, ';
      } else {
        out += ' ' + $refCode + '( ';
      }
      out += ' ' + $data + ", (dataPath || '')";
      if (it.errorPath != '""') {
        out += ' + ' + it.errorPath;
      }
      var $parentData = $dataLvl ? 'data' + ($dataLvl - 1 || '') : 'parentData',
        $parentDataProperty = $dataLvl
          ? it.dataPathArr[$dataLvl]
          : 'parentDataProperty';
      out +=
        ' , ' + $parentData + ' , ' + $parentDataProperty + ', rootData)  ';
      var __callValidate = out;
      out = $$outStack.pop();
      if ($async) {
        if (!it.async)
          throw new Error('async schema referenced by sync schema');
        if ($breakOnError) {
          out += ' var ' + $valid + '; ';
        }
        out += ' try { await ' + __callValidate + '; ';
        if ($breakOnError) {
          out += ' ' + $valid + ' = true; ';
        }
        out +=
          ' } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ';
        if ($breakOnError) {
          out += ' ' + $valid + ' = false; ';
        }
        out += ' } ';
        if ($breakOnError) {
          out += ' if (' + $valid + ') { ';
        }
      } else {
        out +=
          ' if (!' +
          __callValidate +
          ') { if (vErrors === null) vErrors = ' +
          $refCode +
          '.errors; else vErrors = vErrors.concat(' +
          $refCode +
          '.errors); errors = vErrors.length; } ';
        if ($breakOnError) {
          out += ' else { ';
        }
      }
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/allOf.js
var require_allOf = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = function generate_allOf(it, $keyword, $ruleType) {
    var out = ' ';
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $it = it.util.copy(it);
    var $closingBraces = '';
    $it.level++;
    var $nextValid = 'valid' + $it.level;
    var $currentBaseId = $it.baseId,
      $allSchemasEmpty = true;
    var arr1 = $schema;
    if (arr1) {
      var $sch,
        $i = -1,
        l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[($i += 1)];
        if (
          it.opts.strictKeywords
            ? (typeof $sch == 'object' && Object.keys($sch).length > 0) ||
              $sch === false
            : it.util.schemaHasRules($sch, it.RULES.all)
        ) {
          $allSchemasEmpty = false;
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + '[' + $i + ']';
          $it.errSchemaPath = $errSchemaPath + '/' + $i;
          out += '  ' + it.validate($it) + ' ';
          $it.baseId = $currentBaseId;
          if ($breakOnError) {
            out += ' if (' + $nextValid + ') { ';
            $closingBraces += '}';
          }
        }
      }
    }
    if ($breakOnError) {
      if ($allSchemasEmpty) {
        out += ' if (true) { ';
      } else {
        out += ' ' + $closingBraces.slice(0, -1) + ' ';
      }
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/anyOf.js
var require_anyOf = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = function generate_anyOf(it, $keyword, $ruleType) {
    var out = ' ';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = 'data' + ($dataLvl || '');
    var $valid = 'valid' + $lvl;
    var $errs = 'errs__' + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = '';
    $it.level++;
    var $nextValid = 'valid' + $it.level;
    var $noEmptySchema = $schema.every(function ($sch2) {
      return it.opts.strictKeywords
        ? (typeof $sch2 == 'object' && Object.keys($sch2).length > 0) ||
            $sch2 === false
        : it.util.schemaHasRules($sch2, it.RULES.all);
    });
    if ($noEmptySchema) {
      var $currentBaseId = $it.baseId;
      out += ' var ' + $errs + ' = errors; var ' + $valid + ' = false;  ';
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      var arr1 = $schema;
      if (arr1) {
        var $sch,
          $i = -1,
          l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[($i += 1)];
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + '[' + $i + ']';
          $it.errSchemaPath = $errSchemaPath + '/' + $i;
          out += '  ' + it.validate($it) + ' ';
          $it.baseId = $currentBaseId;
          out +=
            ' ' +
            $valid +
            ' = ' +
            $valid +
            ' || ' +
            $nextValid +
            '; if (!' +
            $valid +
            ') { ';
          $closingBraces += '}';
        }
      }
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += ' ' + $closingBraces + ' if (!' + $valid + ') {   var err =   ';
      if (it.createErrors !== false) {
        out +=
          " { keyword: 'anyOf' , dataPath: (dataPath || '') + " +
          it.errorPath +
          ' , schemaPath: ' +
          it.util.toQuotedString($errSchemaPath) +
          ' , params: {} ';
        if (it.opts.messages !== false) {
          out += " , message: 'should match some schema in anyOf' ";
        }
        if (it.opts.verbose) {
          out +=
            ' , schema: validate.schema' +
            $schemaPath +
            ' , parentSchema: validate.schema' +
            it.schemaPath +
            ' , data: ' +
            $data +
            ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      out +=
        ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += ' throw new ValidationError(vErrors); ';
        } else {
          out += ' validate.errors = vErrors; return false; ';
        }
      }
      out +=
        ' } else {  errors = ' +
        $errs +
        '; if (vErrors !== null) { if (' +
        $errs +
        ') vErrors.length = ' +
        $errs +
        '; else vErrors = null; } ';
      if (it.opts.allErrors) {
        out += ' } ';
      }
    } else {
      if ($breakOnError) {
        out += ' if (true) { ';
      }
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/comment.js
var require_comment = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = function generate_comment(it, $keyword, $ruleType) {
    var out = ' ';
    var $schema = it.schema[$keyword];
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $comment = it.util.toQuotedString($schema);
    if (it.opts.$comment === true) {
      out += ' console.log(' + $comment + ');';
    } else if (typeof it.opts.$comment == 'function') {
      out +=
        ' self._opts.$comment(' +
        $comment +
        ', ' +
        it.util.toQuotedString($errSchemaPath) +
        ', validate.root.schema);';
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/const.js
var require_const = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = function generate_const(it, $keyword, $ruleType) {
    var out = ' ';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = 'data' + ($dataLvl || '');
    var $valid = 'valid' + $lvl;
    var $isData = it.opts.$data && $schema && $schema.$data,
      $schemaValue;
    if ($isData) {
      out +=
        ' var schema' +
        $lvl +
        ' = ' +
        it.util.getData($schema.$data, $dataLvl, it.dataPathArr) +
        '; ';
      $schemaValue = 'schema' + $lvl;
    } else {
      $schemaValue = $schema;
    }
    if (!$isData) {
      out += ' var schema' + $lvl + ' = validate.schema' + $schemaPath + ';';
    }
    out +=
      'var ' +
      $valid +
      ' = equal(' +
      $data +
      ', schema' +
      $lvl +
      '); if (!' +
      $valid +
      ') {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    if (it.createErrors !== false) {
      out +=
        " { keyword: 'const' , dataPath: (dataPath || '') + " +
        it.errorPath +
        ' , schemaPath: ' +
        it.util.toQuotedString($errSchemaPath) +
        ' , params: { allowedValue: schema' +
        $lvl +
        ' } ';
      if (it.opts.messages !== false) {
        out += " , message: 'should be equal to constant' ";
      }
      if (it.opts.verbose) {
        out +=
          ' , schema: validate.schema' +
          $schemaPath +
          ' , parentSchema: validate.schema' +
          it.schemaPath +
          ' , data: ' +
          $data +
          ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += ' throw new ValidationError([' + __err + ']); ';
      } else {
        out += ' validate.errors = [' + __err + ']; return false; ';
      }
    } else {
      out +=
        ' var err = ' +
        __err +
        ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' }';
    if ($breakOnError) {
      out += ' else { ';
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/contains.js
var require_contains = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = function generate_contains(it, $keyword, $ruleType) {
    var out = ' ';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = 'data' + ($dataLvl || '');
    var $valid = 'valid' + $lvl;
    var $errs = 'errs__' + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = '';
    $it.level++;
    var $nextValid = 'valid' + $it.level;
    var $idx = 'i' + $lvl,
      $dataNxt = ($it.dataLevel = it.dataLevel + 1),
      $nextData = 'data' + $dataNxt,
      $currentBaseId = it.baseId,
      $nonEmptySchema = it.opts.strictKeywords
        ? (typeof $schema == 'object' && Object.keys($schema).length > 0) ||
          $schema === false
        : it.util.schemaHasRules($schema, it.RULES.all);
    out += 'var ' + $errs + ' = errors;var ' + $valid + ';';
    if ($nonEmptySchema) {
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      $it.schema = $schema;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      out +=
        ' var ' +
        $nextValid +
        ' = false; for (var ' +
        $idx +
        ' = 0; ' +
        $idx +
        ' < ' +
        $data +
        '.length; ' +
        $idx +
        '++) { ';
      $it.errorPath = it.util.getPathExpr(
        it.errorPath,
        $idx,
        it.opts.jsonPointers,
        true,
      );
      var $passData = $data + '[' + $idx + ']';
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) < 2) {
        out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
      } else {
        out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
      }
      out += ' if (' + $nextValid + ') break; }  ';
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += ' ' + $closingBraces + ' if (!' + $nextValid + ') {';
    } else {
      out += ' if (' + $data + '.length == 0) {';
    }
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    if (it.createErrors !== false) {
      out +=
        " { keyword: 'contains' , dataPath: (dataPath || '') + " +
        it.errorPath +
        ' , schemaPath: ' +
        it.util.toQuotedString($errSchemaPath) +
        ' , params: {} ';
      if (it.opts.messages !== false) {
        out += " , message: 'should contain a valid item' ";
      }
      if (it.opts.verbose) {
        out +=
          ' , schema: validate.schema' +
          $schemaPath +
          ' , parentSchema: validate.schema' +
          it.schemaPath +
          ' , data: ' +
          $data +
          ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += ' throw new ValidationError([' + __err + ']); ';
      } else {
        out += ' validate.errors = [' + __err + ']; return false; ';
      }
    } else {
      out +=
        ' var err = ' +
        __err +
        ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } else { ';
    if ($nonEmptySchema) {
      out +=
        '  errors = ' +
        $errs +
        '; if (vErrors !== null) { if (' +
        $errs +
        ') vErrors.length = ' +
        $errs +
        '; else vErrors = null; } ';
    }
    if (it.opts.allErrors) {
      out += ' } ';
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/dependencies.js
var require_dependencies = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = function generate_dependencies(it, $keyword, $ruleType) {
    var out = ' ';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = 'data' + ($dataLvl || '');
    var $errs = 'errs__' + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = '';
    $it.level++;
    var $nextValid = 'valid' + $it.level;
    var $schemaDeps = {},
      $propertyDeps = {},
      $ownProperties = it.opts.ownProperties;
    for ($property in $schema) {
      if ($property == '__proto__') continue;
      var $sch = $schema[$property];
      var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
      $deps[$property] = $sch;
    }
    out += 'var ' + $errs + ' = errors;';
    var $currentErrorPath = it.errorPath;
    out += 'var missing' + $lvl + ';';
    for (var $property in $propertyDeps) {
      $deps = $propertyDeps[$property];
      if ($deps.length) {
        out +=
          ' if ( ' + $data + it.util.getProperty($property) + ' !== undefined ';
        if ($ownProperties) {
          out +=
            ' && Object.prototype.hasOwnProperty.call(' +
            $data +
            ", '" +
            it.util.escapeQuotes($property) +
            "') ";
        }
        if ($breakOnError) {
          out += ' && ( ';
          var arr1 = $deps;
          if (arr1) {
            var $propertyKey,
              $i = -1,
              l1 = arr1.length - 1;
            while ($i < l1) {
              $propertyKey = arr1[($i += 1)];
              if ($i) {
                out += ' || ';
              }
              var $prop = it.util.getProperty($propertyKey),
                $useData = $data + $prop;
              out += ' ( ( ' + $useData + ' === undefined ';
              if ($ownProperties) {
                out +=
                  ' || ! Object.prototype.hasOwnProperty.call(' +
                  $data +
                  ", '" +
                  it.util.escapeQuotes($propertyKey) +
                  "') ";
              }
              out +=
                ') && (missing' +
                $lvl +
                ' = ' +
                it.util.toQuotedString(
                  it.opts.jsonPointers ? $propertyKey : $prop,
                ) +
                ') ) ';
            }
          }
          out += ')) {  ';
          var $propertyPath = 'missing' + $lvl,
            $missingProperty = "' + " + $propertyPath + " + '";
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.opts.jsonPointers
              ? it.util.getPathExpr($currentErrorPath, $propertyPath, true)
              : $currentErrorPath + ' + ' + $propertyPath;
          }
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = '';
          if (it.createErrors !== false) {
            out +=
              " { keyword: 'dependencies' , dataPath: (dataPath || '') + " +
              it.errorPath +
              ' , schemaPath: ' +
              it.util.toQuotedString($errSchemaPath) +
              " , params: { property: '" +
              it.util.escapeQuotes($property) +
              "', missingProperty: '" +
              $missingProperty +
              "', depsCount: " +
              $deps.length +
              ", deps: '" +
              it.util.escapeQuotes(
                $deps.length == 1 ? $deps[0] : $deps.join(', '),
              ) +
              "' } ";
            if (it.opts.messages !== false) {
              out += " , message: 'should have ";
              if ($deps.length == 1) {
                out += 'property ' + it.util.escapeQuotes($deps[0]);
              } else {
                out += 'properties ' + it.util.escapeQuotes($deps.join(', '));
              }
              out +=
                ' when property ' +
                it.util.escapeQuotes($property) +
                " is present' ";
            }
            if (it.opts.verbose) {
              out +=
                ' , schema: validate.schema' +
                $schemaPath +
                ' , parentSchema: validate.schema' +
                it.schemaPath +
                ' , data: ' +
                $data +
                ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += ' throw new ValidationError([' + __err + ']); ';
            } else {
              out += ' validate.errors = [' + __err + ']; return false; ';
            }
          } else {
            out +=
              ' var err = ' +
              __err +
              ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
        } else {
          out += ' ) { ';
          var arr2 = $deps;
          if (arr2) {
            var $propertyKey,
              i2 = -1,
              l2 = arr2.length - 1;
            while (i2 < l2) {
              $propertyKey = arr2[(i2 += 1)];
              var $prop = it.util.getProperty($propertyKey),
                $missingProperty = it.util.escapeQuotes($propertyKey),
                $useData = $data + $prop;
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPath(
                  $currentErrorPath,
                  $propertyKey,
                  it.opts.jsonPointers,
                );
              }
              out += ' if ( ' + $useData + ' === undefined ';
              if ($ownProperties) {
                out +=
                  ' || ! Object.prototype.hasOwnProperty.call(' +
                  $data +
                  ", '" +
                  it.util.escapeQuotes($propertyKey) +
                  "') ";
              }
              out += ') {  var err =   ';
              if (it.createErrors !== false) {
                out +=
                  " { keyword: 'dependencies' , dataPath: (dataPath || '') + " +
                  it.errorPath +
                  ' , schemaPath: ' +
                  it.util.toQuotedString($errSchemaPath) +
                  " , params: { property: '" +
                  it.util.escapeQuotes($property) +
                  "', missingProperty: '" +
                  $missingProperty +
                  "', depsCount: " +
                  $deps.length +
                  ", deps: '" +
                  it.util.escapeQuotes(
                    $deps.length == 1 ? $deps[0] : $deps.join(', '),
                  ) +
                  "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: 'should have ";
                  if ($deps.length == 1) {
                    out += 'property ' + it.util.escapeQuotes($deps[0]);
                  } else {
                    out +=
                      'properties ' + it.util.escapeQuotes($deps.join(', '));
                  }
                  out +=
                    ' when property ' +
                    it.util.escapeQuotes($property) +
                    " is present' ";
                }
                if (it.opts.verbose) {
                  out +=
                    ' , schema: validate.schema' +
                    $schemaPath +
                    ' , parentSchema: validate.schema' +
                    it.schemaPath +
                    ' , data: ' +
                    $data +
                    ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              out +=
                ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
            }
          }
        }
        out += ' }   ';
        if ($breakOnError) {
          $closingBraces += '}';
          out += ' else { ';
        }
      }
    }
    it.errorPath = $currentErrorPath;
    var $currentBaseId = $it.baseId;
    for (var $property in $schemaDeps) {
      var $sch = $schemaDeps[$property];
      if (
        it.opts.strictKeywords
          ? (typeof $sch == 'object' && Object.keys($sch).length > 0) ||
            $sch === false
          : it.util.schemaHasRules($sch, it.RULES.all)
      ) {
        out +=
          ' ' +
          $nextValid +
          ' = true; if ( ' +
          $data +
          it.util.getProperty($property) +
          ' !== undefined ';
        if ($ownProperties) {
          out +=
            ' && Object.prototype.hasOwnProperty.call(' +
            $data +
            ", '" +
            it.util.escapeQuotes($property) +
            "') ";
        }
        out += ') { ';
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + it.util.getProperty($property);
        $it.errSchemaPath =
          $errSchemaPath + '/' + it.util.escapeFragment($property);
        out += '  ' + it.validate($it) + ' ';
        $it.baseId = $currentBaseId;
        out += ' }  ';
        if ($breakOnError) {
          out += ' if (' + $nextValid + ') { ';
          $closingBraces += '}';
        }
      }
    }
    if ($breakOnError) {
      out += '   ' + $closingBraces + ' if (' + $errs + ' == errors) {';
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/enum.js
var require_enum = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = function generate_enum(it, $keyword, $ruleType) {
    var out = ' ';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = 'data' + ($dataLvl || '');
    var $valid = 'valid' + $lvl;
    var $isData = it.opts.$data && $schema && $schema.$data,
      $schemaValue;
    if ($isData) {
      out +=
        ' var schema' +
        $lvl +
        ' = ' +
        it.util.getData($schema.$data, $dataLvl, it.dataPathArr) +
        '; ';
      $schemaValue = 'schema' + $lvl;
    } else {
      $schemaValue = $schema;
    }
    var $i = 'i' + $lvl,
      $vSchema = 'schema' + $lvl;
    if (!$isData) {
      out += ' var ' + $vSchema + ' = validate.schema' + $schemaPath + ';';
    }
    out += 'var ' + $valid + ';';
    if ($isData) {
      out +=
        ' if (schema' +
        $lvl +
        ' === undefined) ' +
        $valid +
        ' = true; else if (!Array.isArray(schema' +
        $lvl +
        ')) ' +
        $valid +
        ' = false; else {';
    }
    out +=
      '' +
      $valid +
      ' = false;for (var ' +
      $i +
      '=0; ' +
      $i +
      '<' +
      $vSchema +
      '.length; ' +
      $i +
      '++) if (equal(' +
      $data +
      ', ' +
      $vSchema +
      '[' +
      $i +
      '])) { ' +
      $valid +
      ' = true; break; }';
    if ($isData) {
      out += '  }  ';
    }
    out += ' if (!' + $valid + ') {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    if (it.createErrors !== false) {
      out +=
        " { keyword: 'enum' , dataPath: (dataPath || '') + " +
        it.errorPath +
        ' , schemaPath: ' +
        it.util.toQuotedString($errSchemaPath) +
        ' , params: { allowedValues: schema' +
        $lvl +
        ' } ';
      if (it.opts.messages !== false) {
        out += " , message: 'should be equal to one of the allowed values' ";
      }
      if (it.opts.verbose) {
        out +=
          ' , schema: validate.schema' +
          $schemaPath +
          ' , parentSchema: validate.schema' +
          it.schemaPath +
          ' , data: ' +
          $data +
          ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += ' throw new ValidationError([' + __err + ']); ';
      } else {
        out += ' validate.errors = [' + __err + ']; return false; ';
      }
    } else {
      out +=
        ' var err = ' +
        __err +
        ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' }';
    if ($breakOnError) {
      out += ' else { ';
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/format.js
var require_format = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = function generate_format(it, $keyword, $ruleType) {
    var out = ' ';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = 'data' + ($dataLvl || '');
    if (it.opts.format === false) {
      if ($breakOnError) {
        out += ' if (true) { ';
      }
      return out;
    }
    var $isData = it.opts.$data && $schema && $schema.$data,
      $schemaValue;
    if ($isData) {
      out +=
        ' var schema' +
        $lvl +
        ' = ' +
        it.util.getData($schema.$data, $dataLvl, it.dataPathArr) +
        '; ';
      $schemaValue = 'schema' + $lvl;
    } else {
      $schemaValue = $schema;
    }
    var $unknownFormats = it.opts.unknownFormats,
      $allowUnknown = Array.isArray($unknownFormats);
    if ($isData) {
      var $format = 'format' + $lvl,
        $isObject = 'isObject' + $lvl,
        $formatType = 'formatType' + $lvl;
      out +=
        ' var ' +
        $format +
        ' = formats[' +
        $schemaValue +
        ']; var ' +
        $isObject +
        ' = typeof ' +
        $format +
        " == 'object' && !(" +
        $format +
        ' instanceof RegExp) && ' +
        $format +
        '.validate; var ' +
        $formatType +
        ' = ' +
        $isObject +
        ' && ' +
        $format +
        ".type || 'string'; if (" +
        $isObject +
        ') { ';
      if (it.async) {
        out += ' var async' + $lvl + ' = ' + $format + '.async; ';
      }
      out += ' ' + $format + ' = ' + $format + '.validate; } if (  ';
      if ($isData) {
        out +=
          ' (' +
          $schemaValue +
          ' !== undefined && typeof ' +
          $schemaValue +
          " != 'string') || ";
      }
      out += ' (';
      if ($unknownFormats != 'ignore') {
        out += ' (' + $schemaValue + ' && !' + $format + ' ';
        if ($allowUnknown) {
          out +=
            ' && self._opts.unknownFormats.indexOf(' +
            $schemaValue +
            ') == -1 ';
        }
        out += ') || ';
      }
      out +=
        ' (' +
        $format +
        ' && ' +
        $formatType +
        " == '" +
        $ruleType +
        "' && !(typeof " +
        $format +
        " == 'function' ? ";
      if (it.async) {
        out +=
          ' (async' +
          $lvl +
          ' ? await ' +
          $format +
          '(' +
          $data +
          ') : ' +
          $format +
          '(' +
          $data +
          ')) ';
      } else {
        out += ' ' + $format + '(' + $data + ') ';
      }
      out += ' : ' + $format + '.test(' + $data + '))))) {';
    } else {
      var $format = it.formats[$schema];
      if (!$format) {
        if ($unknownFormats == 'ignore') {
          it.logger.warn(
            'unknown format "' +
              $schema +
              '" ignored in schema at path "' +
              it.errSchemaPath +
              '"',
          );
          if ($breakOnError) {
            out += ' if (true) { ';
          }
          return out;
        } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
          if ($breakOnError) {
            out += ' if (true) { ';
          }
          return out;
        } else {
          throw new Error(
            'unknown format "' +
              $schema +
              '" is used in schema at path "' +
              it.errSchemaPath +
              '"',
          );
        }
      }
      var $isObject =
        typeof $format == 'object' &&
        !($format instanceof RegExp) &&
        $format.validate;
      var $formatType = ($isObject && $format.type) || 'string';
      if ($isObject) {
        var $async = $format.async === true;
        $format = $format.validate;
      }
      if ($formatType != $ruleType) {
        if ($breakOnError) {
          out += ' if (true) { ';
        }
        return out;
      }
      if ($async) {
        if (!it.async) throw new Error('async format in sync schema');
        var $formatRef = 'formats' + it.util.getProperty($schema) + '.validate';
        out += ' if (!(await ' + $formatRef + '(' + $data + '))) { ';
      } else {
        out += ' if (! ';
        var $formatRef = 'formats' + it.util.getProperty($schema);
        if ($isObject) $formatRef += '.validate';
        if (typeof $format == 'function') {
          out += ' ' + $formatRef + '(' + $data + ') ';
        } else {
          out += ' ' + $formatRef + '.test(' + $data + ') ';
        }
        out += ') { ';
      }
    }
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    if (it.createErrors !== false) {
      out +=
        " { keyword: 'format' , dataPath: (dataPath || '') + " +
        it.errorPath +
        ' , schemaPath: ' +
        it.util.toQuotedString($errSchemaPath) +
        ' , params: { format:  ';
      if ($isData) {
        out += '' + $schemaValue;
      } else {
        out += '' + it.util.toQuotedString($schema);
      }
      out += '  } ';
      if (it.opts.messages !== false) {
        out += ` , message: 'should match format "`;
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += '' + it.util.escapeQuotes($schema);
        }
        out += `"' `;
      }
      if (it.opts.verbose) {
        out += ' , schema:  ';
        if ($isData) {
          out += 'validate.schema' + $schemaPath;
        } else {
          out += '' + it.util.toQuotedString($schema);
        }
        out +=
          '         , parentSchema: validate.schema' +
          it.schemaPath +
          ' , data: ' +
          $data +
          ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += ' throw new ValidationError([' + __err + ']); ';
      } else {
        out += ' validate.errors = [' + __err + ']; return false; ';
      }
    } else {
      out +=
        ' var err = ' +
        __err +
        ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } ';
    if ($breakOnError) {
      out += ' else { ';
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/if.js
var require_if = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = function generate_if(it, $keyword, $ruleType) {
    var out = ' ';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = 'data' + ($dataLvl || '');
    var $valid = 'valid' + $lvl;
    var $errs = 'errs__' + $lvl;
    var $it = it.util.copy(it);
    $it.level++;
    var $nextValid = 'valid' + $it.level;
    var $thenSch = it.schema['then'],
      $elseSch = it.schema['else'],
      $thenPresent =
        $thenSch !== void 0 &&
        (it.opts.strictKeywords
          ? (typeof $thenSch == 'object' && Object.keys($thenSch).length > 0) ||
            $thenSch === false
          : it.util.schemaHasRules($thenSch, it.RULES.all)),
      $elsePresent =
        $elseSch !== void 0 &&
        (it.opts.strictKeywords
          ? (typeof $elseSch == 'object' && Object.keys($elseSch).length > 0) ||
            $elseSch === false
          : it.util.schemaHasRules($elseSch, it.RULES.all)),
      $currentBaseId = $it.baseId;
    if ($thenPresent || $elsePresent) {
      var $ifClause;
      $it.createErrors = false;
      $it.schema = $schema;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      out += ' var ' + $errs + ' = errors; var ' + $valid + ' = true;  ';
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      out += '  ' + it.validate($it) + ' ';
      $it.baseId = $currentBaseId;
      $it.createErrors = true;
      out +=
        '  errors = ' +
        $errs +
        '; if (vErrors !== null) { if (' +
        $errs +
        ') vErrors.length = ' +
        $errs +
        '; else vErrors = null; }  ';
      it.compositeRule = $it.compositeRule = $wasComposite;
      if ($thenPresent) {
        out += ' if (' + $nextValid + ') {  ';
        $it.schema = it.schema['then'];
        $it.schemaPath = it.schemaPath + '.then';
        $it.errSchemaPath = it.errSchemaPath + '/then';
        out += '  ' + it.validate($it) + ' ';
        $it.baseId = $currentBaseId;
        out += ' ' + $valid + ' = ' + $nextValid + '; ';
        if ($thenPresent && $elsePresent) {
          $ifClause = 'ifClause' + $lvl;
          out += ' var ' + $ifClause + " = 'then'; ";
        } else {
          $ifClause = "'then'";
        }
        out += ' } ';
        if ($elsePresent) {
          out += ' else { ';
        }
      } else {
        out += ' if (!' + $nextValid + ') { ';
      }
      if ($elsePresent) {
        $it.schema = it.schema['else'];
        $it.schemaPath = it.schemaPath + '.else';
        $it.errSchemaPath = it.errSchemaPath + '/else';
        out += '  ' + it.validate($it) + ' ';
        $it.baseId = $currentBaseId;
        out += ' ' + $valid + ' = ' + $nextValid + '; ';
        if ($thenPresent && $elsePresent) {
          $ifClause = 'ifClause' + $lvl;
          out += ' var ' + $ifClause + " = 'else'; ";
        } else {
          $ifClause = "'else'";
        }
        out += ' } ';
      }
      out += ' if (!' + $valid + ') {   var err =   ';
      if (it.createErrors !== false) {
        out +=
          " { keyword: 'if' , dataPath: (dataPath || '') + " +
          it.errorPath +
          ' , schemaPath: ' +
          it.util.toQuotedString($errSchemaPath) +
          ' , params: { failingKeyword: ' +
          $ifClause +
          ' } ';
        if (it.opts.messages !== false) {
          out +=
            ` , message: 'should match "' + ` + $ifClause + ` + '" schema' `;
        }
        if (it.opts.verbose) {
          out +=
            ' , schema: validate.schema' +
            $schemaPath +
            ' , parentSchema: validate.schema' +
            it.schemaPath +
            ' , data: ' +
            $data +
            ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      out +=
        ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += ' throw new ValidationError(vErrors); ';
        } else {
          out += ' validate.errors = vErrors; return false; ';
        }
      }
      out += ' }   ';
      if ($breakOnError) {
        out += ' else { ';
      }
    } else {
      if ($breakOnError) {
        out += ' if (true) { ';
      }
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/items.js
var require_items = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = function generate_items(it, $keyword, $ruleType) {
    var out = ' ';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = 'data' + ($dataLvl || '');
    var $valid = 'valid' + $lvl;
    var $errs = 'errs__' + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = '';
    $it.level++;
    var $nextValid = 'valid' + $it.level;
    var $idx = 'i' + $lvl,
      $dataNxt = ($it.dataLevel = it.dataLevel + 1),
      $nextData = 'data' + $dataNxt,
      $currentBaseId = it.baseId;
    out += 'var ' + $errs + ' = errors;var ' + $valid + ';';
    if (Array.isArray($schema)) {
      var $additionalItems = it.schema.additionalItems;
      if ($additionalItems === false) {
        out +=
          ' ' + $valid + ' = ' + $data + '.length <= ' + $schema.length + '; ';
        var $currErrSchemaPath = $errSchemaPath;
        $errSchemaPath = it.errSchemaPath + '/additionalItems';
        out += '  if (!' + $valid + ') {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = '';
        if (it.createErrors !== false) {
          out +=
            " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " +
            it.errorPath +
            ' , schemaPath: ' +
            it.util.toQuotedString($errSchemaPath) +
            ' , params: { limit: ' +
            $schema.length +
            ' } ';
          if (it.opts.messages !== false) {
            out +=
              " , message: 'should NOT have more than " +
              $schema.length +
              " items' ";
          }
          if (it.opts.verbose) {
            out +=
              ' , schema: false , parentSchema: validate.schema' +
              it.schemaPath +
              ' , data: ' +
              $data +
              ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += ' throw new ValidationError([' + __err + ']); ';
          } else {
            out += ' validate.errors = [' + __err + ']; return false; ';
          }
        } else {
          out +=
            ' var err = ' +
            __err +
            ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } ';
        $errSchemaPath = $currErrSchemaPath;
        if ($breakOnError) {
          $closingBraces += '}';
          out += ' else { ';
        }
      }
      var arr1 = $schema;
      if (arr1) {
        var $sch,
          $i = -1,
          l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[($i += 1)];
          if (
            it.opts.strictKeywords
              ? (typeof $sch == 'object' && Object.keys($sch).length > 0) ||
                $sch === false
              : it.util.schemaHasRules($sch, it.RULES.all)
          ) {
            out +=
              ' ' +
              $nextValid +
              ' = true; if (' +
              $data +
              '.length > ' +
              $i +
              ') { ';
            var $passData = $data + '[' + $i + ']';
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + '[' + $i + ']';
            $it.errSchemaPath = $errSchemaPath + '/' + $i;
            $it.errorPath = it.util.getPathExpr(
              it.errorPath,
              $i,
              it.opts.jsonPointers,
              true,
            );
            $it.dataPathArr[$dataNxt] = $i;
            var $code = it.validate($it);
            $it.baseId = $currentBaseId;
            if (it.util.varOccurences($code, $nextData) < 2) {
              out +=
                ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
            } else {
              out +=
                ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
            }
            out += ' }  ';
            if ($breakOnError) {
              out += ' if (' + $nextValid + ') { ';
              $closingBraces += '}';
            }
          }
        }
      }
      if (
        typeof $additionalItems == 'object' &&
        (it.opts.strictKeywords
          ? (typeof $additionalItems == 'object' &&
              Object.keys($additionalItems).length > 0) ||
            $additionalItems === false
          : it.util.schemaHasRules($additionalItems, it.RULES.all))
      ) {
        $it.schema = $additionalItems;
        $it.schemaPath = it.schemaPath + '.additionalItems';
        $it.errSchemaPath = it.errSchemaPath + '/additionalItems';
        out +=
          ' ' +
          $nextValid +
          ' = true; if (' +
          $data +
          '.length > ' +
          $schema.length +
          ') {  for (var ' +
          $idx +
          ' = ' +
          $schema.length +
          '; ' +
          $idx +
          ' < ' +
          $data +
          '.length; ' +
          $idx +
          '++) { ';
        $it.errorPath = it.util.getPathExpr(
          it.errorPath,
          $idx,
          it.opts.jsonPointers,
          true,
        );
        var $passData = $data + '[' + $idx + ']';
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
        } else {
          out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
        }
        if ($breakOnError) {
          out += ' if (!' + $nextValid + ') break; ';
        }
        out += ' } }  ';
        if ($breakOnError) {
          out += ' if (' + $nextValid + ') { ';
          $closingBraces += '}';
        }
      }
    } else if (
      it.opts.strictKeywords
        ? (typeof $schema == 'object' && Object.keys($schema).length > 0) ||
          $schema === false
        : it.util.schemaHasRules($schema, it.RULES.all)
    ) {
      $it.schema = $schema;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      out +=
        '  for (var ' +
        $idx +
        ' = ' +
        0 +
        '; ' +
        $idx +
        ' < ' +
        $data +
        '.length; ' +
        $idx +
        '++) { ';
      $it.errorPath = it.util.getPathExpr(
        it.errorPath,
        $idx,
        it.opts.jsonPointers,
        true,
      );
      var $passData = $data + '[' + $idx + ']';
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) < 2) {
        out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
      } else {
        out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
      }
      if ($breakOnError) {
        out += ' if (!' + $nextValid + ') break; ';
      }
      out += ' }';
    }
    if ($breakOnError) {
      out += ' ' + $closingBraces + ' if (' + $errs + ' == errors) {';
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/_limit.js
var require_limit = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = function generate__limit(it, $keyword, $ruleType) {
    var out = ' ';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = 'data' + ($dataLvl || '');
    var $isData = it.opts.$data && $schema && $schema.$data,
      $schemaValue;
    if ($isData) {
      out +=
        ' var schema' +
        $lvl +
        ' = ' +
        it.util.getData($schema.$data, $dataLvl, it.dataPathArr) +
        '; ';
      $schemaValue = 'schema' + $lvl;
    } else {
      $schemaValue = $schema;
    }
    var $isMax = $keyword == 'maximum',
      $exclusiveKeyword = $isMax ? 'exclusiveMaximum' : 'exclusiveMinimum',
      $schemaExcl = it.schema[$exclusiveKeyword],
      $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data,
      $op = $isMax ? '<' : '>',
      $notOp = $isMax ? '>' : '<',
      $errorKeyword = void 0;
    if (!($isData || typeof $schema == 'number' || $schema === void 0)) {
      throw new Error($keyword + ' must be number');
    }
    if (
      !(
        $isDataExcl ||
        $schemaExcl === void 0 ||
        typeof $schemaExcl == 'number' ||
        typeof $schemaExcl == 'boolean'
      )
    ) {
      throw new Error($exclusiveKeyword + ' must be number or boolean');
    }
    if ($isDataExcl) {
      var $schemaValueExcl = it.util.getData(
          $schemaExcl.$data,
          $dataLvl,
          it.dataPathArr,
        ),
        $exclusive = 'exclusive' + $lvl,
        $exclType = 'exclType' + $lvl,
        $exclIsNumber = 'exclIsNumber' + $lvl,
        $opExpr = 'op' + $lvl,
        $opStr = "' + " + $opExpr + " + '";
      out += ' var schemaExcl' + $lvl + ' = ' + $schemaValueExcl + '; ';
      $schemaValueExcl = 'schemaExcl' + $lvl;
      out +=
        ' var ' +
        $exclusive +
        '; var ' +
        $exclType +
        ' = typeof ' +
        $schemaValueExcl +
        '; if (' +
        $exclType +
        " != 'boolean' && " +
        $exclType +
        " != 'undefined' && " +
        $exclType +
        " != 'number') { ";
      var $errorKeyword = $exclusiveKeyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = '';
      if (it.createErrors !== false) {
        out +=
          " { keyword: '" +
          ($errorKeyword || '_exclusiveLimit') +
          "' , dataPath: (dataPath || '') + " +
          it.errorPath +
          ' , schemaPath: ' +
          it.util.toQuotedString($errSchemaPath) +
          ' , params: {} ';
        if (it.opts.messages !== false) {
          out += " , message: '" + $exclusiveKeyword + " should be boolean' ";
        }
        if (it.opts.verbose) {
          out +=
            ' , schema: validate.schema' +
            $schemaPath +
            ' , parentSchema: validate.schema' +
            it.schemaPath +
            ' , data: ' +
            $data +
            ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += ' throw new ValidationError([' + __err + ']); ';
        } else {
          out += ' validate.errors = [' + __err + ']; return false; ';
        }
      } else {
        out +=
          ' var err = ' +
          __err +
          ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += ' } else if ( ';
      if ($isData) {
        out +=
          ' (' +
          $schemaValue +
          ' !== undefined && typeof ' +
          $schemaValue +
          " != 'number') || ";
      }
      out +=
        ' ' +
        $exclType +
        " == 'number' ? ( (" +
        $exclusive +
        ' = ' +
        $schemaValue +
        ' === undefined || ' +
        $schemaValueExcl +
        ' ' +
        $op +
        '= ' +
        $schemaValue +
        ') ? ' +
        $data +
        ' ' +
        $notOp +
        '= ' +
        $schemaValueExcl +
        ' : ' +
        $data +
        ' ' +
        $notOp +
        ' ' +
        $schemaValue +
        ' ) : ( (' +
        $exclusive +
        ' = ' +
        $schemaValueExcl +
        ' === true) ? ' +
        $data +
        ' ' +
        $notOp +
        '= ' +
        $schemaValue +
        ' : ' +
        $data +
        ' ' +
        $notOp +
        ' ' +
        $schemaValue +
        ' ) || ' +
        $data +
        ' !== ' +
        $data +
        ') { var op' +
        $lvl +
        ' = ' +
        $exclusive +
        " ? '" +
        $op +
        "' : '" +
        $op +
        "='; ";
      if ($schema === void 0) {
        $errorKeyword = $exclusiveKeyword;
        $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
        $schemaValue = $schemaValueExcl;
        $isData = $isDataExcl;
      }
    } else {
      var $exclIsNumber = typeof $schemaExcl == 'number',
        $opStr = $op;
      if ($exclIsNumber && $isData) {
        var $opExpr = "'" + $opStr + "'";
        out += ' if ( ';
        if ($isData) {
          out +=
            ' (' +
            $schemaValue +
            ' !== undefined && typeof ' +
            $schemaValue +
            " != 'number') || ";
        }
        out +=
          ' ( ' +
          $schemaValue +
          ' === undefined || ' +
          $schemaExcl +
          ' ' +
          $op +
          '= ' +
          $schemaValue +
          ' ? ' +
          $data +
          ' ' +
          $notOp +
          '= ' +
          $schemaExcl +
          ' : ' +
          $data +
          ' ' +
          $notOp +
          ' ' +
          $schemaValue +
          ' ) || ' +
          $data +
          ' !== ' +
          $data +
          ') { ';
      } else {
        if ($exclIsNumber && $schema === void 0) {
          $exclusive = true;
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
          $schemaValue = $schemaExcl;
          $notOp += '=';
        } else {
          if ($exclIsNumber)
            $schemaValue = Math[$isMax ? 'min' : 'max']($schemaExcl, $schema);
          if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
            $exclusive = true;
            $errorKeyword = $exclusiveKeyword;
            $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
            $notOp += '=';
          } else {
            $exclusive = false;
            $opStr += '=';
          }
        }
        var $opExpr = "'" + $opStr + "'";
        out += ' if ( ';
        if ($isData) {
          out +=
            ' (' +
            $schemaValue +
            ' !== undefined && typeof ' +
            $schemaValue +
            " != 'number') || ";
        }
        out +=
          ' ' +
          $data +
          ' ' +
          $notOp +
          ' ' +
          $schemaValue +
          ' || ' +
          $data +
          ' !== ' +
          $data +
          ') { ';
      }
    }
    $errorKeyword = $errorKeyword || $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    if (it.createErrors !== false) {
      out +=
        " { keyword: '" +
        ($errorKeyword || '_limit') +
        "' , dataPath: (dataPath || '') + " +
        it.errorPath +
        ' , schemaPath: ' +
        it.util.toQuotedString($errSchemaPath) +
        ' , params: { comparison: ' +
        $opExpr +
        ', limit: ' +
        $schemaValue +
        ', exclusive: ' +
        $exclusive +
        ' } ';
      if (it.opts.messages !== false) {
        out += " , message: 'should be " + $opStr + ' ';
        if ($isData) {
          out += "' + " + $schemaValue;
        } else {
          out += '' + $schemaValue + "'";
        }
      }
      if (it.opts.verbose) {
        out += ' , schema:  ';
        if ($isData) {
          out += 'validate.schema' + $schemaPath;
        } else {
          out += '' + $schema;
        }
        out +=
          '         , parentSchema: validate.schema' +
          it.schemaPath +
          ' , data: ' +
          $data +
          ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += ' throw new ValidationError([' + __err + ']); ';
      } else {
        out += ' validate.errors = [' + __err + ']; return false; ';
      }
    } else {
      out +=
        ' var err = ' +
        __err +
        ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } ';
    if ($breakOnError) {
      out += ' else { ';
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/_limitItems.js
var require_limitItems = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = function generate__limitItems(it, $keyword, $ruleType) {
    var out = ' ';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = 'data' + ($dataLvl || '');
    var $isData = it.opts.$data && $schema && $schema.$data,
      $schemaValue;
    if ($isData) {
      out +=
        ' var schema' +
        $lvl +
        ' = ' +
        it.util.getData($schema.$data, $dataLvl, it.dataPathArr) +
        '; ';
      $schemaValue = 'schema' + $lvl;
    } else {
      $schemaValue = $schema;
    }
    if (!($isData || typeof $schema == 'number')) {
      throw new Error($keyword + ' must be number');
    }
    var $op = $keyword == 'maxItems' ? '>' : '<';
    out += 'if ( ';
    if ($isData) {
      out +=
        ' (' +
        $schemaValue +
        ' !== undefined && typeof ' +
        $schemaValue +
        " != 'number') || ";
    }
    out += ' ' + $data + '.length ' + $op + ' ' + $schemaValue + ') { ';
    var $errorKeyword = $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    if (it.createErrors !== false) {
      out +=
        " { keyword: '" +
        ($errorKeyword || '_limitItems') +
        "' , dataPath: (dataPath || '') + " +
        it.errorPath +
        ' , schemaPath: ' +
        it.util.toQuotedString($errSchemaPath) +
        ' , params: { limit: ' +
        $schemaValue +
        ' } ';
      if (it.opts.messages !== false) {
        out += " , message: 'should NOT have ";
        if ($keyword == 'maxItems') {
          out += 'more';
        } else {
          out += 'fewer';
        }
        out += ' than ';
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += '' + $schema;
        }
        out += " items' ";
      }
      if (it.opts.verbose) {
        out += ' , schema:  ';
        if ($isData) {
          out += 'validate.schema' + $schemaPath;
        } else {
          out += '' + $schema;
        }
        out +=
          '         , parentSchema: validate.schema' +
          it.schemaPath +
          ' , data: ' +
          $data +
          ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += ' throw new ValidationError([' + __err + ']); ';
      } else {
        out += ' validate.errors = [' + __err + ']; return false; ';
      }
    } else {
      out +=
        ' var err = ' +
        __err +
        ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += '} ';
    if ($breakOnError) {
      out += ' else { ';
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/_limitLength.js
var require_limitLength = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = function generate__limitLength(it, $keyword, $ruleType) {
    var out = ' ';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = 'data' + ($dataLvl || '');
    var $isData = it.opts.$data && $schema && $schema.$data,
      $schemaValue;
    if ($isData) {
      out +=
        ' var schema' +
        $lvl +
        ' = ' +
        it.util.getData($schema.$data, $dataLvl, it.dataPathArr) +
        '; ';
      $schemaValue = 'schema' + $lvl;
    } else {
      $schemaValue = $schema;
    }
    if (!($isData || typeof $schema == 'number')) {
      throw new Error($keyword + ' must be number');
    }
    var $op = $keyword == 'maxLength' ? '>' : '<';
    out += 'if ( ';
    if ($isData) {
      out +=
        ' (' +
        $schemaValue +
        ' !== undefined && typeof ' +
        $schemaValue +
        " != 'number') || ";
    }
    if (it.opts.unicode === false) {
      out += ' ' + $data + '.length ';
    } else {
      out += ' ucs2length(' + $data + ') ';
    }
    out += ' ' + $op + ' ' + $schemaValue + ') { ';
    var $errorKeyword = $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    if (it.createErrors !== false) {
      out +=
        " { keyword: '" +
        ($errorKeyword || '_limitLength') +
        "' , dataPath: (dataPath || '') + " +
        it.errorPath +
        ' , schemaPath: ' +
        it.util.toQuotedString($errSchemaPath) +
        ' , params: { limit: ' +
        $schemaValue +
        ' } ';
      if (it.opts.messages !== false) {
        out += " , message: 'should NOT be ";
        if ($keyword == 'maxLength') {
          out += 'longer';
        } else {
          out += 'shorter';
        }
        out += ' than ';
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += '' + $schema;
        }
        out += " characters' ";
      }
      if (it.opts.verbose) {
        out += ' , schema:  ';
        if ($isData) {
          out += 'validate.schema' + $schemaPath;
        } else {
          out += '' + $schema;
        }
        out +=
          '         , parentSchema: validate.schema' +
          it.schemaPath +
          ' , data: ' +
          $data +
          ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += ' throw new ValidationError([' + __err + ']); ';
      } else {
        out += ' validate.errors = [' + __err + ']; return false; ';
      }
    } else {
      out +=
        ' var err = ' +
        __err +
        ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += '} ';
    if ($breakOnError) {
      out += ' else { ';
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/_limitProperties.js
var require_limitProperties = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = function generate__limitProperties(
    it,
    $keyword,
    $ruleType,
  ) {
    var out = ' ';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = 'data' + ($dataLvl || '');
    var $isData = it.opts.$data && $schema && $schema.$data,
      $schemaValue;
    if ($isData) {
      out +=
        ' var schema' +
        $lvl +
        ' = ' +
        it.util.getData($schema.$data, $dataLvl, it.dataPathArr) +
        '; ';
      $schemaValue = 'schema' + $lvl;
    } else {
      $schemaValue = $schema;
    }
    if (!($isData || typeof $schema == 'number')) {
      throw new Error($keyword + ' must be number');
    }
    var $op = $keyword == 'maxProperties' ? '>' : '<';
    out += 'if ( ';
    if ($isData) {
      out +=
        ' (' +
        $schemaValue +
        ' !== undefined && typeof ' +
        $schemaValue +
        " != 'number') || ";
    }
    out +=
      ' Object.keys(' + $data + ').length ' + $op + ' ' + $schemaValue + ') { ';
    var $errorKeyword = $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    if (it.createErrors !== false) {
      out +=
        " { keyword: '" +
        ($errorKeyword || '_limitProperties') +
        "' , dataPath: (dataPath || '') + " +
        it.errorPath +
        ' , schemaPath: ' +
        it.util.toQuotedString($errSchemaPath) +
        ' , params: { limit: ' +
        $schemaValue +
        ' } ';
      if (it.opts.messages !== false) {
        out += " , message: 'should NOT have ";
        if ($keyword == 'maxProperties') {
          out += 'more';
        } else {
          out += 'fewer';
        }
        out += ' than ';
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += '' + $schema;
        }
        out += " properties' ";
      }
      if (it.opts.verbose) {
        out += ' , schema:  ';
        if ($isData) {
          out += 'validate.schema' + $schemaPath;
        } else {
          out += '' + $schema;
        }
        out +=
          '         , parentSchema: validate.schema' +
          it.schemaPath +
          ' , data: ' +
          $data +
          ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += ' throw new ValidationError([' + __err + ']); ';
      } else {
        out += ' validate.errors = [' + __err + ']; return false; ';
      }
    } else {
      out +=
        ' var err = ' +
        __err +
        ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += '} ';
    if ($breakOnError) {
      out += ' else { ';
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/multipleOf.js
var require_multipleOf = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = function generate_multipleOf(it, $keyword, $ruleType) {
    var out = ' ';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = 'data' + ($dataLvl || '');
    var $isData = it.opts.$data && $schema && $schema.$data,
      $schemaValue;
    if ($isData) {
      out +=
        ' var schema' +
        $lvl +
        ' = ' +
        it.util.getData($schema.$data, $dataLvl, it.dataPathArr) +
        '; ';
      $schemaValue = 'schema' + $lvl;
    } else {
      $schemaValue = $schema;
    }
    if (!($isData || typeof $schema == 'number')) {
      throw new Error($keyword + ' must be number');
    }
    out += 'var division' + $lvl + ';if (';
    if ($isData) {
      out +=
        ' ' +
        $schemaValue +
        ' !== undefined && ( typeof ' +
        $schemaValue +
        " != 'number' || ";
    }
    out += ' (division' + $lvl + ' = ' + $data + ' / ' + $schemaValue + ', ';
    if (it.opts.multipleOfPrecision) {
      out +=
        ' Math.abs(Math.round(division' +
        $lvl +
        ') - division' +
        $lvl +
        ') > 1e-' +
        it.opts.multipleOfPrecision +
        ' ';
    } else {
      out += ' division' + $lvl + ' !== parseInt(division' + $lvl + ') ';
    }
    out += ' ) ';
    if ($isData) {
      out += '  )  ';
    }
    out += ' ) {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    if (it.createErrors !== false) {
      out +=
        " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " +
        it.errorPath +
        ' , schemaPath: ' +
        it.util.toQuotedString($errSchemaPath) +
        ' , params: { multipleOf: ' +
        $schemaValue +
        ' } ';
      if (it.opts.messages !== false) {
        out += " , message: 'should be multiple of ";
        if ($isData) {
          out += "' + " + $schemaValue;
        } else {
          out += '' + $schemaValue + "'";
        }
      }
      if (it.opts.verbose) {
        out += ' , schema:  ';
        if ($isData) {
          out += 'validate.schema' + $schemaPath;
        } else {
          out += '' + $schema;
        }
        out +=
          '         , parentSchema: validate.schema' +
          it.schemaPath +
          ' , data: ' +
          $data +
          ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += ' throw new ValidationError([' + __err + ']); ';
      } else {
        out += ' validate.errors = [' + __err + ']; return false; ';
      }
    } else {
      out +=
        ' var err = ' +
        __err +
        ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += '} ';
    if ($breakOnError) {
      out += ' else { ';
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/not.js
var require_not = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = function generate_not(it, $keyword, $ruleType) {
    var out = ' ';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = 'data' + ($dataLvl || '');
    var $errs = 'errs__' + $lvl;
    var $it = it.util.copy(it);
    $it.level++;
    var $nextValid = 'valid' + $it.level;
    if (
      it.opts.strictKeywords
        ? (typeof $schema == 'object' && Object.keys($schema).length > 0) ||
          $schema === false
        : it.util.schemaHasRules($schema, it.RULES.all)
    ) {
      $it.schema = $schema;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      out += ' var ' + $errs + ' = errors;  ';
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      $it.createErrors = false;
      var $allErrorsOption;
      if ($it.opts.allErrors) {
        $allErrorsOption = $it.opts.allErrors;
        $it.opts.allErrors = false;
      }
      out += ' ' + it.validate($it) + ' ';
      $it.createErrors = true;
      if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += ' if (' + $nextValid + ') {   ';
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = '';
      if (it.createErrors !== false) {
        out +=
          " { keyword: 'not' , dataPath: (dataPath || '') + " +
          it.errorPath +
          ' , schemaPath: ' +
          it.util.toQuotedString($errSchemaPath) +
          ' , params: {} ';
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT be valid' ";
        }
        if (it.opts.verbose) {
          out +=
            ' , schema: validate.schema' +
            $schemaPath +
            ' , parentSchema: validate.schema' +
            it.schemaPath +
            ' , data: ' +
            $data +
            ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += ' throw new ValidationError([' + __err + ']); ';
        } else {
          out += ' validate.errors = [' + __err + ']; return false; ';
        }
      } else {
        out +=
          ' var err = ' +
          __err +
          ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out +=
        ' } else {  errors = ' +
        $errs +
        '; if (vErrors !== null) { if (' +
        $errs +
        ') vErrors.length = ' +
        $errs +
        '; else vErrors = null; } ';
      if (it.opts.allErrors) {
        out += ' } ';
      }
    } else {
      out += '  var err =   ';
      if (it.createErrors !== false) {
        out +=
          " { keyword: 'not' , dataPath: (dataPath || '') + " +
          it.errorPath +
          ' , schemaPath: ' +
          it.util.toQuotedString($errSchemaPath) +
          ' , params: {} ';
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT be valid' ";
        }
        if (it.opts.verbose) {
          out +=
            ' , schema: validate.schema' +
            $schemaPath +
            ' , parentSchema: validate.schema' +
            it.schemaPath +
            ' , data: ' +
            $data +
            ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      out +=
        ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      if ($breakOnError) {
        out += ' if (false) { ';
      }
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/oneOf.js
var require_oneOf = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = function generate_oneOf(it, $keyword, $ruleType) {
    var out = ' ';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = 'data' + ($dataLvl || '');
    var $valid = 'valid' + $lvl;
    var $errs = 'errs__' + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = '';
    $it.level++;
    var $nextValid = 'valid' + $it.level;
    var $currentBaseId = $it.baseId,
      $prevValid = 'prevValid' + $lvl,
      $passingSchemas = 'passingSchemas' + $lvl;
    out +=
      'var ' +
      $errs +
      ' = errors , ' +
      $prevValid +
      ' = false , ' +
      $valid +
      ' = false , ' +
      $passingSchemas +
      ' = null; ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var arr1 = $schema;
    if (arr1) {
      var $sch,
        $i = -1,
        l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[($i += 1)];
        if (
          it.opts.strictKeywords
            ? (typeof $sch == 'object' && Object.keys($sch).length > 0) ||
              $sch === false
            : it.util.schemaHasRules($sch, it.RULES.all)
        ) {
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + '[' + $i + ']';
          $it.errSchemaPath = $errSchemaPath + '/' + $i;
          out += '  ' + it.validate($it) + ' ';
          $it.baseId = $currentBaseId;
        } else {
          out += ' var ' + $nextValid + ' = true; ';
        }
        if ($i) {
          out +=
            ' if (' +
            $nextValid +
            ' && ' +
            $prevValid +
            ') { ' +
            $valid +
            ' = false; ' +
            $passingSchemas +
            ' = [' +
            $passingSchemas +
            ', ' +
            $i +
            ']; } else { ';
          $closingBraces += '}';
        }
        out +=
          ' if (' +
          $nextValid +
          ') { ' +
          $valid +
          ' = ' +
          $prevValid +
          ' = true; ' +
          $passingSchemas +
          ' = ' +
          $i +
          '; }';
      }
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += '' + $closingBraces + 'if (!' + $valid + ') {   var err =   ';
    if (it.createErrors !== false) {
      out +=
        " { keyword: 'oneOf' , dataPath: (dataPath || '') + " +
        it.errorPath +
        ' , schemaPath: ' +
        it.util.toQuotedString($errSchemaPath) +
        ' , params: { passingSchemas: ' +
        $passingSchemas +
        ' } ';
      if (it.opts.messages !== false) {
        out += " , message: 'should match exactly one schema in oneOf' ";
      }
      if (it.opts.verbose) {
        out +=
          ' , schema: validate.schema' +
          $schemaPath +
          ' , parentSchema: validate.schema' +
          it.schemaPath +
          ' , data: ' +
          $data +
          ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out +=
      ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    out +=
      '} else {  errors = ' +
      $errs +
      '; if (vErrors !== null) { if (' +
      $errs +
      ') vErrors.length = ' +
      $errs +
      '; else vErrors = null; }';
    if (it.opts.allErrors) {
      out += ' } ';
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/pattern.js
var require_pattern = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = function generate_pattern(it, $keyword, $ruleType) {
    var out = ' ';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = 'data' + ($dataLvl || '');
    var $isData = it.opts.$data && $schema && $schema.$data,
      $schemaValue;
    if ($isData) {
      out +=
        ' var schema' +
        $lvl +
        ' = ' +
        it.util.getData($schema.$data, $dataLvl, it.dataPathArr) +
        '; ';
      $schemaValue = 'schema' + $lvl;
    } else {
      $schemaValue = $schema;
    }
    var $regexp = $isData
      ? '(new RegExp(' + $schemaValue + '))'
      : it.usePattern($schema);
    out += 'if ( ';
    if ($isData) {
      out +=
        ' (' +
        $schemaValue +
        ' !== undefined && typeof ' +
        $schemaValue +
        " != 'string') || ";
    }
    out += ' !' + $regexp + '.test(' + $data + ') ) {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    if (it.createErrors !== false) {
      out +=
        " { keyword: 'pattern' , dataPath: (dataPath || '') + " +
        it.errorPath +
        ' , schemaPath: ' +
        it.util.toQuotedString($errSchemaPath) +
        ' , params: { pattern:  ';
      if ($isData) {
        out += '' + $schemaValue;
      } else {
        out += '' + it.util.toQuotedString($schema);
      }
      out += '  } ';
      if (it.opts.messages !== false) {
        out += ` , message: 'should match pattern "`;
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += '' + it.util.escapeQuotes($schema);
        }
        out += `"' `;
      }
      if (it.opts.verbose) {
        out += ' , schema:  ';
        if ($isData) {
          out += 'validate.schema' + $schemaPath;
        } else {
          out += '' + it.util.toQuotedString($schema);
        }
        out +=
          '         , parentSchema: validate.schema' +
          it.schemaPath +
          ' , data: ' +
          $data +
          ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      if (it.async) {
        out += ' throw new ValidationError([' + __err + ']); ';
      } else {
        out += ' validate.errors = [' + __err + ']; return false; ';
      }
    } else {
      out +=
        ' var err = ' +
        __err +
        ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += '} ';
    if ($breakOnError) {
      out += ' else { ';
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/properties.js
var require_properties = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = function generate_properties(it, $keyword, $ruleType) {
    var out = ' ';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = 'data' + ($dataLvl || '');
    var $errs = 'errs__' + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = '';
    $it.level++;
    var $nextValid = 'valid' + $it.level;
    var $key = 'key' + $lvl,
      $idx = 'idx' + $lvl,
      $dataNxt = ($it.dataLevel = it.dataLevel + 1),
      $nextData = 'data' + $dataNxt,
      $dataProperties = 'dataProperties' + $lvl;
    var $schemaKeys = Object.keys($schema || {}).filter(notProto),
      $pProperties = it.schema.patternProperties || {},
      $pPropertyKeys = Object.keys($pProperties).filter(notProto),
      $aProperties = it.schema.additionalProperties,
      $someProperties = $schemaKeys.length || $pPropertyKeys.length,
      $noAdditional = $aProperties === false,
      $additionalIsSchema =
        typeof $aProperties == 'object' && Object.keys($aProperties).length,
      $removeAdditional = it.opts.removeAdditional,
      $checkAdditional =
        $noAdditional || $additionalIsSchema || $removeAdditional,
      $ownProperties = it.opts.ownProperties,
      $currentBaseId = it.baseId;
    var $required = it.schema.required;
    if (
      $required &&
      !(it.opts.$data && $required.$data) &&
      $required.length < it.opts.loopRequired
    ) {
      var $requiredHash = it.util.toHash($required);
    }
    function notProto(p) {
      return p !== '__proto__';
    }
    out += 'var ' + $errs + ' = errors;var ' + $nextValid + ' = true;';
    if ($ownProperties) {
      out += ' var ' + $dataProperties + ' = undefined;';
    }
    if ($checkAdditional) {
      if ($ownProperties) {
        out +=
          ' ' +
          $dataProperties +
          ' = ' +
          $dataProperties +
          ' || Object.keys(' +
          $data +
          '); for (var ' +
          $idx +
          '=0; ' +
          $idx +
          '<' +
          $dataProperties +
          '.length; ' +
          $idx +
          '++) { var ' +
          $key +
          ' = ' +
          $dataProperties +
          '[' +
          $idx +
          ']; ';
      } else {
        out += ' for (var ' + $key + ' in ' + $data + ') { ';
      }
      if ($someProperties) {
        out += ' var isAdditional' + $lvl + ' = !(false ';
        if ($schemaKeys.length) {
          if ($schemaKeys.length > 8) {
            out +=
              ' || validate.schema' +
              $schemaPath +
              '.hasOwnProperty(' +
              $key +
              ') ';
          } else {
            var arr1 = $schemaKeys;
            if (arr1) {
              var $propertyKey,
                i1 = -1,
                l1 = arr1.length - 1;
              while (i1 < l1) {
                $propertyKey = arr1[(i1 += 1)];
                out +=
                  ' || ' +
                  $key +
                  ' == ' +
                  it.util.toQuotedString($propertyKey) +
                  ' ';
              }
            }
          }
        }
        if ($pPropertyKeys.length) {
          var arr2 = $pPropertyKeys;
          if (arr2) {
            var $pProperty,
              $i = -1,
              l2 = arr2.length - 1;
            while ($i < l2) {
              $pProperty = arr2[($i += 1)];
              out +=
                ' || ' + it.usePattern($pProperty) + '.test(' + $key + ') ';
            }
          }
        }
        out += ' ); if (isAdditional' + $lvl + ') { ';
      }
      if ($removeAdditional == 'all') {
        out += ' delete ' + $data + '[' + $key + ']; ';
      } else {
        var $currentErrorPath = it.errorPath;
        var $additionalProperty = "' + " + $key + " + '";
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr(
            it.errorPath,
            $key,
            it.opts.jsonPointers,
          );
        }
        if ($noAdditional) {
          if ($removeAdditional) {
            out += ' delete ' + $data + '[' + $key + ']; ';
          } else {
            out += ' ' + $nextValid + ' = false; ';
            var $currErrSchemaPath = $errSchemaPath;
            $errSchemaPath = it.errSchemaPath + '/additionalProperties';
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = '';
            if (it.createErrors !== false) {
              out +=
                " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " +
                it.errorPath +
                ' , schemaPath: ' +
                it.util.toQuotedString($errSchemaPath) +
                " , params: { additionalProperty: '" +
                $additionalProperty +
                "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += 'is an invalid additional property';
                } else {
                  out += 'should NOT have additional properties';
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out +=
                  ' , schema: false , parentSchema: validate.schema' +
                  it.schemaPath +
                  ' , data: ' +
                  $data +
                  ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += ' throw new ValidationError([' + __err + ']); ';
              } else {
                out += ' validate.errors = [' + __err + ']; return false; ';
              }
            } else {
              out +=
                ' var err = ' +
                __err +
                ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
            }
            $errSchemaPath = $currErrSchemaPath;
            if ($breakOnError) {
              out += ' break; ';
            }
          }
        } else if ($additionalIsSchema) {
          if ($removeAdditional == 'failing') {
            out += ' var ' + $errs + ' = errors;  ';
            var $wasComposite = it.compositeRule;
            it.compositeRule = $it.compositeRule = true;
            $it.schema = $aProperties;
            $it.schemaPath = it.schemaPath + '.additionalProperties';
            $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
            $it.errorPath = it.opts._errorDataPathProperty
              ? it.errorPath
              : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
            var $passData = $data + '[' + $key + ']';
            $it.dataPathArr[$dataNxt] = $key;
            var $code = it.validate($it);
            $it.baseId = $currentBaseId;
            if (it.util.varOccurences($code, $nextData) < 2) {
              out +=
                ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
            } else {
              out +=
                ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
            }
            out +=
              ' if (!' +
              $nextValid +
              ') { errors = ' +
              $errs +
              '; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete ' +
              $data +
              '[' +
              $key +
              ']; }  ';
            it.compositeRule = $it.compositeRule = $wasComposite;
          } else {
            $it.schema = $aProperties;
            $it.schemaPath = it.schemaPath + '.additionalProperties';
            $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
            $it.errorPath = it.opts._errorDataPathProperty
              ? it.errorPath
              : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
            var $passData = $data + '[' + $key + ']';
            $it.dataPathArr[$dataNxt] = $key;
            var $code = it.validate($it);
            $it.baseId = $currentBaseId;
            if (it.util.varOccurences($code, $nextData) < 2) {
              out +=
                ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
            } else {
              out +=
                ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
            }
            if ($breakOnError) {
              out += ' if (!' + $nextValid + ') break; ';
            }
          }
        }
        it.errorPath = $currentErrorPath;
      }
      if ($someProperties) {
        out += ' } ';
      }
      out += ' }  ';
      if ($breakOnError) {
        out += ' if (' + $nextValid + ') { ';
        $closingBraces += '}';
      }
    }
    var $useDefaults = it.opts.useDefaults && !it.compositeRule;
    if ($schemaKeys.length) {
      var arr3 = $schemaKeys;
      if (arr3) {
        var $propertyKey,
          i3 = -1,
          l3 = arr3.length - 1;
        while (i3 < l3) {
          $propertyKey = arr3[(i3 += 1)];
          var $sch = $schema[$propertyKey];
          if (
            it.opts.strictKeywords
              ? (typeof $sch == 'object' && Object.keys($sch).length > 0) ||
                $sch === false
              : it.util.schemaHasRules($sch, it.RULES.all)
          ) {
            var $prop = it.util.getProperty($propertyKey),
              $passData = $data + $prop,
              $hasDefault = $useDefaults && $sch.default !== void 0;
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + $prop;
            $it.errSchemaPath =
              $errSchemaPath + '/' + it.util.escapeFragment($propertyKey);
            $it.errorPath = it.util.getPath(
              it.errorPath,
              $propertyKey,
              it.opts.jsonPointers,
            );
            $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
            var $code = it.validate($it);
            $it.baseId = $currentBaseId;
            if (it.util.varOccurences($code, $nextData) < 2) {
              $code = it.util.varReplace($code, $nextData, $passData);
              var $useData = $passData;
            } else {
              var $useData = $nextData;
              out += ' var ' + $nextData + ' = ' + $passData + '; ';
            }
            if ($hasDefault) {
              out += ' ' + $code + ' ';
            } else {
              if ($requiredHash && $requiredHash[$propertyKey]) {
                out += ' if ( ' + $useData + ' === undefined ';
                if ($ownProperties) {
                  out +=
                    ' || ! Object.prototype.hasOwnProperty.call(' +
                    $data +
                    ", '" +
                    it.util.escapeQuotes($propertyKey) +
                    "') ";
                }
                out += ') { ' + $nextValid + ' = false; ';
                var $currentErrorPath = it.errorPath,
                  $currErrSchemaPath = $errSchemaPath,
                  $missingProperty = it.util.escapeQuotes($propertyKey);
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.util.getPath(
                    $currentErrorPath,
                    $propertyKey,
                    it.opts.jsonPointers,
                  );
                }
                $errSchemaPath = it.errSchemaPath + '/required';
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = '';
                if (it.createErrors !== false) {
                  out +=
                    " { keyword: 'required' , dataPath: (dataPath || '') + " +
                    it.errorPath +
                    ' , schemaPath: ' +
                    it.util.toQuotedString($errSchemaPath) +
                    " , params: { missingProperty: '" +
                    $missingProperty +
                    "' } ";
                  if (it.opts.messages !== false) {
                    out += " , message: '";
                    if (it.opts._errorDataPathProperty) {
                      out += 'is a required property';
                    } else {
                      out +=
                        "should have required property \\'" +
                        $missingProperty +
                        "\\'";
                    }
                    out += "' ";
                  }
                  if (it.opts.verbose) {
                    out +=
                      ' , schema: validate.schema' +
                      $schemaPath +
                      ' , parentSchema: validate.schema' +
                      it.schemaPath +
                      ' , data: ' +
                      $data +
                      ' ';
                  }
                  out += ' } ';
                } else {
                  out += ' {} ';
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                  if (it.async) {
                    out += ' throw new ValidationError([' + __err + ']); ';
                  } else {
                    out += ' validate.errors = [' + __err + ']; return false; ';
                  }
                } else {
                  out +=
                    ' var err = ' +
                    __err +
                    ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                }
                $errSchemaPath = $currErrSchemaPath;
                it.errorPath = $currentErrorPath;
                out += ' } else { ';
              } else {
                if ($breakOnError) {
                  out += ' if ( ' + $useData + ' === undefined ';
                  if ($ownProperties) {
                    out +=
                      ' || ! Object.prototype.hasOwnProperty.call(' +
                      $data +
                      ", '" +
                      it.util.escapeQuotes($propertyKey) +
                      "') ";
                  }
                  out += ') { ' + $nextValid + ' = true; } else { ';
                } else {
                  out += ' if (' + $useData + ' !== undefined ';
                  if ($ownProperties) {
                    out +=
                      ' &&   Object.prototype.hasOwnProperty.call(' +
                      $data +
                      ", '" +
                      it.util.escapeQuotes($propertyKey) +
                      "') ";
                  }
                  out += ' ) { ';
                }
              }
              out += ' ' + $code + ' } ';
            }
          }
          if ($breakOnError) {
            out += ' if (' + $nextValid + ') { ';
            $closingBraces += '}';
          }
        }
      }
    }
    if ($pPropertyKeys.length) {
      var arr4 = $pPropertyKeys;
      if (arr4) {
        var $pProperty,
          i4 = -1,
          l4 = arr4.length - 1;
        while (i4 < l4) {
          $pProperty = arr4[(i4 += 1)];
          var $sch = $pProperties[$pProperty];
          if (
            it.opts.strictKeywords
              ? (typeof $sch == 'object' && Object.keys($sch).length > 0) ||
                $sch === false
              : it.util.schemaHasRules($sch, it.RULES.all)
          ) {
            $it.schema = $sch;
            $it.schemaPath =
              it.schemaPath +
              '.patternProperties' +
              it.util.getProperty($pProperty);
            $it.errSchemaPath =
              it.errSchemaPath +
              '/patternProperties/' +
              it.util.escapeFragment($pProperty);
            if ($ownProperties) {
              out +=
                ' ' +
                $dataProperties +
                ' = ' +
                $dataProperties +
                ' || Object.keys(' +
                $data +
                '); for (var ' +
                $idx +
                '=0; ' +
                $idx +
                '<' +
                $dataProperties +
                '.length; ' +
                $idx +
                '++) { var ' +
                $key +
                ' = ' +
                $dataProperties +
                '[' +
                $idx +
                ']; ';
            } else {
              out += ' for (var ' + $key + ' in ' + $data + ') { ';
            }
            out +=
              ' if (' + it.usePattern($pProperty) + '.test(' + $key + ')) { ';
            $it.errorPath = it.util.getPathExpr(
              it.errorPath,
              $key,
              it.opts.jsonPointers,
            );
            var $passData = $data + '[' + $key + ']';
            $it.dataPathArr[$dataNxt] = $key;
            var $code = it.validate($it);
            $it.baseId = $currentBaseId;
            if (it.util.varOccurences($code, $nextData) < 2) {
              out +=
                ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
            } else {
              out +=
                ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
            }
            if ($breakOnError) {
              out += ' if (!' + $nextValid + ') break; ';
            }
            out += ' } ';
            if ($breakOnError) {
              out += ' else ' + $nextValid + ' = true; ';
            }
            out += ' }  ';
            if ($breakOnError) {
              out += ' if (' + $nextValid + ') { ';
              $closingBraces += '}';
            }
          }
        }
      }
    }
    if ($breakOnError) {
      out += ' ' + $closingBraces + ' if (' + $errs + ' == errors) {';
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/propertyNames.js
var require_propertyNames = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = function generate_propertyNames(it, $keyword, $ruleType) {
    var out = ' ';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = 'data' + ($dataLvl || '');
    var $errs = 'errs__' + $lvl;
    var $it = it.util.copy(it);
    var $closingBraces = '';
    $it.level++;
    var $nextValid = 'valid' + $it.level;
    out += 'var ' + $errs + ' = errors;';
    if (
      it.opts.strictKeywords
        ? (typeof $schema == 'object' && Object.keys($schema).length > 0) ||
          $schema === false
        : it.util.schemaHasRules($schema, it.RULES.all)
    ) {
      $it.schema = $schema;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      var $key = 'key' + $lvl,
        $idx = 'idx' + $lvl,
        $i = 'i' + $lvl,
        $invalidName = "' + " + $key + " + '",
        $dataNxt = ($it.dataLevel = it.dataLevel + 1),
        $nextData = 'data' + $dataNxt,
        $dataProperties = 'dataProperties' + $lvl,
        $ownProperties = it.opts.ownProperties,
        $currentBaseId = it.baseId;
      if ($ownProperties) {
        out += ' var ' + $dataProperties + ' = undefined; ';
      }
      if ($ownProperties) {
        out +=
          ' ' +
          $dataProperties +
          ' = ' +
          $dataProperties +
          ' || Object.keys(' +
          $data +
          '); for (var ' +
          $idx +
          '=0; ' +
          $idx +
          '<' +
          $dataProperties +
          '.length; ' +
          $idx +
          '++) { var ' +
          $key +
          ' = ' +
          $dataProperties +
          '[' +
          $idx +
          ']; ';
      } else {
        out += ' for (var ' + $key + ' in ' + $data + ') { ';
      }
      out += ' var startErrs' + $lvl + ' = errors; ';
      var $passData = $key;
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) < 2) {
        out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
      } else {
        out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
      }
      it.compositeRule = $it.compositeRule = $wasComposite;
      out +=
        ' if (!' +
        $nextValid +
        ') { for (var ' +
        $i +
        '=startErrs' +
        $lvl +
        '; ' +
        $i +
        '<errors; ' +
        $i +
        '++) { vErrors[' +
        $i +
        '].propertyName = ' +
        $key +
        '; }   var err =   ';
      if (it.createErrors !== false) {
        out +=
          " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " +
          it.errorPath +
          ' , schemaPath: ' +
          it.util.toQuotedString($errSchemaPath) +
          " , params: { propertyName: '" +
          $invalidName +
          "' } ";
        if (it.opts.messages !== false) {
          out +=
            " , message: 'property name \\'" +
            $invalidName +
            "\\' is invalid' ";
        }
        if (it.opts.verbose) {
          out +=
            ' , schema: validate.schema' +
            $schemaPath +
            ' , parentSchema: validate.schema' +
            it.schemaPath +
            ' , data: ' +
            $data +
            ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      out +=
        ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += ' throw new ValidationError(vErrors); ';
        } else {
          out += ' validate.errors = vErrors; return false; ';
        }
      }
      if ($breakOnError) {
        out += ' break; ';
      }
      out += ' } }';
    }
    if ($breakOnError) {
      out += ' ' + $closingBraces + ' if (' + $errs + ' == errors) {';
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/required.js
var require_required = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = function generate_required(it, $keyword, $ruleType) {
    var out = ' ';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = 'data' + ($dataLvl || '');
    var $valid = 'valid' + $lvl;
    var $isData = it.opts.$data && $schema && $schema.$data,
      $schemaValue;
    if ($isData) {
      out +=
        ' var schema' +
        $lvl +
        ' = ' +
        it.util.getData($schema.$data, $dataLvl, it.dataPathArr) +
        '; ';
      $schemaValue = 'schema' + $lvl;
    } else {
      $schemaValue = $schema;
    }
    var $vSchema = 'schema' + $lvl;
    if (!$isData) {
      if (
        $schema.length < it.opts.loopRequired &&
        it.schema.properties &&
        Object.keys(it.schema.properties).length
      ) {
        var $required = [];
        var arr1 = $schema;
        if (arr1) {
          var $property,
            i1 = -1,
            l1 = arr1.length - 1;
          while (i1 < l1) {
            $property = arr1[(i1 += 1)];
            var $propertySch = it.schema.properties[$property];
            if (
              !(
                $propertySch &&
                (it.opts.strictKeywords
                  ? (typeof $propertySch == 'object' &&
                      Object.keys($propertySch).length > 0) ||
                    $propertySch === false
                  : it.util.schemaHasRules($propertySch, it.RULES.all))
              )
            ) {
              $required[$required.length] = $property;
            }
          }
        }
      } else {
        var $required = $schema;
      }
    }
    if ($isData || $required.length) {
      var $currentErrorPath = it.errorPath,
        $loopRequired = $isData || $required.length >= it.opts.loopRequired,
        $ownProperties = it.opts.ownProperties;
      if ($breakOnError) {
        out += ' var missing' + $lvl + '; ';
        if ($loopRequired) {
          if (!$isData) {
            out +=
              ' var ' + $vSchema + ' = validate.schema' + $schemaPath + '; ';
          }
          var $i = 'i' + $lvl,
            $propertyPath = 'schema' + $lvl + '[' + $i + ']',
            $missingProperty = "' + " + $propertyPath + " + '";
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.util.getPathExpr(
              $currentErrorPath,
              $propertyPath,
              it.opts.jsonPointers,
            );
          }
          out += ' var ' + $valid + ' = true; ';
          if ($isData) {
            out +=
              ' if (schema' +
              $lvl +
              ' === undefined) ' +
              $valid +
              ' = true; else if (!Array.isArray(schema' +
              $lvl +
              ')) ' +
              $valid +
              ' = false; else {';
          }
          out +=
            ' for (var ' +
            $i +
            ' = 0; ' +
            $i +
            ' < ' +
            $vSchema +
            '.length; ' +
            $i +
            '++) { ' +
            $valid +
            ' = ' +
            $data +
            '[' +
            $vSchema +
            '[' +
            $i +
            ']] !== undefined ';
          if ($ownProperties) {
            out +=
              ' &&   Object.prototype.hasOwnProperty.call(' +
              $data +
              ', ' +
              $vSchema +
              '[' +
              $i +
              ']) ';
          }
          out += '; if (!' + $valid + ') break; } ';
          if ($isData) {
            out += '  }  ';
          }
          out += '  if (!' + $valid + ') {   ';
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = '';
          if (it.createErrors !== false) {
            out +=
              " { keyword: 'required' , dataPath: (dataPath || '') + " +
              it.errorPath +
              ' , schemaPath: ' +
              it.util.toQuotedString($errSchemaPath) +
              " , params: { missingProperty: '" +
              $missingProperty +
              "' } ";
            if (it.opts.messages !== false) {
              out += " , message: '";
              if (it.opts._errorDataPathProperty) {
                out += 'is a required property';
              } else {
                out +=
                  "should have required property \\'" +
                  $missingProperty +
                  "\\'";
              }
              out += "' ";
            }
            if (it.opts.verbose) {
              out +=
                ' , schema: validate.schema' +
                $schemaPath +
                ' , parentSchema: validate.schema' +
                it.schemaPath +
                ' , data: ' +
                $data +
                ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += ' throw new ValidationError([' + __err + ']); ';
            } else {
              out += ' validate.errors = [' + __err + ']; return false; ';
            }
          } else {
            out +=
              ' var err = ' +
              __err +
              ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
          out += ' } else { ';
        } else {
          out += ' if ( ';
          var arr2 = $required;
          if (arr2) {
            var $propertyKey,
              $i = -1,
              l2 = arr2.length - 1;
            while ($i < l2) {
              $propertyKey = arr2[($i += 1)];
              if ($i) {
                out += ' || ';
              }
              var $prop = it.util.getProperty($propertyKey),
                $useData = $data + $prop;
              out += ' ( ( ' + $useData + ' === undefined ';
              if ($ownProperties) {
                out +=
                  ' || ! Object.prototype.hasOwnProperty.call(' +
                  $data +
                  ", '" +
                  it.util.escapeQuotes($propertyKey) +
                  "') ";
              }
              out +=
                ') && (missing' +
                $lvl +
                ' = ' +
                it.util.toQuotedString(
                  it.opts.jsonPointers ? $propertyKey : $prop,
                ) +
                ') ) ';
            }
          }
          out += ') {  ';
          var $propertyPath = 'missing' + $lvl,
            $missingProperty = "' + " + $propertyPath + " + '";
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.opts.jsonPointers
              ? it.util.getPathExpr($currentErrorPath, $propertyPath, true)
              : $currentErrorPath + ' + ' + $propertyPath;
          }
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = '';
          if (it.createErrors !== false) {
            out +=
              " { keyword: 'required' , dataPath: (dataPath || '') + " +
              it.errorPath +
              ' , schemaPath: ' +
              it.util.toQuotedString($errSchemaPath) +
              " , params: { missingProperty: '" +
              $missingProperty +
              "' } ";
            if (it.opts.messages !== false) {
              out += " , message: '";
              if (it.opts._errorDataPathProperty) {
                out += 'is a required property';
              } else {
                out +=
                  "should have required property \\'" +
                  $missingProperty +
                  "\\'";
              }
              out += "' ";
            }
            if (it.opts.verbose) {
              out +=
                ' , schema: validate.schema' +
                $schemaPath +
                ' , parentSchema: validate.schema' +
                it.schemaPath +
                ' , data: ' +
                $data +
                ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += ' throw new ValidationError([' + __err + ']); ';
            } else {
              out += ' validate.errors = [' + __err + ']; return false; ';
            }
          } else {
            out +=
              ' var err = ' +
              __err +
              ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
          out += ' } else { ';
        }
      } else {
        if ($loopRequired) {
          if (!$isData) {
            out +=
              ' var ' + $vSchema + ' = validate.schema' + $schemaPath + '; ';
          }
          var $i = 'i' + $lvl,
            $propertyPath = 'schema' + $lvl + '[' + $i + ']',
            $missingProperty = "' + " + $propertyPath + " + '";
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.util.getPathExpr(
              $currentErrorPath,
              $propertyPath,
              it.opts.jsonPointers,
            );
          }
          if ($isData) {
            out +=
              ' if (' +
              $vSchema +
              ' && !Array.isArray(' +
              $vSchema +
              ')) {  var err =   ';
            if (it.createErrors !== false) {
              out +=
                " { keyword: 'required' , dataPath: (dataPath || '') + " +
                it.errorPath +
                ' , schemaPath: ' +
                it.util.toQuotedString($errSchemaPath) +
                " , params: { missingProperty: '" +
                $missingProperty +
                "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += 'is a required property';
                } else {
                  out +=
                    "should have required property \\'" +
                    $missingProperty +
                    "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out +=
                  ' , schema: validate.schema' +
                  $schemaPath +
                  ' , parentSchema: validate.schema' +
                  it.schemaPath +
                  ' , data: ' +
                  $data +
                  ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            out +=
              ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (' +
              $vSchema +
              ' !== undefined) { ';
          }
          out +=
            ' for (var ' +
            $i +
            ' = 0; ' +
            $i +
            ' < ' +
            $vSchema +
            '.length; ' +
            $i +
            '++) { if (' +
            $data +
            '[' +
            $vSchema +
            '[' +
            $i +
            ']] === undefined ';
          if ($ownProperties) {
            out +=
              ' || ! Object.prototype.hasOwnProperty.call(' +
              $data +
              ', ' +
              $vSchema +
              '[' +
              $i +
              ']) ';
          }
          out += ') {  var err =   ';
          if (it.createErrors !== false) {
            out +=
              " { keyword: 'required' , dataPath: (dataPath || '') + " +
              it.errorPath +
              ' , schemaPath: ' +
              it.util.toQuotedString($errSchemaPath) +
              " , params: { missingProperty: '" +
              $missingProperty +
              "' } ";
            if (it.opts.messages !== false) {
              out += " , message: '";
              if (it.opts._errorDataPathProperty) {
                out += 'is a required property';
              } else {
                out +=
                  "should have required property \\'" +
                  $missingProperty +
                  "\\'";
              }
              out += "' ";
            }
            if (it.opts.verbose) {
              out +=
                ' , schema: validate.schema' +
                $schemaPath +
                ' , parentSchema: validate.schema' +
                it.schemaPath +
                ' , data: ' +
                $data +
                ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          out +=
            ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ';
          if ($isData) {
            out += '  }  ';
          }
        } else {
          var arr3 = $required;
          if (arr3) {
            var $propertyKey,
              i3 = -1,
              l3 = arr3.length - 1;
            while (i3 < l3) {
              $propertyKey = arr3[(i3 += 1)];
              var $prop = it.util.getProperty($propertyKey),
                $missingProperty = it.util.escapeQuotes($propertyKey),
                $useData = $data + $prop;
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPath(
                  $currentErrorPath,
                  $propertyKey,
                  it.opts.jsonPointers,
                );
              }
              out += ' if ( ' + $useData + ' === undefined ';
              if ($ownProperties) {
                out +=
                  ' || ! Object.prototype.hasOwnProperty.call(' +
                  $data +
                  ", '" +
                  it.util.escapeQuotes($propertyKey) +
                  "') ";
              }
              out += ') {  var err =   ';
              if (it.createErrors !== false) {
                out +=
                  " { keyword: 'required' , dataPath: (dataPath || '') + " +
                  it.errorPath +
                  ' , schemaPath: ' +
                  it.util.toQuotedString($errSchemaPath) +
                  " , params: { missingProperty: '" +
                  $missingProperty +
                  "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: '";
                  if (it.opts._errorDataPathProperty) {
                    out += 'is a required property';
                  } else {
                    out +=
                      "should have required property \\'" +
                      $missingProperty +
                      "\\'";
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out +=
                    ' , schema: validate.schema' +
                    $schemaPath +
                    ' , parentSchema: validate.schema' +
                    it.schemaPath +
                    ' , data: ' +
                    $data +
                    ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              out +=
                ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
            }
          }
        }
      }
      it.errorPath = $currentErrorPath;
    } else if ($breakOnError) {
      out += ' if (true) {';
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/uniqueItems.js
var require_uniqueItems = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
    var out = ' ';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $data = 'data' + ($dataLvl || '');
    var $valid = 'valid' + $lvl;
    var $isData = it.opts.$data && $schema && $schema.$data,
      $schemaValue;
    if ($isData) {
      out +=
        ' var schema' +
        $lvl +
        ' = ' +
        it.util.getData($schema.$data, $dataLvl, it.dataPathArr) +
        '; ';
      $schemaValue = 'schema' + $lvl;
    } else {
      $schemaValue = $schema;
    }
    if (($schema || $isData) && it.opts.uniqueItems !== false) {
      if ($isData) {
        out +=
          ' var ' +
          $valid +
          '; if (' +
          $schemaValue +
          ' === false || ' +
          $schemaValue +
          ' === undefined) ' +
          $valid +
          ' = true; else if (typeof ' +
          $schemaValue +
          " != 'boolean') " +
          $valid +
          ' = false; else { ';
      }
      out +=
        ' var i = ' +
        $data +
        '.length , ' +
        $valid +
        ' = true , j; if (i > 1) { ';
      var $itemType = it.schema.items && it.schema.items.type,
        $typeIsArray = Array.isArray($itemType);
      if (
        !$itemType ||
        $itemType == 'object' ||
        $itemType == 'array' ||
        ($typeIsArray &&
          ($itemType.indexOf('object') >= 0 || $itemType.indexOf('array') >= 0))
      ) {
        out +=
          ' outer: for (;i--;) { for (j = i; j--;) { if (equal(' +
          $data +
          '[i], ' +
          $data +
          '[j])) { ' +
          $valid +
          ' = false; break outer; } } } ';
      } else {
        out +=
          ' var itemIndices = {}, item; for (;i--;) { var item = ' +
          $data +
          '[i]; ';
        var $method = 'checkDataType' + ($typeIsArray ? 's' : '');
        out +=
          ' if (' +
          it.util[$method]($itemType, 'item', it.opts.strictNumbers, true) +
          ') continue; ';
        if ($typeIsArray) {
          out += ` if (typeof item == 'string') item = '"' + item; `;
        }
        out +=
          " if (typeof itemIndices[item] == 'number') { " +
          $valid +
          ' = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ';
      }
      out += ' } ';
      if ($isData) {
        out += '  }  ';
      }
      out += ' if (!' + $valid + ') {   ';
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = '';
      if (it.createErrors !== false) {
        out +=
          " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " +
          it.errorPath +
          ' , schemaPath: ' +
          it.util.toQuotedString($errSchemaPath) +
          ' , params: { i: i, j: j } ';
        if (it.opts.messages !== false) {
          out +=
            " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' ";
        }
        if (it.opts.verbose) {
          out += ' , schema:  ';
          if ($isData) {
            out += 'validate.schema' + $schemaPath;
          } else {
            out += '' + $schema;
          }
          out +=
            '         , parentSchema: validate.schema' +
            it.schemaPath +
            ' , data: ' +
            $data +
            ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += ' throw new ValidationError([' + __err + ']); ';
        } else {
          out += ' validate.errors = [' + __err + ']; return false; ';
        }
      } else {
        out +=
          ' var err = ' +
          __err +
          ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += ' } ';
      if ($breakOnError) {
        out += ' else { ';
      }
    } else {
      if ($breakOnError) {
        out += ' if (true) { ';
      }
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/index.js
var require_dotjs = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = {
    $ref: require_ref(),
    allOf: require_allOf(),
    anyOf: require_anyOf(),
    $comment: require_comment(),
    const: require_const(),
    contains: require_contains(),
    dependencies: require_dependencies(),
    enum: require_enum(),
    format: require_format(),
    if: require_if(),
    items: require_items(),
    maximum: require_limit(),
    minimum: require_limit(),
    maxItems: require_limitItems(),
    minItems: require_limitItems(),
    maxLength: require_limitLength(),
    minLength: require_limitLength(),
    maxProperties: require_limitProperties(),
    minProperties: require_limitProperties(),
    multipleOf: require_multipleOf(),
    not: require_not(),
    oneOf: require_oneOf(),
    pattern: require_pattern(),
    properties: require_properties(),
    propertyNames: require_propertyNames(),
    required: require_required(),
    uniqueItems: require_uniqueItems(),
    validate: require_validate3(),
  };
});

// node_modules/ajv/lib/compile/rules.js
var require_rules2 = __commonJS((exports2, module2) => {
  'use strict';
  var ruleModules = require_dotjs();
  var toHash = require_util3().toHash;
  module2.exports = function rules() {
    var RULES = [
      {
        type: 'number',
        rules: [
          { maximum: ['exclusiveMaximum'] },
          { minimum: ['exclusiveMinimum'] },
          'multipleOf',
          'format',
        ],
      },
      {
        type: 'string',
        rules: ['maxLength', 'minLength', 'pattern', 'format'],
      },
      {
        type: 'array',
        rules: ['maxItems', 'minItems', 'items', 'contains', 'uniqueItems'],
      },
      {
        type: 'object',
        rules: [
          'maxProperties',
          'minProperties',
          'required',
          'dependencies',
          'propertyNames',
          { properties: ['additionalProperties', 'patternProperties'] },
        ],
      },
      {
        rules: [
          '$ref',
          'const',
          'enum',
          'not',
          'anyOf',
          'oneOf',
          'allOf',
          'if',
        ],
      },
    ];
    var ALL = ['type', '$comment'];
    var KEYWORDS = [
      '$schema',
      '$id',
      'id',
      '$data',
      '$async',
      'title',
      'description',
      'default',
      'definitions',
      'examples',
      'readOnly',
      'writeOnly',
      'contentMediaType',
      'contentEncoding',
      'additionalItems',
      'then',
      'else',
    ];
    var TYPES = [
      'number',
      'integer',
      'string',
      'array',
      'object',
      'boolean',
      'null',
    ];
    RULES.all = toHash(ALL);
    RULES.types = toHash(TYPES);
    RULES.forEach(function (group) {
      group.rules = group.rules.map(function (keyword) {
        var implKeywords;
        if (typeof keyword == 'object') {
          var key = Object.keys(keyword)[0];
          implKeywords = keyword[key];
          keyword = key;
          implKeywords.forEach(function (k) {
            ALL.push(k);
            RULES.all[k] = true;
          });
        }
        ALL.push(keyword);
        var rule = (RULES.all[keyword] = {
          keyword,
          code: ruleModules[keyword],
          implements: implKeywords,
        });
        return rule;
      });
      RULES.all.$comment = {
        keyword: '$comment',
        code: ruleModules.$comment,
      };
      if (group.type) RULES.types[group.type] = group;
    });
    RULES.keywords = toHash(ALL.concat(KEYWORDS));
    RULES.custom = {};
    return RULES;
  };
});

// node_modules/ajv/lib/data.js
var require_data = __commonJS((exports2, module2) => {
  'use strict';
  var KEYWORDS = [
    'multipleOf',
    'maximum',
    'exclusiveMaximum',
    'minimum',
    'exclusiveMinimum',
    'maxLength',
    'minLength',
    'pattern',
    'additionalItems',
    'maxItems',
    'minItems',
    'uniqueItems',
    'maxProperties',
    'minProperties',
    'required',
    'additionalProperties',
    'enum',
    'format',
    'const',
  ];
  module2.exports = function (metaSchema, keywordsJsonPointers) {
    for (var i = 0; i < keywordsJsonPointers.length; i++) {
      metaSchema = JSON.parse(JSON.stringify(metaSchema));
      var segments = keywordsJsonPointers[i].split('/');
      var keywords = metaSchema;
      var j;
      for (j = 1; j < segments.length; j++) keywords = keywords[segments[j]];
      for (j = 0; j < KEYWORDS.length; j++) {
        var key = KEYWORDS[j];
        var schema = keywords[key];
        if (schema) {
          keywords[key] = {
            anyOf: [
              schema,
              {
                $ref:
                  'https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#',
              },
            ],
          };
        }
      }
    }
    return metaSchema;
  };
});

// node_modules/ajv/lib/compile/async.js
var require_async2 = __commonJS((exports2, module2) => {
  'use strict';
  var MissingRefError = require_error_classes().MissingRef;
  module2.exports = compileAsync;
  function compileAsync(schema, meta, callback) {
    var self2 = this;
    if (typeof this._opts.loadSchema != 'function')
      throw new Error('options.loadSchema should be a function');
    if (typeof meta == 'function') {
      callback = meta;
      meta = void 0;
    }
    var p = loadMetaSchemaOf(schema).then(function () {
      var schemaObj = self2._addSchema(schema, void 0, meta);
      return schemaObj.validate || _compileAsync(schemaObj);
    });
    if (callback) {
      p.then(function (v) {
        callback(null, v);
      }, callback);
    }
    return p;
    function loadMetaSchemaOf(sch) {
      var $schema = sch.$schema;
      return $schema && !self2.getSchema($schema)
        ? compileAsync.call(self2, { $ref: $schema }, true)
        : Promise.resolve();
    }
    function _compileAsync(schemaObj) {
      try {
        return self2._compile(schemaObj);
      } catch (e) {
        if (e instanceof MissingRefError) return loadMissingSchema(e);
        throw e;
      }
      function loadMissingSchema(e) {
        var ref = e.missingSchema;
        if (added(ref))
          throw new Error(
            'Schema ' +
              ref +
              ' is loaded but ' +
              e.missingRef +
              ' cannot be resolved',
          );
        var schemaPromise = self2._loadingSchemas[ref];
        if (!schemaPromise) {
          schemaPromise = self2._loadingSchemas[ref] = self2._opts.loadSchema(
            ref,
          );
          schemaPromise.then(removePromise, removePromise);
        }
        return schemaPromise
          .then(function (sch) {
            if (!added(ref)) {
              return loadMetaSchemaOf(sch).then(function () {
                if (!added(ref)) self2.addSchema(sch, ref, void 0, meta);
              });
            }
          })
          .then(function () {
            return _compileAsync(schemaObj);
          });
        function removePromise() {
          delete self2._loadingSchemas[ref];
        }
        function added(ref2) {
          return self2._refs[ref2] || self2._schemas[ref2];
        }
      }
    }
  }
});

// node_modules/ajv/lib/dotjs/custom.js
var require_custom = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = function generate_custom(it, $keyword, $ruleType) {
    var out = ' ';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = 'data' + ($dataLvl || '');
    var $valid = 'valid' + $lvl;
    var $errs = 'errs__' + $lvl;
    var $isData = it.opts.$data && $schema && $schema.$data,
      $schemaValue;
    if ($isData) {
      out +=
        ' var schema' +
        $lvl +
        ' = ' +
        it.util.getData($schema.$data, $dataLvl, it.dataPathArr) +
        '; ';
      $schemaValue = 'schema' + $lvl;
    } else {
      $schemaValue = $schema;
    }
    var $rule = this,
      $definition = 'definition' + $lvl,
      $rDef = $rule.definition,
      $closingBraces = '';
    var $compile, $inline, $macro, $ruleValidate, $validateCode;
    if ($isData && $rDef.$data) {
      $validateCode = 'keywordValidate' + $lvl;
      var $validateSchema = $rDef.validateSchema;
      out +=
        ' var ' +
        $definition +
        " = RULES.custom['" +
        $keyword +
        "'].definition; var " +
        $validateCode +
        ' = ' +
        $definition +
        '.validate;';
    } else {
      $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
      if (!$ruleValidate) return;
      $schemaValue = 'validate.schema' + $schemaPath;
      $validateCode = $ruleValidate.code;
      $compile = $rDef.compile;
      $inline = $rDef.inline;
      $macro = $rDef.macro;
    }
    var $ruleErrs = $validateCode + '.errors',
      $i = 'i' + $lvl,
      $ruleErr = 'ruleErr' + $lvl,
      $asyncKeyword = $rDef.async;
    if ($asyncKeyword && !it.async)
      throw new Error('async keyword in sync schema');
    if (!($inline || $macro)) {
      out += '' + $ruleErrs + ' = null;';
    }
    out += 'var ' + $errs + ' = errors;var ' + $valid + ';';
    if ($isData && $rDef.$data) {
      $closingBraces += '}';
      out +=
        ' if (' +
        $schemaValue +
        ' === undefined) { ' +
        $valid +
        ' = true; } else { ';
      if ($validateSchema) {
        $closingBraces += '}';
        out +=
          ' ' +
          $valid +
          ' = ' +
          $definition +
          '.validateSchema(' +
          $schemaValue +
          '); if (' +
          $valid +
          ') { ';
      }
    }
    if ($inline) {
      if ($rDef.statements) {
        out += ' ' + $ruleValidate.validate + ' ';
      } else {
        out += ' ' + $valid + ' = ' + $ruleValidate.validate + '; ';
      }
    } else if ($macro) {
      var $it = it.util.copy(it);
      var $closingBraces = '';
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      $it.schema = $ruleValidate.validate;
      $it.schemaPath = '';
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += ' ' + $code;
    } else {
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = '';
      out += '  ' + $validateCode + '.call( ';
      if (it.opts.passContext) {
        out += 'this';
      } else {
        out += 'self';
      }
      if ($compile || $rDef.schema === false) {
        out += ' , ' + $data + ' ';
      } else {
        out +=
          ' , ' +
          $schemaValue +
          ' , ' +
          $data +
          ' , validate.schema' +
          it.schemaPath +
          ' ';
      }
      out += " , (dataPath || '')";
      if (it.errorPath != '""') {
        out += ' + ' + it.errorPath;
      }
      var $parentData = $dataLvl ? 'data' + ($dataLvl - 1 || '') : 'parentData',
        $parentDataProperty = $dataLvl
          ? it.dataPathArr[$dataLvl]
          : 'parentDataProperty';
      out +=
        ' , ' + $parentData + ' , ' + $parentDataProperty + ' , rootData )  ';
      var def_callRuleValidate = out;
      out = $$outStack.pop();
      if ($rDef.errors === false) {
        out += ' ' + $valid + ' = ';
        if ($asyncKeyword) {
          out += 'await ';
        }
        out += '' + def_callRuleValidate + '; ';
      } else {
        if ($asyncKeyword) {
          $ruleErrs = 'customErrors' + $lvl;
          out +=
            ' var ' +
            $ruleErrs +
            ' = null; try { ' +
            $valid +
            ' = await ' +
            def_callRuleValidate +
            '; } catch (e) { ' +
            $valid +
            ' = false; if (e instanceof ValidationError) ' +
            $ruleErrs +
            ' = e.errors; else throw e; } ';
        } else {
          out +=
            ' ' +
            $ruleErrs +
            ' = null; ' +
            $valid +
            ' = ' +
            def_callRuleValidate +
            '; ';
        }
      }
    }
    if ($rDef.modifying) {
      out +=
        ' if (' +
        $parentData +
        ') ' +
        $data +
        ' = ' +
        $parentData +
        '[' +
        $parentDataProperty +
        '];';
    }
    out += '' + $closingBraces;
    if ($rDef.valid) {
      if ($breakOnError) {
        out += ' if (true) { ';
      }
    } else {
      out += ' if ( ';
      if ($rDef.valid === void 0) {
        out += ' !';
        if ($macro) {
          out += '' + $nextValid;
        } else {
          out += '' + $valid;
        }
      } else {
        out += ' ' + !$rDef.valid + ' ';
      }
      out += ') { ';
      $errorKeyword = $rule.keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = '';
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = '';
      if (it.createErrors !== false) {
        out +=
          " { keyword: '" +
          ($errorKeyword || 'custom') +
          "' , dataPath: (dataPath || '') + " +
          it.errorPath +
          ' , schemaPath: ' +
          it.util.toQuotedString($errSchemaPath) +
          " , params: { keyword: '" +
          $rule.keyword +
          "' } ";
        if (it.opts.messages !== false) {
          out +=
            ` , message: 'should pass "` +
            $rule.keyword +
            `" keyword validation' `;
        }
        if (it.opts.verbose) {
          out +=
            ' , schema: validate.schema' +
            $schemaPath +
            ' , parentSchema: validate.schema' +
            it.schemaPath +
            ' , data: ' +
            $data +
            ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += ' throw new ValidationError([' + __err + ']); ';
        } else {
          out += ' validate.errors = [' + __err + ']; return false; ';
        }
      } else {
        out +=
          ' var err = ' +
          __err +
          ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      var def_customError = out;
      out = $$outStack.pop();
      if ($inline) {
        if ($rDef.errors) {
          if ($rDef.errors != 'full') {
            out +=
              '  for (var ' +
              $i +
              '=' +
              $errs +
              '; ' +
              $i +
              '<errors; ' +
              $i +
              '++) { var ' +
              $ruleErr +
              ' = vErrors[' +
              $i +
              ']; if (' +
              $ruleErr +
              '.dataPath === undefined) ' +
              $ruleErr +
              ".dataPath = (dataPath || '') + " +
              it.errorPath +
              '; if (' +
              $ruleErr +
              '.schemaPath === undefined) { ' +
              $ruleErr +
              '.schemaPath = "' +
              $errSchemaPath +
              '"; } ';
            if (it.opts.verbose) {
              out +=
                ' ' +
                $ruleErr +
                '.schema = ' +
                $schemaValue +
                '; ' +
                $ruleErr +
                '.data = ' +
                $data +
                '; ';
            }
            out += ' } ';
          }
        } else {
          if ($rDef.errors === false) {
            out += ' ' + def_customError + ' ';
          } else {
            out +=
              ' if (' +
              $errs +
              ' == errors) { ' +
              def_customError +
              ' } else {  for (var ' +
              $i +
              '=' +
              $errs +
              '; ' +
              $i +
              '<errors; ' +
              $i +
              '++) { var ' +
              $ruleErr +
              ' = vErrors[' +
              $i +
              ']; if (' +
              $ruleErr +
              '.dataPath === undefined) ' +
              $ruleErr +
              ".dataPath = (dataPath || '') + " +
              it.errorPath +
              '; if (' +
              $ruleErr +
              '.schemaPath === undefined) { ' +
              $ruleErr +
              '.schemaPath = "' +
              $errSchemaPath +
              '"; } ';
            if (it.opts.verbose) {
              out +=
                ' ' +
                $ruleErr +
                '.schema = ' +
                $schemaValue +
                '; ' +
                $ruleErr +
                '.data = ' +
                $data +
                '; ';
            }
            out += ' } } ';
          }
        }
      } else if ($macro) {
        out += '   var err =   ';
        if (it.createErrors !== false) {
          out +=
            " { keyword: '" +
            ($errorKeyword || 'custom') +
            "' , dataPath: (dataPath || '') + " +
            it.errorPath +
            ' , schemaPath: ' +
            it.util.toQuotedString($errSchemaPath) +
            " , params: { keyword: '" +
            $rule.keyword +
            "' } ";
          if (it.opts.messages !== false) {
            out +=
              ` , message: 'should pass "` +
              $rule.keyword +
              `" keyword validation' `;
          }
          if (it.opts.verbose) {
            out +=
              ' , schema: validate.schema' +
              $schemaPath +
              ' , parentSchema: validate.schema' +
              it.schemaPath +
              ' , data: ' +
              $data +
              ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        out +=
          ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += ' throw new ValidationError(vErrors); ';
          } else {
            out += ' validate.errors = vErrors; return false; ';
          }
        }
      } else {
        if ($rDef.errors === false) {
          out += ' ' + def_customError + ' ';
        } else {
          out +=
            ' if (Array.isArray(' +
            $ruleErrs +
            ')) { if (vErrors === null) vErrors = ' +
            $ruleErrs +
            '; else vErrors = vErrors.concat(' +
            $ruleErrs +
            '); errors = vErrors.length;  for (var ' +
            $i +
            '=' +
            $errs +
            '; ' +
            $i +
            '<errors; ' +
            $i +
            '++) { var ' +
            $ruleErr +
            ' = vErrors[' +
            $i +
            ']; if (' +
            $ruleErr +
            '.dataPath === undefined) ' +
            $ruleErr +
            ".dataPath = (dataPath || '') + " +
            it.errorPath +
            ';  ' +
            $ruleErr +
            '.schemaPath = "' +
            $errSchemaPath +
            '";  ';
          if (it.opts.verbose) {
            out +=
              ' ' +
              $ruleErr +
              '.schema = ' +
              $schemaValue +
              '; ' +
              $ruleErr +
              '.data = ' +
              $data +
              '; ';
          }
          out += ' } } else { ' + def_customError + ' } ';
        }
      }
      out += ' } ';
      if ($breakOnError) {
        out += ' else { ';
      }
    }
    return out;
  };
});

// node_modules/ajv/lib/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS((exports2, module2) => {
  module2.exports = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    $id: 'http://json-schema.org/draft-07/schema#',
    title: 'Core schema meta-schema',
    definitions: {
      schemaArray: {
        type: 'array',
        minItems: 1,
        items: { $ref: '#' },
      },
      nonNegativeInteger: {
        type: 'integer',
        minimum: 0,
      },
      nonNegativeIntegerDefault0: {
        allOf: [{ $ref: '#/definitions/nonNegativeInteger' }, { default: 0 }],
      },
      simpleTypes: {
        enum: [
          'array',
          'boolean',
          'integer',
          'null',
          'number',
          'object',
          'string',
        ],
      },
      stringArray: {
        type: 'array',
        items: { type: 'string' },
        uniqueItems: true,
        default: [],
      },
    },
    type: ['object', 'boolean'],
    properties: {
      $id: {
        type: 'string',
        format: 'uri-reference',
      },
      $schema: {
        type: 'string',
        format: 'uri',
      },
      $ref: {
        type: 'string',
        format: 'uri-reference',
      },
      $comment: {
        type: 'string',
      },
      title: {
        type: 'string',
      },
      description: {
        type: 'string',
      },
      default: true,
      readOnly: {
        type: 'boolean',
        default: false,
      },
      examples: {
        type: 'array',
        items: true,
      },
      multipleOf: {
        type: 'number',
        exclusiveMinimum: 0,
      },
      maximum: {
        type: 'number',
      },
      exclusiveMaximum: {
        type: 'number',
      },
      minimum: {
        type: 'number',
      },
      exclusiveMinimum: {
        type: 'number',
      },
      maxLength: { $ref: '#/definitions/nonNegativeInteger' },
      minLength: { $ref: '#/definitions/nonNegativeIntegerDefault0' },
      pattern: {
        type: 'string',
        format: 'regex',
      },
      additionalItems: { $ref: '#' },
      items: {
        anyOf: [{ $ref: '#' }, { $ref: '#/definitions/schemaArray' }],
        default: true,
      },
      maxItems: { $ref: '#/definitions/nonNegativeInteger' },
      minItems: { $ref: '#/definitions/nonNegativeIntegerDefault0' },
      uniqueItems: {
        type: 'boolean',
        default: false,
      },
      contains: { $ref: '#' },
      maxProperties: { $ref: '#/definitions/nonNegativeInteger' },
      minProperties: { $ref: '#/definitions/nonNegativeIntegerDefault0' },
      required: { $ref: '#/definitions/stringArray' },
      additionalProperties: { $ref: '#' },
      definitions: {
        type: 'object',
        additionalProperties: { $ref: '#' },
        default: {},
      },
      properties: {
        type: 'object',
        additionalProperties: { $ref: '#' },
        default: {},
      },
      patternProperties: {
        type: 'object',
        additionalProperties: { $ref: '#' },
        propertyNames: { format: 'regex' },
        default: {},
      },
      dependencies: {
        type: 'object',
        additionalProperties: {
          anyOf: [{ $ref: '#' }, { $ref: '#/definitions/stringArray' }],
        },
      },
      propertyNames: { $ref: '#' },
      const: true,
      enum: {
        type: 'array',
        items: true,
        minItems: 1,
        uniqueItems: true,
      },
      type: {
        anyOf: [
          { $ref: '#/definitions/simpleTypes' },
          {
            type: 'array',
            items: { $ref: '#/definitions/simpleTypes' },
            minItems: 1,
            uniqueItems: true,
          },
        ],
      },
      format: { type: 'string' },
      contentMediaType: { type: 'string' },
      contentEncoding: { type: 'string' },
      if: { $ref: '#' },
      then: { $ref: '#' },
      else: { $ref: '#' },
      allOf: { $ref: '#/definitions/schemaArray' },
      anyOf: { $ref: '#/definitions/schemaArray' },
      oneOf: { $ref: '#/definitions/schemaArray' },
      not: { $ref: '#' },
    },
    default: true,
  };
});

// node_modules/ajv/lib/definition_schema.js
var require_definition_schema = __commonJS((exports2, module2) => {
  'use strict';
  var metaSchema = require_json_schema_draft_07();
  module2.exports = {
    $id:
      'https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js',
    definitions: {
      simpleTypes: metaSchema.definitions.simpleTypes,
    },
    type: 'object',
    dependencies: {
      schema: ['validate'],
      $data: ['validate'],
      statements: ['inline'],
      valid: { not: { required: ['macro'] } },
    },
    properties: {
      type: metaSchema.properties.type,
      schema: { type: 'boolean' },
      statements: { type: 'boolean' },
      dependencies: {
        type: 'array',
        items: { type: 'string' },
      },
      metaSchema: { type: 'object' },
      modifying: { type: 'boolean' },
      valid: { type: 'boolean' },
      $data: { type: 'boolean' },
      async: { type: 'boolean' },
      errors: {
        anyOf: [{ type: 'boolean' }, { const: 'full' }],
      },
    },
  };
});

// node_modules/ajv/lib/keyword.js
var require_keyword = __commonJS((exports2, module2) => {
  'use strict';
  var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
  var customRuleCode = require_custom();
  var definitionSchema = require_definition_schema();
  module2.exports = {
    add: addKeyword,
    get: getKeyword,
    remove: removeKeyword,
    validate: validateKeyword,
  };
  function addKeyword(keyword, definition) {
    var RULES = this.RULES;
    if (RULES.keywords[keyword])
      throw new Error('Keyword ' + keyword + ' is already defined');
    if (!IDENTIFIER.test(keyword))
      throw new Error('Keyword ' + keyword + ' is not a valid identifier');
    if (definition) {
      this.validateKeyword(definition, true);
      var dataType = definition.type;
      if (Array.isArray(dataType)) {
        for (var i = 0; i < dataType.length; i++)
          _addRule(keyword, dataType[i], definition);
      } else {
        _addRule(keyword, dataType, definition);
      }
      var metaSchema = definition.metaSchema;
      if (metaSchema) {
        if (definition.$data && this._opts.$data) {
          metaSchema = {
            anyOf: [
              metaSchema,
              {
                $ref:
                  'https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#',
              },
            ],
          };
        }
        definition.validateSchema = this.compile(metaSchema, true);
      }
    }
    RULES.keywords[keyword] = RULES.all[keyword] = true;
    function _addRule(keyword2, dataType2, definition2) {
      var ruleGroup;
      for (var i2 = 0; i2 < RULES.length; i2++) {
        var rg = RULES[i2];
        if (rg.type == dataType2) {
          ruleGroup = rg;
          break;
        }
      }
      if (!ruleGroup) {
        ruleGroup = { type: dataType2, rules: [] };
        RULES.push(ruleGroup);
      }
      var rule = {
        keyword: keyword2,
        definition: definition2,
        custom: true,
        code: customRuleCode,
        implements: definition2.implements,
      };
      ruleGroup.rules.push(rule);
      RULES.custom[keyword2] = rule;
    }
    return this;
  }
  function getKeyword(keyword) {
    var rule = this.RULES.custom[keyword];
    return rule ? rule.definition : this.RULES.keywords[keyword] || false;
  }
  function removeKeyword(keyword) {
    var RULES = this.RULES;
    delete RULES.keywords[keyword];
    delete RULES.all[keyword];
    delete RULES.custom[keyword];
    for (var i = 0; i < RULES.length; i++) {
      var rules = RULES[i].rules;
      for (var j = 0; j < rules.length; j++) {
        if (rules[j].keyword == keyword) {
          rules.splice(j, 1);
          break;
        }
      }
    }
    return this;
  }
  function validateKeyword(definition, throwError) {
    validateKeyword.errors = null;
    var v = (this._validateKeyword =
      this._validateKeyword || this.compile(definitionSchema, true));
    if (v(definition)) return true;
    validateKeyword.errors = v.errors;
    if (throwError)
      throw new Error(
        'custom keyword definition is invalid: ' + this.errorsText(v.errors),
      );
    else return false;
  }
});

// node_modules/ajv/lib/refs/data.json
var require_data2 = __commonJS((exports2, module2) => {
  module2.exports = {
    $schema: 'http://json-schema.org/draft-07/schema#',
    $id:
      'https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#',
    description:
      'Meta-schema for $data reference (JSON Schema extension proposal)',
    type: 'object',
    required: ['$data'],
    properties: {
      $data: {
        type: 'string',
        anyOf: [
          { format: 'relative-json-pointer' },
          { format: 'json-pointer' },
        ],
      },
    },
    additionalProperties: false,
  };
});

// node_modules/ajv/lib/ajv.js
var require_ajv = __commonJS((exports2, module2) => {
  'use strict';
  var compileSchema = require_compile();
  var resolve = require_resolve();
  var Cache = require_cache();
  var SchemaObject = require_schema_obj();
  var stableStringify = require_fast_json_stable_stringify();
  var formats = require_formats2();
  var rules = require_rules2();
  var $dataMetaSchema = require_data();
  var util = require_util3();
  module2.exports = Ajv;
  Ajv.prototype.validate = validate;
  Ajv.prototype.compile = compile;
  Ajv.prototype.addSchema = addSchema;
  Ajv.prototype.addMetaSchema = addMetaSchema;
  Ajv.prototype.validateSchema = validateSchema;
  Ajv.prototype.getSchema = getSchema;
  Ajv.prototype.removeSchema = removeSchema;
  Ajv.prototype.addFormat = addFormat;
  Ajv.prototype.errorsText = errorsText;
  Ajv.prototype._addSchema = _addSchema;
  Ajv.prototype._compile = _compile;
  Ajv.prototype.compileAsync = require_async2();
  var customKeyword = require_keyword();
  Ajv.prototype.addKeyword = customKeyword.add;
  Ajv.prototype.getKeyword = customKeyword.get;
  Ajv.prototype.removeKeyword = customKeyword.remove;
  Ajv.prototype.validateKeyword = customKeyword.validate;
  var errorClasses = require_error_classes();
  Ajv.ValidationError = errorClasses.Validation;
  Ajv.MissingRefError = errorClasses.MissingRef;
  Ajv.$dataMetaSchema = $dataMetaSchema;
  var META_SCHEMA_ID = 'http://json-schema.org/draft-07/schema';
  var META_IGNORE_OPTIONS = [
    'removeAdditional',
    'useDefaults',
    'coerceTypes',
    'strictDefaults',
  ];
  var META_SUPPORT_DATA = ['/properties'];
  function Ajv(opts) {
    if (!(this instanceof Ajv)) return new Ajv(opts);
    opts = this._opts = util.copy(opts) || {};
    setLogger(this);
    this._schemas = {};
    this._refs = {};
    this._fragments = {};
    this._formats = formats(opts.format);
    this._cache = opts.cache || new Cache();
    this._loadingSchemas = {};
    this._compilations = [];
    this.RULES = rules();
    this._getId = chooseGetId(opts);
    opts.loopRequired = opts.loopRequired || Infinity;
    if (opts.errorDataPath == 'property') opts._errorDataPathProperty = true;
    if (opts.serialize === void 0) opts.serialize = stableStringify;
    this._metaOpts = getMetaSchemaOptions(this);
    if (opts.formats) addInitialFormats(this);
    if (opts.keywords) addInitialKeywords(this);
    addDefaultMetaSchema(this);
    if (typeof opts.meta == 'object') this.addMetaSchema(opts.meta);
    if (opts.nullable)
      this.addKeyword('nullable', { metaSchema: { type: 'boolean' } });
    addInitialSchemas(this);
  }
  function validate(schemaKeyRef, data) {
    var v;
    if (typeof schemaKeyRef == 'string') {
      v = this.getSchema(schemaKeyRef);
      if (!v)
        throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
    } else {
      var schemaObj = this._addSchema(schemaKeyRef);
      v = schemaObj.validate || this._compile(schemaObj);
    }
    var valid = v(data);
    if (v.$async !== true) this.errors = v.errors;
    return valid;
  }
  function compile(schema, _meta) {
    var schemaObj = this._addSchema(schema, void 0, _meta);
    return schemaObj.validate || this._compile(schemaObj);
  }
  function addSchema(schema, key, _skipValidation, _meta) {
    if (Array.isArray(schema)) {
      for (var i = 0; i < schema.length; i++)
        this.addSchema(schema[i], void 0, _skipValidation, _meta);
      return this;
    }
    var id = this._getId(schema);
    if (id !== void 0 && typeof id != 'string')
      throw new Error('schema id must be string');
    key = resolve.normalizeId(key || id);
    checkUnique(this, key);
    this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
    return this;
  }
  function addMetaSchema(schema, key, skipValidation) {
    this.addSchema(schema, key, skipValidation, true);
    return this;
  }
  function validateSchema(schema, throwOrLogError) {
    var $schema = schema.$schema;
    if ($schema !== void 0 && typeof $schema != 'string')
      throw new Error('$schema must be a string');
    $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
    if (!$schema) {
      this.logger.warn('meta-schema not available');
      this.errors = null;
      return true;
    }
    var valid = this.validate($schema, schema);
    if (!valid && throwOrLogError) {
      var message = 'schema is invalid: ' + this.errorsText();
      if (this._opts.validateSchema == 'log') this.logger.error(message);
      else throw new Error(message);
    }
    return valid;
  }
  function defaultMeta(self2) {
    var meta = self2._opts.meta;
    self2._opts.defaultMeta =
      typeof meta == 'object'
        ? self2._getId(meta) || meta
        : self2.getSchema(META_SCHEMA_ID)
        ? META_SCHEMA_ID
        : void 0;
    return self2._opts.defaultMeta;
  }
  function getSchema(keyRef) {
    var schemaObj = _getSchemaObj(this, keyRef);
    switch (typeof schemaObj) {
      case 'object':
        return schemaObj.validate || this._compile(schemaObj);
      case 'string':
        return this.getSchema(schemaObj);
      case 'undefined':
        return _getSchemaFragment(this, keyRef);
    }
  }
  function _getSchemaFragment(self2, ref) {
    var res = resolve.schema.call(self2, { schema: {} }, ref);
    if (res) {
      var schema = res.schema,
        root = res.root,
        baseId = res.baseId;
      var v = compileSchema.call(self2, schema, root, void 0, baseId);
      self2._fragments[ref] = new SchemaObject({
        ref,
        fragment: true,
        schema,
        root,
        baseId,
        validate: v,
      });
      return v;
    }
  }
  function _getSchemaObj(self2, keyRef) {
    keyRef = resolve.normalizeId(keyRef);
    return (
      self2._schemas[keyRef] || self2._refs[keyRef] || self2._fragments[keyRef]
    );
  }
  function removeSchema(schemaKeyRef) {
    if (schemaKeyRef instanceof RegExp) {
      _removeAllSchemas(this, this._schemas, schemaKeyRef);
      _removeAllSchemas(this, this._refs, schemaKeyRef);
      return this;
    }
    switch (typeof schemaKeyRef) {
      case 'undefined':
        _removeAllSchemas(this, this._schemas);
        _removeAllSchemas(this, this._refs);
        this._cache.clear();
        return this;
      case 'string':
        var schemaObj = _getSchemaObj(this, schemaKeyRef);
        if (schemaObj) this._cache.del(schemaObj.cacheKey);
        delete this._schemas[schemaKeyRef];
        delete this._refs[schemaKeyRef];
        return this;
      case 'object':
        var serialize = this._opts.serialize;
        var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
        this._cache.del(cacheKey);
        var id = this._getId(schemaKeyRef);
        if (id) {
          id = resolve.normalizeId(id);
          delete this._schemas[id];
          delete this._refs[id];
        }
    }
    return this;
  }
  function _removeAllSchemas(self2, schemas, regex) {
    for (var keyRef in schemas) {
      var schemaObj = schemas[keyRef];
      if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
        self2._cache.del(schemaObj.cacheKey);
        delete schemas[keyRef];
      }
    }
  }
  function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
    if (typeof schema != 'object' && typeof schema != 'boolean')
      throw new Error('schema should be object or boolean');
    var serialize = this._opts.serialize;
    var cacheKey = serialize ? serialize(schema) : schema;
    var cached = this._cache.get(cacheKey);
    if (cached) return cached;
    shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
    var id = resolve.normalizeId(this._getId(schema));
    if (id && shouldAddSchema) checkUnique(this, id);
    var willValidate = this._opts.validateSchema !== false && !skipValidation;
    var recursiveMeta;
    if (
      willValidate &&
      !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema))
    )
      this.validateSchema(schema, true);
    var localRefs = resolve.ids.call(this, schema);
    var schemaObj = new SchemaObject({
      id,
      schema,
      localRefs,
      cacheKey,
      meta,
    });
    if (id[0] != '#' && shouldAddSchema) this._refs[id] = schemaObj;
    this._cache.put(cacheKey, schemaObj);
    if (willValidate && recursiveMeta) this.validateSchema(schema, true);
    return schemaObj;
  }
  function _compile(schemaObj, root) {
    if (schemaObj.compiling) {
      schemaObj.validate = callValidate;
      callValidate.schema = schemaObj.schema;
      callValidate.errors = null;
      callValidate.root = root ? root : callValidate;
      if (schemaObj.schema.$async === true) callValidate.$async = true;
      return callValidate;
    }
    schemaObj.compiling = true;
    var currentOpts;
    if (schemaObj.meta) {
      currentOpts = this._opts;
      this._opts = this._metaOpts;
    }
    var v;
    try {
      v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs);
    } catch (e) {
      delete schemaObj.validate;
      throw e;
    } finally {
      schemaObj.compiling = false;
      if (schemaObj.meta) this._opts = currentOpts;
    }
    schemaObj.validate = v;
    schemaObj.refs = v.refs;
    schemaObj.refVal = v.refVal;
    schemaObj.root = v.root;
    return v;
    function callValidate() {
      var _validate = schemaObj.validate;
      var result = _validate.apply(this, arguments);
      callValidate.errors = _validate.errors;
      return result;
    }
  }
  function chooseGetId(opts) {
    switch (opts.schemaId) {
      case 'auto':
        return _get$IdOrId;
      case 'id':
        return _getId;
      default:
        return _get$Id;
    }
  }
  function _getId(schema) {
    if (schema.$id) this.logger.warn('schema $id ignored', schema.$id);
    return schema.id;
  }
  function _get$Id(schema) {
    if (schema.id) this.logger.warn('schema id ignored', schema.id);
    return schema.$id;
  }
  function _get$IdOrId(schema) {
    if (schema.$id && schema.id && schema.$id != schema.id)
      throw new Error('schema $id is different from id');
    return schema.$id || schema.id;
  }
  function errorsText(errors, options) {
    errors = errors || this.errors;
    if (!errors) return 'No errors';
    options = options || {};
    var separator = options.separator === void 0 ? ', ' : options.separator;
    var dataVar = options.dataVar === void 0 ? 'data' : options.dataVar;
    var text = '';
    for (var i = 0; i < errors.length; i++) {
      var e = errors[i];
      if (e) text += dataVar + e.dataPath + ' ' + e.message + separator;
    }
    return text.slice(0, -separator.length);
  }
  function addFormat(name, format) {
    if (typeof format == 'string') format = new RegExp(format);
    this._formats[name] = format;
    return this;
  }
  function addDefaultMetaSchema(self2) {
    var $dataSchema;
    if (self2._opts.$data) {
      $dataSchema = require_data2();
      self2.addMetaSchema($dataSchema, $dataSchema.$id, true);
    }
    if (self2._opts.meta === false) return;
    var metaSchema = require_json_schema_draft_07();
    if (self2._opts.$data)
      metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
    self2.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
    self2._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;
  }
  function addInitialSchemas(self2) {
    var optsSchemas = self2._opts.schemas;
    if (!optsSchemas) return;
    if (Array.isArray(optsSchemas)) self2.addSchema(optsSchemas);
    else for (var key in optsSchemas) self2.addSchema(optsSchemas[key], key);
  }
  function addInitialFormats(self2) {
    for (var name in self2._opts.formats) {
      var format = self2._opts.formats[name];
      self2.addFormat(name, format);
    }
  }
  function addInitialKeywords(self2) {
    for (var name in self2._opts.keywords) {
      var keyword = self2._opts.keywords[name];
      self2.addKeyword(name, keyword);
    }
  }
  function checkUnique(self2, id) {
    if (self2._schemas[id] || self2._refs[id])
      throw new Error('schema with key or id "' + id + '" already exists');
  }
  function getMetaSchemaOptions(self2) {
    var metaOpts = util.copy(self2._opts);
    for (var i = 0; i < META_IGNORE_OPTIONS.length; i++)
      delete metaOpts[META_IGNORE_OPTIONS[i]];
    return metaOpts;
  }
  function setLogger(self2) {
    var logger = self2._opts.logger;
    if (logger === false) {
      self2.logger = { log: noop, warn: noop, error: noop };
    } else {
      if (logger === void 0) logger = console;
      if (
        !(
          typeof logger == 'object' &&
          logger.log &&
          logger.warn &&
          logger.error
        )
      )
        throw new Error('logger must implement log, warn and error methods');
      self2.logger = logger;
    }
  }
  function noop() {}
});

// node_modules/har-validator/lib/error.js
var require_error3 = __commonJS((exports2, module2) => {
  function HARError(errors) {
    var message = 'validation failed';
    this.name = 'HARError';
    this.message = message;
    this.errors = errors;
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error(message).stack;
    }
  }
  HARError.prototype = Error.prototype;
  module2.exports = HARError;
});

// node_modules/har-schema/lib/afterRequest.json
var require_afterRequest = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: 'afterRequest.json#',
    $schema: 'http://json-schema.org/draft-06/schema#',
    type: 'object',
    optional: true,
    required: ['lastAccess', 'eTag', 'hitCount'],
    properties: {
      expires: {
        type: 'string',
        pattern:
          '^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?',
      },
      lastAccess: {
        type: 'string',
        pattern:
          '^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?',
      },
      eTag: {
        type: 'string',
      },
      hitCount: {
        type: 'integer',
      },
      comment: {
        type: 'string',
      },
    },
  };
});

// node_modules/har-schema/lib/beforeRequest.json
var require_beforeRequest = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: 'beforeRequest.json#',
    $schema: 'http://json-schema.org/draft-06/schema#',
    type: 'object',
    optional: true,
    required: ['lastAccess', 'eTag', 'hitCount'],
    properties: {
      expires: {
        type: 'string',
        pattern:
          '^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?',
      },
      lastAccess: {
        type: 'string',
        pattern:
          '^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?',
      },
      eTag: {
        type: 'string',
      },
      hitCount: {
        type: 'integer',
      },
      comment: {
        type: 'string',
      },
    },
  };
});

// node_modules/har-schema/lib/browser.json
var require_browser = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: 'browser.json#',
    $schema: 'http://json-schema.org/draft-06/schema#',
    type: 'object',
    required: ['name', 'version'],
    properties: {
      name: {
        type: 'string',
      },
      version: {
        type: 'string',
      },
      comment: {
        type: 'string',
      },
    },
  };
});

// node_modules/har-schema/lib/cache.json
var require_cache2 = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: 'cache.json#',
    $schema: 'http://json-schema.org/draft-06/schema#',
    properties: {
      beforeRequest: {
        oneOf: [{ type: 'null' }, { $ref: 'beforeRequest.json#' }],
      },
      afterRequest: {
        oneOf: [{ type: 'null' }, { $ref: 'afterRequest.json#' }],
      },
      comment: {
        type: 'string',
      },
    },
  };
});

// node_modules/har-schema/lib/content.json
var require_content = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: 'content.json#',
    $schema: 'http://json-schema.org/draft-06/schema#',
    type: 'object',
    required: ['size', 'mimeType'],
    properties: {
      size: {
        type: 'integer',
      },
      compression: {
        type: 'integer',
      },
      mimeType: {
        type: 'string',
      },
      text: {
        type: 'string',
      },
      encoding: {
        type: 'string',
      },
      comment: {
        type: 'string',
      },
    },
  };
});

// node_modules/har-schema/lib/cookie.json
var require_cookie2 = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: 'cookie.json#',
    $schema: 'http://json-schema.org/draft-06/schema#',
    type: 'object',
    required: ['name', 'value'],
    properties: {
      name: {
        type: 'string',
      },
      value: {
        type: 'string',
      },
      path: {
        type: 'string',
      },
      domain: {
        type: 'string',
      },
      expires: {
        type: ['string', 'null'],
        format: 'date-time',
      },
      httpOnly: {
        type: 'boolean',
      },
      secure: {
        type: 'boolean',
      },
      comment: {
        type: 'string',
      },
    },
  };
});

// node_modules/har-schema/lib/creator.json
var require_creator = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: 'creator.json#',
    $schema: 'http://json-schema.org/draft-06/schema#',
    type: 'object',
    required: ['name', 'version'],
    properties: {
      name: {
        type: 'string',
      },
      version: {
        type: 'string',
      },
      comment: {
        type: 'string',
      },
    },
  };
});

// node_modules/har-schema/lib/entry.json
var require_entry = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: 'entry.json#',
    $schema: 'http://json-schema.org/draft-06/schema#',
    type: 'object',
    optional: true,
    required: [
      'startedDateTime',
      'time',
      'request',
      'response',
      'cache',
      'timings',
    ],
    properties: {
      pageref: {
        type: 'string',
      },
      startedDateTime: {
        type: 'string',
        format: 'date-time',
        pattern:
          '^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))',
      },
      time: {
        type: 'number',
        min: 0,
      },
      request: {
        $ref: 'request.json#',
      },
      response: {
        $ref: 'response.json#',
      },
      cache: {
        $ref: 'cache.json#',
      },
      timings: {
        $ref: 'timings.json#',
      },
      serverIPAddress: {
        type: 'string',
        oneOf: [{ format: 'ipv4' }, { format: 'ipv6' }],
      },
      connection: {
        type: 'string',
      },
      comment: {
        type: 'string',
      },
    },
  };
});

// node_modules/har-schema/lib/har.json
var require_har = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: 'har.json#',
    $schema: 'http://json-schema.org/draft-06/schema#',
    type: 'object',
    required: ['log'],
    properties: {
      log: {
        $ref: 'log.json#',
      },
    },
  };
});

// node_modules/har-schema/lib/header.json
var require_header = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: 'header.json#',
    $schema: 'http://json-schema.org/draft-06/schema#',
    type: 'object',
    required: ['name', 'value'],
    properties: {
      name: {
        type: 'string',
      },
      value: {
        type: 'string',
      },
      comment: {
        type: 'string',
      },
    },
  };
});

// node_modules/har-schema/lib/log.json
var require_log = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: 'log.json#',
    $schema: 'http://json-schema.org/draft-06/schema#',
    type: 'object',
    required: ['version', 'creator', 'entries'],
    properties: {
      version: {
        type: 'string',
      },
      creator: {
        $ref: 'creator.json#',
      },
      browser: {
        $ref: 'browser.json#',
      },
      pages: {
        type: 'array',
        items: {
          $ref: 'page.json#',
        },
      },
      entries: {
        type: 'array',
        items: {
          $ref: 'entry.json#',
        },
      },
      comment: {
        type: 'string',
      },
    },
  };
});

// node_modules/har-schema/lib/page.json
var require_page = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: 'page.json#',
    $schema: 'http://json-schema.org/draft-06/schema#',
    type: 'object',
    optional: true,
    required: ['startedDateTime', 'id', 'title', 'pageTimings'],
    properties: {
      startedDateTime: {
        type: 'string',
        format: 'date-time',
        pattern:
          '^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))',
      },
      id: {
        type: 'string',
        unique: true,
      },
      title: {
        type: 'string',
      },
      pageTimings: {
        $ref: 'pageTimings.json#',
      },
      comment: {
        type: 'string',
      },
    },
  };
});

// node_modules/har-schema/lib/pageTimings.json
var require_pageTimings = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: 'pageTimings.json#',
    $schema: 'http://json-schema.org/draft-06/schema#',
    type: 'object',
    properties: {
      onContentLoad: {
        type: 'number',
        min: -1,
      },
      onLoad: {
        type: 'number',
        min: -1,
      },
      comment: {
        type: 'string',
      },
    },
  };
});

// node_modules/har-schema/lib/postData.json
var require_postData = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: 'postData.json#',
    $schema: 'http://json-schema.org/draft-06/schema#',
    type: 'object',
    optional: true,
    required: ['mimeType'],
    properties: {
      mimeType: {
        type: 'string',
      },
      text: {
        type: 'string',
      },
      params: {
        type: 'array',
        required: ['name'],
        properties: {
          name: {
            type: 'string',
          },
          value: {
            type: 'string',
          },
          fileName: {
            type: 'string',
          },
          contentType: {
            type: 'string',
          },
          comment: {
            type: 'string',
          },
        },
      },
      comment: {
        type: 'string',
      },
    },
  };
});

// node_modules/har-schema/lib/query.json
var require_query4 = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: 'query.json#',
    $schema: 'http://json-schema.org/draft-06/schema#',
    type: 'object',
    required: ['name', 'value'],
    properties: {
      name: {
        type: 'string',
      },
      value: {
        type: 'string',
      },
      comment: {
        type: 'string',
      },
    },
  };
});

// node_modules/har-schema/lib/request.json
var require_request = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: 'request.json#',
    $schema: 'http://json-schema.org/draft-06/schema#',
    type: 'object',
    required: [
      'method',
      'url',
      'httpVersion',
      'cookies',
      'headers',
      'queryString',
      'headersSize',
      'bodySize',
    ],
    properties: {
      method: {
        type: 'string',
      },
      url: {
        type: 'string',
        format: 'uri',
      },
      httpVersion: {
        type: 'string',
      },
      cookies: {
        type: 'array',
        items: {
          $ref: 'cookie.json#',
        },
      },
      headers: {
        type: 'array',
        items: {
          $ref: 'header.json#',
        },
      },
      queryString: {
        type: 'array',
        items: {
          $ref: 'query.json#',
        },
      },
      postData: {
        $ref: 'postData.json#',
      },
      headersSize: {
        type: 'integer',
      },
      bodySize: {
        type: 'integer',
      },
      comment: {
        type: 'string',
      },
    },
  };
});

// node_modules/har-schema/lib/response.json
var require_response = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: 'response.json#',
    $schema: 'http://json-schema.org/draft-06/schema#',
    type: 'object',
    required: [
      'status',
      'statusText',
      'httpVersion',
      'cookies',
      'headers',
      'content',
      'redirectURL',
      'headersSize',
      'bodySize',
    ],
    properties: {
      status: {
        type: 'integer',
      },
      statusText: {
        type: 'string',
      },
      httpVersion: {
        type: 'string',
      },
      cookies: {
        type: 'array',
        items: {
          $ref: 'cookie.json#',
        },
      },
      headers: {
        type: 'array',
        items: {
          $ref: 'header.json#',
        },
      },
      content: {
        $ref: 'content.json#',
      },
      redirectURL: {
        type: 'string',
      },
      headersSize: {
        type: 'integer',
      },
      bodySize: {
        type: 'integer',
      },
      comment: {
        type: 'string',
      },
    },
  };
});

// node_modules/har-schema/lib/timings.json
var require_timings = __commonJS((exports2, module2) => {
  module2.exports = {
    $id: 'timings.json#',
    $schema: 'http://json-schema.org/draft-06/schema#',
    required: ['send', 'wait', 'receive'],
    properties: {
      dns: {
        type: 'number',
        min: -1,
      },
      connect: {
        type: 'number',
        min: -1,
      },
      blocked: {
        type: 'number',
        min: -1,
      },
      send: {
        type: 'number',
        min: -1,
      },
      wait: {
        type: 'number',
        min: -1,
      },
      receive: {
        type: 'number',
        min: -1,
      },
      ssl: {
        type: 'number',
        min: -1,
      },
      comment: {
        type: 'string',
      },
    },
  };
});

// node_modules/har-schema/lib/index.js
var require_lib5 = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = {
    afterRequest: require_afterRequest(),
    beforeRequest: require_beforeRequest(),
    browser: require_browser(),
    cache: require_cache2(),
    content: require_content(),
    cookie: require_cookie2(),
    creator: require_creator(),
    entry: require_entry(),
    har: require_har(),
    header: require_header(),
    log: require_log(),
    page: require_page(),
    pageTimings: require_pageTimings(),
    postData: require_postData(),
    query: require_query4(),
    request: require_request(),
    response: require_response(),
    timings: require_timings(),
  };
});

// node_modules/ajv/lib/refs/json-schema-draft-06.json
var require_json_schema_draft_06 = __commonJS((exports2, module2) => {
  module2.exports = {
    $schema: 'http://json-schema.org/draft-06/schema#',
    $id: 'http://json-schema.org/draft-06/schema#',
    title: 'Core schema meta-schema',
    definitions: {
      schemaArray: {
        type: 'array',
        minItems: 1,
        items: { $ref: '#' },
      },
      nonNegativeInteger: {
        type: 'integer',
        minimum: 0,
      },
      nonNegativeIntegerDefault0: {
        allOf: [{ $ref: '#/definitions/nonNegativeInteger' }, { default: 0 }],
      },
      simpleTypes: {
        enum: [
          'array',
          'boolean',
          'integer',
          'null',
          'number',
          'object',
          'string',
        ],
      },
      stringArray: {
        type: 'array',
        items: { type: 'string' },
        uniqueItems: true,
        default: [],
      },
    },
    type: ['object', 'boolean'],
    properties: {
      $id: {
        type: 'string',
        format: 'uri-reference',
      },
      $schema: {
        type: 'string',
        format: 'uri',
      },
      $ref: {
        type: 'string',
        format: 'uri-reference',
      },
      title: {
        type: 'string',
      },
      description: {
        type: 'string',
      },
      default: {},
      examples: {
        type: 'array',
        items: {},
      },
      multipleOf: {
        type: 'number',
        exclusiveMinimum: 0,
      },
      maximum: {
        type: 'number',
      },
      exclusiveMaximum: {
        type: 'number',
      },
      minimum: {
        type: 'number',
      },
      exclusiveMinimum: {
        type: 'number',
      },
      maxLength: { $ref: '#/definitions/nonNegativeInteger' },
      minLength: { $ref: '#/definitions/nonNegativeIntegerDefault0' },
      pattern: {
        type: 'string',
        format: 'regex',
      },
      additionalItems: { $ref: '#' },
      items: {
        anyOf: [{ $ref: '#' }, { $ref: '#/definitions/schemaArray' }],
        default: {},
      },
      maxItems: { $ref: '#/definitions/nonNegativeInteger' },
      minItems: { $ref: '#/definitions/nonNegativeIntegerDefault0' },
      uniqueItems: {
        type: 'boolean',
        default: false,
      },
      contains: { $ref: '#' },
      maxProperties: { $ref: '#/definitions/nonNegativeInteger' },
      minProperties: { $ref: '#/definitions/nonNegativeIntegerDefault0' },
      required: { $ref: '#/definitions/stringArray' },
      additionalProperties: { $ref: '#' },
      definitions: {
        type: 'object',
        additionalProperties: { $ref: '#' },
        default: {},
      },
      properties: {
        type: 'object',
        additionalProperties: { $ref: '#' },
        default: {},
      },
      patternProperties: {
        type: 'object',
        additionalProperties: { $ref: '#' },
        default: {},
      },
      dependencies: {
        type: 'object',
        additionalProperties: {
          anyOf: [{ $ref: '#' }, { $ref: '#/definitions/stringArray' }],
        },
      },
      propertyNames: { $ref: '#' },
      const: {},
      enum: {
        type: 'array',
        minItems: 1,
        uniqueItems: true,
      },
      type: {
        anyOf: [
          { $ref: '#/definitions/simpleTypes' },
          {
            type: 'array',
            items: { $ref: '#/definitions/simpleTypes' },
            minItems: 1,
            uniqueItems: true,
          },
        ],
      },
      format: { type: 'string' },
      allOf: { $ref: '#/definitions/schemaArray' },
      anyOf: { $ref: '#/definitions/schemaArray' },
      oneOf: { $ref: '#/definitions/schemaArray' },
      not: { $ref: '#' },
    },
    default: {},
  };
});

// node_modules/har-validator/lib/promise.js
var require_promise = __commonJS((exports2) => {
  var Ajv = require_ajv();
  var HARError = require_error3();
  var schemas = require_lib5();
  var ajv;
  function createAjvInstance() {
    var ajv2 = new Ajv({
      allErrors: true,
    });
    ajv2.addMetaSchema(require_json_schema_draft_06());
    ajv2.addSchema(schemas);
    return ajv2;
  }
  function validate(name, data) {
    data = data || {};
    ajv = ajv || createAjvInstance();
    var validate2 = ajv.getSchema(name + '.json');
    return new Promise(function (resolve, reject) {
      var valid = validate2(data);
      !valid ? reject(new HARError(validate2.errors)) : resolve(data);
    });
  }
  exports2.afterRequest = function (data) {
    return validate('afterRequest', data);
  };
  exports2.beforeRequest = function (data) {
    return validate('beforeRequest', data);
  };
  exports2.browser = function (data) {
    return validate('browser', data);
  };
  exports2.cache = function (data) {
    return validate('cache', data);
  };
  exports2.content = function (data) {
    return validate('content', data);
  };
  exports2.cookie = function (data) {
    return validate('cookie', data);
  };
  exports2.creator = function (data) {
    return validate('creator', data);
  };
  exports2.entry = function (data) {
    return validate('entry', data);
  };
  exports2.har = function (data) {
    return validate('har', data);
  };
  exports2.header = function (data) {
    return validate('header', data);
  };
  exports2.log = function (data) {
    return validate('log', data);
  };
  exports2.page = function (data) {
    return validate('page', data);
  };
  exports2.pageTimings = function (data) {
    return validate('pageTimings', data);
  };
  exports2.postData = function (data) {
    return validate('postData', data);
  };
  exports2.query = function (data) {
    return validate('query', data);
  };
  exports2.request = function (data) {
    return validate('request', data);
  };
  exports2.response = function (data) {
    return validate('response', data);
  };
  exports2.timings = function (data) {
    return validate('timings', data);
  };
});

// node_modules/request/lib/har.js
var require_har2 = __commonJS((exports2) => {
  'use strict';
  var fs = require('fs');
  var qs = require('querystring');
  var validate = require_promise();
  var extend = require_extend();
  function Har(request) {
    this.request = request;
  }
  Har.prototype.reducer = function (obj, pair) {
    if (obj[pair.name] === void 0) {
      obj[pair.name] = pair.value;
      return obj;
    }
    var arr = [obj[pair.name], pair.value];
    obj[pair.name] = arr;
    return obj;
  };
  Har.prototype.prep = function (data) {
    data.queryObj = {};
    data.headersObj = {};
    data.postData.jsonObj = false;
    data.postData.paramsObj = false;
    if (data.queryString && data.queryString.length) {
      data.queryObj = data.queryString.reduce(this.reducer, {});
    }
    if (data.headers && data.headers.length) {
      data.headersObj = data.headers.reduceRight(function (headers, header) {
        headers[header.name] = header.value;
        return headers;
      }, {});
    }
    if (data.cookies && data.cookies.length) {
      var cookies = data.cookies.map(function (cookie) {
        return cookie.name + '=' + cookie.value;
      });
      if (cookies.length) {
        data.headersObj.cookie = cookies.join('; ');
      }
    }
    function some(arr) {
      return arr.some(function (type) {
        return data.postData.mimeType.indexOf(type) === 0;
      });
    }
    if (
      some([
        'multipart/mixed',
        'multipart/related',
        'multipart/form-data',
        'multipart/alternative',
      ])
    ) {
      data.postData.mimeType = 'multipart/form-data';
    } else if (some(['application/x-www-form-urlencoded'])) {
      if (!data.postData.params) {
        data.postData.text = '';
      } else {
        data.postData.paramsObj = data.postData.params.reduce(this.reducer, {});
        data.postData.text = qs.stringify(data.postData.paramsObj);
      }
    } else if (
      some([
        'text/json',
        'text/x-json',
        'application/json',
        'application/x-json',
      ])
    ) {
      data.postData.mimeType = 'application/json';
      if (data.postData.text) {
        try {
          data.postData.jsonObj = JSON.parse(data.postData.text);
        } catch (e) {
          this.request.debug(e);
          data.postData.mimeType = 'text/plain';
        }
      }
    }
    return data;
  };
  Har.prototype.options = function (options) {
    if (!options.har) {
      return options;
    }
    var har = {};
    extend(har, options.har);
    if (har.log && har.log.entries) {
      har = har.log.entries[0];
    }
    har.url = har.url || options.url || options.uri || options.baseUrl || '/';
    har.httpVersion = har.httpVersion || 'HTTP/1.1';
    har.queryString = har.queryString || [];
    har.headers = har.headers || [];
    har.cookies = har.cookies || [];
    har.postData = har.postData || {};
    har.postData.mimeType = har.postData.mimeType || 'application/octet-stream';
    har.bodySize = 0;
    har.headersSize = 0;
    har.postData.size = 0;
    if (!validate.request(har)) {
      return options;
    }
    var req = this.prep(har);
    if (req.url) {
      options.url = req.url;
    }
    if (req.method) {
      options.method = req.method;
    }
    if (Object.keys(req.queryObj).length) {
      options.qs = req.queryObj;
    }
    if (Object.keys(req.headersObj).length) {
      options.headers = req.headersObj;
    }
    function test(type) {
      return req.postData.mimeType.indexOf(type) === 0;
    }
    if (test('application/x-www-form-urlencoded')) {
      options.form = req.postData.paramsObj;
    } else if (test('application/json')) {
      if (req.postData.jsonObj) {
        options.body = req.postData.jsonObj;
        options.json = true;
      }
    } else if (test('multipart/form-data')) {
      options.formData = {};
      req.postData.params.forEach(function (param) {
        var attachment = {};
        if (!param.fileName && !param.contentType) {
          options.formData[param.name] = param.value;
          return;
        }
        if (param.fileName && !param.value) {
          attachment.value = fs.createReadStream(param.fileName);
        } else if (param.value) {
          attachment.value = param.value;
        }
        if (param.fileName) {
          attachment.options = {
            filename: param.fileName,
            contentType: param.contentType ? param.contentType : null,
          };
        }
        options.formData[param.name] = attachment;
      });
    } else {
      if (req.postData.text) {
        options.body = req.postData.text;
      }
    }
    return options;
  };
  exports2.Har = Har;
});

// node_modules/uuid/lib/rng.js
var require_rng = __commonJS((exports2, module2) => {
  var crypto = require('crypto');
  module2.exports = function nodeRNG() {
    return crypto.randomBytes(16);
  };
});

// node_modules/uuid/lib/bytesToUuid.js
var require_bytesToUuid = __commonJS((exports2, module2) => {
  var byteToHex = [];
  for (var i = 0; i < 256; ++i) {
    byteToHex[i] = (i + 256).toString(16).substr(1);
  }
  function bytesToUuid(buf, offset) {
    var i2 = offset || 0;
    var bth = byteToHex;
    return [
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      '-',
      bth[buf[i2++]],
      bth[buf[i2++]],
      '-',
      bth[buf[i2++]],
      bth[buf[i2++]],
      '-',
      bth[buf[i2++]],
      bth[buf[i2++]],
      '-',
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
      bth[buf[i2++]],
    ].join('');
  }
  module2.exports = bytesToUuid;
});

// node_modules/uuid/v4.js
var require_v4 = __commonJS((exports2, module2) => {
  var rng = require_rng();
  var bytesToUuid = require_bytesToUuid();
  function v4(options, buf, offset) {
    var i = (buf && offset) || 0;
    if (typeof options == 'string') {
      buf = options === 'binary' ? new Array(16) : null;
      options = null;
    }
    options = options || {};
    var rnds = options.random || (options.rng || rng)();
    rnds[6] = (rnds[6] & 15) | 64;
    rnds[8] = (rnds[8] & 63) | 128;
    if (buf) {
      for (var ii = 0; ii < 16; ++ii) {
        buf[i + ii] = rnds[ii];
      }
    }
    return buf || bytesToUuid(rnds);
  }
  module2.exports = v4;
});

// node_modules/request/lib/auth.js
var require_auth = __commonJS((exports2) => {
  'use strict';
  var caseless = require_caseless();
  var uuid = require_v4();
  var helpers = require_helpers();
  var md5 = helpers.md5;
  var toBase64 = helpers.toBase64;
  function Auth(request) {
    this.request = request;
    this.hasAuth = false;
    this.sentAuth = false;
    this.bearerToken = null;
    this.user = null;
    this.pass = null;
  }
  Auth.prototype.basic = function (user, pass, sendImmediately) {
    var self2 = this;
    if (
      typeof user !== 'string' ||
      (pass !== void 0 && typeof pass !== 'string')
    ) {
      self2.request.emit(
        'error',
        new Error('auth() received invalid user or password'),
      );
    }
    self2.user = user;
    self2.pass = pass;
    self2.hasAuth = true;
    var header = user + ':' + (pass || '');
    if (sendImmediately || typeof sendImmediately === 'undefined') {
      var authHeader = 'Basic ' + toBase64(header);
      self2.sentAuth = true;
      return authHeader;
    }
  };
  Auth.prototype.bearer = function (bearer, sendImmediately) {
    var self2 = this;
    self2.bearerToken = bearer;
    self2.hasAuth = true;
    if (sendImmediately || typeof sendImmediately === 'undefined') {
      if (typeof bearer === 'function') {
        bearer = bearer();
      }
      var authHeader = 'Bearer ' + (bearer || '');
      self2.sentAuth = true;
      return authHeader;
    }
  };
  Auth.prototype.digest = function (method, path, authHeader) {
    var self2 = this;
    var challenge = {};
    var re = /([a-z0-9_-]+)=(?:"([^"]+)"|([a-z0-9_-]+))/gi;
    while (true) {
      var match = re.exec(authHeader);
      if (!match) {
        break;
      }
      challenge[match[1]] = match[2] || match[3];
    }
    var ha1Compute = function (algorithm, user, realm, pass, nonce, cnonce2) {
      var ha12 = md5(user + ':' + realm + ':' + pass);
      if (algorithm && algorithm.toLowerCase() === 'md5-sess') {
        return md5(ha12 + ':' + nonce + ':' + cnonce2);
      } else {
        return ha12;
      }
    };
    var qop = /(^|,)\s*auth\s*($|,)/.test(challenge.qop) && 'auth';
    var nc = qop && '00000001';
    var cnonce = qop && uuid().replace(/-/g, '');
    var ha1 = ha1Compute(
      challenge.algorithm,
      self2.user,
      challenge.realm,
      self2.pass,
      challenge.nonce,
      cnonce,
    );
    var ha2 = md5(method + ':' + path);
    var digestResponse = qop
      ? md5(
          ha1 +
            ':' +
            challenge.nonce +
            ':' +
            nc +
            ':' +
            cnonce +
            ':' +
            qop +
            ':' +
            ha2,
        )
      : md5(ha1 + ':' + challenge.nonce + ':' + ha2);
    var authValues = {
      username: self2.user,
      realm: challenge.realm,
      nonce: challenge.nonce,
      uri: path,
      qop,
      response: digestResponse,
      nc,
      cnonce,
      algorithm: challenge.algorithm,
      opaque: challenge.opaque,
    };
    authHeader = [];
    for (var k in authValues) {
      if (authValues[k]) {
        if (k === 'qop' || k === 'nc' || k === 'algorithm') {
          authHeader.push(k + '=' + authValues[k]);
        } else {
          authHeader.push(k + '="' + authValues[k] + '"');
        }
      }
    }
    authHeader = 'Digest ' + authHeader.join(', ');
    self2.sentAuth = true;
    return authHeader;
  };
  Auth.prototype.onRequest = function (user, pass, sendImmediately, bearer) {
    var self2 = this;
    var request = self2.request;
    var authHeader;
    if (bearer === void 0 && user === void 0) {
      self2.request.emit('error', new Error('no auth mechanism defined'));
    } else if (bearer !== void 0) {
      authHeader = self2.bearer(bearer, sendImmediately);
    } else {
      authHeader = self2.basic(user, pass, sendImmediately);
    }
    if (authHeader) {
      request.setHeader('authorization', authHeader);
    }
  };
  Auth.prototype.onResponse = function (response) {
    var self2 = this;
    var request = self2.request;
    if (!self2.hasAuth || self2.sentAuth) {
      return null;
    }
    var c = caseless(response.headers);
    var authHeader = c.get('www-authenticate');
    var authVerb = authHeader && authHeader.split(' ')[0].toLowerCase();
    request.debug('reauth', authVerb);
    switch (authVerb) {
      case 'basic':
        return self2.basic(self2.user, self2.pass, true);
      case 'bearer':
        return self2.bearer(self2.bearerToken, true);
      case 'digest':
        return self2.digest(request.method, request.path, authHeader);
    }
  };
  exports2.Auth = Auth;
});

// node_modules/oauth-sign/index.js
var require_oauth_sign = __commonJS((exports2) => {
  var crypto = require('crypto');
  function sha(key, body, algorithm) {
    return crypto.createHmac(algorithm, key).update(body).digest('base64');
  }
  function rsa(key, body) {
    return crypto.createSign('RSA-SHA1').update(body).sign(key, 'base64');
  }
  function rfc3986(str) {
    return encodeURIComponent(str)
      .replace(/!/g, '%21')
      .replace(/\*/g, '%2A')
      .replace(/\(/g, '%28')
      .replace(/\)/g, '%29')
      .replace(/'/g, '%27');
  }
  function map(obj) {
    var key,
      val,
      arr = [];
    for (key in obj) {
      val = obj[key];
      if (Array.isArray(val))
        for (var i = 0; i < val.length; i++) arr.push([key, val[i]]);
      else if (typeof val === 'object')
        for (var prop in val) arr.push([key + '[' + prop + ']', val[prop]]);
      else arr.push([key, val]);
    }
    return arr;
  }
  function compare(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
  }
  function generateBase(httpMethod, base_uri, params) {
    var normalized = map(params)
      .map(function (p) {
        return [rfc3986(p[0]), rfc3986(p[1] || '')];
      })
      .sort(function (a, b) {
        return compare(a[0], b[0]) || compare(a[1], b[1]);
      })
      .map(function (p) {
        return p.join('=');
      })
      .join('&');
    var base = [
      rfc3986(httpMethod ? httpMethod.toUpperCase() : 'GET'),
      rfc3986(base_uri),
      rfc3986(normalized),
    ].join('&');
    return base;
  }
  function hmacsign(
    httpMethod,
    base_uri,
    params,
    consumer_secret,
    token_secret,
  ) {
    var base = generateBase(httpMethod, base_uri, params);
    var key = [consumer_secret || '', token_secret || '']
      .map(rfc3986)
      .join('&');
    return sha(key, base, 'sha1');
  }
  function hmacsign256(
    httpMethod,
    base_uri,
    params,
    consumer_secret,
    token_secret,
  ) {
    var base = generateBase(httpMethod, base_uri, params);
    var key = [consumer_secret || '', token_secret || '']
      .map(rfc3986)
      .join('&');
    return sha(key, base, 'sha256');
  }
  function rsasign(httpMethod, base_uri, params, private_key, token_secret) {
    var base = generateBase(httpMethod, base_uri, params);
    var key = private_key || '';
    return rsa(key, base);
  }
  function plaintext(consumer_secret, token_secret) {
    var key = [consumer_secret || '', token_secret || '']
      .map(rfc3986)
      .join('&');
    return key;
  }
  function sign(
    signMethod,
    httpMethod,
    base_uri,
    params,
    consumer_secret,
    token_secret,
  ) {
    var method;
    var skipArgs = 1;
    switch (signMethod) {
      case 'RSA-SHA1':
        method = rsasign;
        break;
      case 'HMAC-SHA1':
        method = hmacsign;
        break;
      case 'HMAC-SHA256':
        method = hmacsign256;
        break;
      case 'PLAINTEXT':
        method = plaintext;
        skipArgs = 4;
        break;
      default:
        throw new Error('Signature method not supported: ' + signMethod);
    }
    return method.apply(null, [].slice.call(arguments, skipArgs));
  }
  exports2.hmacsign = hmacsign;
  exports2.hmacsign256 = hmacsign256;
  exports2.rsasign = rsasign;
  exports2.plaintext = plaintext;
  exports2.sign = sign;
  exports2.rfc3986 = rfc3986;
  exports2.generateBase = generateBase;
});

// node_modules/request/lib/oauth.js
var require_oauth = __commonJS((exports2) => {
  'use strict';
  var url = require('url');
  var qs = require_lib4();
  var caseless = require_caseless();
  var uuid = require_v4();
  var oauth = require_oauth_sign();
  var crypto = require('crypto');
  var Buffer2 = require_safe_buffer().Buffer;
  function OAuth(request) {
    this.request = request;
    this.params = null;
  }
  OAuth.prototype.buildParams = function (
    _oauth,
    uri,
    method,
    query,
    form,
    qsLib,
  ) {
    var oa = {};
    for (var i in _oauth) {
      oa['oauth_' + i] = _oauth[i];
    }
    if (!oa.oauth_version) {
      oa.oauth_version = '1.0';
    }
    if (!oa.oauth_timestamp) {
      oa.oauth_timestamp = Math.floor(Date.now() / 1e3).toString();
    }
    if (!oa.oauth_nonce) {
      oa.oauth_nonce = uuid().replace(/-/g, '');
    }
    if (!oa.oauth_signature_method) {
      oa.oauth_signature_method = 'HMAC-SHA1';
    }
    var consumer_secret_or_private_key =
      oa.oauth_consumer_secret || oa.oauth_private_key;
    delete oa.oauth_consumer_secret;
    delete oa.oauth_private_key;
    var token_secret = oa.oauth_token_secret;
    delete oa.oauth_token_secret;
    var realm = oa.oauth_realm;
    delete oa.oauth_realm;
    delete oa.oauth_transport_method;
    var baseurl = uri.protocol + '//' + uri.host + uri.pathname;
    var params = qsLib.parse(
      [].concat(query, form, qsLib.stringify(oa)).join('&'),
    );
    oa.oauth_signature = oauth.sign(
      oa.oauth_signature_method,
      method,
      baseurl,
      params,
      consumer_secret_or_private_key,
      token_secret,
    );
    if (realm) {
      oa.realm = realm;
    }
    return oa;
  };
  OAuth.prototype.buildBodyHash = function (_oauth, body) {
    if (
      ['HMAC-SHA1', 'RSA-SHA1'].indexOf(
        _oauth.signature_method || 'HMAC-SHA1',
      ) < 0
    ) {
      this.request.emit(
        'error',
        new Error(
          'oauth: ' +
            _oauth.signature_method +
            ' signature_method not supported with body_hash signing.',
        ),
      );
    }
    var shasum = crypto.createHash('sha1');
    shasum.update(body || '');
    var sha1 = shasum.digest('hex');
    return Buffer2.from(sha1, 'hex').toString('base64');
  };
  OAuth.prototype.concatParams = function (oa, sep, wrap) {
    wrap = wrap || '';
    var params = Object.keys(oa)
      .filter(function (i) {
        return i !== 'realm' && i !== 'oauth_signature';
      })
      .sort();
    if (oa.realm) {
      params.splice(0, 0, 'realm');
    }
    params.push('oauth_signature');
    return params
      .map(function (i) {
        return i + '=' + wrap + oauth.rfc3986(oa[i]) + wrap;
      })
      .join(sep);
  };
  OAuth.prototype.onRequest = function (_oauth) {
    var self2 = this;
    self2.params = _oauth;
    var uri = self2.request.uri || {};
    var method = self2.request.method || '';
    var headers = caseless(self2.request.headers);
    var body = self2.request.body || '';
    var qsLib = self2.request.qsLib || qs;
    var form;
    var query;
    var contentType = headers.get('content-type') || '';
    var formContentType = 'application/x-www-form-urlencoded';
    var transport = _oauth.transport_method || 'header';
    if (contentType.slice(0, formContentType.length) === formContentType) {
      contentType = formContentType;
      form = body;
    }
    if (uri.query) {
      query = uri.query;
    }
    if (
      transport === 'body' &&
      (method !== 'POST' || contentType !== formContentType)
    ) {
      self2.request.emit(
        'error',
        new Error(
          'oauth: transport_method of body requires POST and content-type ' +
            formContentType,
        ),
      );
    }
    if (!form && typeof _oauth.body_hash === 'boolean') {
      _oauth.body_hash = self2.buildBodyHash(
        _oauth,
        self2.request.body.toString(),
      );
    }
    var oa = self2.buildParams(_oauth, uri, method, query, form, qsLib);
    switch (transport) {
      case 'header':
        self2.request.setHeader(
          'Authorization',
          'OAuth ' + self2.concatParams(oa, ',', '"'),
        );
        break;
      case 'query':
        var href = (self2.request.uri.href +=
          (query ? '&' : '?') + self2.concatParams(oa, '&'));
        self2.request.uri = url.parse(href);
        self2.request.path = self2.request.uri.path;
        break;
      case 'body':
        self2.request.body =
          (form ? form + '&' : '') + self2.concatParams(oa, '&');
        break;
      default:
        self2.request.emit(
          'error',
          new Error('oauth: transport_method invalid'),
        );
    }
  };
  exports2.OAuth = OAuth;
});

// node_modules/request/lib/hawk.js
var require_hawk = __commonJS((exports2) => {
  'use strict';
  var crypto = require('crypto');
  function randomString(size) {
    var bits = (size + 1) * 6;
    var buffer = crypto.randomBytes(Math.ceil(bits / 8));
    var string = buffer
      .toString('base64')
      .replace(/\+/g, '-')
      .replace(/\//g, '_')
      .replace(/=/g, '');
    return string.slice(0, size);
  }
  function calculatePayloadHash(payload, algorithm, contentType) {
    var hash = crypto.createHash(algorithm);
    hash.update('hawk.1.payload\n');
    hash.update(
      (contentType ? contentType.split(';')[0].trim().toLowerCase() : '') +
        '\n',
    );
    hash.update(payload || '');
    hash.update('\n');
    return hash.digest('base64');
  }
  exports2.calculateMac = function (credentials, opts) {
    var normalized =
      'hawk.1.header\n' +
      opts.ts +
      '\n' +
      opts.nonce +
      '\n' +
      (opts.method || '').toUpperCase() +
      '\n' +
      opts.resource +
      '\n' +
      opts.host.toLowerCase() +
      '\n' +
      opts.port +
      '\n' +
      (opts.hash || '') +
      '\n';
    if (opts.ext) {
      normalized =
        normalized + opts.ext.replace('\\', '\\\\').replace('\n', '\\n');
    }
    normalized = normalized + '\n';
    if (opts.app) {
      normalized = normalized + opts.app + '\n' + (opts.dlg || '') + '\n';
    }
    var hmac = crypto
      .createHmac(credentials.algorithm, credentials.key)
      .update(normalized);
    var digest = hmac.digest('base64');
    return digest;
  };
  exports2.header = function (uri, method, opts) {
    var timestamp =
      opts.timestamp ||
      Math.floor((Date.now() + (opts.localtimeOffsetMsec || 0)) / 1e3);
    var credentials = opts.credentials;
    if (
      !credentials ||
      !credentials.id ||
      !credentials.key ||
      !credentials.algorithm
    ) {
      return '';
    }
    if (['sha1', 'sha256'].indexOf(credentials.algorithm) === -1) {
      return '';
    }
    var artifacts = {
      ts: timestamp,
      nonce: opts.nonce || randomString(6),
      method,
      resource: uri.pathname + (uri.search || ''),
      host: uri.hostname,
      port: uri.port || (uri.protocol === 'http:' ? 80 : 443),
      hash: opts.hash,
      ext: opts.ext,
      app: opts.app,
      dlg: opts.dlg,
    };
    if (!artifacts.hash && (opts.payload || opts.payload === '')) {
      artifacts.hash = calculatePayloadHash(
        opts.payload,
        credentials.algorithm,
        opts.contentType,
      );
    }
    var mac = exports2.calculateMac(credentials, artifacts);
    var hasExt =
      artifacts.ext !== null &&
      artifacts.ext !== void 0 &&
      artifacts.ext !== '';
    var header =
      'Hawk id="' +
      credentials.id +
      '", ts="' +
      artifacts.ts +
      '", nonce="' +
      artifacts.nonce +
      (artifacts.hash ? '", hash="' + artifacts.hash : '') +
      (hasExt
        ? '", ext="' + artifacts.ext.replace(/\\/g, '\\\\').replace(/"/g, '\\"')
        : '') +
      '", mac="' +
      mac +
      '"';
    if (artifacts.app) {
      header =
        header +
        ', app="' +
        artifacts.app +
        (artifacts.dlg ? '", dlg="' + artifacts.dlg : '') +
        '"';
    }
    return header;
  };
});

// node_modules/request/lib/multipart.js
var require_multipart = __commonJS((exports2) => {
  'use strict';
  var uuid = require_v4();
  var CombinedStream = require_combined_stream();
  var isstream = require_isstream();
  var Buffer2 = require_safe_buffer().Buffer;
  function Multipart(request) {
    this.request = request;
    this.boundary = uuid();
    this.chunked = false;
    this.body = null;
  }
  Multipart.prototype.isChunked = function (options) {
    var self2 = this;
    var chunked = false;
    var parts = options.data || options;
    if (!parts.forEach) {
      self2.request.emit(
        'error',
        new Error('Argument error, options.multipart.'),
      );
    }
    if (options.chunked !== void 0) {
      chunked = options.chunked;
    }
    if (self2.request.getHeader('transfer-encoding') === 'chunked') {
      chunked = true;
    }
    if (!chunked) {
      parts.forEach(function (part) {
        if (typeof part.body === 'undefined') {
          self2.request.emit(
            'error',
            new Error('Body attribute missing in multipart.'),
          );
        }
        if (isstream(part.body)) {
          chunked = true;
        }
      });
    }
    return chunked;
  };
  Multipart.prototype.setHeaders = function (chunked) {
    var self2 = this;
    if (chunked && !self2.request.hasHeader('transfer-encoding')) {
      self2.request.setHeader('transfer-encoding', 'chunked');
    }
    var header = self2.request.getHeader('content-type');
    if (!header || header.indexOf('multipart') === -1) {
      self2.request.setHeader(
        'content-type',
        'multipart/related; boundary=' + self2.boundary,
      );
    } else {
      if (header.indexOf('boundary') !== -1) {
        self2.boundary = header.replace(/.*boundary=([^\s;]+).*/, '$1');
      } else {
        self2.request.setHeader(
          'content-type',
          header + '; boundary=' + self2.boundary,
        );
      }
    }
  };
  Multipart.prototype.build = function (parts, chunked) {
    var self2 = this;
    var body = chunked ? new CombinedStream() : [];
    function add(part) {
      if (typeof part === 'number') {
        part = part.toString();
      }
      return chunked ? body.append(part) : body.push(Buffer2.from(part));
    }
    if (self2.request.preambleCRLF) {
      add('\r\n');
    }
    parts.forEach(function (part) {
      var preamble = '--' + self2.boundary + '\r\n';
      Object.keys(part).forEach(function (key) {
        if (key === 'body') {
          return;
        }
        preamble += key + ': ' + part[key] + '\r\n';
      });
      preamble += '\r\n';
      add(preamble);
      add(part.body);
      add('\r\n');
    });
    add('--' + self2.boundary + '--');
    if (self2.request.postambleCRLF) {
      add('\r\n');
    }
    return body;
  };
  Multipart.prototype.onRequest = function (options) {
    var self2 = this;
    var chunked = self2.isChunked(options);
    var parts = options.data || options;
    self2.setHeaders(chunked);
    self2.chunked = chunked;
    self2.body = self2.build(parts, chunked);
  };
  exports2.Multipart = Multipart;
});

// node_modules/request/lib/redirect.js
var require_redirect = __commonJS((exports2) => {
  'use strict';
  var url = require('url');
  var isUrl = /^https?:/;
  function Redirect(request) {
    this.request = request;
    this.followRedirect = true;
    this.followRedirects = true;
    this.followAllRedirects = false;
    this.followOriginalHttpMethod = false;
    this.allowRedirect = function () {
      return true;
    };
    this.maxRedirects = 10;
    this.redirects = [];
    this.redirectsFollowed = 0;
    this.removeRefererHeader = false;
  }
  Redirect.prototype.onRequest = function (options) {
    var self2 = this;
    if (options.maxRedirects !== void 0) {
      self2.maxRedirects = options.maxRedirects;
    }
    if (typeof options.followRedirect === 'function') {
      self2.allowRedirect = options.followRedirect;
    }
    if (options.followRedirect !== void 0) {
      self2.followRedirects = !!options.followRedirect;
    }
    if (options.followAllRedirects !== void 0) {
      self2.followAllRedirects = options.followAllRedirects;
    }
    if (self2.followRedirects || self2.followAllRedirects) {
      self2.redirects = self2.redirects || [];
    }
    if (options.removeRefererHeader !== void 0) {
      self2.removeRefererHeader = options.removeRefererHeader;
    }
    if (options.followOriginalHttpMethod !== void 0) {
      self2.followOriginalHttpMethod = options.followOriginalHttpMethod;
    }
  };
  Redirect.prototype.redirectTo = function (response) {
    var self2 = this;
    var request = self2.request;
    var redirectTo = null;
    if (
      response.statusCode >= 300 &&
      response.statusCode < 400 &&
      response.caseless.has('location')
    ) {
      var location = response.caseless.get('location');
      request.debug('redirect', location);
      if (self2.followAllRedirects) {
        redirectTo = location;
      } else if (self2.followRedirects) {
        switch (request.method) {
          case 'PATCH':
          case 'PUT':
          case 'POST':
          case 'DELETE':
            break;
          default:
            redirectTo = location;
            break;
        }
      }
    } else if (response.statusCode === 401) {
      var authHeader = request._auth.onResponse(response);
      if (authHeader) {
        request.setHeader('authorization', authHeader);
        redirectTo = request.uri;
      }
    }
    return redirectTo;
  };
  Redirect.prototype.onResponse = function (response) {
    var self2 = this;
    var request = self2.request;
    var redirectTo = self2.redirectTo(response);
    if (!redirectTo || !self2.allowRedirect.call(request, response)) {
      return false;
    }
    request.debug('redirect to', redirectTo);
    if (response.resume) {
      response.resume();
    }
    if (self2.redirectsFollowed >= self2.maxRedirects) {
      request.emit(
        'error',
        new Error(
          'Exceeded maxRedirects. Probably stuck in a redirect loop ' +
            request.uri.href,
        ),
      );
      return false;
    }
    self2.redirectsFollowed += 1;
    if (!isUrl.test(redirectTo)) {
      redirectTo = url.resolve(request.uri.href, redirectTo);
    }
    var uriPrev = request.uri;
    request.uri = url.parse(redirectTo);
    if (request.uri.protocol !== uriPrev.protocol) {
      delete request.agent;
    }
    self2.redirects.push({
      statusCode: response.statusCode,
      redirectUri: redirectTo,
    });
    if (
      self2.followAllRedirects &&
      request.method !== 'HEAD' &&
      response.statusCode !== 401 &&
      response.statusCode !== 307
    ) {
      request.method = self2.followOriginalHttpMethod ? request.method : 'GET';
    }
    delete request.src;
    delete request.req;
    delete request._started;
    if (response.statusCode !== 401 && response.statusCode !== 307) {
      delete request.body;
      delete request._form;
      if (request.headers) {
        request.removeHeader('host');
        request.removeHeader('content-type');
        request.removeHeader('content-length');
        if (request.uri.hostname !== request.originalHost.split(':')[0]) {
          request.removeHeader('authorization');
        }
      }
    }
    if (!self2.removeRefererHeader) {
      request.setHeader('referer', uriPrev.href);
    }
    request.emit('redirect');
    request.init();
    return true;
  };
  exports2.Redirect = Redirect;
});

// node_modules/tunnel-agent/index.js
var require_tunnel_agent = __commonJS((exports2) => {
  'use strict';
  var net = require('net');
  var tls = require('tls');
  var http = require('http');
  var https = require('https');
  var events = require('events');
  var assert = require('assert');
  var util = require('util');
  var Buffer2 = require_safe_buffer().Buffer;
  exports2.httpOverHttp = httpOverHttp;
  exports2.httpsOverHttp = httpsOverHttp;
  exports2.httpOverHttps = httpOverHttps;
  exports2.httpsOverHttps = httpsOverHttps;
  function httpOverHttp(options) {
    var agent = new TunnelingAgent(options);
    agent.request = http.request;
    return agent;
  }
  function httpsOverHttp(options) {
    var agent = new TunnelingAgent(options);
    agent.request = http.request;
    agent.createSocket = createSecureSocket;
    agent.defaultPort = 443;
    return agent;
  }
  function httpOverHttps(options) {
    var agent = new TunnelingAgent(options);
    agent.request = https.request;
    return agent;
  }
  function httpsOverHttps(options) {
    var agent = new TunnelingAgent(options);
    agent.request = https.request;
    agent.createSocket = createSecureSocket;
    agent.defaultPort = 443;
    return agent;
  }
  function TunnelingAgent(options) {
    var self2 = this;
    self2.options = options || {};
    self2.proxyOptions = self2.options.proxy || {};
    self2.maxSockets = self2.options.maxSockets || http.Agent.defaultMaxSockets;
    self2.requests = [];
    self2.sockets = [];
    self2.on('free', function onFree(socket, host, port) {
      for (var i = 0, len = self2.requests.length; i < len; ++i) {
        var pending = self2.requests[i];
        if (pending.host === host && pending.port === port) {
          self2.requests.splice(i, 1);
          pending.request.onSocket(socket);
          return;
        }
      }
      socket.destroy();
      self2.removeSocket(socket);
    });
  }
  util.inherits(TunnelingAgent, events.EventEmitter);
  TunnelingAgent.prototype.addRequest = function addRequest(req, options) {
    var self2 = this;
    if (typeof options === 'string') {
      options = {
        host: options,
        port: arguments[2],
        path: arguments[3],
      };
    }
    if (self2.sockets.length >= this.maxSockets) {
      self2.requests.push({
        host: options.host,
        port: options.port,
        request: req,
      });
      return;
    }
    self2.createConnection({
      host: options.host,
      port: options.port,
      request: req,
    });
  };
  TunnelingAgent.prototype.createConnection = function createConnection(
    pending,
  ) {
    var self2 = this;
    self2.createSocket(pending, function (socket) {
      socket.on('free', onFree);
      socket.on('close', onCloseOrRemove);
      socket.on('agentRemove', onCloseOrRemove);
      pending.request.onSocket(socket);
      function onFree() {
        self2.emit('free', socket, pending.host, pending.port);
      }
      function onCloseOrRemove(err) {
        self2.removeSocket(socket);
        socket.removeListener('free', onFree);
        socket.removeListener('close', onCloseOrRemove);
        socket.removeListener('agentRemove', onCloseOrRemove);
      }
    });
  };
  TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
    var self2 = this;
    var placeholder = {};
    self2.sockets.push(placeholder);
    var connectOptions = mergeOptions({}, self2.proxyOptions, {
      method: 'CONNECT',
      path: options.host + ':' + options.port,
      agent: false,
    });
    if (connectOptions.proxyAuth) {
      connectOptions.headers = connectOptions.headers || {};
      connectOptions.headers['Proxy-Authorization'] =
        'Basic ' + Buffer2.from(connectOptions.proxyAuth).toString('base64');
    }
    debug('making CONNECT request');
    var connectReq = self2.request(connectOptions);
    connectReq.useChunkedEncodingByDefault = false;
    connectReq.once('response', onResponse);
    connectReq.once('upgrade', onUpgrade);
    connectReq.once('connect', onConnect);
    connectReq.once('error', onError);
    connectReq.end();
    function onResponse(res) {
      res.upgrade = true;
    }
    function onUpgrade(res, socket, head) {
      process.nextTick(function () {
        onConnect(res, socket, head);
      });
    }
    function onConnect(res, socket, head) {
      connectReq.removeAllListeners();
      socket.removeAllListeners();
      if (res.statusCode === 200) {
        assert.equal(head.length, 0);
        debug('tunneling connection has established');
        self2.sockets[self2.sockets.indexOf(placeholder)] = socket;
        cb(socket);
      } else {
        debug(
          'tunneling socket could not be established, statusCode=%d',
          res.statusCode,
        );
        var error = new Error(
          'tunneling socket could not be established, statusCode=' +
            res.statusCode,
        );
        error.code = 'ECONNRESET';
        options.request.emit('error', error);
        self2.removeSocket(placeholder);
      }
    }
    function onError(cause) {
      connectReq.removeAllListeners();
      debug(
        'tunneling socket could not be established, cause=%s\n',
        cause.message,
        cause.stack,
      );
      var error = new Error(
        'tunneling socket could not be established, cause=' + cause.message,
      );
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self2.removeSocket(placeholder);
    }
  };
  TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
    var pos = this.sockets.indexOf(socket);
    if (pos === -1) return;
    this.sockets.splice(pos, 1);
    var pending = this.requests.shift();
    if (pending) {
      this.createConnection(pending);
    }
  };
  function createSecureSocket(options, cb) {
    var self2 = this;
    TunnelingAgent.prototype.createSocket.call(
      self2,
      options,
      function (socket) {
        var secureSocket = tls.connect(
          0,
          mergeOptions({}, self2.options, {
            servername: options.host,
            socket,
          }),
        );
        self2.sockets[self2.sockets.indexOf(socket)] = secureSocket;
        cb(secureSocket);
      },
    );
  }
  function mergeOptions(target) {
    for (var i = 1, len = arguments.length; i < len; ++i) {
      var overrides = arguments[i];
      if (typeof overrides === 'object') {
        var keys = Object.keys(overrides);
        for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
          var k = keys[j];
          if (overrides[k] !== void 0) {
            target[k] = overrides[k];
          }
        }
      }
    }
    return target;
  }
  var debug;
  if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
    debug = function () {
      var args = Array.prototype.slice.call(arguments);
      if (typeof args[0] === 'string') {
        args[0] = 'TUNNEL: ' + args[0];
      } else {
        args.unshift('TUNNEL:');
      }
      console.error.apply(console, args);
    };
  } else {
    debug = function () {};
  }
  exports2.debug = debug;
});

// node_modules/request/lib/tunnel.js
var require_tunnel = __commonJS((exports2) => {
  'use strict';
  var url = require('url');
  var tunnel = require_tunnel_agent();
  var defaultProxyHeaderWhiteList = [
    'accept',
    'accept-charset',
    'accept-encoding',
    'accept-language',
    'accept-ranges',
    'cache-control',
    'content-encoding',
    'content-language',
    'content-location',
    'content-md5',
    'content-range',
    'content-type',
    'connection',
    'date',
    'expect',
    'max-forwards',
    'pragma',
    'referer',
    'te',
    'user-agent',
    'via',
  ];
  var defaultProxyHeaderExclusiveList = ['proxy-authorization'];
  function constructProxyHost(uriObject) {
    var port = uriObject.port;
    var protocol = uriObject.protocol;
    var proxyHost = uriObject.hostname + ':';
    if (port) {
      proxyHost += port;
    } else if (protocol === 'https:') {
      proxyHost += '443';
    } else {
      proxyHost += '80';
    }
    return proxyHost;
  }
  function constructProxyHeaderWhiteList(headers, proxyHeaderWhiteList) {
    var whiteList = proxyHeaderWhiteList.reduce(function (set, header) {
      set[header.toLowerCase()] = true;
      return set;
    }, {});
    return Object.keys(headers)
      .filter(function (header) {
        return whiteList[header.toLowerCase()];
      })
      .reduce(function (set, header) {
        set[header] = headers[header];
        return set;
      }, {});
  }
  function constructTunnelOptions(request, proxyHeaders) {
    var proxy = request.proxy;
    var tunnelOptions = {
      proxy: {
        host: proxy.hostname,
        port: +proxy.port,
        proxyAuth: proxy.auth,
        headers: proxyHeaders,
      },
      headers: request.headers,
      ca: request.ca,
      cert: request.cert,
      key: request.key,
      passphrase: request.passphrase,
      pfx: request.pfx,
      ciphers: request.ciphers,
      rejectUnauthorized: request.rejectUnauthorized,
      secureOptions: request.secureOptions,
      secureProtocol: request.secureProtocol,
    };
    return tunnelOptions;
  }
  function constructTunnelFnName(uri, proxy) {
    var uriProtocol = uri.protocol === 'https:' ? 'https' : 'http';
    var proxyProtocol = proxy.protocol === 'https:' ? 'Https' : 'Http';
    return [uriProtocol, proxyProtocol].join('Over');
  }
  function getTunnelFn(request) {
    var uri = request.uri;
    var proxy = request.proxy;
    var tunnelFnName = constructTunnelFnName(uri, proxy);
    return tunnel[tunnelFnName];
  }
  function Tunnel(request) {
    this.request = request;
    this.proxyHeaderWhiteList = defaultProxyHeaderWhiteList;
    this.proxyHeaderExclusiveList = [];
    if (typeof request.tunnel !== 'undefined') {
      this.tunnelOverride = request.tunnel;
    }
  }
  Tunnel.prototype.isEnabled = function () {
    var self2 = this;
    var request = self2.request;
    if (typeof self2.tunnelOverride !== 'undefined') {
      return self2.tunnelOverride;
    }
    if (request.uri.protocol === 'https:') {
      return true;
    }
    return false;
  };
  Tunnel.prototype.setup = function (options) {
    var self2 = this;
    var request = self2.request;
    options = options || {};
    if (typeof request.proxy === 'string') {
      request.proxy = url.parse(request.proxy);
    }
    if (!request.proxy || !request.tunnel) {
      return false;
    }
    if (options.proxyHeaderWhiteList) {
      self2.proxyHeaderWhiteList = options.proxyHeaderWhiteList;
    }
    if (options.proxyHeaderExclusiveList) {
      self2.proxyHeaderExclusiveList = options.proxyHeaderExclusiveList;
    }
    var proxyHeaderExclusiveList = self2.proxyHeaderExclusiveList.concat(
      defaultProxyHeaderExclusiveList,
    );
    var proxyHeaderWhiteList = self2.proxyHeaderWhiteList.concat(
      proxyHeaderExclusiveList,
    );
    var proxyHeaders = constructProxyHeaderWhiteList(
      request.headers,
      proxyHeaderWhiteList,
    );
    proxyHeaders.host = constructProxyHost(request.uri);
    proxyHeaderExclusiveList.forEach(request.removeHeader, request);
    var tunnelFn = getTunnelFn(request);
    var tunnelOptions = constructTunnelOptions(request, proxyHeaders);
    request.agent = tunnelFn(tunnelOptions);
    return true;
  };
  Tunnel.defaultProxyHeaderWhiteList = defaultProxyHeaderWhiteList;
  Tunnel.defaultProxyHeaderExclusiveList = defaultProxyHeaderExclusiveList;
  exports2.Tunnel = Tunnel;
});

// node_modules/performance-now/lib/performance-now.js
var require_performance_now = __commonJS((exports2, module2) => {
  (function () {
    var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
    if (
      typeof performance !== 'undefined' &&
      performance !== null &&
      performance.now
    ) {
      module2.exports = function () {
        return performance.now();
      };
    } else if (
      typeof process !== 'undefined' &&
      process !== null &&
      process.hrtime
    ) {
      module2.exports = function () {
        return (getNanoSeconds() - nodeLoadTime) / 1e6;
      };
      hrtime = process.hrtime;
      getNanoSeconds = function () {
        var hr;
        hr = hrtime();
        return hr[0] * 1e9 + hr[1];
      };
      moduleLoadTime = getNanoSeconds();
      upTime = process.uptime() * 1e9;
      nodeLoadTime = moduleLoadTime - upTime;
    } else if (Date.now) {
      module2.exports = function () {
        return Date.now() - loadTime;
      };
      loadTime = Date.now();
    } else {
      module2.exports = function () {
        return new Date().getTime() - loadTime;
      };
      loadTime = new Date().getTime();
    }
  }.call(exports2));
});

// node_modules/request/request.js
var require_request2 = __commonJS((exports2, module2) => {
  'use strict';
  var http = require('http');
  var https = require('https');
  var url = require('url');
  var util = require('util');
  var stream = require('stream');
  var zlib = require('zlib');
  var aws2 = require_aws_sign2();
  var aws4 = require_aws4();
  var httpSignature = require_lib3();
  var mime = require_mime_types();
  var caseless = require_caseless();
  var ForeverAgent = require_forever_agent();
  var FormData = require_form_data();
  var extend = require_extend();
  var isstream = require_isstream();
  var isTypedArray = require_is_typedarray().strict;
  var helpers = require_helpers();
  var cookies = require_cookies();
  var getProxyFromURI = require_getProxyFromURI();
  var Querystring = require_querystring().Querystring;
  var Har = require_har2().Har;
  var Auth = require_auth().Auth;
  var OAuth = require_oauth().OAuth;
  var hawk = require_hawk();
  var Multipart = require_multipart().Multipart;
  var Redirect = require_redirect().Redirect;
  var Tunnel = require_tunnel().Tunnel;
  var now2 = require_performance_now();
  var Buffer2 = require_safe_buffer().Buffer;
  var safeStringify = helpers.safeStringify;
  var isReadStream = helpers.isReadStream;
  var toBase64 = helpers.toBase64;
  var defer = helpers.defer;
  var copy = helpers.copy;
  var version = helpers.version;
  var globalCookieJar = cookies.jar();
  var globalPool = {};
  function filterForNonReserved(reserved, options) {
    var object = {};
    for (var i in options) {
      var notReserved = reserved.indexOf(i) === -1;
      if (notReserved) {
        object[i] = options[i];
      }
    }
    return object;
  }
  function filterOutReservedFunctions(reserved, options) {
    var object = {};
    for (var i in options) {
      var isReserved = !(reserved.indexOf(i) === -1);
      var isFunction = typeof options[i] === 'function';
      if (!(isReserved && isFunction)) {
        object[i] = options[i];
      }
    }
    return object;
  }
  function requestToJSON() {
    var self2 = this;
    return {
      uri: self2.uri,
      method: self2.method,
      headers: self2.headers,
    };
  }
  function responseToJSON() {
    var self2 = this;
    return {
      statusCode: self2.statusCode,
      body: self2.body,
      headers: self2.headers,
      request: requestToJSON.call(self2.request),
    };
  }
  function Request(options) {
    var self2 = this;
    if (options.har) {
      self2._har = new Har(self2);
      options = self2._har.options(options);
    }
    stream.Stream.call(self2);
    var reserved = Object.keys(Request.prototype);
    var nonReserved = filterForNonReserved(reserved, options);
    extend(self2, nonReserved);
    options = filterOutReservedFunctions(reserved, options);
    self2.readable = true;
    self2.writable = true;
    if (options.method) {
      self2.explicitMethod = true;
    }
    self2._qs = new Querystring(self2);
    self2._auth = new Auth(self2);
    self2._oauth = new OAuth(self2);
    self2._multipart = new Multipart(self2);
    self2._redirect = new Redirect(self2);
    self2._tunnel = new Tunnel(self2);
    self2.init(options);
  }
  util.inherits(Request, stream.Stream);
  Request.debug =
    process.env.NODE_DEBUG && /\brequest\b/.test(process.env.NODE_DEBUG);
  function debug() {
    if (Request.debug) {
      console.error('REQUEST %s', util.format.apply(util, arguments));
    }
  }
  Request.prototype.debug = debug;
  Request.prototype.init = function (options) {
    var self2 = this;
    if (!options) {
      options = {};
    }
    self2.headers = self2.headers ? copy(self2.headers) : {};
    for (var headerName in self2.headers) {
      if (typeof self2.headers[headerName] === 'undefined') {
        delete self2.headers[headerName];
      }
    }
    caseless.httpify(self2, self2.headers);
    if (!self2.method) {
      self2.method = options.method || 'GET';
    }
    if (!self2.localAddress) {
      self2.localAddress = options.localAddress;
    }
    self2._qs.init(options);
    debug(options);
    if (!self2.pool && self2.pool !== false) {
      self2.pool = globalPool;
    }
    self2.dests = self2.dests || [];
    self2.__isRequestRequest = true;
    if (!self2._callback && self2.callback) {
      self2._callback = self2.callback;
      self2.callback = function () {
        if (self2._callbackCalled) {
          return;
        }
        self2._callbackCalled = true;
        self2._callback.apply(self2, arguments);
      };
      self2.on('error', self2.callback.bind());
      self2.on('complete', self2.callback.bind(self2, null));
    }
    if (!self2.uri && self2.url) {
      self2.uri = self2.url;
      delete self2.url;
    }
    if (self2.baseUrl) {
      if (typeof self2.baseUrl !== 'string') {
        return self2.emit(
          'error',
          new Error('options.baseUrl must be a string'),
        );
      }
      if (typeof self2.uri !== 'string') {
        return self2.emit(
          'error',
          new Error('options.uri must be a string when using options.baseUrl'),
        );
      }
      if (self2.uri.indexOf('//') === 0 || self2.uri.indexOf('://') !== -1) {
        return self2.emit(
          'error',
          new Error('options.uri must be a path when using options.baseUrl'),
        );
      }
      var baseUrlEndsWithSlash =
        self2.baseUrl.lastIndexOf('/') === self2.baseUrl.length - 1;
      var uriStartsWithSlash = self2.uri.indexOf('/') === 0;
      if (baseUrlEndsWithSlash && uriStartsWithSlash) {
        self2.uri = self2.baseUrl + self2.uri.slice(1);
      } else if (baseUrlEndsWithSlash || uriStartsWithSlash) {
        self2.uri = self2.baseUrl + self2.uri;
      } else if (self2.uri === '') {
        self2.uri = self2.baseUrl;
      } else {
        self2.uri = self2.baseUrl + '/' + self2.uri;
      }
      delete self2.baseUrl;
    }
    if (!self2.uri) {
      return self2.emit(
        'error',
        new Error('options.uri is a required argument'),
      );
    }
    if (typeof self2.uri === 'string') {
      self2.uri = url.parse(self2.uri);
    }
    if (!self2.uri.href) {
      self2.uri.href = url.format(self2.uri);
    }
    if (self2.uri.protocol === 'unix:') {
      return self2.emit(
        'error',
        new Error(
          '`unix://` URL scheme is no longer supported. Please use the format `http://unix:SOCKET:PATH`',
        ),
      );
    }
    if (self2.uri.host === 'unix') {
      self2.enableUnixSocket();
    }
    if (self2.strictSSL === false) {
      self2.rejectUnauthorized = false;
    }
    if (!self2.uri.pathname) {
      self2.uri.pathname = '/';
    }
    if (
      !(self2.uri.host || (self2.uri.hostname && self2.uri.port)) &&
      !self2.uri.isUnix
    ) {
      var faultyUri = url.format(self2.uri);
      var message = 'Invalid URI "' + faultyUri + '"';
      if (Object.keys(options).length === 0) {
        message += '. This can be caused by a crappy redirection.';
      }
      self2.abort();
      return self2.emit('error', new Error(message));
    }
    if (!self2.hasOwnProperty('proxy')) {
      self2.proxy = getProxyFromURI(self2.uri);
    }
    self2.tunnel = self2._tunnel.isEnabled();
    if (self2.proxy) {
      self2._tunnel.setup(options);
    }
    self2._redirect.onRequest(options);
    self2.setHost = false;
    if (!self2.hasHeader('host')) {
      var hostHeaderName = self2.originalHostHeaderName || 'host';
      self2.setHeader(hostHeaderName, self2.uri.host);
      if (self2.uri.port) {
        if (
          (self2.uri.port === '80' && self2.uri.protocol === 'http:') ||
          (self2.uri.port === '443' && self2.uri.protocol === 'https:')
        ) {
          self2.setHeader(hostHeaderName, self2.uri.hostname);
        }
      }
      self2.setHost = true;
    }
    self2.jar(self2._jar || options.jar);
    if (!self2.uri.port) {
      if (self2.uri.protocol === 'http:') {
        self2.uri.port = 80;
      } else if (self2.uri.protocol === 'https:') {
        self2.uri.port = 443;
      }
    }
    if (self2.proxy && !self2.tunnel) {
      self2.port = self2.proxy.port;
      self2.host = self2.proxy.hostname;
    } else {
      self2.port = self2.uri.port;
      self2.host = self2.uri.hostname;
    }
    if (options.form) {
      self2.form(options.form);
    }
    if (options.formData) {
      var formData = options.formData;
      var requestForm = self2.form();
      var appendFormValue = function (key, value) {
        if (
          value &&
          value.hasOwnProperty('value') &&
          value.hasOwnProperty('options')
        ) {
          requestForm.append(key, value.value, value.options);
        } else {
          requestForm.append(key, value);
        }
      };
      for (var formKey in formData) {
        if (formData.hasOwnProperty(formKey)) {
          var formValue = formData[formKey];
          if (formValue instanceof Array) {
            for (var j = 0; j < formValue.length; j++) {
              appendFormValue(formKey, formValue[j]);
            }
          } else {
            appendFormValue(formKey, formValue);
          }
        }
      }
    }
    if (options.qs) {
      self2.qs(options.qs);
    }
    if (self2.uri.path) {
      self2.path = self2.uri.path;
    } else {
      self2.path = self2.uri.pathname + (self2.uri.search || '');
    }
    if (self2.path.length === 0) {
      self2.path = '/';
    }
    if (options.aws) {
      self2.aws(options.aws);
    }
    if (options.hawk) {
      self2.hawk(options.hawk);
    }
    if (options.httpSignature) {
      self2.httpSignature(options.httpSignature);
    }
    if (options.auth) {
      if (Object.prototype.hasOwnProperty.call(options.auth, 'username')) {
        options.auth.user = options.auth.username;
      }
      if (Object.prototype.hasOwnProperty.call(options.auth, 'password')) {
        options.auth.pass = options.auth.password;
      }
      self2.auth(
        options.auth.user,
        options.auth.pass,
        options.auth.sendImmediately,
        options.auth.bearer,
      );
    }
    if (self2.gzip && !self2.hasHeader('accept-encoding')) {
      self2.setHeader('accept-encoding', 'gzip, deflate');
    }
    if (self2.uri.auth && !self2.hasHeader('authorization')) {
      var uriAuthPieces = self2.uri.auth.split(':').map(function (item) {
        return self2._qs.unescape(item);
      });
      self2.auth(uriAuthPieces[0], uriAuthPieces.slice(1).join(':'), true);
    }
    if (
      !self2.tunnel &&
      self2.proxy &&
      self2.proxy.auth &&
      !self2.hasHeader('proxy-authorization')
    ) {
      var proxyAuthPieces = self2.proxy.auth.split(':').map(function (item) {
        return self2._qs.unescape(item);
      });
      var authHeader = 'Basic ' + toBase64(proxyAuthPieces.join(':'));
      self2.setHeader('proxy-authorization', authHeader);
    }
    if (self2.proxy && !self2.tunnel) {
      self2.path = self2.uri.protocol + '//' + self2.uri.host + self2.path;
    }
    if (options.json) {
      self2.json(options.json);
    }
    if (options.multipart) {
      self2.multipart(options.multipart);
    }
    if (options.time) {
      self2.timing = true;
      self2.elapsedTime = self2.elapsedTime || 0;
    }
    function setContentLength() {
      if (isTypedArray(self2.body)) {
        self2.body = Buffer2.from(self2.body);
      }
      if (!self2.hasHeader('content-length')) {
        var length;
        if (typeof self2.body === 'string') {
          length = Buffer2.byteLength(self2.body);
        } else if (Array.isArray(self2.body)) {
          length = self2.body.reduce(function (a, b) {
            return a + b.length;
          }, 0);
        } else {
          length = self2.body.length;
        }
        if (length) {
          self2.setHeader('content-length', length);
        } else {
          self2.emit('error', new Error('Argument error, options.body.'));
        }
      }
    }
    if (self2.body && !isstream(self2.body)) {
      setContentLength();
    }
    if (options.oauth) {
      self2.oauth(options.oauth);
    } else if (self2._oauth.params && self2.hasHeader('authorization')) {
      self2.oauth(self2._oauth.params);
    }
    var protocol =
      self2.proxy && !self2.tunnel ? self2.proxy.protocol : self2.uri.protocol;
    var defaultModules = { 'http:': http, 'https:': https };
    var httpModules = self2.httpModules || {};
    self2.httpModule = httpModules[protocol] || defaultModules[protocol];
    if (!self2.httpModule) {
      return self2.emit('error', new Error('Invalid protocol: ' + protocol));
    }
    if (options.ca) {
      self2.ca = options.ca;
    }
    if (!self2.agent) {
      if (options.agentOptions) {
        self2.agentOptions = options.agentOptions;
      }
      if (options.agentClass) {
        self2.agentClass = options.agentClass;
      } else if (options.forever) {
        var v = version();
        if (v.major === 0 && v.minor <= 10) {
          self2.agentClass =
            protocol === 'http:' ? ForeverAgent : ForeverAgent.SSL;
        } else {
          self2.agentClass = self2.httpModule.Agent;
          self2.agentOptions = self2.agentOptions || {};
          self2.agentOptions.keepAlive = true;
        }
      } else {
        self2.agentClass = self2.httpModule.Agent;
      }
    }
    if (self2.pool === false) {
      self2.agent = false;
    } else {
      self2.agent = self2.agent || self2.getNewAgent();
    }
    self2.on('pipe', function (src) {
      if (self2.ntick && self2._started) {
        self2.emit(
          'error',
          new Error(
            'You cannot pipe to this stream after the outbound request has started.',
          ),
        );
      }
      self2.src = src;
      if (isReadStream(src)) {
        if (!self2.hasHeader('content-type')) {
          self2.setHeader('content-type', mime.lookup(src.path));
        }
      } else {
        if (src.headers) {
          for (var i in src.headers) {
            if (!self2.hasHeader(i)) {
              self2.setHeader(i, src.headers[i]);
            }
          }
        }
        if (self2._json && !self2.hasHeader('content-type')) {
          self2.setHeader('content-type', 'application/json');
        }
        if (src.method && !self2.explicitMethod) {
          self2.method = src.method;
        }
      }
    });
    defer(function () {
      if (self2._aborted) {
        return;
      }
      var end = function () {
        if (self2._form) {
          if (!self2._auth.hasAuth) {
            self2._form.pipe(self2);
          } else if (self2._auth.hasAuth && self2._auth.sentAuth) {
            self2._form.pipe(self2);
          }
        }
        if (self2._multipart && self2._multipart.chunked) {
          self2._multipart.body.pipe(self2);
        }
        if (self2.body) {
          if (isstream(self2.body)) {
            self2.body.pipe(self2);
          } else {
            setContentLength();
            if (Array.isArray(self2.body)) {
              self2.body.forEach(function (part) {
                self2.write(part);
              });
            } else {
              self2.write(self2.body);
            }
            self2.end();
          }
        } else if (self2.requestBodyStream) {
          console.warn(
            'options.requestBodyStream is deprecated, please pass the request object to stream.pipe.',
          );
          self2.requestBodyStream.pipe(self2);
        } else if (!self2.src) {
          if (self2._auth.hasAuth && !self2._auth.sentAuth) {
            self2.end();
            return;
          }
          if (self2.method !== 'GET' && typeof self2.method !== 'undefined') {
            self2.setHeader('content-length', 0);
          }
          self2.end();
        }
      };
      if (self2._form && !self2.hasHeader('content-length')) {
        self2.setHeader(self2._form.getHeaders(), true);
        self2._form.getLength(function (err, length) {
          if (!err && !isNaN(length)) {
            self2.setHeader('content-length', length);
          }
          end();
        });
      } else {
        end();
      }
      self2.ntick = true;
    });
  };
  Request.prototype.getNewAgent = function () {
    var self2 = this;
    var Agent = self2.agentClass;
    var options = {};
    if (self2.agentOptions) {
      for (var i in self2.agentOptions) {
        options[i] = self2.agentOptions[i];
      }
    }
    if (self2.ca) {
      options.ca = self2.ca;
    }
    if (self2.ciphers) {
      options.ciphers = self2.ciphers;
    }
    if (self2.secureProtocol) {
      options.secureProtocol = self2.secureProtocol;
    }
    if (self2.secureOptions) {
      options.secureOptions = self2.secureOptions;
    }
    if (typeof self2.rejectUnauthorized !== 'undefined') {
      options.rejectUnauthorized = self2.rejectUnauthorized;
    }
    if (self2.cert && self2.key) {
      options.key = self2.key;
      options.cert = self2.cert;
    }
    if (self2.pfx) {
      options.pfx = self2.pfx;
    }
    if (self2.passphrase) {
      options.passphrase = self2.passphrase;
    }
    var poolKey = '';
    if (Agent !== self2.httpModule.Agent) {
      poolKey += Agent.name;
    }
    var proxy = self2.proxy;
    if (typeof proxy === 'string') {
      proxy = url.parse(proxy);
    }
    var isHttps =
      (proxy && proxy.protocol === 'https:') || this.uri.protocol === 'https:';
    if (isHttps) {
      if (options.ca) {
        if (poolKey) {
          poolKey += ':';
        }
        poolKey += options.ca;
      }
      if (typeof options.rejectUnauthorized !== 'undefined') {
        if (poolKey) {
          poolKey += ':';
        }
        poolKey += options.rejectUnauthorized;
      }
      if (options.cert) {
        if (poolKey) {
          poolKey += ':';
        }
        poolKey +=
          options.cert.toString('ascii') + options.key.toString('ascii');
      }
      if (options.pfx) {
        if (poolKey) {
          poolKey += ':';
        }
        poolKey += options.pfx.toString('ascii');
      }
      if (options.ciphers) {
        if (poolKey) {
          poolKey += ':';
        }
        poolKey += options.ciphers;
      }
      if (options.secureProtocol) {
        if (poolKey) {
          poolKey += ':';
        }
        poolKey += options.secureProtocol;
      }
      if (options.secureOptions) {
        if (poolKey) {
          poolKey += ':';
        }
        poolKey += options.secureOptions;
      }
    }
    if (
      self2.pool === globalPool &&
      !poolKey &&
      Object.keys(options).length === 0 &&
      self2.httpModule.globalAgent
    ) {
      return self2.httpModule.globalAgent;
    }
    poolKey = self2.uri.protocol + poolKey;
    if (!self2.pool[poolKey]) {
      self2.pool[poolKey] = new Agent(options);
      if (self2.pool.maxSockets) {
        self2.pool[poolKey].maxSockets = self2.pool.maxSockets;
      }
    }
    return self2.pool[poolKey];
  };
  Request.prototype.start = function () {
    var self2 = this;
    if (self2.timing) {
      var startTime = new Date().getTime();
      var startTimeNow = now2();
    }
    if (self2._aborted) {
      return;
    }
    self2._started = true;
    self2.method = self2.method || 'GET';
    self2.href = self2.uri.href;
    if (
      self2.src &&
      self2.src.stat &&
      self2.src.stat.size &&
      !self2.hasHeader('content-length')
    ) {
      self2.setHeader('content-length', self2.src.stat.size);
    }
    if (self2._aws) {
      self2.aws(self2._aws, true);
    }
    var reqOptions = copy(self2);
    delete reqOptions.auth;
    debug('make request', self2.uri.href);
    delete reqOptions.timeout;
    try {
      self2.req = self2.httpModule.request(reqOptions);
    } catch (err) {
      self2.emit('error', err);
      return;
    }
    if (self2.timing) {
      self2.startTime = startTime;
      self2.startTimeNow = startTimeNow;
      self2.timings = {};
    }
    var timeout;
    if (self2.timeout && !self2.timeoutTimer) {
      if (self2.timeout < 0) {
        timeout = 0;
      } else if (typeof self2.timeout === 'number' && isFinite(self2.timeout)) {
        timeout = self2.timeout;
      }
    }
    self2.req.on('response', self2.onRequestResponse.bind(self2));
    self2.req.on('error', self2.onRequestError.bind(self2));
    self2.req.on('drain', function () {
      self2.emit('drain');
    });
    self2.req.on('socket', function (socket) {
      var isConnecting = socket._connecting || socket.connecting;
      if (self2.timing) {
        self2.timings.socket = now2() - self2.startTimeNow;
        if (isConnecting) {
          var onLookupTiming = function () {
            self2.timings.lookup = now2() - self2.startTimeNow;
          };
          var onConnectTiming = function () {
            self2.timings.connect = now2() - self2.startTimeNow;
          };
          socket.once('lookup', onLookupTiming);
          socket.once('connect', onConnectTiming);
          self2.req.once('error', function () {
            socket.removeListener('lookup', onLookupTiming);
            socket.removeListener('connect', onConnectTiming);
          });
        }
      }
      var setReqTimeout = function () {
        self2.req.setTimeout(timeout, function () {
          if (self2.req) {
            self2.abort();
            var e = new Error('ESOCKETTIMEDOUT');
            e.code = 'ESOCKETTIMEDOUT';
            e.connect = false;
            self2.emit('error', e);
          }
        });
      };
      if (timeout !== void 0) {
        if (isConnecting) {
          var onReqSockConnect = function () {
            socket.removeListener('connect', onReqSockConnect);
            self2.clearTimeout();
            setReqTimeout();
          };
          socket.on('connect', onReqSockConnect);
          self2.req.on('error', function (err) {
            socket.removeListener('connect', onReqSockConnect);
          });
          self2.timeoutTimer = setTimeout(function () {
            socket.removeListener('connect', onReqSockConnect);
            self2.abort();
            var e = new Error('ETIMEDOUT');
            e.code = 'ETIMEDOUT';
            e.connect = true;
            self2.emit('error', e);
          }, timeout);
        } else {
          setReqTimeout();
        }
      }
      self2.emit('socket', socket);
    });
    self2.emit('request', self2.req);
  };
  Request.prototype.onRequestError = function (error) {
    var self2 = this;
    if (self2._aborted) {
      return;
    }
    if (
      self2.req &&
      self2.req._reusedSocket &&
      error.code === 'ECONNRESET' &&
      self2.agent.addRequestNoreuse
    ) {
      self2.agent = {
        addRequest: self2.agent.addRequestNoreuse.bind(self2.agent),
      };
      self2.start();
      self2.req.end();
      return;
    }
    self2.clearTimeout();
    self2.emit('error', error);
  };
  Request.prototype.onRequestResponse = function (response) {
    var self2 = this;
    if (self2.timing) {
      self2.timings.response = now2() - self2.startTimeNow;
    }
    debug(
      'onRequestResponse',
      self2.uri.href,
      response.statusCode,
      response.headers,
    );
    response.on('end', function () {
      if (self2.timing) {
        self2.timings.end = now2() - self2.startTimeNow;
        response.timingStart = self2.startTime;
        if (!self2.timings.socket) {
          self2.timings.socket = 0;
        }
        if (!self2.timings.lookup) {
          self2.timings.lookup = self2.timings.socket;
        }
        if (!self2.timings.connect) {
          self2.timings.connect = self2.timings.lookup;
        }
        if (!self2.timings.response) {
          self2.timings.response = self2.timings.connect;
        }
        debug('elapsed time', self2.timings.end);
        self2.elapsedTime += Math.round(self2.timings.end);
        response.elapsedTime = self2.elapsedTime;
        response.timings = self2.timings;
        response.timingPhases = {
          wait: self2.timings.socket,
          dns: self2.timings.lookup - self2.timings.socket,
          tcp: self2.timings.connect - self2.timings.lookup,
          firstByte: self2.timings.response - self2.timings.connect,
          download: self2.timings.end - self2.timings.response,
          total: self2.timings.end,
        };
      }
      debug(
        'response end',
        self2.uri.href,
        response.statusCode,
        response.headers,
      );
    });
    if (self2._aborted) {
      debug('aborted', self2.uri.href);
      response.resume();
      return;
    }
    self2.response = response;
    response.request = self2;
    response.toJSON = responseToJSON;
    if (
      self2.httpModule === https &&
      self2.strictSSL &&
      (!response.hasOwnProperty('socket') || !response.socket.authorized)
    ) {
      debug('strict ssl error', self2.uri.href);
      var sslErr = response.hasOwnProperty('socket')
        ? response.socket.authorizationError
        : self2.uri.href + ' does not support SSL';
      self2.emit('error', new Error('SSL Error: ' + sslErr));
      return;
    }
    self2.originalHost = self2.getHeader('host');
    if (!self2.originalHostHeaderName) {
      self2.originalHostHeaderName = self2.hasHeader('host');
    }
    if (self2.setHost) {
      self2.removeHeader('host');
    }
    self2.clearTimeout();
    var targetCookieJar =
      self2._jar && self2._jar.setCookie ? self2._jar : globalCookieJar;
    var addCookie = function (cookie) {
      try {
        targetCookieJar.setCookie(cookie, self2.uri.href, {
          ignoreError: true,
        });
      } catch (e) {
        self2.emit('error', e);
      }
    };
    response.caseless = caseless(response.headers);
    if (response.caseless.has('set-cookie') && !self2._disableCookies) {
      var headerName = response.caseless.has('set-cookie');
      if (Array.isArray(response.headers[headerName])) {
        response.headers[headerName].forEach(addCookie);
      } else {
        addCookie(response.headers[headerName]);
      }
    }
    if (self2._redirect.onResponse(response)) {
      return;
    } else {
      response.on('close', function () {
        if (!self2._ended) {
          self2.response.emit('end');
        }
      });
      response.once('end', function () {
        self2._ended = true;
      });
      var noBody = function (code) {
        return (
          self2.method === 'HEAD' ||
          (code >= 100 && code < 200) ||
          code === 204 ||
          code === 304
        );
      };
      var responseContent;
      if (self2.gzip && !noBody(response.statusCode)) {
        var contentEncoding =
          response.headers['content-encoding'] || 'identity';
        contentEncoding = contentEncoding.trim().toLowerCase();
        var zlibOptions = {
          flush: zlib.Z_SYNC_FLUSH,
          finishFlush: zlib.Z_SYNC_FLUSH,
        };
        if (contentEncoding === 'gzip') {
          responseContent = zlib.createGunzip(zlibOptions);
          response.pipe(responseContent);
        } else if (contentEncoding === 'deflate') {
          responseContent = zlib.createInflate(zlibOptions);
          response.pipe(responseContent);
        } else {
          if (contentEncoding !== 'identity') {
            debug('ignoring unrecognized Content-Encoding ' + contentEncoding);
          }
          responseContent = response;
        }
      } else {
        responseContent = response;
      }
      if (self2.encoding) {
        if (self2.dests.length !== 0) {
          console.error(
            'Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.',
          );
        } else {
          responseContent.setEncoding(self2.encoding);
        }
      }
      if (self2._paused) {
        responseContent.pause();
      }
      self2.responseContent = responseContent;
      self2.emit('response', response);
      self2.dests.forEach(function (dest) {
        self2.pipeDest(dest);
      });
      responseContent.on('data', function (chunk) {
        if (self2.timing && !self2.responseStarted) {
          self2.responseStartTime = new Date().getTime();
          response.responseStartTime = self2.responseStartTime;
        }
        self2._destdata = true;
        self2.emit('data', chunk);
      });
      responseContent.once('end', function (chunk) {
        self2.emit('end', chunk);
      });
      responseContent.on('error', function (error) {
        self2.emit('error', error);
      });
      responseContent.on('close', function () {
        self2.emit('close');
      });
      if (self2.callback) {
        self2.readResponseBody(response);
      } else {
        self2.on('end', function () {
          if (self2._aborted) {
            debug('aborted', self2.uri.href);
            return;
          }
          self2.emit('complete', response);
        });
      }
    }
    debug('finish init function', self2.uri.href);
  };
  Request.prototype.readResponseBody = function (response) {
    var self2 = this;
    debug("reading response's body");
    var buffers = [];
    var bufferLength = 0;
    var strings = [];
    self2.on('data', function (chunk) {
      if (!Buffer2.isBuffer(chunk)) {
        strings.push(chunk);
      } else if (chunk.length) {
        bufferLength += chunk.length;
        buffers.push(chunk);
      }
    });
    self2.on('end', function () {
      debug('end event', self2.uri.href);
      if (self2._aborted) {
        debug('aborted', self2.uri.href);
        buffers = [];
        bufferLength = 0;
        return;
      }
      if (bufferLength) {
        debug('has body', self2.uri.href, bufferLength);
        response.body = Buffer2.concat(buffers, bufferLength);
        if (self2.encoding !== null) {
          response.body = response.body.toString(self2.encoding);
        }
        buffers = [];
        bufferLength = 0;
      } else if (strings.length) {
        if (
          self2.encoding === 'utf8' &&
          strings[0].length > 0 &&
          strings[0][0] === '\uFEFF'
        ) {
          strings[0] = strings[0].substring(1);
        }
        response.body = strings.join('');
      }
      if (self2._json) {
        try {
          response.body = JSON.parse(response.body, self2._jsonReviver);
        } catch (e) {
          debug('invalid JSON received', self2.uri.href);
        }
      }
      debug('emitting complete', self2.uri.href);
      if (typeof response.body === 'undefined' && !self2._json) {
        response.body = self2.encoding === null ? Buffer2.alloc(0) : '';
      }
      self2.emit('complete', response, response.body);
    });
  };
  Request.prototype.abort = function () {
    var self2 = this;
    self2._aborted = true;
    if (self2.req) {
      self2.req.abort();
    } else if (self2.response) {
      self2.response.destroy();
    }
    self2.clearTimeout();
    self2.emit('abort');
  };
  Request.prototype.pipeDest = function (dest) {
    var self2 = this;
    var response = self2.response;
    if (dest.headers && !dest.headersSent) {
      if (response.caseless.has('content-type')) {
        var ctname = response.caseless.has('content-type');
        if (dest.setHeader) {
          dest.setHeader(ctname, response.headers[ctname]);
        } else {
          dest.headers[ctname] = response.headers[ctname];
        }
      }
      if (response.caseless.has('content-length')) {
        var clname = response.caseless.has('content-length');
        if (dest.setHeader) {
          dest.setHeader(clname, response.headers[clname]);
        } else {
          dest.headers[clname] = response.headers[clname];
        }
      }
    }
    if (dest.setHeader && !dest.headersSent) {
      for (var i in response.headers) {
        if (!self2.gzip || i !== 'content-encoding') {
          dest.setHeader(i, response.headers[i]);
        }
      }
      dest.statusCode = response.statusCode;
    }
    if (self2.pipefilter) {
      self2.pipefilter(response, dest);
    }
  };
  Request.prototype.qs = function (q2, clobber) {
    var self2 = this;
    var base;
    if (!clobber && self2.uri.query) {
      base = self2._qs.parse(self2.uri.query);
    } else {
      base = {};
    }
    for (var i in q2) {
      base[i] = q2[i];
    }
    var qs = self2._qs.stringify(base);
    if (qs === '') {
      return self2;
    }
    self2.uri = url.parse(self2.uri.href.split('?')[0] + '?' + qs);
    self2.url = self2.uri;
    self2.path = self2.uri.path;
    if (self2.uri.host === 'unix') {
      self2.enableUnixSocket();
    }
    return self2;
  };
  Request.prototype.form = function (form) {
    var self2 = this;
    if (form) {
      if (
        !/^application\/x-www-form-urlencoded\b/.test(
          self2.getHeader('content-type'),
        )
      ) {
        self2.setHeader('content-type', 'application/x-www-form-urlencoded');
      }
      self2.body =
        typeof form === 'string'
          ? self2._qs.rfc3986(form.toString('utf8'))
          : self2._qs.stringify(form).toString('utf8');
      return self2;
    }
    self2._form = new FormData();
    self2._form.on('error', function (err) {
      err.message = 'form-data: ' + err.message;
      self2.emit('error', err);
      self2.abort();
    });
    return self2._form;
  };
  Request.prototype.multipart = function (multipart) {
    var self2 = this;
    self2._multipart.onRequest(multipart);
    if (!self2._multipart.chunked) {
      self2.body = self2._multipart.body;
    }
    return self2;
  };
  Request.prototype.json = function (val) {
    var self2 = this;
    if (!self2.hasHeader('accept')) {
      self2.setHeader('accept', 'application/json');
    }
    if (typeof self2.jsonReplacer === 'function') {
      self2._jsonReplacer = self2.jsonReplacer;
    }
    self2._json = true;
    if (typeof val === 'boolean') {
      if (self2.body !== void 0) {
        if (
          !/^application\/x-www-form-urlencoded\b/.test(
            self2.getHeader('content-type'),
          )
        ) {
          self2.body = safeStringify(self2.body, self2._jsonReplacer);
        } else {
          self2.body = self2._qs.rfc3986(self2.body);
        }
        if (!self2.hasHeader('content-type')) {
          self2.setHeader('content-type', 'application/json');
        }
      }
    } else {
      self2.body = safeStringify(val, self2._jsonReplacer);
      if (!self2.hasHeader('content-type')) {
        self2.setHeader('content-type', 'application/json');
      }
    }
    if (typeof self2.jsonReviver === 'function') {
      self2._jsonReviver = self2.jsonReviver;
    }
    return self2;
  };
  Request.prototype.getHeader = function (name, headers) {
    var self2 = this;
    var result, re, match;
    if (!headers) {
      headers = self2.headers;
    }
    Object.keys(headers).forEach(function (key) {
      if (key.length !== name.length) {
        return;
      }
      re = new RegExp(name, 'i');
      match = key.match(re);
      if (match) {
        result = headers[key];
      }
    });
    return result;
  };
  Request.prototype.enableUnixSocket = function () {
    var unixParts = this.uri.path.split(':');
    var host = unixParts[0];
    var path = unixParts[1];
    this.socketPath = host;
    this.uri.pathname = path;
    this.uri.path = path;
    this.uri.host = host;
    this.uri.hostname = host;
    this.uri.isUnix = true;
  };
  Request.prototype.auth = function (user, pass, sendImmediately, bearer) {
    var self2 = this;
    self2._auth.onRequest(user, pass, sendImmediately, bearer);
    return self2;
  };
  Request.prototype.aws = function (opts, now3) {
    var self2 = this;
    if (!now3) {
      self2._aws = opts;
      return self2;
    }
    if (opts.sign_version === 4 || opts.sign_version === '4') {
      var options = {
        host: self2.uri.host,
        path: self2.uri.path,
        method: self2.method,
        headers: self2.headers,
        body: self2.body,
      };
      if (opts.service) {
        options.service = opts.service;
      }
      var signRes = aws4.sign(options, {
        accessKeyId: opts.key,
        secretAccessKey: opts.secret,
        sessionToken: opts.session,
      });
      self2.setHeader('authorization', signRes.headers.Authorization);
      self2.setHeader('x-amz-date', signRes.headers['X-Amz-Date']);
      if (signRes.headers['X-Amz-Security-Token']) {
        self2.setHeader(
          'x-amz-security-token',
          signRes.headers['X-Amz-Security-Token'],
        );
      }
    } else {
      var date = new Date();
      self2.setHeader('date', date.toUTCString());
      var auth = {
        key: opts.key,
        secret: opts.secret,
        verb: self2.method.toUpperCase(),
        date,
        contentType: self2.getHeader('content-type') || '',
        md5: self2.getHeader('content-md5') || '',
        amazonHeaders: aws2.canonicalizeHeaders(self2.headers),
      };
      var path = self2.uri.path;
      if (opts.bucket && path) {
        auth.resource = '/' + opts.bucket + path;
      } else if (opts.bucket && !path) {
        auth.resource = '/' + opts.bucket;
      } else if (!opts.bucket && path) {
        auth.resource = path;
      } else if (!opts.bucket && !path) {
        auth.resource = '/';
      }
      auth.resource = aws2.canonicalizeResource(auth.resource);
      self2.setHeader('authorization', aws2.authorization(auth));
    }
    return self2;
  };
  Request.prototype.httpSignature = function (opts) {
    var self2 = this;
    httpSignature.signRequest(
      {
        getHeader: function (header) {
          return self2.getHeader(header, self2.headers);
        },
        setHeader: function (header, value) {
          self2.setHeader(header, value);
        },
        method: self2.method,
        path: self2.path,
      },
      opts,
    );
    debug('httpSignature authorization', self2.getHeader('authorization'));
    return self2;
  };
  Request.prototype.hawk = function (opts) {
    var self2 = this;
    self2.setHeader(
      'Authorization',
      hawk.header(self2.uri, self2.method, opts),
    );
  };
  Request.prototype.oauth = function (_oauth) {
    var self2 = this;
    self2._oauth.onRequest(_oauth);
    return self2;
  };
  Request.prototype.jar = function (jar) {
    var self2 = this;
    var cookies2;
    if (self2._redirect.redirectsFollowed === 0) {
      self2.originalCookieHeader = self2.getHeader('cookie');
    }
    if (!jar) {
      cookies2 = false;
      self2._disableCookies = true;
    } else {
      var targetCookieJar = jar.getCookieString ? jar : globalCookieJar;
      var urihref = self2.uri.href;
      if (targetCookieJar) {
        cookies2 = targetCookieJar.getCookieString(urihref);
      }
    }
    if (cookies2 && cookies2.length) {
      if (self2.originalCookieHeader) {
        self2.setHeader('cookie', self2.originalCookieHeader + '; ' + cookies2);
      } else {
        self2.setHeader('cookie', cookies2);
      }
    }
    self2._jar = jar;
    return self2;
  };
  Request.prototype.pipe = function (dest, opts) {
    var self2 = this;
    if (self2.response) {
      if (self2._destdata) {
        self2.emit(
          'error',
          new Error(
            'You cannot pipe after data has been emitted from the response.',
          ),
        );
      } else if (self2._ended) {
        self2.emit(
          'error',
          new Error('You cannot pipe after the response has been ended.'),
        );
      } else {
        stream.Stream.prototype.pipe.call(self2, dest, opts);
        self2.pipeDest(dest);
        return dest;
      }
    } else {
      self2.dests.push(dest);
      stream.Stream.prototype.pipe.call(self2, dest, opts);
      return dest;
    }
  };
  Request.prototype.write = function () {
    var self2 = this;
    if (self2._aborted) {
      return;
    }
    if (!self2._started) {
      self2.start();
    }
    if (self2.req) {
      return self2.req.write.apply(self2.req, arguments);
    }
  };
  Request.prototype.end = function (chunk) {
    var self2 = this;
    if (self2._aborted) {
      return;
    }
    if (chunk) {
      self2.write(chunk);
    }
    if (!self2._started) {
      self2.start();
    }
    if (self2.req) {
      self2.req.end();
    }
  };
  Request.prototype.pause = function () {
    var self2 = this;
    if (!self2.responseContent) {
      self2._paused = true;
    } else {
      self2.responseContent.pause.apply(self2.responseContent, arguments);
    }
  };
  Request.prototype.resume = function () {
    var self2 = this;
    if (!self2.responseContent) {
      self2._paused = false;
    } else {
      self2.responseContent.resume.apply(self2.responseContent, arguments);
    }
  };
  Request.prototype.destroy = function () {
    var self2 = this;
    this.clearTimeout();
    if (!self2._ended) {
      self2.end();
    } else if (self2.response) {
      self2.response.destroy();
    }
  };
  Request.prototype.clearTimeout = function () {
    if (this.timeoutTimer) {
      clearTimeout(this.timeoutTimer);
      this.timeoutTimer = null;
    }
  };
  Request.defaultProxyHeaderWhiteList = Tunnel.defaultProxyHeaderWhiteList.slice();
  Request.defaultProxyHeaderExclusiveList = Tunnel.defaultProxyHeaderExclusiveList.slice();
  Request.prototype.toJSON = requestToJSON;
  module2.exports = Request;
});

// node_modules/request/index.js
var require_request3 = __commonJS((exports2, module2) => {
  'use strict';
  var extend = require_extend();
  var cookies = require_cookies();
  var helpers = require_helpers();
  var paramsHaveRequestBody = helpers.paramsHaveRequestBody;
  function initParams(uri, options, callback) {
    if (typeof options === 'function') {
      callback = options;
    }
    var params = {};
    if (options !== null && typeof options === 'object') {
      extend(params, options, { uri });
    } else if (typeof uri === 'string') {
      extend(params, { uri });
    } else {
      extend(params, uri);
    }
    params.callback = callback || params.callback;
    return params;
  }
  function request(uri, options, callback) {
    if (typeof uri === 'undefined') {
      throw new Error('undefined is not a valid uri or options object.');
    }
    var params = initParams(uri, options, callback);
    if (params.method === 'HEAD' && paramsHaveRequestBody(params)) {
      throw new Error('HTTP HEAD requests MUST NOT include a request body.');
    }
    return new request.Request(params);
  }
  function verbFunc(verb) {
    var method = verb.toUpperCase();
    return function (uri, options, callback) {
      var params = initParams(uri, options, callback);
      params.method = method;
      return request(params, params.callback);
    };
  }
  request.get = verbFunc('get');
  request.head = verbFunc('head');
  request.options = verbFunc('options');
  request.post = verbFunc('post');
  request.put = verbFunc('put');
  request.patch = verbFunc('patch');
  request.del = verbFunc('delete');
  request['delete'] = verbFunc('delete');
  request.jar = function (store) {
    return cookies.jar(store);
  };
  request.cookie = function (str) {
    return cookies.parse(str);
  };
  function wrapRequestMethod(method, options, requester, verb) {
    return function (uri, opts, callback) {
      var params = initParams(uri, opts, callback);
      var target = {};
      extend(true, target, options, params);
      target.pool = params.pool || options.pool;
      if (verb) {
        target.method = verb.toUpperCase();
      }
      if (typeof requester === 'function') {
        method = requester;
      }
      return method(target, target.callback);
    };
  }
  request.defaults = function (options, requester) {
    var self2 = this;
    options = options || {};
    if (typeof options === 'function') {
      requester = options;
      options = {};
    }
    var defaults = wrapRequestMethod(self2, options, requester);
    var verbs = ['get', 'head', 'post', 'put', 'patch', 'del', 'delete'];
    verbs.forEach(function (verb) {
      defaults[verb] = wrapRequestMethod(self2[verb], options, requester, verb);
    });
    defaults.cookie = wrapRequestMethod(self2.cookie, options, requester);
    defaults.jar = self2.jar;
    defaults.defaults = self2.defaults;
    return defaults;
  };
  request.forever = function (agentOptions, optionsArg) {
    var options = {};
    if (optionsArg) {
      extend(options, optionsArg);
    }
    if (agentOptions) {
      options.agentOptions = agentOptions;
    }
    options.forever = true;
    return request.defaults(options);
  };
  module2.exports = request;
  request.Request = require_request2();
  request.initParams = initParams;
  Object.defineProperty(request, 'debug', {
    enumerable: true,
    get: function () {
      return request.Request.debug;
    },
    set: function (debug) {
      request.Request.debug = debug;
    },
  });
});

// node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS((exports2, module2) => {
  function RetryOperation(timeouts, options) {
    if (typeof options === 'boolean') {
      options = { forever: options };
    }
    this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
    this._timeouts = timeouts;
    this._options = options || {};
    this._maxRetryTime = (options && options.maxRetryTime) || Infinity;
    this._fn = null;
    this._errors = [];
    this._attempts = 1;
    this._operationTimeout = null;
    this._operationTimeoutCb = null;
    this._timeout = null;
    this._operationStart = null;
    if (this._options.forever) {
      this._cachedTimeouts = this._timeouts.slice(0);
    }
  }
  module2.exports = RetryOperation;
  RetryOperation.prototype.reset = function () {
    this._attempts = 1;
    this._timeouts = this._originalTimeouts;
  };
  RetryOperation.prototype.stop = function () {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    this._timeouts = [];
    this._cachedTimeouts = null;
  };
  RetryOperation.prototype.retry = function (err) {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    if (!err) {
      return false;
    }
    var currentTime = new Date().getTime();
    if (err && currentTime - this._operationStart >= this._maxRetryTime) {
      this._errors.unshift(new Error('RetryOperation timeout occurred'));
      return false;
    }
    this._errors.push(err);
    var timeout = this._timeouts.shift();
    if (timeout === void 0) {
      if (this._cachedTimeouts) {
        this._errors.splice(this._errors.length - 1, this._errors.length);
        this._timeouts = this._cachedTimeouts.slice(0);
        timeout = this._timeouts.shift();
      } else {
        return false;
      }
    }
    var self2 = this;
    var timer = setTimeout(function () {
      self2._attempts++;
      if (self2._operationTimeoutCb) {
        self2._timeout = setTimeout(function () {
          self2._operationTimeoutCb(self2._attempts);
        }, self2._operationTimeout);
        if (self2._options.unref) {
          self2._timeout.unref();
        }
      }
      self2._fn(self2._attempts);
    }, timeout);
    if (this._options.unref) {
      timer.unref();
    }
    return true;
  };
  RetryOperation.prototype.attempt = function (fn, timeoutOps) {
    this._fn = fn;
    if (timeoutOps) {
      if (timeoutOps.timeout) {
        this._operationTimeout = timeoutOps.timeout;
      }
      if (timeoutOps.cb) {
        this._operationTimeoutCb = timeoutOps.cb;
      }
    }
    var self2 = this;
    if (this._operationTimeoutCb) {
      this._timeout = setTimeout(function () {
        self2._operationTimeoutCb();
      }, self2._operationTimeout);
    }
    this._operationStart = new Date().getTime();
    this._fn(this._attempts);
  };
  RetryOperation.prototype.try = function (fn) {
    console.log('Using RetryOperation.try() is deprecated');
    this.attempt(fn);
  };
  RetryOperation.prototype.start = function (fn) {
    console.log('Using RetryOperation.start() is deprecated');
    this.attempt(fn);
  };
  RetryOperation.prototype.start = RetryOperation.prototype.try;
  RetryOperation.prototype.errors = function () {
    return this._errors;
  };
  RetryOperation.prototype.attempts = function () {
    return this._attempts;
  };
  RetryOperation.prototype.mainError = function () {
    if (this._errors.length === 0) {
      return null;
    }
    var counts = {};
    var mainError = null;
    var mainErrorCount = 0;
    for (var i = 0; i < this._errors.length; i++) {
      var error = this._errors[i];
      var message = error.message;
      var count = (counts[message] || 0) + 1;
      counts[message] = count;
      if (count >= mainErrorCount) {
        mainError = error;
        mainErrorCount = count;
      }
    }
    return mainError;
  };
});

// node_modules/retry/lib/retry.js
var require_retry = __commonJS((exports2) => {
  var RetryOperation = require_retry_operation();
  exports2.operation = function (options) {
    var timeouts = exports2.timeouts(options);
    return new RetryOperation(timeouts, {
      forever: options && options.forever,
      unref: options && options.unref,
      maxRetryTime: options && options.maxRetryTime,
    });
  };
  exports2.timeouts = function (options) {
    if (options instanceof Array) {
      return [].concat(options);
    }
    var opts = {
      retries: 10,
      factor: 2,
      minTimeout: 1 * 1e3,
      maxTimeout: Infinity,
      randomize: false,
    };
    for (var key in options) {
      opts[key] = options[key];
    }
    if (opts.minTimeout > opts.maxTimeout) {
      throw new Error('minTimeout is greater than maxTimeout');
    }
    var timeouts = [];
    for (var i = 0; i < opts.retries; i++) {
      timeouts.push(this.createTimeout(i, opts));
    }
    if (options && options.forever && !timeouts.length) {
      timeouts.push(this.createTimeout(i, opts));
    }
    timeouts.sort(function (a, b) {
      return a - b;
    });
    return timeouts;
  };
  exports2.createTimeout = function (attempt, opts) {
    var random = opts.randomize ? Math.random() + 1 : 1;
    var timeout = Math.round(
      random * opts.minTimeout * Math.pow(opts.factor, attempt),
    );
    timeout = Math.min(timeout, opts.maxTimeout);
    return timeout;
  };
  exports2.wrap = function (obj, options, methods) {
    if (options instanceof Array) {
      methods = options;
      options = null;
    }
    if (!methods) {
      methods = [];
      for (var key in obj) {
        if (typeof obj[key] === 'function') {
          methods.push(key);
        }
      }
    }
    for (var i = 0; i < methods.length; i++) {
      var method = methods[i];
      var original = obj[method];
      obj[method] = function retryWrapper(original2) {
        var op = exports2.operation(options);
        var args = Array.prototype.slice.call(arguments, 1);
        var callback = args.pop();
        args.push(function (err) {
          if (op.retry(err)) {
            return;
          }
          if (err) {
            arguments[0] = op.mainError();
          }
          callback.apply(this, arguments);
        });
        op.attempt(function () {
          original2.apply(obj, args);
        });
      }.bind(obj, original);
      obj[method].options = options;
    }
  };
});

// node_modules/retry/index.js
var require_retry2 = __commonJS((exports2, module2) => {
  module2.exports = require_retry();
});

// node_modules/@cloudbase/node-sdk/lib/utils/retry.js
var require_retry3 = __commonJS((exports2) => {
  'use strict';
  var __importDefault =
    (exports2 && exports2.__importDefault) ||
    function (mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
  Object.defineProperty(exports2, '__esModule', { value: true });
  var retry_1 = __importDefault(require_retry2());
  var RetryOperation = require_retry_operation();
  function defaultShouldRetry(e, result) {
    return { retryAble: false, message: '' };
  }
  function withRetry(fn, retryOptions) {
    if (!retryOptions || retryOptions.retries === 0) {
      return fn();
    }
    const timeouts = retryOptions.timeouts
      ? [...retryOptions.timeouts]
      : retry_1.default.timeouts(retryOptions);
    const operation = new RetryOperation(timeouts, {
      forever: retryOptions.forever,
      unref: retryOptions.unref,
      maxRetryTime: retryOptions.maxRetryTime,
    });
    const shouldRetry = retryOptions.shouldRetry || defaultShouldRetry;
    return new Promise((resolve, reject) => {
      const isReadyToRetry = (e, resp, operation2) => {
        const { retryAble, message } = shouldRetry(e, resp, operation2);
        const info = {};
        info.nth = operation2.attempts();
        info.at = new Date();
        info.message = message;
        const readyToRetry =
          retryAble && operation2.retry(Object.assign({}, info));
        if (!readyToRetry) {
          const ref = e || resp;
          if (ref && operation2.attempts() > 1) {
            ref.attempt = {};
            ref.attempt.timeouts = operation2._originalTimeouts;
            ref.attempt.attempts = operation2.attempts();
            ref.attempt.errors = operation2.errors();
            if (!retryAble) {
              ref.attempt.errors.push(info);
            }
          }
        }
        return readyToRetry;
      };
      operation.attempt(async () => {
        try {
          const result = await fn(operation.attempts());
          if (!isReadyToRetry(null, result, operation)) {
            resolve(result);
          }
        } catch (e) {
          try {
            if (!isReadyToRetry(e, null, operation)) {
              reject(e);
            }
          } catch (e2) {
            reject(e2);
          }
        }
      }, retryOptions.timeoutOps);
    });
  }
  exports2.withRetry = withRetry;
});

// node_modules/@cloudbase/node-sdk/lib/utils/request-timings-measurer.js
var require_request_timings_measurer = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var EventEmitter = require('events').EventEmitter;
  var RequestTimgingsMeasurer = class extends EventEmitter {
    constructor(options) {
      super();
      this.e = null;
      this.timings = {};
      this.e = null;
      this.enable = options.enable === true;
      this.timerStarted = false;
      this.intervalId = null;
      this.timeoutId = null;
      this.waitingTime = options.waitingTime || 1e3;
      this.interval = options.interval || 200;
    }
    static new(options) {
      return new RequestTimgingsMeasurer(options);
    }
    measure(clientRequest) {
      if (!this.enable) {
        return;
      }
      this.startTimer();
      const timings = this.timings;
      timings.start = Date.now();
      clientRequest
        .once('response', (message) => {
          timings.response = Date.now();
          timings.waiting = Date.now() - timings.start;
          message.once('end', () => {
            timings.socket = timings.socket || 0;
            timings.download = Date.now() - timings.response;
            timings.end = Date.now() - timings.start;
            this.stopTimer('end');
          });
        })
        .once('socket', (socket) => {
          timings.socket = Date.now() - timings.start;
          const onlookup = () => {
            this.timings.lookup = Date.now() - this.timings.start;
          };
          const onconnect = () => {
            this.timings.connect = Date.now() - this.timings.start;
          };
          const onready = () => {
            this.timings.ready = Date.now() - this.timings.start;
          };
          if (socket.connecting) {
            socket.once('lookup', onlookup);
            socket.once('connect', onconnect);
            socket.once('ready', onready);
            socket.once('error', (e) => {
              socket.off('lookup', onlookup);
              socket.off('connect', onconnect);
              socket.off('ready', onready);
              this.e = e;
              this.timings.error = Date.now() - this.timings.start;
              this.stopTimer(`ee:${e.message}`);
            });
          } else {
            this.timings.lookup = -1;
            this.timings.connect = -1;
            this.timings.ready = -1;
          }
        })
        .on('error', (e) => {
          this.stopTimer(`ee:${e.message}`);
        });
    }
    startTimer() {
      if (!this.enable) {
        return;
      }
      if (this.timerStarted) {
        return;
      }
      this.timerStarted = true;
      this.intervalId = null;
      this.timeoutId = setTimeout(() => {
        this.process('inprogress');
        this.intervalId = setInterval(() => {
          this.process('inprogress');
        }, this.interval);
      }, this.waitingTime);
    }
    stopTimer(reason) {
      this.timerStarted = false;
      clearTimeout(this.timeoutId);
      clearInterval(this.intervalId);
      this.process(reason);
    }
    process(reason) {
      this.emit('progress', Object.assign({}, this.timings), reason);
    }
  };
  exports2.RequestTimgingsMeasurer = RequestTimgingsMeasurer;
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports2, module2) => {
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module2.exports = function (val, options) {
    options = options || {};
    var type = typeof val;
    if (type === 'string' && val.length > 0) {
      return parse(val);
    } else if (type === 'number' && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      'val is not a non-empty string or a valid number. val=' +
        JSON.stringify(val),
    );
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str,
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;
      case 'weeks':
      case 'week':
      case 'w':
        return n * w;
      case 'days':
      case 'day':
      case 'd':
        return n * d;
      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;
      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;
      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;
      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + 'd';
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + 'h';
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + 'm';
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, 'day');
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, 'hour');
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, 'minute');
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, 'second');
    }
    return ms + ' ms';
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
  }
});

// node_modules/humanize-ms/index.js
var require_humanize_ms = __commonJS((exports2, module2) => {
  /*!
   * humanize-ms - index.js
   * Copyright(c) 2014 dead_horse <dead_horse@qq.com>
   * MIT Licensed
   */
  'use strict';
  var util = require('util');
  var ms = require_ms();
  module2.exports = function (t) {
    if (typeof t === 'number') return t;
    var r = ms(t);
    if (r === void 0) {
      var err = new Error(util.format('humanize-ms(%j) result undefined', t));
      console.warn(err.stack);
    }
    return r;
  };
});

// node_modules/debug/node_modules/ms/index.js
var require_ms2 = __commonJS((exports2, module2) => {
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module2.exports = function (val, options) {
    options = options || {};
    var type = typeof val;
    if (type === 'string' && val.length > 0) {
      return parse(val);
    } else if (type === 'number' && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      'val is not a non-empty string or a valid number. val=' +
        JSON.stringify(val),
    );
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str,
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;
      case 'weeks':
      case 'week':
      case 'w':
        return n * w;
      case 'days':
      case 'day':
      case 'd':
        return n * d;
      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;
      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;
      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;
      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + 'd';
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + 'h';
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + 'm';
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, 'day');
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, 'hour');
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, 'minute');
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, 'second');
    }
    return ms + ' ms';
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
  }
});

// node_modules/debug/src/common.js
var require_common2 = __commonJS((exports2, module2) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms2();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date());
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== 'string') {
          args.unshift('%O');
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === '%%') {
            return '%';
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === 'function') {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, 'enabled', {
        enumerable: true,
        configurable: false,
        get: () =>
          enableOverride === null
            ? createDebug.enabled(namespace)
            : enableOverride,
        set: (v) => {
          enableOverride = v;
        },
      });
      if (typeof createDebug.init === 'function') {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(
        this.namespace +
          (typeof delimiter === 'undefined' ? ':' : delimiter) +
          namespace,
      );
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === 'string' ? namespaces : '').split(
        /[\s,]+/,
      );
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, '.*?');
        if (namespaces[0] === '-') {
          createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
        } else {
          createDebug.names.push(new RegExp('^' + namespaces + '$'));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips
          .map(toNamespace)
          .map((namespace) => '-' + namespace),
      ].join(',');
      createDebug.enable('');
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === '*') {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp
        .toString()
        .substring(2, regexp.toString().length - 2)
        .replace(/\.\*\?$/, '*');
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn(
        'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.',
      );
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module2.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser2 = __commonJS((exports2, module2) => {
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.storage = localstorage();
  exports2.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn(
          'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.',
        );
      }
    };
  })();
  exports2.colors = [
    '#0000CC',
    '#0000FF',
    '#0033CC',
    '#0033FF',
    '#0066CC',
    '#0066FF',
    '#0099CC',
    '#0099FF',
    '#00CC00',
    '#00CC33',
    '#00CC66',
    '#00CC99',
    '#00CCCC',
    '#00CCFF',
    '#3300CC',
    '#3300FF',
    '#3333CC',
    '#3333FF',
    '#3366CC',
    '#3366FF',
    '#3399CC',
    '#3399FF',
    '#33CC00',
    '#33CC33',
    '#33CC66',
    '#33CC99',
    '#33CCCC',
    '#33CCFF',
    '#6600CC',
    '#6600FF',
    '#6633CC',
    '#6633FF',
    '#66CC00',
    '#66CC33',
    '#9900CC',
    '#9900FF',
    '#9933CC',
    '#9933FF',
    '#99CC00',
    '#99CC33',
    '#CC0000',
    '#CC0033',
    '#CC0066',
    '#CC0099',
    '#CC00CC',
    '#CC00FF',
    '#CC3300',
    '#CC3333',
    '#CC3366',
    '#CC3399',
    '#CC33CC',
    '#CC33FF',
    '#CC6600',
    '#CC6633',
    '#CC9900',
    '#CC9933',
    '#CCCC00',
    '#CCCC33',
    '#FF0000',
    '#FF0033',
    '#FF0066',
    '#FF0099',
    '#FF00CC',
    '#FF00FF',
    '#FF3300',
    '#FF3333',
    '#FF3366',
    '#FF3399',
    '#FF33CC',
    '#FF33FF',
    '#FF6600',
    '#FF6633',
    '#FF9900',
    '#FF9933',
    '#FFCC00',
    '#FFCC33',
  ];
  function useColors() {
    if (
      typeof window !== 'undefined' &&
      window.process &&
      (window.process.type === 'renderer' || window.process.__nwjs)
    ) {
      return true;
    }
    if (
      typeof navigator !== 'undefined' &&
      navigator.userAgent &&
      navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
    ) {
      return false;
    }
    return (
      (typeof document !== 'undefined' &&
        document.documentElement &&
        document.documentElement.style &&
        document.documentElement.style.WebkitAppearance) ||
      (typeof window !== 'undefined' &&
        window.console &&
        (window.console.firebug ||
          (window.console.exception && window.console.table))) ||
      (typeof navigator !== 'undefined' &&
        navigator.userAgent &&
        navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
        parseInt(RegExp.$1, 10) >= 31) ||
      (typeof navigator !== 'undefined' &&
        navigator.userAgent &&
        navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
    );
  }
  function formatArgs(args) {
    args[0] =
      (this.useColors ? '%c' : '') +
      this.namespace +
      (this.useColors ? ' %c' : ' ') +
      args[0] +
      (this.useColors ? '%c ' : ' ') +
      '+' +
      module2.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit');
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === '%%') {
        return;
      }
      index++;
      if (match === '%c') {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports2.log = console.debug || console.log || (() => {});
  function save(namespaces) {
    try {
      if (namespaces) {
        exports2.storage.setItem('debug', namespaces);
      } else {
        exports2.storage.removeItem('debug');
      }
    } catch (error) {}
  }
  function load() {
    let r;
    try {
      r = exports2.storage.getItem('debug');
    } catch (error) {}
    if (!r && typeof process !== 'undefined' && 'env' in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {}
  }
  module2.exports = require_common2()(exports2);
  var { formatters } = module2.exports;
  formatters.j = function (v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return '[UnexpectedJSONParseError]: ' + error.message;
    }
  };
});

// node_modules/supports-color/node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf('--');
    return (
      position !== -1 &&
      (terminatorPosition === -1 || position < terminatorPosition)
    );
  };
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports2, module2) => {
  'use strict';
  var os = require('os');
  var tty = require('tty');
  var hasFlag = require_has_flag();
  var { env } = process;
  var forceColor;
  if (
    hasFlag('no-color') ||
    hasFlag('no-colors') ||
    hasFlag('color=false') ||
    hasFlag('color=never')
  ) {
    forceColor = 0;
  } else if (
    hasFlag('color') ||
    hasFlag('colors') ||
    hasFlag('color=true') ||
    hasFlag('color=always')
  ) {
    forceColor = 1;
  }
  if ('FORCE_COLOR' in env) {
    if (env.FORCE_COLOR === 'true') {
      forceColor = 1;
    } else if (env.FORCE_COLOR === 'false') {
      forceColor = 0;
    } else {
      forceColor =
        env.FORCE_COLOR.length === 0
          ? 1
          : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3,
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (
      hasFlag('color=16m') ||
      hasFlag('color=full') ||
      hasFlag('color=truecolor')
    ) {
      return 3;
    }
    if (hasFlag('color=256')) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === void 0) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === 'dumb') {
      return min;
    }
    if (process.platform === 'win32') {
      const osRelease = os.release().split('.');
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ('CI' in env) {
      if (
        [
          'TRAVIS',
          'CIRCLECI',
          'APPVEYOR',
          'GITLAB_CI',
          'GITHUB_ACTIONS',
          'BUILDKITE',
        ].some((sign) => sign in env) ||
        env.CI_NAME === 'codeship'
      ) {
        return 1;
      }
      return min;
    }
    if ('TEAMCITY_VERSION' in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === 'truecolor') {
      return 3;
    }
    if ('TERM_PROGRAM' in env) {
      const version = parseInt(
        (env.TERM_PROGRAM_VERSION || '').split('.')[0],
        10,
      );
      switch (env.TERM_PROGRAM) {
        case 'iTerm.app':
          return version >= 3 ? 3 : 2;
        case 'Apple_Terminal':
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (
      /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(
        env.TERM,
      )
    ) {
      return 1;
    }
    if ('COLORTERM' in env) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
  }
  module2.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2))),
  };
});

// node_modules/debug/src/node.js
var require_node = __commonJS((exports2, module2) => {
  var tty = require('tty');
  var util = require('util');
  exports2.init = init2;
  exports2.log = log2;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.destroy = util.deprecate(() => {},
  'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
  exports2.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports2.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221,
      ];
    }
  } catch (error) {}
  exports2.inspectOpts = Object.keys(process.env)
    .filter((key) => {
      return /^debug_/i.test(key);
    })
    .reduce((obj, key) => {
      const prop = key
        .substring(6)
        .toLowerCase()
        .replace(/_([a-z])/g, (_2, k) => {
          return k.toUpperCase();
        });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === 'null') {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
  function useColors() {
    return 'colors' in exports2.inspectOpts
      ? Boolean(exports2.inspectOpts.colors)
      : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = '[3' + (c < 8 ? c : '8;5;' + c);
      const prefix = `  ${colorCode};1m${name} [0m`;
      args[0] = prefix + args[0].split('\n').join('\n' + prefix);
      args.push(colorCode + 'm+' + module2.exports.humanize(this.diff) + '[0m');
    } else {
      args[0] = getDate() + name + ' ' + args[0];
    }
  }
  function getDate() {
    if (exports2.inspectOpts.hideDate) {
      return '';
    }
    return new Date().toISOString() + ' ';
  }
  function log2(...args) {
    return process.stderr.write(util.format(...args) + '\n');
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init2(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports2.inspectOpts);
    for (let i = 0; i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
    }
  }
  module2.exports = require_common2()(exports2);
  var { formatters } = module2.exports;
  formatters.o = function (v) {
    this.inspectOpts.colors = this.useColors;
    return util
      .inspect(v, this.inspectOpts)
      .split('\n')
      .map((str) => str.trim())
      .join(' ');
  };
  formatters.O = function (v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src = __commonJS((exports2, module2) => {
  if (
    typeof process === 'undefined' ||
    process.type === 'renderer' ||
    process.browser === true ||
    process.__nwjs
  ) {
    module2.exports = require_browser2();
  } else {
    module2.exports = require_node();
  }
});

// node_modules/depd/lib/compat/callsite-tostring.js
var require_callsite_tostring = __commonJS((exports2, module2) => {
  /*!
   * depd
   * Copyright(c) 2014 Douglas Christopher Wilson
   * MIT Licensed
   */
  'use strict';
  module2.exports = callSiteToString2;
  function callSiteFileLocation(callSite) {
    var fileName;
    var fileLocation = '';
    if (callSite.isNative()) {
      fileLocation = 'native';
    } else if (callSite.isEval()) {
      fileName = callSite.getScriptNameOrSourceURL();
      if (!fileName) {
        fileLocation = callSite.getEvalOrigin();
      }
    } else {
      fileName = callSite.getFileName();
    }
    if (fileName) {
      fileLocation += fileName;
      var lineNumber = callSite.getLineNumber();
      if (lineNumber != null) {
        fileLocation += ':' + lineNumber;
        var columnNumber = callSite.getColumnNumber();
        if (columnNumber) {
          fileLocation += ':' + columnNumber;
        }
      }
    }
    return fileLocation || 'unknown source';
  }
  function callSiteToString2(callSite) {
    var addSuffix = true;
    var fileLocation = callSiteFileLocation(callSite);
    var functionName = callSite.getFunctionName();
    var isConstructor = callSite.isConstructor();
    var isMethodCall = !(callSite.isToplevel() || isConstructor);
    var line = '';
    if (isMethodCall) {
      var methodName = callSite.getMethodName();
      var typeName = getConstructorName(callSite);
      if (functionName) {
        if (typeName && functionName.indexOf(typeName) !== 0) {
          line += typeName + '.';
        }
        line += functionName;
        if (
          methodName &&
          functionName.lastIndexOf('.' + methodName) !==
            functionName.length - methodName.length - 1
        ) {
          line += ' [as ' + methodName + ']';
        }
      } else {
        line += typeName + '.' + (methodName || '<anonymous>');
      }
    } else if (isConstructor) {
      line += 'new ' + (functionName || '<anonymous>');
    } else if (functionName) {
      line += functionName;
    } else {
      addSuffix = false;
      line += fileLocation;
    }
    if (addSuffix) {
      line += ' (' + fileLocation + ')';
    }
    return line;
  }
  function getConstructorName(obj) {
    var receiver = obj.receiver;
    return (receiver.constructor && receiver.constructor.name) || null;
  }
});

// node_modules/depd/lib/compat/event-listener-count.js
var require_event_listener_count = __commonJS((exports2, module2) => {
  /*!
   * depd
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  'use strict';
  module2.exports = eventListenerCount2;
  function eventListenerCount2(emitter, type) {
    return emitter.listeners(type).length;
  }
});

// node_modules/depd/lib/compat/index.js
var require_compat = __commonJS((exports2, module2) => {
  /*!
   * depd
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  'use strict';
  var EventEmitter = require('events').EventEmitter;
  lazyProperty(
    module2.exports,
    'callSiteToString',
    function callSiteToString2() {
      var limit = Error.stackTraceLimit;
      var obj = {};
      var prep = Error.prepareStackTrace;
      function prepareObjectStackTrace2(obj2, stack2) {
        return stack2;
      }
      Error.prepareStackTrace = prepareObjectStackTrace2;
      Error.stackTraceLimit = 2;
      Error.captureStackTrace(obj);
      var stack = obj.stack.slice();
      Error.prepareStackTrace = prep;
      Error.stackTraceLimit = limit;
      return stack[0].toString ? toString : require_callsite_tostring();
    },
  );
  lazyProperty(
    module2.exports,
    'eventListenerCount',
    function eventListenerCount2() {
      return EventEmitter.listenerCount || require_event_listener_count();
    },
  );
  function lazyProperty(obj, prop, getter) {
    function get() {
      var val = getter();
      Object.defineProperty(obj, prop, {
        configurable: true,
        enumerable: true,
        value: val,
      });
      return val;
    }
    Object.defineProperty(obj, prop, {
      configurable: true,
      enumerable: true,
      get,
    });
  }
  function toString(obj) {
    return obj.toString();
  }
});

// node_modules/depd/index.js
var require_depd = __commonJS((exports, module) => {
  /*!
   * depd
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   */
  var callSiteToString = require_compat().callSiteToString;
  var eventListenerCount = require_compat().eventListenerCount;
  var relative = require('path').relative;
  module.exports = depd;
  var basePath = process.cwd();
  function containsNamespace(str, namespace) {
    var vals = str.split(/[ ,]+/);
    var ns = String(namespace).toLowerCase();
    for (var i = 0; i < vals.length; i++) {
      var val = vals[i];
      if (val && (val === '*' || val.toLowerCase() === ns)) {
        return true;
      }
    }
    return false;
  }
  function convertDataDescriptorToAccessor(obj, prop, message) {
    var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
    var value = descriptor.value;
    descriptor.get = function getter() {
      return value;
    };
    if (descriptor.writable) {
      descriptor.set = function setter(val) {
        return (value = val);
      };
    }
    delete descriptor.value;
    delete descriptor.writable;
    Object.defineProperty(obj, prop, descriptor);
    return descriptor;
  }
  function createArgumentsString(arity) {
    var str = '';
    for (var i = 0; i < arity; i++) {
      str += ', arg' + i;
    }
    return str.substr(2);
  }
  function createStackString(stack) {
    var str = this.name + ': ' + this.namespace;
    if (this.message) {
      str += ' deprecated ' + this.message;
    }
    for (var i = 0; i < stack.length; i++) {
      str += '\n    at ' + callSiteToString(stack[i]);
    }
    return str;
  }
  function depd(namespace) {
    if (!namespace) {
      throw new TypeError('argument namespace is required');
    }
    var stack = getStack();
    var site = callSiteLocation(stack[1]);
    var file = site[0];
    function deprecate(message) {
      log.call(deprecate, message);
    }
    deprecate._file = file;
    deprecate._ignored = isignored(namespace);
    deprecate._namespace = namespace;
    deprecate._traced = istraced(namespace);
    deprecate._warned = Object.create(null);
    deprecate.function = wrapfunction;
    deprecate.property = wrapproperty;
    return deprecate;
  }
  function isignored(namespace) {
    if (process.noDeprecation) {
      return true;
    }
    var str = process.env.NO_DEPRECATION || '';
    return containsNamespace(str, namespace);
  }
  function istraced(namespace) {
    if (process.traceDeprecation) {
      return true;
    }
    var str = process.env.TRACE_DEPRECATION || '';
    return containsNamespace(str, namespace);
  }
  function log(message, site) {
    var haslisteners = eventListenerCount(process, 'deprecation') !== 0;
    if (!haslisteners && this._ignored) {
      return;
    }
    var caller;
    var callFile;
    var callSite;
    var depSite;
    var i = 0;
    var seen = false;
    var stack = getStack();
    var file = this._file;
    if (site) {
      depSite = site;
      callSite = callSiteLocation(stack[1]);
      callSite.name = depSite.name;
      file = callSite[0];
    } else {
      i = 2;
      depSite = callSiteLocation(stack[i]);
      callSite = depSite;
    }
    for (; i < stack.length; i++) {
      caller = callSiteLocation(stack[i]);
      callFile = caller[0];
      if (callFile === file) {
        seen = true;
      } else if (callFile === this._file) {
        file = this._file;
      } else if (seen) {
        break;
      }
    }
    var key = caller ? depSite.join(':') + '__' + caller.join(':') : void 0;
    if (key !== void 0 && key in this._warned) {
      return;
    }
    this._warned[key] = true;
    var msg = message;
    if (!msg) {
      msg =
        callSite === depSite || !callSite.name
          ? defaultMessage(depSite)
          : defaultMessage(callSite);
    }
    if (haslisteners) {
      var err = DeprecationError(this._namespace, msg, stack.slice(i));
      process.emit('deprecation', err);
      return;
    }
    var format = process.stderr.isTTY ? formatColor : formatPlain;
    var output = format.call(this, msg, caller, stack.slice(i));
    process.stderr.write(output + '\n', 'utf8');
  }
  function callSiteLocation(callSite) {
    var file = callSite.getFileName() || '<anonymous>';
    var line = callSite.getLineNumber();
    var colm = callSite.getColumnNumber();
    if (callSite.isEval()) {
      file = callSite.getEvalOrigin() + ', ' + file;
    }
    var site = [file, line, colm];
    site.callSite = callSite;
    site.name = callSite.getFunctionName();
    return site;
  }
  function defaultMessage(site) {
    var callSite = site.callSite;
    var funcName = site.name;
    if (!funcName) {
      funcName = '<anonymous@' + formatLocation(site) + '>';
    }
    var context = callSite.getThis();
    var typeName = context && callSite.getTypeName();
    if (typeName === 'Object') {
      typeName = void 0;
    }
    if (typeName === 'Function') {
      typeName = context.name || typeName;
    }
    return typeName && callSite.getMethodName()
      ? typeName + '.' + funcName
      : funcName;
  }
  function formatPlain(msg, caller, stack) {
    var timestamp = new Date().toUTCString();
    var formatted = timestamp + ' ' + this._namespace + ' deprecated ' + msg;
    if (this._traced) {
      for (var i = 0; i < stack.length; i++) {
        formatted += '\n    at ' + callSiteToString(stack[i]);
      }
      return formatted;
    }
    if (caller) {
      formatted += ' at ' + formatLocation(caller);
    }
    return formatted;
  }
  function formatColor(msg, caller, stack) {
    var formatted = '[36;1m' + this._namespace + '[22;39m [33;1mdeprecated[22;39m [0m' + msg + '[39m';
    if (this._traced) {
      for (var i = 0; i < stack.length; i++) {
        formatted += '\n    [36mat ' + callSiteToString(stack[i]) + '[39m';
      }
      return formatted;
    }
    if (caller) {
      formatted += ' [36m' + formatLocation(caller) + '[39m';
    }
    return formatted;
  }
  function formatLocation(callSite) {
    return (
      relative(basePath, callSite[0]) + ':' + callSite[1] + ':' + callSite[2]
    );
  }
  function getStack() {
    var limit = Error.stackTraceLimit;
    var obj = {};
    var prep = Error.prepareStackTrace;
    Error.prepareStackTrace = prepareObjectStackTrace;
    Error.stackTraceLimit = Math.max(10, limit);
    Error.captureStackTrace(obj);
    var stack = obj.stack.slice(1);
    Error.prepareStackTrace = prep;
    Error.stackTraceLimit = limit;
    return stack;
  }
  function prepareObjectStackTrace(obj, stack) {
    return stack;
  }
  function wrapfunction(fn, message) {
    if (typeof fn !== 'function') {
      throw new TypeError('argument fn must be a function');
    }
    var args = createArgumentsString(fn.length);
    var deprecate = this;
    var stack = getStack();
    var site = callSiteLocation(stack[1]);
    site.name = fn.name;
    var deprecatedfn = eval(
      '(function (' +
        args +
        ') {\n"use strict"\nlog.call(deprecate, message, site)\nreturn fn.apply(this, arguments)\n})',
    );
    return deprecatedfn;
  }
  function wrapproperty(obj, prop, message) {
    if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
      throw new TypeError('argument obj must be object');
    }
    var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
    if (!descriptor) {
      throw new TypeError('must call property on owner object');
    }
    if (!descriptor.configurable) {
      throw new TypeError('property must be configurable');
    }
    var deprecate = this;
    var stack = getStack();
    var site = callSiteLocation(stack[1]);
    site.name = prop;
    if ('value' in descriptor) {
      descriptor = convertDataDescriptorToAccessor(obj, prop, message);
    }
    var get = descriptor.get;
    var set = descriptor.set;
    if (typeof get === 'function') {
      descriptor.get = function getter() {
        log.call(deprecate, message, site);
        return get.apply(this, arguments);
      };
    }
    if (typeof set === 'function') {
      descriptor.set = function setter() {
        log.call(deprecate, message, site);
        return set.apply(this, arguments);
      };
    }
    Object.defineProperty(obj, prop, descriptor);
  }
  function DeprecationError(namespace, message, stack) {
    var error = new Error();
    var stackString;
    Object.defineProperty(error, 'constructor', {
      value: DeprecationError,
    });
    Object.defineProperty(error, 'message', {
      configurable: true,
      enumerable: false,
      value: message,
      writable: true,
    });
    Object.defineProperty(error, 'name', {
      enumerable: false,
      configurable: true,
      value: 'DeprecationError',
      writable: true,
    });
    Object.defineProperty(error, 'namespace', {
      configurable: true,
      enumerable: false,
      value: namespace,
      writable: true,
    });
    Object.defineProperty(error, 'stack', {
      configurable: true,
      enumerable: false,
      get: function () {
        if (stackString !== void 0) {
          return stackString;
        }
        return (stackString = createStackString.call(this, stack));
      },
      set: function setter(val) {
        stackString = val;
      },
    });
    return error;
  }
});

// node_modules/agentkeepalive/lib/constants.js
var require_constants2 = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = {
    CURRENT_ID: Symbol('agentkeepalive#currentId'),
    CREATE_ID: Symbol('agentkeepalive#createId'),
    INIT_SOCKET: Symbol('agentkeepalive#initSocket'),
    CREATE_HTTPS_CONNECTION: Symbol('agentkeepalive#createHttpsConnection'),
    SOCKET_CREATED_TIME: Symbol('agentkeepalive#socketCreatedTime'),
    SOCKET_NAME: Symbol('agentkeepalive#socketName'),
    SOCKET_REQUEST_COUNT: Symbol('agentkeepalive#socketRequestCount'),
    SOCKET_REQUEST_FINISHED_COUNT: Symbol(
      'agentkeepalive#socketRequestFinishedCount',
    ),
  };
});

// node_modules/agentkeepalive/lib/agent.js
var require_agent = __commonJS((exports2, module2) => {
  'use strict';
  var OriginalAgent = require('http').Agent;
  var ms = require_humanize_ms();
  var debug = require_src()('agentkeepalive');
  var deprecate = require_depd()('agentkeepalive');
  var {
    INIT_SOCKET,
    CURRENT_ID,
    CREATE_ID,
    SOCKET_CREATED_TIME,
    SOCKET_NAME,
    SOCKET_REQUEST_COUNT,
    SOCKET_REQUEST_FINISHED_COUNT,
  } = require_constants2();
  var defaultTimeoutListenerCount = 1;
  var majorVersion = parseInt(process.version.split('.', 1)[0].substring(1));
  if (majorVersion >= 11 && majorVersion <= 12) {
    defaultTimeoutListenerCount = 2;
  } else if (majorVersion >= 13) {
    defaultTimeoutListenerCount = 3;
  }
  var Agent = class extends OriginalAgent {
    constructor(options) {
      options = options || {};
      options.keepAlive = options.keepAlive !== false;
      if (options.freeSocketTimeout === void 0) {
        options.freeSocketTimeout = 15e3;
      }
      if (options.keepAliveTimeout) {
        deprecate(
          'options.keepAliveTimeout is deprecated, please use options.freeSocketTimeout instead',
        );
        options.freeSocketTimeout = options.keepAliveTimeout;
        delete options.keepAliveTimeout;
      }
      if (options.freeSocketKeepAliveTimeout) {
        deprecate(
          'options.freeSocketKeepAliveTimeout is deprecated, please use options.freeSocketTimeout instead',
        );
        options.freeSocketTimeout = options.freeSocketKeepAliveTimeout;
        delete options.freeSocketKeepAliveTimeout;
      }
      if (options.timeout === void 0) {
        options.timeout = Math.max(options.freeSocketTimeout * 2, 3e4);
      }
      options.timeout = ms(options.timeout);
      options.freeSocketTimeout = ms(options.freeSocketTimeout);
      options.socketActiveTTL = options.socketActiveTTL
        ? ms(options.socketActiveTTL)
        : 0;
      super(options);
      this[CURRENT_ID] = 0;
      this.createSocketCount = 0;
      this.createSocketCountLastCheck = 0;
      this.createSocketErrorCount = 0;
      this.createSocketErrorCountLastCheck = 0;
      this.closeSocketCount = 0;
      this.closeSocketCountLastCheck = 0;
      this.errorSocketCount = 0;
      this.errorSocketCountLastCheck = 0;
      this.requestCount = 0;
      this.requestCountLastCheck = 0;
      this.timeoutSocketCount = 0;
      this.timeoutSocketCountLastCheck = 0;
      this.on('free', (socket) => {
        const timeout = this.calcSocketTimeout(socket);
        if (timeout > 0 && socket.timeout !== timeout) {
          socket.setTimeout(timeout);
        }
      });
    }
    get freeSocketKeepAliveTimeout() {
      deprecate(
        'agent.freeSocketKeepAliveTimeout is deprecated, please use agent.options.freeSocketTimeout instead',
      );
      return this.options.freeSocketTimeout;
    }
    get timeout() {
      deprecate(
        'agent.timeout is deprecated, please use agent.options.timeout instead',
      );
      return this.options.timeout;
    }
    get socketActiveTTL() {
      deprecate(
        'agent.socketActiveTTL is deprecated, please use agent.options.socketActiveTTL instead',
      );
      return this.options.socketActiveTTL;
    }
    calcSocketTimeout(socket) {
      let freeSocketTimeout = this.options.freeSocketTimeout;
      const socketActiveTTL = this.options.socketActiveTTL;
      if (socketActiveTTL) {
        const aliveTime = Date.now() - socket[SOCKET_CREATED_TIME];
        const diff = socketActiveTTL - aliveTime;
        if (diff <= 0) {
          return diff;
        }
        if (freeSocketTimeout && diff < freeSocketTimeout) {
          freeSocketTimeout = diff;
        }
      }
      if (freeSocketTimeout) {
        const customFreeSocketTimeout =
          socket.freeSocketTimeout || socket.freeSocketKeepAliveTimeout;
        return customFreeSocketTimeout || freeSocketTimeout;
      }
    }
    keepSocketAlive(socket) {
      const result = super.keepSocketAlive(socket);
      if (!result) return result;
      const customTimeout = this.calcSocketTimeout(socket);
      if (typeof customTimeout === 'undefined') {
        return true;
      }
      if (customTimeout <= 0) {
        debug(
          '%s(requests: %s, finished: %s) free but need to destroy by TTL, request count %s, diff is %s',
          socket[SOCKET_NAME],
          socket[SOCKET_REQUEST_COUNT],
          socket[SOCKET_REQUEST_FINISHED_COUNT],
          customTimeout,
        );
        return false;
      }
      if (socket.timeout !== customTimeout) {
        socket.setTimeout(customTimeout);
      }
      return true;
    }
    reuseSocket(...args) {
      super.reuseSocket(...args);
      const socket = args[0];
      const req = args[1];
      req.reusedSocket = true;
      const agentTimeout = this.options.timeout;
      if (getSocketTimeout(socket) !== agentTimeout) {
        socket.setTimeout(agentTimeout);
        debug('%s reset timeout to %sms', socket[SOCKET_NAME], agentTimeout);
      }
      socket[SOCKET_REQUEST_COUNT]++;
      debug(
        '%s(requests: %s, finished: %s) reuse on addRequest, timeout %sms',
        socket[SOCKET_NAME],
        socket[SOCKET_REQUEST_COUNT],
        socket[SOCKET_REQUEST_FINISHED_COUNT],
        getSocketTimeout(socket),
      );
    }
    [CREATE_ID]() {
      const id = this[CURRENT_ID]++;
      if (this[CURRENT_ID] === Number.MAX_SAFE_INTEGER) this[CURRENT_ID] = 0;
      return id;
    }
    [INIT_SOCKET](socket, options) {
      if (options.timeout) {
        const timeout = getSocketTimeout(socket);
        if (!timeout) {
          socket.setTimeout(options.timeout);
        }
      }
      if (this.options.keepAlive) {
        socket.setNoDelay(true);
      }
      this.createSocketCount++;
      if (this.options.socketActiveTTL) {
        socket[SOCKET_CREATED_TIME] = Date.now();
      }
      socket[SOCKET_NAME] = `sock[${this[CREATE_ID]()}#${
        options._agentKey
      }]`.split('-----BEGIN', 1)[0];
      socket[SOCKET_REQUEST_COUNT] = 1;
      socket[SOCKET_REQUEST_FINISHED_COUNT] = 0;
      installListeners(this, socket, options);
    }
    createConnection(options, oncreate) {
      let called = false;
      const onNewCreate = (err, socket) => {
        if (called) return;
        called = true;
        if (err) {
          this.createSocketErrorCount++;
          return oncreate(err);
        }
        this[INIT_SOCKET](socket, options);
        oncreate(err, socket);
      };
      const newSocket = super.createConnection(options, onNewCreate);
      if (newSocket) onNewCreate(null, newSocket);
    }
    get statusChanged() {
      const changed =
        this.createSocketCount !== this.createSocketCountLastCheck ||
        this.createSocketErrorCount !== this.createSocketErrorCountLastCheck ||
        this.closeSocketCount !== this.closeSocketCountLastCheck ||
        this.errorSocketCount !== this.errorSocketCountLastCheck ||
        this.timeoutSocketCount !== this.timeoutSocketCountLastCheck ||
        this.requestCount !== this.requestCountLastCheck;
      if (changed) {
        this.createSocketCountLastCheck = this.createSocketCount;
        this.createSocketErrorCountLastCheck = this.createSocketErrorCount;
        this.closeSocketCountLastCheck = this.closeSocketCount;
        this.errorSocketCountLastCheck = this.errorSocketCount;
        this.timeoutSocketCountLastCheck = this.timeoutSocketCount;
        this.requestCountLastCheck = this.requestCount;
      }
      return changed;
    }
    getCurrentStatus() {
      return {
        createSocketCount: this.createSocketCount,
        createSocketErrorCount: this.createSocketErrorCount,
        closeSocketCount: this.closeSocketCount,
        errorSocketCount: this.errorSocketCount,
        timeoutSocketCount: this.timeoutSocketCount,
        requestCount: this.requestCount,
        freeSockets: inspect(this.freeSockets),
        sockets: inspect(this.sockets),
        requests: inspect(this.requests),
      };
    }
  };
  function getSocketTimeout(socket) {
    return socket.timeout || socket._idleTimeout;
  }
  function installListeners(agent, socket, options) {
    debug(
      '%s create, timeout %sms',
      socket[SOCKET_NAME],
      getSocketTimeout(socket),
    );
    function onFree() {
      if (!socket._httpMessage && socket[SOCKET_REQUEST_COUNT] === 1) return;
      socket[SOCKET_REQUEST_FINISHED_COUNT]++;
      agent.requestCount++;
      debug(
        '%s(requests: %s, finished: %s) free',
        socket[SOCKET_NAME],
        socket[SOCKET_REQUEST_COUNT],
        socket[SOCKET_REQUEST_FINISHED_COUNT],
      );
      const name = agent.getName(options);
      if (
        socket.writable &&
        agent.requests[name] &&
        agent.requests[name].length
      ) {
        socket[SOCKET_REQUEST_COUNT]++;
        debug(
          '%s(requests: %s, finished: %s) will be reuse on agent free event',
          socket[SOCKET_NAME],
          socket[SOCKET_REQUEST_COUNT],
          socket[SOCKET_REQUEST_FINISHED_COUNT],
        );
      }
    }
    socket.on('free', onFree);
    function onClose(isError) {
      debug(
        '%s(requests: %s, finished: %s) close, isError: %s',
        socket[SOCKET_NAME],
        socket[SOCKET_REQUEST_COUNT],
        socket[SOCKET_REQUEST_FINISHED_COUNT],
        isError,
      );
      agent.closeSocketCount++;
    }
    socket.on('close', onClose);
    function onTimeout() {
      const listenerCount = socket.listeners('timeout').length;
      const timeout = getSocketTimeout(socket);
      const req = socket._httpMessage;
      const reqTimeoutListenerCount =
        (req && req.listeners('timeout').length) || 0;
      debug(
        '%s(requests: %s, finished: %s) timeout after %sms, listeners %s, defaultTimeoutListenerCount %s, hasHttpRequest %s, HttpRequest timeoutListenerCount %s',
        socket[SOCKET_NAME],
        socket[SOCKET_REQUEST_COUNT],
        socket[SOCKET_REQUEST_FINISHED_COUNT],
        timeout,
        listenerCount,
        defaultTimeoutListenerCount,
        !!req,
        reqTimeoutListenerCount,
      );
      if (debug.enabled) {
        debug(
          'timeout listeners: %s',
          socket
            .listeners('timeout')
            .map((f) => f.name)
            .join(', '),
        );
      }
      agent.timeoutSocketCount++;
      const name = agent.getName(options);
      if (
        agent.freeSockets[name] &&
        agent.freeSockets[name].indexOf(socket) !== -1
      ) {
        socket.destroy();
        agent.removeSocket(socket, options);
        debug('%s is free, destroy quietly', socket[SOCKET_NAME]);
      } else {
        if (reqTimeoutListenerCount === 0) {
          const error = new Error('Socket timeout');
          error.code = 'ERR_SOCKET_TIMEOUT';
          error.timeout = timeout;
          socket.destroy(error);
          agent.removeSocket(socket, options);
          debug('%s destroy with timeout error', socket[SOCKET_NAME]);
        }
      }
    }
    socket.on('timeout', onTimeout);
    function onError(err) {
      const listenerCount = socket.listeners('error').length;
      debug(
        '%s(requests: %s, finished: %s) error: %s, listenerCount: %s',
        socket[SOCKET_NAME],
        socket[SOCKET_REQUEST_COUNT],
        socket[SOCKET_REQUEST_FINISHED_COUNT],
        err,
        listenerCount,
      );
      agent.errorSocketCount++;
      if (listenerCount === 1) {
        debug('%s emit uncaught error event', socket[SOCKET_NAME]);
        socket.removeListener('error', onError);
        socket.emit('error', err);
      }
    }
    socket.on('error', onError);
    function onRemove() {
      debug(
        '%s(requests: %s, finished: %s) agentRemove',
        socket[SOCKET_NAME],
        socket[SOCKET_REQUEST_COUNT],
        socket[SOCKET_REQUEST_FINISHED_COUNT],
      );
      socket.removeListener('close', onClose);
      socket.removeListener('error', onError);
      socket.removeListener('free', onFree);
      socket.removeListener('timeout', onTimeout);
      socket.removeListener('agentRemove', onRemove);
    }
    socket.on('agentRemove', onRemove);
  }
  module2.exports = Agent;
  function inspect(obj) {
    const res = {};
    for (const key in obj) {
      res[key] = obj[key].length;
    }
    return res;
  }
});

// node_modules/agentkeepalive/lib/https_agent.js
var require_https_agent = __commonJS((exports2, module2) => {
  'use strict';
  var OriginalHttpsAgent = require('https').Agent;
  var HttpAgent = require_agent();
  var { INIT_SOCKET, CREATE_HTTPS_CONNECTION } = require_constants2();
  var HttpsAgent = class extends HttpAgent {
    constructor(options) {
      super(options);
      this.defaultPort = 443;
      this.protocol = 'https:';
      this.maxCachedSessions = this.options.maxCachedSessions;
      if (this.maxCachedSessions === void 0) {
        this.maxCachedSessions = 100;
      }
      this._sessionCache = {
        map: {},
        list: [],
      };
    }
    createConnection(options) {
      const socket = this[CREATE_HTTPS_CONNECTION](options);
      this[INIT_SOCKET](socket, options);
      return socket;
    }
  };
  HttpsAgent.prototype[CREATE_HTTPS_CONNECTION] =
    OriginalHttpsAgent.prototype.createConnection;
  ['getName', '_getSession', '_cacheSession', '_evictSession'].forEach(
    function (method) {
      if (typeof OriginalHttpsAgent.prototype[method] === 'function') {
        HttpsAgent.prototype[method] = OriginalHttpsAgent.prototype[method];
      }
    },
  );
  module2.exports = HttpsAgent;
});

// node_modules/agentkeepalive/index.js
var require_agentkeepalive = __commonJS((exports2, module2) => {
  'use strict';
  module2.exports = require_agent();
  module2.exports.HttpsAgent = require_https_agent();
  module2.exports.constants = require_constants2();
});

// node_modules/@cloudbase/node-sdk/lib/utils/request.js
var require_request4 = __commonJS((exports2) => {
  'use strict';
  var __importDefault =
    (exports2 && exports2.__importDefault) ||
    function (mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
  var __importStar =
    (exports2 && exports2.__importStar) ||
    function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
      }
      result['default'] = mod;
      return result;
    };
  Object.defineProperty(exports2, '__esModule', { value: true });
  var http_1 = __importDefault(require('http'));
  var request_1 = __importDefault(require_request3());
  var retry_1 = require_retry3();
  var request_timings_measurer_1 = require_request_timings_measurer();
  var agentkeepalive_1 = __importStar(require_agentkeepalive());
  var SAFE_RETRY_CODE_SET = new Set([
    'ENOTFOUND',
    'ENETDOWN',
    'EHOSTDOWN',
    'ENETUNREACH',
    'EHOSTUNREACH',
    'ECONNREFUSED',
  ]);
  var RETRY_CODE_SET = new Set(['ECONNRESET', 'ESOCKETTIMEDOUT']);
  var RETRY_STATUS_CODE_SET = new Set([]);
  function shouldRetry(e, result, operation) {
    if (e && SAFE_RETRY_CODE_SET.has(e.code)) {
      return {
        retryAble: true,
        message: e.message,
      };
    }
    if (e && e.code === 'ETIMEDOUT' && e.connect === true) {
      return {
        retryAble: true,
        message: e.message,
      };
    }
    if (result && RETRY_STATUS_CODE_SET.has(result.statusCode)) {
      return {
        retryAble: true,
        message: `${result.request.method} ${result.request.href} ${
          result.statusCode
        } ${http_1.default.STATUS_CODES[result.statusCode]}`,
      };
    }
    return {
      retryAble: false,
      message: '',
    };
  }
  function requestWithTimingsMeasure(opts, extraOptions) {
    return new Promise((resolve, reject) => {
      const timingsMeasurerOptions = extraOptions.timingsMeasurerOptions || {};
      const {
        waitingTime = 1e3,
        interval = 200,
        enable = !!extraOptions.debug,
      } = timingsMeasurerOptions;
      const timingsMeasurer = request_timings_measurer_1.RequestTimgingsMeasurer.new(
        {
          waitingTime,
          interval,
          enable,
        },
      );
      timingsMeasurer.on('progress', (timings, reason = '') => {
        const timingsLine = `s:${timings.socket || '-'}|l:${
          timings.lookup || '-'
        }|c:${timings.connect || '-'}|r:${timings.ready || '-'}|w:${
          timings.waiting || '-'
        }|d:${timings.download || '-'}|e:${timings.end || '-'}|E:${
          timings.error || '-'
        }`;
        console.warn(
          `[RequestTimgings][${extraOptions.op || ''}] spent ${
            Date.now() - timings.start
          }ms(${timingsLine}) [${extraOptions.seqId}][${
            extraOptions.attempts || 1
          }][${reason}]`,
        );
      });
      if (opts.keepalive) {
        opts.agentClass = opts.url.startsWith('https')
          ? agentkeepalive_1.HttpsAgent
          : agentkeepalive_1.default;
        opts.agentOptions = {
          keepAliveMsecs: 3e3,
          maxSockets: 100,
          maxFreeSockets: 10,
          freeSocketTimeout: 2e4,
          timeout: 2e4,
          socketActiveTTL: null,
        };
      }
      (function r(times) {
        const clientRequest = request_1.default(
          opts,
          function (err, response, body) {
            const reusedSocket = !!(
              clientRequest &&
              clientRequest.req &&
              clientRequest.req.reusedSocket
            );
            if (err && extraOptions.debug) {
              console.warn(
                `[RequestTimgings][keepalive:${opts.keepalive}][reusedSocket:${reusedSocket}][times:${times}][code:${err.code}][message:${err.message}]${opts.url}`,
              );
            }
            if (
              err &&
              err.code === 'ECONNRESET' &&
              reusedSocket &&
              times >= 0 &&
              opts.keepalive
            ) {
              return r(--times);
            }
            return err ? reject(err) : resolve(response);
          },
        );
        if (
          (request_1.default.Request &&
            clientRequest instanceof request_1.default.Request) ||
          clientRequest instanceof http_1.default.ClientRequest
        ) {
          timingsMeasurer.measure(clientRequest);
        }
      })(1);
    });
  }
  exports2.requestWithTimingsMeasure = requestWithTimingsMeasure;
  function extraRequest(opts, extraOptions) {
    if (extraOptions && extraOptions.retryOptions) {
      return retry_1.withRetry((attempts) => {
        return requestWithTimingsMeasure(
          opts,
          Object.assign({}, extraOptions, { attempts }),
        );
      }, Object.assign({ shouldRetry }, extraOptions.retryOptions));
    } else {
      return requestWithTimingsMeasure(
        opts,
        Object.assign({}, extraOptions, { attempts: 1 }),
      );
    }
  }
  exports2.extraRequest = extraRequest;
});

// node_modules/@cloudbase/node-sdk/lib/utils/requestHook.js
var require_requestHook = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  exports2.handleWxOpenApiData = (res, err, response, body) => {
    const { headers } = response;
    let transformRes = res;
    if (headers['content-type'] === 'application/json; charset=utf-8') {
      transformRes = JSON.parse(transformRes.toString());
    }
    return transformRes;
  };
});

// node_modules/@cloudbase/node-sdk/lib/utils/getWxCloudApiToken.js
var require_getWxCloudApiToken = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var cloudbase_1 = require_cloudbase();
  function getWxCloudApiToken() {
    const {
      TRIGGER_SRC,
      WX_TRIGGER_API_TOKEN_V0,
      WX_API_TOKEN,
    } = cloudbase_1.CloudBase.getCloudbaseContext();
    if (TRIGGER_SRC === 'timer') {
      return WX_TRIGGER_API_TOKEN_V0 || WX_API_TOKEN || '';
    } else {
      return WX_API_TOKEN || '';
    }
  }
  exports2.getWxCloudApiToken = getWxCloudApiToken;
});

// node_modules/@cloudbase/signature-nodejs/lib/utils.lang.js
var require_utils_lang = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  function isNumber(v) {
    return v === +v;
  }
  exports2.isNumber = isNumber;
  function isString(v) {
    return typeof v === 'string';
  }
  exports2.isString = isString;
  function isObject(v) {
    return v != null && typeof v === 'object' && Array.isArray(v) === false;
  }
  exports2.isObject = isObject;
  function isPlainObject(v) {
    return (
      isObject(v) && [null, Object.prototype].includes(Object.getPrototypeOf(v))
    );
  }
  exports2.isPlainObject = isPlainObject;
});

// node_modules/@cloudbase/signature-nodejs/lib/keyvalue.js
var require_keyvalue = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var utils_lang_1 = require_utils_lang();
  var SortedKeyValue = class {
    constructor(obj, selectkeys) {
      this._keys = [];
      this._values = [];
      this._pairs = [];
      this._obj = {};
      if (!utils_lang_1.isObject(obj)) {
        return this;
      }
      Object.keys(obj || {})
        .sort((l, r) => {
          return l.toString().localeCompare(r);
        })
        .forEach((key) => {
          if (!selectkeys || selectkeys.includes(key)) {
            this._keys.push(key);
            this._values.push(obj[key]);
            this._pairs.push([key, obj[key]]);
            this._obj[key.toLowerCase()] = obj[key];
          }
        });
    }
    static kv(obj, selectkeys) {
      return new SortedKeyValue(obj, selectkeys);
    }
    get(key) {
      return this._obj[key];
    }
    keys() {
      return this._keys;
    }
    values() {
      return this._values;
    }
    pairs() {
      return this._pairs;
    }
    toString(kvSeparator = '=', joinSeparator = '&') {
      return this._pairs
        .map((pair) => pair.join(kvSeparator))
        .join(joinSeparator);
    }
  };
  exports2.SortedKeyValue = SortedKeyValue;
});

// node_modules/@cloudbase/signature-nodejs/lib/utils.js
var require_utils7 = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var crypto = require('crypto');
  function formateDate(timestamp) {
    return new Date(timestamp * 1e3).toISOString().split('T')[0];
  }
  exports2.formateDate = formateDate;
  function second() {
    return Math.floor(new Date().getTime() / 1e3);
  }
  exports2.second = second;
  function stringify(v) {
    return typeof v !== 'string' ? JSON.stringify(v) : v;
  }
  exports2.stringify = stringify;
  function sha256hash(string, encoding = 'hex') {
    return crypto.createHash('sha256').update(string).digest(encoding);
  }
  exports2.sha256hash = sha256hash;
  function sha256hmac(string, secret = '', encoding) {
    return crypto.createHmac('sha256', secret).update(string).digest(encoding);
  }
  exports2.sha256hmac = sha256hmac;
  function isNodeEnv() {
    return process && process.release && process.release.name === 'node';
  }
  exports2.isNodeEnv = isNodeEnv;
});

// node_modules/is-stream/index.js
var require_is_stream = __commonJS((exports2, module2) => {
  'use strict';
  var isStream = (stream) =>
    stream !== null &&
    typeof stream === 'object' &&
    typeof stream.pipe === 'function';
  isStream.writable = (stream) =>
    isStream(stream) &&
    stream.writable !== false &&
    typeof stream._write === 'function' &&
    typeof stream._writableState === 'object';
  isStream.readable = (stream) =>
    isStream(stream) &&
    stream.readable !== false &&
    typeof stream._read === 'function' &&
    typeof stream._readableState === 'object';
  isStream.duplex = (stream) =>
    isStream.writable(stream) && isStream.readable(stream);
  isStream.transform = (stream) =>
    isStream.duplex(stream) &&
    typeof stream._transform === 'function' &&
    typeof stream._transformState === 'object';
  module2.exports = isStream;
});

// node_modules/@cloudbase/signature-nodejs/lib/signer.js
var require_signer2 = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var crypto = require('crypto');
  var utils_1 = require_utils7();
  var utils_lang_1 = require_utils_lang();
  var keyvalue_1 = require_keyvalue();
  var url_1 = require('url');
  var debug = require('util').debuglog('@cloudbase/signature');
  var isStream = require_is_stream();
  exports2.signedParamsSeparator = ';';
  var HOST_KEY = 'host';
  var CONTENT_TYPE_KEY = 'content-type';
  var MIME;
  (function (MIME2) {
    MIME2['MULTIPART_FORM_DATA'] = 'multipart/form-data';
    MIME2['APPLICATION_JSON'] = 'application/json';
  })(MIME || (MIME = {}));
  var Signer = class {
    constructor(credential, service, options = {}) {
      this.credential = credential;
      this.service = service;
      this.algorithm = 'TC3-HMAC-SHA256';
      this.options = options;
    }
    static camSafeUrlEncode(str) {
      return encodeURIComponent(str)
        .replace(/!/g, '%21')
        .replace(/'/g, '%27')
        .replace(/\(/g, '%28')
        .replace(/\)/g, '%29')
        .replace(/\*/g, '%2A');
    }
    static formatKeyAndValue(obj, options = {}) {
      if (!utils_lang_1.isPlainObject(obj)) {
        return obj;
      }
      const {
        multipart,
        enableValueToLowerCase = false,
        selectedKeys,
        filter,
      } = options;
      const kv = {};
      Object.keys(obj || {}).forEach((key) => {
        const lowercaseKey = Signer.camSafeUrlEncode(key.toLowerCase().trim());
        if (
          Array.isArray(selectedKeys) &&
          !selectedKeys.includes(lowercaseKey)
        ) {
          return;
        }
        if (typeof filter === 'function') {
          if (filter(key, obj[key], options)) {
            return;
          }
        }
        if (key && obj[key] !== void 0) {
          if (lowercaseKey === CONTENT_TYPE_KEY) {
            if (obj[key].startsWith(MIME.MULTIPART_FORM_DATA)) {
              kv[lowercaseKey] = MIME.MULTIPART_FORM_DATA;
            } else {
              kv[lowercaseKey] = obj[key];
            }
            return;
          }
          if (isStream(obj[key])) {
            return;
          } else if (utils_1.isNodeEnv() && Buffer.isBuffer(obj[key])) {
            if (multipart) {
              kv[lowercaseKey] = obj[key];
            } else {
              kv[lowercaseKey] = enableValueToLowerCase
                ? utils_1.stringify(obj[key]).trim().toLowerCase()
                : utils_1.stringify(obj[key]).trim();
            }
          } else {
            kv[lowercaseKey] = enableValueToLowerCase
              ? utils_1.stringify(obj[key]).trim().toLowerCase()
              : utils_1.stringify(obj[key]).trim();
          }
        }
      });
      return kv;
    }
    static calcParamsHash(params, keys = null, options = {}) {
      debug(params, 'calcParamsHash');
      if (utils_lang_1.isString(params)) {
        return utils_1.sha256hash(params);
      }
      keys = keys || keyvalue_1.SortedKeyValue.kv(params).keys();
      const hash = crypto.createHash('sha256');
      for (const key of keys) {
        if (!params[key]) {
          continue;
        }
        if (isStream(params[key])) {
          continue;
        }
        hash.update(`&${key}=`);
        hash.update(params[key]);
        hash.update('\r\n');
      }
      return hash.digest(options.encoding || 'hex');
    }
    tc3sign(method, url, headers, params, timestamp, options = {}) {
      timestamp = timestamp || utils_1.second();
      const urlInfo = url_1.parse(url);
      const formatedHeaders = Signer.formatKeyAndValue(headers, {
        enableValueToLowerCase: true,
      });
      const headerKV = keyvalue_1.SortedKeyValue.kv(formatedHeaders);
      const signedHeaders = headerKV.keys();
      const canonicalHeaders = headerKV.toString(':', '\n') + '\n';
      const { enableHostCheck = true, enableContentTypeCheck = true } = options;
      if (enableHostCheck && headerKV.get(HOST_KEY) !== urlInfo.host) {
        throw new TypeError(
          `host:${urlInfo.host} in url must be equals to host:${headerKV.get(
            'host',
          )} in headers`,
        );
      }
      if (enableContentTypeCheck && !headerKV.get(CONTENT_TYPE_KEY)) {
        throw new TypeError(`${CONTENT_TYPE_KEY} field must in headers`);
      }
      const multipart = headerKV
        .get(CONTENT_TYPE_KEY)
        .startsWith(MIME.MULTIPART_FORM_DATA);
      const formatedParams =
        method.toUpperCase() === 'GET'
          ? ''
          : Signer.formatKeyAndValue(params, {
              multipart,
            });
      const paramKV = keyvalue_1.SortedKeyValue.kv(formatedParams);
      const signedParams = paramKV.keys();
      const hashedPayload = Signer.calcParamsHash(formatedParams, null);
      const signedUrl = url.replace(/^https?:/, '').split('?')[0];
      const canonicalRequest = `${method}
${signedUrl}
${urlInfo.query || ''}
${canonicalHeaders}
${signedHeaders.join(';')}
${hashedPayload}`;
      debug(canonicalRequest, 'canonicalRequest\n\n');
      const date = utils_1.formateDate(timestamp);
      const service = this.service;
      const algorithm = this.algorithm;
      const credentialScope = `${date}/${service}/tc3_request`;
      const stringToSign = `${algorithm}
${timestamp}
${credentialScope}
${utils_1.sha256hash(canonicalRequest)}`;
      debug(stringToSign, 'stringToSign\n\n');
      const secretDate = utils_1.sha256hmac(
        date,
        `TC3${this.credential.secretKey}`,
      );
      const secretService = utils_1.sha256hmac(service, secretDate);
      const secretSigning = utils_1.sha256hmac('tc3_request', secretService);
      const signature = utils_1.sha256hmac(stringToSign, secretSigning, 'hex');
      debug(secretDate.toString('hex'), 'secretDate');
      debug(secretService.toString('hex'), 'secretService');
      debug(secretSigning.toString('hex'), 'secretSigning');
      debug(signature, 'signature');
      const { withSignedParams = false } = options;
      return {
        authorization: `${algorithm} Credential=${
          this.credential.secretId
        }/${credentialScope},${
          withSignedParams ? ` SignedParams=${signedParams.join(';')},` : ''
        } SignedHeaders=${signedHeaders.join(';')}, Signature=${signature}`,
        signedParams,
        signedHeaders,
        signature,
        timestamp,
        multipart,
      };
    }
  };
  exports2.Signer = Signer;
});

// node_modules/@cloudbase/signature-nodejs/lib/utils.http.js
var require_utils_http = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var utils_1 = require_utils7();
  var utils_lang_1 = require_utils_lang();
  var isStream = require_is_stream();
  function canUseFormdata(data) {
    let enable = true;
    for (const key in data) {
      const value = data[key];
      if (
        !isStream(value) &&
        utils_1.isNodeEnv() &&
        !Buffer.isBuffer(value) &&
        !utils_lang_1.isString(value) &&
        !utils_lang_1.isNumber(value)
      ) {
        enable = false;
        break;
      }
    }
    return enable;
  }
  exports2.canUseFormdata = canUseFormdata;
  function mustUseFormdata(data) {
    let must = false;
    for (const key in data) {
      const value = data[key];
      if ((utils_1.isNodeEnv() && Buffer.isBuffer(value)) || isStream(value)) {
        must = true;
        break;
      }
    }
    return must;
  }
  exports2.mustUseFormdata = mustUseFormdata;
});

// node_modules/clone/clone.js
var require_clone = __commonJS((exports2, module2) => {
  var clone = (function () {
    'use strict';
    function _instanceof(obj, type) {
      return type != null && obj instanceof type;
    }
    var nativeMap;
    try {
      nativeMap = Map;
    } catch (_2) {
      nativeMap = function () {};
    }
    var nativeSet;
    try {
      nativeSet = Set;
    } catch (_2) {
      nativeSet = function () {};
    }
    var nativePromise;
    try {
      nativePromise = Promise;
    } catch (_2) {
      nativePromise = function () {};
    }
    function clone2(parent, circular, depth, prototype, includeNonEnumerable) {
      if (typeof circular === 'object') {
        depth = circular.depth;
        prototype = circular.prototype;
        includeNonEnumerable = circular.includeNonEnumerable;
        circular = circular.circular;
      }
      var allParents = [];
      var allChildren = [];
      var useBuffer = typeof Buffer != 'undefined';
      if (typeof circular == 'undefined') circular = true;
      if (typeof depth == 'undefined') depth = Infinity;
      function _clone(parent2, depth2) {
        if (parent2 === null) return null;
        if (depth2 === 0) return parent2;
        var child;
        var proto;
        if (typeof parent2 != 'object') {
          return parent2;
        }
        if (_instanceof(parent2, nativeMap)) {
          child = new nativeMap();
        } else if (_instanceof(parent2, nativeSet)) {
          child = new nativeSet();
        } else if (_instanceof(parent2, nativePromise)) {
          child = new nativePromise(function (resolve, reject) {
            parent2.then(
              function (value) {
                resolve(_clone(value, depth2 - 1));
              },
              function (err) {
                reject(_clone(err, depth2 - 1));
              },
            );
          });
        } else if (clone2.__isArray(parent2)) {
          child = [];
        } else if (clone2.__isRegExp(parent2)) {
          child = new RegExp(parent2.source, __getRegExpFlags(parent2));
          if (parent2.lastIndex) child.lastIndex = parent2.lastIndex;
        } else if (clone2.__isDate(parent2)) {
          child = new Date(parent2.getTime());
        } else if (useBuffer && Buffer.isBuffer(parent2)) {
          if (Buffer.allocUnsafe) {
            child = Buffer.allocUnsafe(parent2.length);
          } else {
            child = new Buffer(parent2.length);
          }
          parent2.copy(child);
          return child;
        } else if (_instanceof(parent2, Error)) {
          child = Object.create(parent2);
        } else {
          if (typeof prototype == 'undefined') {
            proto = Object.getPrototypeOf(parent2);
            child = Object.create(proto);
          } else {
            child = Object.create(prototype);
            proto = prototype;
          }
        }
        if (circular) {
          var index = allParents.indexOf(parent2);
          if (index != -1) {
            return allChildren[index];
          }
          allParents.push(parent2);
          allChildren.push(child);
        }
        if (_instanceof(parent2, nativeMap)) {
          parent2.forEach(function (value, key) {
            var keyChild = _clone(key, depth2 - 1);
            var valueChild = _clone(value, depth2 - 1);
            child.set(keyChild, valueChild);
          });
        }
        if (_instanceof(parent2, nativeSet)) {
          parent2.forEach(function (value) {
            var entryChild = _clone(value, depth2 - 1);
            child.add(entryChild);
          });
        }
        for (var i in parent2) {
          var attrs;
          if (proto) {
            attrs = Object.getOwnPropertyDescriptor(proto, i);
          }
          if (attrs && attrs.set == null) {
            continue;
          }
          child[i] = _clone(parent2[i], depth2 - 1);
        }
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(parent2);
          for (var i = 0; i < symbols.length; i++) {
            var symbol = symbols[i];
            var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol);
            if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
              continue;
            }
            child[symbol] = _clone(parent2[symbol], depth2 - 1);
            if (!descriptor.enumerable) {
              Object.defineProperty(child, symbol, {
                enumerable: false,
              });
            }
          }
        }
        if (includeNonEnumerable) {
          var allPropertyNames = Object.getOwnPropertyNames(parent2);
          for (var i = 0; i < allPropertyNames.length; i++) {
            var propertyName = allPropertyNames[i];
            var descriptor = Object.getOwnPropertyDescriptor(
              parent2,
              propertyName,
            );
            if (descriptor && descriptor.enumerable) {
              continue;
            }
            child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
            Object.defineProperty(child, propertyName, {
              enumerable: false,
            });
          }
        }
        return child;
      }
      return _clone(parent, depth);
    }
    clone2.clonePrototype = function clonePrototype(parent) {
      if (parent === null) return null;
      var c = function () {};
      c.prototype = parent;
      return new c();
    };
    function __objToStr(o) {
      return Object.prototype.toString.call(o);
    }
    clone2.__objToStr = __objToStr;
    function __isDate(o) {
      return typeof o === 'object' && __objToStr(o) === '[object Date]';
    }
    clone2.__isDate = __isDate;
    function __isArray(o) {
      return typeof o === 'object' && __objToStr(o) === '[object Array]';
    }
    clone2.__isArray = __isArray;
    function __isRegExp(o) {
      return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
    }
    clone2.__isRegExp = __isRegExp;
    function __getRegExpFlags(re) {
      var flags = '';
      if (re.global) flags += 'g';
      if (re.ignoreCase) flags += 'i';
      if (re.multiline) flags += 'm';
      return flags;
    }
    clone2.__getRegExpFlags = __getRegExpFlags;
    return clone2;
  })();
  if (typeof module2 === 'object' && module2.exports) {
    module2.exports = clone;
  }
});

// node_modules/@cloudbase/signature-nodejs/lib/index.js
var require_lib6 = __commonJS((exports2) => {
  'use strict';
  function __export(m) {
    for (var p in m) if (!exports2.hasOwnProperty(p)) exports2[p] = m[p];
  }
  Object.defineProperty(exports2, '__esModule', { value: true });
  __export(require_keyvalue());
  __export(require_signer2());
  __export(require_utils_http());
  __export(require_utils_lang());
  __export(require_utils7());
  var signer_1 = require_signer2();
  var utils_1 = require_utils7();
  var clone = require_clone();
  function sign(options) {
    const { secretId, secretKey, method, url } = options;
    const signer = new signer_1.Signer({ secretId, secretKey }, 'tcb');
    const headers = clone(options.headers || {});
    const params = clone(options.params || {});
    const timestamp = options.timestamp || utils_1.second() - 1;
    const signatureInfo = signer.tc3sign(
      method,
      url,
      headers,
      params,
      timestamp,
      {
        withSignedParams: options.withSignedParams,
      },
    );
    return {
      authorization: signatureInfo.authorization,
      timestamp: signatureInfo.timestamp,
      multipart: signatureInfo.multipart,
    };
  }
  exports2.sign = sign;
});

// node_modules/@cloudbase/node-sdk/lib/utils/secretManager.js
var require_secretManager = __commonJS((exports2) => {
  'use strict';
  var __importDefault =
    (exports2 && exports2.__importDefault) ||
    function (mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
  Object.defineProperty(exports2, '__esModule', { value: true });
  var request_1 = __importDefault(require_request3());
  var SecretManager = class {
    constructor() {
      this.TMP_SECRET_URL =
        'http://metadata.tencentyun.com/meta-data/cam/security-credentials/TCB_QcsRole';
      this.tmpSecret = null;
    }
    async getTmpSecret() {
      if (this.tmpSecret) {
        const now2 = new Date().getTime();
        const expire = this.tmpSecret.expire * 1e3;
        const oneHour = 3600 * 1e3;
        if (now2 < expire - oneHour) {
          return this.tmpSecret;
        } else {
          return this.fetchTmpSecret();
        }
      } else {
        return this.fetchTmpSecret();
      }
    }
    async fetchTmpSecret() {
      const body = await this.get(this.TMP_SECRET_URL);
      const payload = JSON.parse(body);
      this.tmpSecret = {
        id: payload.TmpSecretId,
        key: payload.TmpSecretKey,
        expire: payload.ExpiredTime,
        token: payload.Token,
      };
      return this.tmpSecret;
    }
    get(url) {
      return new Promise((resolve, reject) => {
        request_1.default.get(url, (err, res, body) => {
          if (err) {
            reject(err);
          } else {
            resolve(body);
          }
        });
      });
    }
  };
  exports2.default = SecretManager;
});

// node_modules/@cloudbase/node-sdk/package.json
var require_package = __commonJS((exports2, module2) => {
  module2.exports = {
    name: '@cloudbase/node-sdk',
    version: '2.5.0',
    description: 'tencent cloud base server sdk for node.js',
    main: 'lib/index.js',
    scripts: {
      eslint: 'eslint "./**/*.ts"',
      'eslint-fix': 'eslint --fix "./**/*.ts"',
      build: 'rm -rf lib/* && npm run tsc',
      tsc: 'tsc -p tsconfig.json',
      'tsc:w': 'tsc -p tsconfig.json -w',
      tstest:
        'mocha --timeout 5000 --require espower-typescript/guess test/**/*.test.ts',
      test: 'jest  --detectOpenHandles --verbose --coverage --runInBand',
      coverage: 'jest --detectOpenHandles --coverage',
      coveralls: 'cat ./coverage/lcov.info | coveralls',
    },
    repository: {
      type: 'git',
      url: 'https://github.com/TencentCloudBase/node-sdk',
    },
    bugs: {
      url: 'https://github.com/TencentCloudBase/node-sdk/issues',
    },
    homepage: 'https://github.com/TencentCloudBase/node-sdk#readme',
    keywords: ['node sdk'],
    author: 'lukejyhuang',
    license: 'MIT',
    typings: 'types/index.d.ts',
    dependencies: {
      '@cloudbase/database': '1.2.2',
      '@cloudbase/signature-nodejs': '1.0.0-beta.0',
      '@types/retry': '^0.12.0',
      agentkeepalive: '^4.1.3',
      'is-regex': '^1.0.4',
      jsonwebtoken: '^8.5.1',
      'lodash.merge': '^4.6.1',
      request: '^2.87.0',
      'request-promise': '^4.2.5',
      retry: '^0.12.0',
      'ts-node': '^8.10.2',
      xml2js: '^0.4.19',
    },
    devDependencies: {
      '@types/jest': '^23.1.4',
      '@types/mocha': '^5.2.4',
      '@types/node': '^10.12.12',
      '@typescript-eslint/eslint-plugin': '^2.16.0',
      '@typescript-eslint/parser': '^2.16.0',
      'babel-eslint': '^10.0.3',
      coveralls: '^3.0.9',
      'dumper.js': '^1.3.0',
      eslint: '^7.1.0',
      'eslint-config-alloy': '^3.5.0',
      'eslint-plugin-prettier': '^3.1.2',
      husky: '^3.1.0',
      jest: '^23.3.0',
      'lint-staged': '^9.2.5',
      mocha: '^5.2.0',
      'power-assert': '^1.5.0',
      prettier: '^1.19.1',
      'ts-jest': '^23.10.4',
      tslib: '^1.7.1',
      typescript: '3.5.3',
    },
    engines: {
      node: '>=8.6.0',
    },
    husky: {
      hooks: {
        'pre-commit': 'npm run build && git add . && lint-staged',
      },
    },
    'lint-staged': {
      '*.ts': ['eslint --fix', 'git add'],
    },
  };
});

// node_modules/@cloudbase/node-sdk/lib/utils/httpRequest.js
var require_httpRequest = __commonJS((exports2) => {
  'use strict';
  var __importDefault =
    (exports2 && exports2.__importDefault) ||
    function (mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
  var __importStar =
    (exports2 && exports2.__importStar) ||
    function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
      }
      result['default'] = mod;
      return result;
    };
  Object.defineProperty(exports2, '__esModule', { value: true });
  var http_1 = __importDefault(require('http'));
  var tracing_1 = require_tracing();
  var utils = __importStar(require_utils3());
  var code_1 = require_code3();
  var symbol_1 = require_symbol4();
  var cloudbase_1 = require_cloudbase();
  var request_1 = require_request4();
  var requestHook_1 = require_requestHook();
  var getWxCloudApiToken_1 = require_getWxCloudApiToken();
  var signature_nodejs_1 = require_lib6();
  var url_1 = __importDefault(require('url'));
  var secretManager_1 = __importDefault(require_secretManager());
  var { version } = require_package();
  var { E, second, processReturn, getServerInjectUrl } = utils;
  var Request = class {
    constructor(args) {
      this.urlPath = '/admin';
      this.defaultTimeout = 15e3;
      this.timestamp = new Date().valueOf();
      this.tracingInfo = tracing_1.generateTracingInfo();
      this.slowWarnTimer = null;
      this.hooks = {};
      this.args = args;
      this.config = args.config;
      this.opts = args.opts || {};
      this.secretManager = new secretManager_1.default();
    }
    async request() {
      await this.validateSecretIdAndKey();
      const params = await this.makeParams();
      const opts = await this.makeReqOpts(params);
      const action = this.getAction();
      const key = {
        functions: 'function_name',
        database: 'collectionName',
        wx: 'apiName',
      }[action.split('.')[0]];
      const argopts = this.opts;
      const config = this.config;
      if (!params.envName) {
        if (config.envName) {
          return processReturn(
            config.throwOnCode,
            Object.assign({}, code_1.ERROR.INVALID_PARAM, {
              message: '\u672A\u53D6\u5230init \u6307\u5B9A env\uFF01',
            }),
          );
        } else {
          console.warn(
            `\u5F53\u524D\u672A\u6307\u5B9Aenv\uFF0C\u5C06\u9ED8\u8BA4\u4F7F\u7528\u7B2C\u4E00\u4E2A\u521B\u5EFA\u7684\u73AF\u5883\uFF01`,
          );
        }
      }
      let retryOptions = null;
      if (argopts.retryOptions) {
        retryOptions = argopts.retryOptions;
      } else if (config.retries && typeof config.retries === 'number') {
        retryOptions = { retries: config.retries };
      }
      return request_1
        .extraRequest(opts, {
          debug: config.debug,
          op: `${action}:${this.args.params[key]}@${params.envName}`,
          seqId: this.getSeqId(),
          retryOptions,
          timingsMeasurerOptions: config.timingsMeasurerOptions || {},
        })
        .then((response) => {
          this.slowWarnTimer && clearTimeout(this.slowWarnTimer);
          const { body } = response;
          if (response.statusCode === 200) {
            let res;
            try {
              res = typeof body === 'string' ? JSON.parse(body) : body;
              if (this.hooks && this.hooks.handleData) {
                res = this.hooks.handleData(res, null, response, body);
              }
            } catch (e) {
              res = body;
            }
            return res;
          } else {
            const e = E({
              code: response.statusCode,
              message: ` ${response.statusCode} ${
                http_1.default.STATUS_CODES[response.statusCode]
              } | [${opts.url}]`,
            });
            throw e;
          }
        });
    }
    setHooks(hooks) {
      Object.assign(this.hooks, hooks);
    }
    getSeqId() {
      return this.tracingInfo.seqId;
    }
    getAction() {
      const { params } = this.args;
      const { action } = params;
      return action;
    }
    setSlowWarning(timeout) {
      const action = this.getAction();
      const { seqId } = this.tracingInfo;
      this.slowWarnTimer = setTimeout(() => {
        const msg = `Your current request ${
          action || ''
        } is longer than 3s, it may be due to the network or your query performance | [${seqId}]`;
        console.warn(msg);
      }, timeout);
    }
    async makeParams() {
      const {
        TCB_SESSIONTOKEN,
        TCB_ENV,
        SCF_NAMESPACE,
      } = cloudbase_1.CloudBase.getCloudbaseContext();
      const args = this.args;
      const opts = this.opts;
      const config = this.config;
      const { eventId } = this.tracingInfo;
      let crossAuthorizationData =
        opts.getCrossAccountInfo &&
        (await opts.getCrossAccountInfo()).authorization;
      const params = Object.assign({}, args.params, {
        envName: config.envName,
        eventId,
        wxCloudApiToken: getWxCloudApiToken_1.getWxCloudApiToken(),
        tcb_sessionToken: TCB_SESSIONTOKEN || '',
        sessionToken: config.sessionToken,
        sdk_version: version,
        crossAuthorizationToken: crossAuthorizationData
          ? Buffer.from(JSON.stringify(crossAuthorizationData)).toString(
              'base64',
            )
          : '',
      });
      if (params.envName === symbol_1.SYMBOL_CURRENT_ENV) {
        params.envName = TCB_ENV || SCF_NAMESPACE;
      }
      utils.filterUndefined(params);
      return params;
    }
    async makeReqOpts(params) {
      const config = this.config;
      const args = this.args;
      const url = this.getUrl();
      const method = this.getMethod();
      const opts = {
        url,
        method,
        timeout: this.getTimeout(),
        headers: await this.getHeaders(params),
        proxy: config.proxy,
      };
      opts.keepalive = config.keepalive === true;
      if (args.method === 'post') {
        if (args.isFormData) {
          opts.formData = params;
          opts.encoding = null;
        } else {
          opts.body = params;
          opts.json = true;
        }
      } else {
        opts.qs = params;
      }
      return opts;
    }
    getProtocol() {
      return this.config.isHttp === true ? 'http' : 'https';
    }
    getMethod() {
      return this.args.method || 'get';
    }
    getTimeout() {
      const { opts = {} } = this.args;
      return opts.timeout || this.config.timeout || this.defaultTimeout;
    }
    async validateSecretIdAndKey() {
      const {
        TENCENTCLOUD_SECRETID,
        TENCENTCLOUD_SECRETKEY,
        TENCENTCLOUD_SESSIONTOKEN,
      } = cloudbase_1.CloudBase.getCloudbaseContext();
      const isInSCF = utils.checkIsInScf();
      const isInContainer = utils.checkIsInContainer();
      let opts = this.opts;
      let getCrossAccountInfo =
        opts.getCrossAccountInfo || this.config.getCrossAccountInfo;
      if (getCrossAccountInfo) {
        let crossAccountInfo = await getCrossAccountInfo();
        let { credential } = await getCrossAccountInfo();
        let { secretId, secretKey, token } = credential || {};
        this.config = Object.assign({}, this.config, {
          secretId,
          secretKey,
          sessionToken: token,
        });
        this.opts.getCrossAccountInfo = () => Promise.resolve(crossAccountInfo);
        if (!this.config.secretId || !this.config.secretKey) {
          throw E(
            Object.assign({}, code_1.ERROR.INVALID_PARAM, {
              message: 'missing secretId or secretKey of tencent cloud',
            }),
          );
        }
      } else {
        const { secretId, secretKey } = this.config;
        if (!secretId || !secretKey) {
          if (isInContainer) {
            const tmpSecret = await this.secretManager.getTmpSecret();
            this.config = Object.assign({}, this.config, {
              secretId: tmpSecret.id,
              secretKey: tmpSecret.key,
              sessionToken: tmpSecret.token,
            });
            return;
          }
          if (!TENCENTCLOUD_SECRETID || !TENCENTCLOUD_SECRETKEY) {
            if (isInSCF) {
              throw E(
                Object.assign({}, code_1.ERROR.INVALID_PARAM, {
                  message: 'missing authoration key, redeploy the function',
                }),
              );
            } else {
              throw E(
                Object.assign({}, code_1.ERROR.INVALID_PARAM, {
                  message: 'missing secretId or secretKey of tencent cloud',
                }),
              );
            }
          } else {
            this.config = Object.assign({}, this.config, {
              secretId: TENCENTCLOUD_SECRETID,
              secretKey: TENCENTCLOUD_SECRETKEY,
              sessionToken: TENCENTCLOUD_SESSIONTOKEN,
            });
          }
        }
      }
    }
    async getHeaders(params) {
      let { TCB_SOURCE } = cloudbase_1.CloudBase.getCloudbaseContext();
      const config = this.config;
      const { secretId, secretKey } = config;
      const args = this.args;
      const method = this.getMethod();
      const isInSCF = utils.checkIsInScf();
      TCB_SOURCE = TCB_SOURCE || '';
      const SOURCE = isInSCF ? `${TCB_SOURCE},scf` : ',not_scf';
      const url = this.getUrl();
      let requiredHeaders = {
        'User-Agent': `tcb-node-sdk/${version}`,
        'x-tcb-source': SOURCE,
        'x-client-timestamp': this.timestamp,
        'X-SDK-Version': `tcb-node-sdk/${version}`,
        Host: url_1.default.parse(url).host,
      };
      if (config.version) {
        requiredHeaders['X-SDK-Version'] = config.version;
      }
      if (this.tracingInfo.trace) {
        requiredHeaders['x-tcb-tracelog'] = this.tracingInfo.trace;
      }
      const region =
        this.config.region || process.env.TENCENTCLOUD_REGION || '';
      if (region) {
        requiredHeaders['X-TCB-Region'] = region;
      }
      requiredHeaders = Object.assign(
        {},
        config.headers,
        args.headers,
        requiredHeaders,
      );
      const { authorization, timestamp } = signature_nodejs_1.sign({
        secretId,
        secretKey,
        method,
        url,
        params: await this.makeParams(),
        headers: requiredHeaders,
        withSignedParams: true,
        timestamp: second() - 1,
      });
      requiredHeaders['Authorization'] = authorization;
      requiredHeaders['X-Signature-Expires'] = 600;
      requiredHeaders['X-Timestamp'] = timestamp;
      return Object.assign({}, requiredHeaders);
    }
    getUrl() {
      const isInSCF = utils.checkIsInScf();
      const isInternal = utils.checkIsInternal();
      const { eventId, seqId } = this.tracingInfo;
      const { serviceUrl } = this.config;
      const serverInjectUrl = getServerInjectUrl();
      if (isInSCF) {
        if (!process.env.TENCENTCLOUD_REGION) {
          console.error('[ERROR] missing `TENCENTCLOUD_REGION` environment');
        }
        if (!process.env.SCF_NAMESPACE) {
          console.error('[ERROR] missing `SCF_NAMESPACE` environment');
        }
      }
      const {
        TCB_ENV,
        SCF_NAMESPACE,
      } = cloudbase_1.CloudBase.getCloudbaseContext();
      const region =
        this.config.region || process.env.TENCENTCLOUD_REGION || '';
      const envId =
        this.config.envName === symbol_1.SYMBOL_CURRENT_ENV
          ? TCB_ENV || SCF_NAMESPACE
          : this.config.envName || '';
      const internetRegionEndpoint = region
        ? `${region}.tcb-api.tencentcloudapi.com`
        : `tcb-api.tencentcloudapi.com`;
      const internalRegionEndpoint = region
        ? `internal.${region}.tcb-api.tencentcloudapi.com`
        : `internal.tcb-api.tencentcloudapi.com`;
      const isSameRegionVisit = this.config.region
        ? this.config.region === process.env.TENCENTCLOUD_REGION
        : true;
      const endpoint =
        isSameRegionVisit && isInternal
          ? internalRegionEndpoint
          : internetRegionEndpoint;
      const envEndpoint = envId ? `${envId}.${endpoint}` : endpoint;
      const protocol = isInternal ? 'http' : this.getProtocol();
      const defaultUrl = `${protocol}://${envEndpoint}${this.urlPath}`;
      const url = serviceUrl || serverInjectUrl || defaultUrl;
      const qs = cloudbase_1.CloudBase.scfContext
        ? `&eventId=${eventId}&seqId=${seqId}&scfRequestId=${cloudbase_1.CloudBase.scfContext.requestId}`
        : `&eventId=${eventId}&seqId=${seqId}`;
      return url.includes('?') ? `${url}${qs}` : `${url}?${qs}`;
    }
  };
  exports2.Request = Request;
  exports2.default = async (args) => {
    const req = new Request(args);
    const config = args.config;
    const { action } = args.params;
    if (action === 'wx.openApi' || action === 'wx.wxPayApi') {
      req.setHooks({ handleData: requestHook_1.handleWxOpenApiData });
    }
    if (action.startsWith('database')) {
      req.setSlowWarning(3e3);
    }
    try {
      const res = await req.request();
      if (res && res.code) {
        return processReturn(config.throwOnCode, res);
      }
      return res;
    } finally {
    }
  };
});

// node_modules/@cloudbase/node-sdk/lib/functions/index.js
var require_functions = __commonJS((exports2) => {
  'use strict';
  var __importDefault =
    (exports2 && exports2.__importDefault) ||
    function (mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
  Object.defineProperty(exports2, '__esModule', { value: true });
  var httpRequest_1 = __importDefault(require_httpRequest());
  var utils_1 = require_utils3();
  var code_1 = require_code3();
  var cloudbase_1 = require_cloudbase();
  async function callFunction(cloudbase2, { name, data }, opts) {
    const { TCB_ROUTE_KEY } = cloudbase_1.CloudBase.getCloudbaseContext();
    let transformData;
    try {
      transformData = data ? JSON.stringify(data) : '';
    } catch (e) {
      throw utils_1.E(
        Object.assign({}, e, {
          code: code_1.ERROR.INVALID_PARAM.code,
          message: '\u5BF9\u8C61\u51FA\u73B0\u4E86\u5FAA\u73AF\u5F15\u7528',
        }),
      );
    }
    if (!name) {
      throw utils_1.E(
        Object.assign({}, code_1.ERROR.INVALID_PARAM, {
          message: '\u51FD\u6570\u540D\u4E0D\u80FD\u4E3A\u7A7A',
        }),
      );
    }
    const params = {
      action: 'functions.invokeFunction',
      function_name: name,
      request_data: transformData,
    };
    return httpRequest_1
      .default({
        config: cloudbase2.config,
        params,
        method: 'post',
        opts,
        headers: Object.assign(
          { 'content-type': 'application/json' },
          TCB_ROUTE_KEY ? { 'X-Tcb-Route-Key': TCB_ROUTE_KEY } : {},
        ),
      })
      .then((res) => {
        if (res.code) {
          return res;
        }
        let result;
        try {
          result = JSON.parse(res.data.response_data);
        } catch (e) {
          result = res.data.response_data;
        }
        return {
          result,
          requestId: res.requestId,
        };
      });
  }
  exports2.callFunction = callFunction;
});

// node_modules/jws/lib/data-stream.js
var require_data_stream = __commonJS((exports2, module2) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var Stream = require('stream');
  var util = require('util');
  function DataStream(data) {
    this.buffer = null;
    this.writable = true;
    this.readable = true;
    if (!data) {
      this.buffer = Buffer2.alloc(0);
      return this;
    }
    if (typeof data.pipe === 'function') {
      this.buffer = Buffer2.alloc(0);
      data.pipe(this);
      return this;
    }
    if (data.length || typeof data === 'object') {
      this.buffer = data;
      this.writable = false;
      process.nextTick(
        function () {
          this.emit('end', data);
          this.readable = false;
          this.emit('close');
        }.bind(this),
      );
      return this;
    }
    throw new TypeError('Unexpected data type (' + typeof data + ')');
  }
  util.inherits(DataStream, Stream);
  DataStream.prototype.write = function write(data) {
    this.buffer = Buffer2.concat([this.buffer, Buffer2.from(data)]);
    this.emit('data', data);
  };
  DataStream.prototype.end = function end(data) {
    if (data) this.write(data);
    this.emit('end', data);
    this.emit('close');
    this.writable = false;
    this.readable = false;
  };
  module2.exports = DataStream;
});

// node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = __commonJS((exports2, module2) => {
  'use strict';
  var Buffer2 = require('buffer').Buffer;
  var SlowBuffer = require('buffer').SlowBuffer;
  module2.exports = bufferEq;
  function bufferEq(a, b) {
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    var c = 0;
    for (var i = 0; i < a.length; i++) {
      c |= a[i] ^ b[i];
    }
    return c === 0;
  }
  bufferEq.install = function () {
    Buffer2.prototype.equal = SlowBuffer.prototype.equal = function equal(
      that,
    ) {
      return bufferEq(this, that);
    };
  };
  var origBufEqual = Buffer2.prototype.equal;
  var origSlowBufEqual = SlowBuffer.prototype.equal;
  bufferEq.restore = function () {
    Buffer2.prototype.equal = origBufEqual;
    SlowBuffer.prototype.equal = origSlowBufEqual;
  };
});

// node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS((exports2, module2) => {
  'use strict';
  function getParamSize(keySize) {
    var result = ((keySize / 8) | 0) + (keySize % 8 === 0 ? 0 : 1);
    return result;
  }
  var paramBytesForAlg = {
    ES256: getParamSize(256),
    ES384: getParamSize(384),
    ES512: getParamSize(521),
  };
  function getParamBytesForAlg(alg) {
    var paramBytes = paramBytesForAlg[alg];
    if (paramBytes) {
      return paramBytes;
    }
    throw new Error('Unknown algorithm "' + alg + '"');
  }
  module2.exports = getParamBytesForAlg;
});

// node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS((exports2, module2) => {
  'use strict';
  var Buffer2 = require_safe_buffer().Buffer;
  var getParamBytesForAlg = require_param_bytes_for_alg();
  var MAX_OCTET = 128;
  var CLASS_UNIVERSAL = 0;
  var PRIMITIVE_BIT = 32;
  var TAG_SEQ = 16;
  var TAG_INT = 2;
  var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | (CLASS_UNIVERSAL << 6);
  var ENCODED_TAG_INT = TAG_INT | (CLASS_UNIVERSAL << 6);
  function base64Url(base64) {
    return base64.replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
  }
  function signatureAsBuffer(signature) {
    if (Buffer2.isBuffer(signature)) {
      return signature;
    } else if (typeof signature === 'string') {
      return Buffer2.from(signature, 'base64');
    }
    throw new TypeError('ECDSA signature must be a Base64 string or a Buffer');
  }
  function derToJose(signature, alg) {
    signature = signatureAsBuffer(signature);
    var paramBytes = getParamBytesForAlg(alg);
    var maxEncodedParamLength = paramBytes + 1;
    var inputLength = signature.length;
    var offset = 0;
    if (signature[offset++] !== ENCODED_TAG_SEQ) {
      throw new Error('Could not find expected "seq"');
    }
    var seqLength = signature[offset++];
    if (seqLength === (MAX_OCTET | 1)) {
      seqLength = signature[offset++];
    }
    if (inputLength - offset < seqLength) {
      throw new Error(
        '"seq" specified length of "' +
          seqLength +
          '", only "' +
          (inputLength - offset) +
          '" remaining',
      );
    }
    if (signature[offset++] !== ENCODED_TAG_INT) {
      throw new Error('Could not find expected "int" for "r"');
    }
    var rLength = signature[offset++];
    if (inputLength - offset - 2 < rLength) {
      throw new Error(
        '"r" specified length of "' +
          rLength +
          '", only "' +
          (inputLength - offset - 2) +
          '" available',
      );
    }
    if (maxEncodedParamLength < rLength) {
      throw new Error(
        '"r" specified length of "' +
          rLength +
          '", max of "' +
          maxEncodedParamLength +
          '" is acceptable',
      );
    }
    var rOffset = offset;
    offset += rLength;
    if (signature[offset++] !== ENCODED_TAG_INT) {
      throw new Error('Could not find expected "int" for "s"');
    }
    var sLength = signature[offset++];
    if (inputLength - offset !== sLength) {
      throw new Error(
        '"s" specified length of "' +
          sLength +
          '", expected "' +
          (inputLength - offset) +
          '"',
      );
    }
    if (maxEncodedParamLength < sLength) {
      throw new Error(
        '"s" specified length of "' +
          sLength +
          '", max of "' +
          maxEncodedParamLength +
          '" is acceptable',
      );
    }
    var sOffset = offset;
    offset += sLength;
    if (offset !== inputLength) {
      throw new Error(
        'Expected to consume entire buffer, but "' +
          (inputLength - offset) +
          '" bytes remain',
      );
    }
    var rPadding = paramBytes - rLength,
      sPadding = paramBytes - sLength;
    var dst = Buffer2.allocUnsafe(rPadding + rLength + sPadding + sLength);
    for (offset = 0; offset < rPadding; ++offset) {
      dst[offset] = 0;
    }
    signature.copy(
      dst,
      offset,
      rOffset + Math.max(-rPadding, 0),
      rOffset + rLength,
    );
    offset = paramBytes;
    for (var o = offset; offset < o + sPadding; ++offset) {
      dst[offset] = 0;
    }
    signature.copy(
      dst,
      offset,
      sOffset + Math.max(-sPadding, 0),
      sOffset + sLength,
    );
    dst = dst.toString('base64');
    dst = base64Url(dst);
    return dst;
  }
  function countPadding(buf, start, stop) {
    var padding = 0;
    while (start + padding < stop && buf[start + padding] === 0) {
      ++padding;
    }
    var needsSign = buf[start + padding] >= MAX_OCTET;
    if (needsSign) {
      --padding;
    }
    return padding;
  }
  function joseToDer(signature, alg) {
    signature = signatureAsBuffer(signature);
    var paramBytes = getParamBytesForAlg(alg);
    var signatureBytes = signature.length;
    if (signatureBytes !== paramBytes * 2) {
      throw new TypeError(
        '"' +
          alg +
          '" signatures must be "' +
          paramBytes * 2 +
          '" bytes, saw "' +
          signatureBytes +
          '"',
      );
    }
    var rPadding = countPadding(signature, 0, paramBytes);
    var sPadding = countPadding(signature, paramBytes, signature.length);
    var rLength = paramBytes - rPadding;
    var sLength = paramBytes - sPadding;
    var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
    var shortLength = rsBytes < MAX_OCTET;
    var dst = Buffer2.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
    var offset = 0;
    dst[offset++] = ENCODED_TAG_SEQ;
    if (shortLength) {
      dst[offset++] = rsBytes;
    } else {
      dst[offset++] = MAX_OCTET | 1;
      dst[offset++] = rsBytes & 255;
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = rLength;
    if (rPadding < 0) {
      dst[offset++] = 0;
      offset += signature.copy(dst, offset, 0, paramBytes);
    } else {
      offset += signature.copy(dst, offset, rPadding, paramBytes);
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = sLength;
    if (sPadding < 0) {
      dst[offset++] = 0;
      signature.copy(dst, offset, paramBytes);
    } else {
      signature.copy(dst, offset, paramBytes + sPadding);
    }
    return dst;
  }
  module2.exports = {
    derToJose,
    joseToDer,
  };
});

// node_modules/jwa/index.js
var require_jwa = __commonJS((exports2, module2) => {
  var bufferEqual = require_buffer_equal_constant_time();
  var Buffer2 = require_safe_buffer().Buffer;
  var crypto = require('crypto');
  var formatEcdsa = require_ecdsa_sig_formatter();
  var util = require('util');
  var MSG_INVALID_ALGORITHM =
    '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
  var MSG_INVALID_SECRET = 'secret must be a string or buffer';
  var MSG_INVALID_VERIFIER_KEY = 'key must be a string or a buffer';
  var MSG_INVALID_SIGNER_KEY = 'key must be a string, a buffer or an object';
  var supportsKeyObjects = typeof crypto.createPublicKey === 'function';
  if (supportsKeyObjects) {
    MSG_INVALID_VERIFIER_KEY += ' or a KeyObject';
    MSG_INVALID_SECRET += 'or a KeyObject';
  }
  function checkIsPublicKey(key) {
    if (Buffer2.isBuffer(key)) {
      return;
    }
    if (typeof key === 'string') {
      return;
    }
    if (!supportsKeyObjects) {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key !== 'object') {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.type !== 'string') {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.asymmetricKeyType !== 'string') {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.export !== 'function') {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
  }
  function checkIsPrivateKey(key) {
    if (Buffer2.isBuffer(key)) {
      return;
    }
    if (typeof key === 'string') {
      return;
    }
    if (typeof key === 'object') {
      return;
    }
    throw typeError(MSG_INVALID_SIGNER_KEY);
  }
  function checkIsSecretKey(key) {
    if (Buffer2.isBuffer(key)) {
      return;
    }
    if (typeof key === 'string') {
      return key;
    }
    if (!supportsKeyObjects) {
      throw typeError(MSG_INVALID_SECRET);
    }
    if (typeof key !== 'object') {
      throw typeError(MSG_INVALID_SECRET);
    }
    if (key.type !== 'secret') {
      throw typeError(MSG_INVALID_SECRET);
    }
    if (typeof key.export !== 'function') {
      throw typeError(MSG_INVALID_SECRET);
    }
  }
  function fromBase64(base64) {
    return base64.replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
  }
  function toBase64(base64url) {
    base64url = base64url.toString();
    var padding = 4 - (base64url.length % 4);
    if (padding !== 4) {
      for (var i = 0; i < padding; ++i) {
        base64url += '=';
      }
    }
    return base64url.replace(/\-/g, '+').replace(/_/g, '/');
  }
  function typeError(template) {
    var args = [].slice.call(arguments, 1);
    var errMsg = util.format.bind(util, template).apply(null, args);
    return new TypeError(errMsg);
  }
  function bufferOrString(obj) {
    return Buffer2.isBuffer(obj) || typeof obj === 'string';
  }
  function normalizeInput(thing) {
    if (!bufferOrString(thing)) thing = JSON.stringify(thing);
    return thing;
  }
  function createHmacSigner(bits) {
    return function sign(thing, secret) {
      checkIsSecretKey(secret);
      thing = normalizeInput(thing);
      var hmac = crypto.createHmac('sha' + bits, secret);
      var sig = (hmac.update(thing), hmac.digest('base64'));
      return fromBase64(sig);
    };
  }
  function createHmacVerifier(bits) {
    return function verify(thing, signature, secret) {
      var computedSig = createHmacSigner(bits)(thing, secret);
      return bufferEqual(Buffer2.from(signature), Buffer2.from(computedSig));
    };
  }
  function createKeySigner(bits) {
    return function sign(thing, privateKey) {
      checkIsPrivateKey(privateKey);
      thing = normalizeInput(thing);
      var signer = crypto.createSign('RSA-SHA' + bits);
      var sig = (signer.update(thing), signer.sign(privateKey, 'base64'));
      return fromBase64(sig);
    };
  }
  function createKeyVerifier(bits) {
    return function verify(thing, signature, publicKey) {
      checkIsPublicKey(publicKey);
      thing = normalizeInput(thing);
      signature = toBase64(signature);
      var verifier = crypto.createVerify('RSA-SHA' + bits);
      verifier.update(thing);
      return verifier.verify(publicKey, signature, 'base64');
    };
  }
  function createPSSKeySigner(bits) {
    return function sign(thing, privateKey) {
      checkIsPrivateKey(privateKey);
      thing = normalizeInput(thing);
      var signer = crypto.createSign('RSA-SHA' + bits);
      var sig =
        (signer.update(thing),
        signer.sign(
          {
            key: privateKey,
            padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
            saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST,
          },
          'base64',
        ));
      return fromBase64(sig);
    };
  }
  function createPSSKeyVerifier(bits) {
    return function verify(thing, signature, publicKey) {
      checkIsPublicKey(publicKey);
      thing = normalizeInput(thing);
      signature = toBase64(signature);
      var verifier = crypto.createVerify('RSA-SHA' + bits);
      verifier.update(thing);
      return verifier.verify(
        {
          key: publicKey,
          padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST,
        },
        signature,
        'base64',
      );
    };
  }
  function createECDSASigner(bits) {
    var inner = createKeySigner(bits);
    return function sign() {
      var signature = inner.apply(null, arguments);
      signature = formatEcdsa.derToJose(signature, 'ES' + bits);
      return signature;
    };
  }
  function createECDSAVerifer(bits) {
    var inner = createKeyVerifier(bits);
    return function verify(thing, signature, publicKey) {
      signature = formatEcdsa
        .joseToDer(signature, 'ES' + bits)
        .toString('base64');
      var result = inner(thing, signature, publicKey);
      return result;
    };
  }
  function createNoneSigner() {
    return function sign() {
      return '';
    };
  }
  function createNoneVerifier() {
    return function verify(thing, signature) {
      return signature === '';
    };
  }
  module2.exports = function jwa(algorithm) {
    var signerFactories = {
      hs: createHmacSigner,
      rs: createKeySigner,
      ps: createPSSKeySigner,
      es: createECDSASigner,
      none: createNoneSigner,
    };
    var verifierFactories = {
      hs: createHmacVerifier,
      rs: createKeyVerifier,
      ps: createPSSKeyVerifier,
      es: createECDSAVerifer,
      none: createNoneVerifier,
    };
    var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
    if (!match) throw typeError(MSG_INVALID_ALGORITHM, algorithm);
    var algo = (match[1] || match[3]).toLowerCase();
    var bits = match[2];
    return {
      sign: signerFactories[algo](bits),
      verify: verifierFactories[algo](bits),
    };
  };
});

// node_modules/jws/lib/tostring.js
var require_tostring = __commonJS((exports2, module2) => {
  var Buffer2 = require('buffer').Buffer;
  module2.exports = function toString(obj) {
    if (typeof obj === 'string') return obj;
    if (typeof obj === 'number' || Buffer2.isBuffer(obj)) return obj.toString();
    return JSON.stringify(obj);
  };
});

// node_modules/jws/lib/sign-stream.js
var require_sign_stream = __commonJS((exports2, module2) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var DataStream = require_data_stream();
  var jwa = require_jwa();
  var Stream = require('stream');
  var toString = require_tostring();
  var util = require('util');
  function base64url(string, encoding) {
    return Buffer2.from(string, encoding)
      .toString('base64')
      .replace(/=/g, '')
      .replace(/\+/g, '-')
      .replace(/\//g, '_');
  }
  function jwsSecuredInput(header, payload, encoding) {
    encoding = encoding || 'utf8';
    var encodedHeader = base64url(toString(header), 'binary');
    var encodedPayload = base64url(toString(payload), encoding);
    return util.format('%s.%s', encodedHeader, encodedPayload);
  }
  function jwsSign(opts) {
    var header = opts.header;
    var payload = opts.payload;
    var secretOrKey = opts.secret || opts.privateKey;
    var encoding = opts.encoding;
    var algo = jwa(header.alg);
    var securedInput = jwsSecuredInput(header, payload, encoding);
    var signature = algo.sign(securedInput, secretOrKey);
    return util.format('%s.%s', securedInput, signature);
  }
  function SignStream(opts) {
    var secret = opts.secret || opts.privateKey || opts.key;
    var secretStream = new DataStream(secret);
    this.readable = true;
    this.header = opts.header;
    this.encoding = opts.encoding;
    this.secret = this.privateKey = this.key = secretStream;
    this.payload = new DataStream(opts.payload);
    this.secret.once(
      'close',
      function () {
        if (!this.payload.writable && this.readable) this.sign();
      }.bind(this),
    );
    this.payload.once(
      'close',
      function () {
        if (!this.secret.writable && this.readable) this.sign();
      }.bind(this),
    );
  }
  util.inherits(SignStream, Stream);
  SignStream.prototype.sign = function sign() {
    try {
      var signature = jwsSign({
        header: this.header,
        payload: this.payload.buffer,
        secret: this.secret.buffer,
        encoding: this.encoding,
      });
      this.emit('done', signature);
      this.emit('data', signature);
      this.emit('end');
      this.readable = false;
      return signature;
    } catch (e) {
      this.readable = false;
      this.emit('error', e);
      this.emit('close');
    }
  };
  SignStream.sign = jwsSign;
  module2.exports = SignStream;
});

// node_modules/jws/lib/verify-stream.js
var require_verify_stream = __commonJS((exports2, module2) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var DataStream = require_data_stream();
  var jwa = require_jwa();
  var Stream = require('stream');
  var toString = require_tostring();
  var util = require('util');
  var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
  function isObject(thing) {
    return Object.prototype.toString.call(thing) === '[object Object]';
  }
  function safeJsonParse(thing) {
    if (isObject(thing)) return thing;
    try {
      return JSON.parse(thing);
    } catch (e) {
      return void 0;
    }
  }
  function headerFromJWS(jwsSig) {
    var encodedHeader = jwsSig.split('.', 1)[0];
    return safeJsonParse(
      Buffer2.from(encodedHeader, 'base64').toString('binary'),
    );
  }
  function securedInputFromJWS(jwsSig) {
    return jwsSig.split('.', 2).join('.');
  }
  function signatureFromJWS(jwsSig) {
    return jwsSig.split('.')[2];
  }
  function payloadFromJWS(jwsSig, encoding) {
    encoding = encoding || 'utf8';
    var payload = jwsSig.split('.')[1];
    return Buffer2.from(payload, 'base64').toString(encoding);
  }
  function isValidJws(string) {
    return JWS_REGEX.test(string) && !!headerFromJWS(string);
  }
  function jwsVerify(jwsSig, algorithm, secretOrKey) {
    if (!algorithm) {
      var err = new Error('Missing algorithm parameter for jws.verify');
      err.code = 'MISSING_ALGORITHM';
      throw err;
    }
    jwsSig = toString(jwsSig);
    var signature = signatureFromJWS(jwsSig);
    var securedInput = securedInputFromJWS(jwsSig);
    var algo = jwa(algorithm);
    return algo.verify(securedInput, signature, secretOrKey);
  }
  function jwsDecode(jwsSig, opts) {
    opts = opts || {};
    jwsSig = toString(jwsSig);
    if (!isValidJws(jwsSig)) return null;
    var header = headerFromJWS(jwsSig);
    if (!header) return null;
    var payload = payloadFromJWS(jwsSig);
    if (header.typ === 'JWT' || opts.json)
      payload = JSON.parse(payload, opts.encoding);
    return {
      header,
      payload,
      signature: signatureFromJWS(jwsSig),
    };
  }
  function VerifyStream(opts) {
    opts = opts || {};
    var secretOrKey = opts.secret || opts.publicKey || opts.key;
    var secretStream = new DataStream(secretOrKey);
    this.readable = true;
    this.algorithm = opts.algorithm;
    this.encoding = opts.encoding;
    this.secret = this.publicKey = this.key = secretStream;
    this.signature = new DataStream(opts.signature);
    this.secret.once(
      'close',
      function () {
        if (!this.signature.writable && this.readable) this.verify();
      }.bind(this),
    );
    this.signature.once(
      'close',
      function () {
        if (!this.secret.writable && this.readable) this.verify();
      }.bind(this),
    );
  }
  util.inherits(VerifyStream, Stream);
  VerifyStream.prototype.verify = function verify() {
    try {
      var valid = jwsVerify(
        this.signature.buffer,
        this.algorithm,
        this.key.buffer,
      );
      var obj = jwsDecode(this.signature.buffer, this.encoding);
      this.emit('done', valid, obj);
      this.emit('data', valid);
      this.emit('end');
      this.readable = false;
      return valid;
    } catch (e) {
      this.readable = false;
      this.emit('error', e);
      this.emit('close');
    }
  };
  VerifyStream.decode = jwsDecode;
  VerifyStream.isValid = isValidJws;
  VerifyStream.verify = jwsVerify;
  module2.exports = VerifyStream;
});

// node_modules/jws/index.js
var require_jws = __commonJS((exports2) => {
  var SignStream = require_sign_stream();
  var VerifyStream = require_verify_stream();
  var ALGORITHMS = [
    'HS256',
    'HS384',
    'HS512',
    'RS256',
    'RS384',
    'RS512',
    'PS256',
    'PS384',
    'PS512',
    'ES256',
    'ES384',
    'ES512',
  ];
  exports2.ALGORITHMS = ALGORITHMS;
  exports2.sign = SignStream.sign;
  exports2.verify = VerifyStream.verify;
  exports2.decode = VerifyStream.decode;
  exports2.isValid = VerifyStream.isValid;
  exports2.createSign = function createSign(opts) {
    return new SignStream(opts);
  };
  exports2.createVerify = function createVerify(opts) {
    return new VerifyStream(opts);
  };
});

// node_modules/jsonwebtoken/decode.js
var require_decode = __commonJS((exports2, module2) => {
  var jws = require_jws();
  module2.exports = function (jwt, options) {
    options = options || {};
    var decoded = jws.decode(jwt, options);
    if (!decoded) {
      return null;
    }
    var payload = decoded.payload;
    if (typeof payload === 'string') {
      try {
        var obj = JSON.parse(payload);
        if (obj !== null && typeof obj === 'object') {
          payload = obj;
        }
      } catch (e) {}
    }
    if (options.complete === true) {
      return {
        header: decoded.header,
        payload,
        signature: decoded.signature,
      };
    }
    return payload;
  };
});

// node_modules/jsonwebtoken/lib/JsonWebTokenError.js
var require_JsonWebTokenError = __commonJS((exports2, module2) => {
  var JsonWebTokenError = function (message, error) {
    Error.call(this, message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = 'JsonWebTokenError';
    this.message = message;
    if (error) this.inner = error;
  };
  JsonWebTokenError.prototype = Object.create(Error.prototype);
  JsonWebTokenError.prototype.constructor = JsonWebTokenError;
  module2.exports = JsonWebTokenError;
});

// node_modules/jsonwebtoken/lib/NotBeforeError.js
var require_NotBeforeError = __commonJS((exports2, module2) => {
  var JsonWebTokenError = require_JsonWebTokenError();
  var NotBeforeError = function (message, date) {
    JsonWebTokenError.call(this, message);
    this.name = 'NotBeforeError';
    this.date = date;
  };
  NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);
  NotBeforeError.prototype.constructor = NotBeforeError;
  module2.exports = NotBeforeError;
});

// node_modules/jsonwebtoken/lib/TokenExpiredError.js
var require_TokenExpiredError = __commonJS((exports2, module2) => {
  var JsonWebTokenError = require_JsonWebTokenError();
  var TokenExpiredError = function (message, expiredAt) {
    JsonWebTokenError.call(this, message);
    this.name = 'TokenExpiredError';
    this.expiredAt = expiredAt;
  };
  TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);
  TokenExpiredError.prototype.constructor = TokenExpiredError;
  module2.exports = TokenExpiredError;
});

// node_modules/jsonwebtoken/lib/timespan.js
var require_timespan = __commonJS((exports2, module2) => {
  var ms = require_ms();
  module2.exports = function (time, iat) {
    var timestamp = iat || Math.floor(Date.now() / 1e3);
    if (typeof time === 'string') {
      var milliseconds = ms(time);
      if (typeof milliseconds === 'undefined') {
        return;
      }
      return Math.floor(timestamp + milliseconds / 1e3);
    } else if (typeof time === 'number') {
      return timestamp + time;
    } else {
      return;
    }
  };
});

// node_modules/jsonwebtoken/node_modules/semver/semver.js
var require_semver = __commonJS((exports2, module2) => {
  exports2 = module2.exports = SemVer;
  var debug;
  if (
    typeof process === 'object' &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)
  ) {
    debug = function () {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift('SEMVER');
      console.log.apply(console, args);
    };
  } else {
    debug = function () {};
  }
  exports2.SEMVER_SPEC_VERSION = '2.0.0';
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var re = (exports2.re = []);
  var src = (exports2.src = []);
  var R = 0;
  var NUMERICIDENTIFIER = R++;
  src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
  var NUMERICIDENTIFIERLOOSE = R++;
  src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';
  var NONNUMERICIDENTIFIER = R++;
  src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';
  var MAINVERSION = R++;
  src[MAINVERSION] =
    '(' +
    src[NUMERICIDENTIFIER] +
    ')\\.(' +
    src[NUMERICIDENTIFIER] +
    ')\\.(' +
    src[NUMERICIDENTIFIER] +
    ')';
  var MAINVERSIONLOOSE = R++;
  src[MAINVERSIONLOOSE] =
    '(' +
    src[NUMERICIDENTIFIERLOOSE] +
    ')\\.(' +
    src[NUMERICIDENTIFIERLOOSE] +
    ')\\.(' +
    src[NUMERICIDENTIFIERLOOSE] +
    ')';
  var PRERELEASEIDENTIFIER = R++;
  src[PRERELEASEIDENTIFIER] =
    '(?:' + src[NUMERICIDENTIFIER] + '|' + src[NONNUMERICIDENTIFIER] + ')';
  var PRERELEASEIDENTIFIERLOOSE = R++;
  src[PRERELEASEIDENTIFIERLOOSE] =
    '(?:' + src[NUMERICIDENTIFIERLOOSE] + '|' + src[NONNUMERICIDENTIFIER] + ')';
  var PRERELEASE = R++;
  src[PRERELEASE] =
    '(?:-(' +
    src[PRERELEASEIDENTIFIER] +
    '(?:\\.' +
    src[PRERELEASEIDENTIFIER] +
    ')*))';
  var PRERELEASELOOSE = R++;
  src[PRERELEASELOOSE] =
    '(?:-?(' +
    src[PRERELEASEIDENTIFIERLOOSE] +
    '(?:\\.' +
    src[PRERELEASEIDENTIFIERLOOSE] +
    ')*))';
  var BUILDIDENTIFIER = R++;
  src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';
  var BUILD = R++;
  src[BUILD] =
    '(?:\\+(' + src[BUILDIDENTIFIER] + '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';
  var FULL = R++;
  var FULLPLAIN =
    'v?' + src[MAINVERSION] + src[PRERELEASE] + '?' + src[BUILD] + '?';
  src[FULL] = '^' + FULLPLAIN + '$';
  var LOOSEPLAIN =
    '[v=\\s]*' +
    src[MAINVERSIONLOOSE] +
    src[PRERELEASELOOSE] +
    '?' +
    src[BUILD] +
    '?';
  var LOOSE = R++;
  src[LOOSE] = '^' + LOOSEPLAIN + '$';
  var GTLT = R++;
  src[GTLT] = '((?:<|>)?=?)';
  var XRANGEIDENTIFIERLOOSE = R++;
  src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
  var XRANGEIDENTIFIER = R++;
  src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';
  var XRANGEPLAIN = R++;
  src[XRANGEPLAIN] =
    '[v=\\s]*(' +
    src[XRANGEIDENTIFIER] +
    ')(?:\\.(' +
    src[XRANGEIDENTIFIER] +
    ')(?:\\.(' +
    src[XRANGEIDENTIFIER] +
    ')(?:' +
    src[PRERELEASE] +
    ')?' +
    src[BUILD] +
    '?)?)?';
  var XRANGEPLAINLOOSE = R++;
  src[XRANGEPLAINLOOSE] =
    '[v=\\s]*(' +
    src[XRANGEIDENTIFIERLOOSE] +
    ')(?:\\.(' +
    src[XRANGEIDENTIFIERLOOSE] +
    ')(?:\\.(' +
    src[XRANGEIDENTIFIERLOOSE] +
    ')(?:' +
    src[PRERELEASELOOSE] +
    ')?' +
    src[BUILD] +
    '?)?)?';
  var XRANGE = R++;
  src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
  var XRANGELOOSE = R++;
  src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';
  var COERCE = R++;
  src[COERCE] =
    '(?:^|[^\\d])(\\d{1,' +
    MAX_SAFE_COMPONENT_LENGTH +
    '})(?:\\.(\\d{1,' +
    MAX_SAFE_COMPONENT_LENGTH +
    '}))?(?:\\.(\\d{1,' +
    MAX_SAFE_COMPONENT_LENGTH +
    '}))?(?:$|[^\\d])';
  var LONETILDE = R++;
  src[LONETILDE] = '(?:~>?)';
  var TILDETRIM = R++;
  src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
  re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
  var tildeTrimReplace = '$1~';
  var TILDE = R++;
  src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
  var TILDELOOSE = R++;
  src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';
  var LONECARET = R++;
  src[LONECARET] = '(?:\\^)';
  var CARETTRIM = R++;
  src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
  re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
  var caretTrimReplace = '$1^';
  var CARET = R++;
  src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
  var CARETLOOSE = R++;
  src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';
  var COMPARATORLOOSE = R++;
  src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
  var COMPARATOR = R++;
  src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';
  var COMPARATORTRIM = R++;
  src[COMPARATORTRIM] =
    '(\\s*)' + src[GTLT] + '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';
  re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
  var comparatorTrimReplace = '$1$2$3';
  var HYPHENRANGE = R++;
  src[HYPHENRANGE] =
    '^\\s*(' + src[XRANGEPLAIN] + ')\\s+-\\s+(' + src[XRANGEPLAIN] + ')\\s*$';
  var HYPHENRANGELOOSE = R++;
  src[HYPHENRANGELOOSE] =
    '^\\s*(' +
    src[XRANGEPLAINLOOSE] +
    ')\\s+-\\s+(' +
    src[XRANGEPLAINLOOSE] +
    ')\\s*$';
  var STAR = R++;
  src[STAR] = '(<|>)?=?\\s*\\*';
  for (var i = 0; i < R; i++) {
    debug(i, src[i]);
    if (!re[i]) {
      re[i] = new RegExp(src[i]);
    }
  }
  exports2.parse = parse;
  function parse(version, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false,
      };
    }
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version !== 'string') {
      return null;
    }
    if (version.length > MAX_LENGTH) {
      return null;
    }
    var r = options.loose ? re[LOOSE] : re[FULL];
    if (!r.test(version)) {
      return null;
    }
    try {
      return new SemVer(version, options);
    } catch (er) {
      return null;
    }
  }
  exports2.valid = valid;
  function valid(version, options) {
    var v = parse(version, options);
    return v ? v.version : null;
  }
  exports2.clean = clean;
  function clean(version, options) {
    var s = parse(version.trim().replace(/^[=v]+/, ''), options);
    return s ? s.version : null;
  }
  exports2.SemVer = SemVer;
  function SemVer(version, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false,
      };
    }
    if (version instanceof SemVer) {
      if (version.loose === options.loose) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== 'string') {
      throw new TypeError('Invalid Version: ' + version);
    }
    if (version.length > MAX_LENGTH) {
      throw new TypeError(
        'version is longer than ' + MAX_LENGTH + ' characters',
      );
    }
    if (!(this instanceof SemVer)) {
      return new SemVer(version, options);
    }
    debug('SemVer', version, options);
    this.options = options;
    this.loose = !!options.loose;
    var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL]);
    if (!m) {
      throw new TypeError('Invalid Version: ' + version);
    }
    this.raw = version;
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version');
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version');
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version');
    }
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split('.').map(function (id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m[5] ? m[5].split('.') : [];
    this.format();
  }
  SemVer.prototype.format = function () {
    this.version = this.major + '.' + this.minor + '.' + this.patch;
    if (this.prerelease.length) {
      this.version += '-' + this.prerelease.join('.');
    }
    return this.version;
  };
  SemVer.prototype.toString = function () {
    return this.version;
  };
  SemVer.prototype.compare = function (other) {
    debug('SemVer.compare', this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return this.compareMain(other) || this.comparePre(other);
  };
  SemVer.prototype.compareMain = function (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return (
      compareIdentifiers(this.major, other.major) ||
      compareIdentifiers(this.minor, other.minor) ||
      compareIdentifiers(this.patch, other.patch)
    );
  };
  SemVer.prototype.comparePre = function (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    var i2 = 0;
    do {
      var a = this.prerelease[i2];
      var b = other.prerelease[i2];
      debug('prerelease compare', i2, a, b);
      if (a === void 0 && b === void 0) {
        return 0;
      } else if (b === void 0) {
        return 1;
      } else if (a === void 0) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i2);
  };
  SemVer.prototype.inc = function (release, identifier) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc('pre', identifier);
        break;
      case 'preminor':
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc('pre', identifier);
        break;
      case 'prepatch':
        this.prerelease.length = 0;
        this.inc('patch', identifier);
        this.inc('pre', identifier);
        break;
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier);
        }
        this.inc('pre', identifier);
        break;
      case 'major':
        if (
          this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0
        ) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case 'minor':
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case 'patch':
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case 'pre':
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i2 = this.prerelease.length;
          while (--i2 >= 0) {
            if (typeof this.prerelease[i2] === 'number') {
              this.prerelease[i2]++;
              i2 = -2;
            }
          }
          if (i2 === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error('invalid increment argument: ' + release);
    }
    this.format();
    this.raw = this.version;
    return this;
  };
  exports2.inc = inc;
  function inc(version, release, loose, identifier) {
    if (typeof loose === 'string') {
      identifier = loose;
      loose = void 0;
    }
    try {
      return new SemVer(version, loose).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  }
  exports2.diff = diff;
  function diff(version1, version2) {
    if (eq(version1, version2)) {
      return null;
    } else {
      var v1 = parse(version1);
      var v2 = parse(version2);
      var prefix = '';
      if (v1.prerelease.length || v2.prerelease.length) {
        prefix = 'pre';
        var defaultResult = 'prerelease';
      }
      for (var key in v1) {
        if (key === 'major' || key === 'minor' || key === 'patch') {
          if (v1[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }
      return defaultResult;
    }
  }
  exports2.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;
  function compareIdentifiers(a, b) {
    var anum = numeric.test(a);
    var bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b
      ? 0
      : anum && !bnum
      ? -1
      : bnum && !anum
      ? 1
      : a < b
      ? -1
      : 1;
  }
  exports2.rcompareIdentifiers = rcompareIdentifiers;
  function rcompareIdentifiers(a, b) {
    return compareIdentifiers(b, a);
  }
  exports2.major = major;
  function major(a, loose) {
    return new SemVer(a, loose).major;
  }
  exports2.minor = minor;
  function minor(a, loose) {
    return new SemVer(a, loose).minor;
  }
  exports2.patch = patch;
  function patch(a, loose) {
    return new SemVer(a, loose).patch;
  }
  exports2.compare = compare;
  function compare(a, b, loose) {
    return new SemVer(a, loose).compare(new SemVer(b, loose));
  }
  exports2.compareLoose = compareLoose;
  function compareLoose(a, b) {
    return compare(a, b, true);
  }
  exports2.rcompare = rcompare;
  function rcompare(a, b, loose) {
    return compare(b, a, loose);
  }
  exports2.sort = sort;
  function sort(list, loose) {
    return list.sort(function (a, b) {
      return exports2.compare(a, b, loose);
    });
  }
  exports2.rsort = rsort;
  function rsort(list, loose) {
    return list.sort(function (a, b) {
      return exports2.rcompare(a, b, loose);
    });
  }
  exports2.gt = gt2;
  function gt2(a, b, loose) {
    return compare(a, b, loose) > 0;
  }
  exports2.lt = lt;
  function lt(a, b, loose) {
    return compare(a, b, loose) < 0;
  }
  exports2.eq = eq;
  function eq(a, b, loose) {
    return compare(a, b, loose) === 0;
  }
  exports2.neq = neq2;
  function neq2(a, b, loose) {
    return compare(a, b, loose) !== 0;
  }
  exports2.gte = gte;
  function gte(a, b, loose) {
    return compare(a, b, loose) >= 0;
  }
  exports2.lte = lte;
  function lte(a, b, loose) {
    return compare(a, b, loose) <= 0;
  }
  exports2.cmp = cmp;
  function cmp(a, op, b, loose) {
    switch (op) {
      case '===':
        if (typeof a === 'object') a = a.version;
        if (typeof b === 'object') b = b.version;
        return a === b;
      case '!==':
        if (typeof a === 'object') a = a.version;
        if (typeof b === 'object') b = b.version;
        return a !== b;
      case '':
      case '=':
      case '==':
        return eq(a, b, loose);
      case '!=':
        return neq2(a, b, loose);
      case '>':
        return gt2(a, b, loose);
      case '>=':
        return gte(a, b, loose);
      case '<':
        return lt(a, b, loose);
      case '<=':
        return lte(a, b, loose);
      default:
        throw new TypeError('Invalid operator: ' + op);
    }
  }
  exports2.Comparator = Comparator;
  function Comparator(comp, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false,
      };
    }
    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options);
    }
    debug('comparator', comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);
    if (this.semver === ANY) {
      this.value = '';
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug('comp', this);
  }
  var ANY = {};
  Comparator.prototype.parse = function (comp) {
    var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
    var m = comp.match(r);
    if (!m) {
      throw new TypeError('Invalid comparator: ' + comp);
    }
    this.operator = m[1];
    if (this.operator === '=') {
      this.operator = '';
    }
    if (!m[2]) {
      this.semver = ANY;
    } else {
      this.semver = new SemVer(m[2], this.options.loose);
    }
  };
  Comparator.prototype.toString = function () {
    return this.value;
  };
  Comparator.prototype.test = function (version) {
    debug('Comparator.test', version, this.options.loose);
    if (this.semver === ANY) {
      return true;
    }
    if (typeof version === 'string') {
      version = new SemVer(version, this.options);
    }
    return cmp(version, this.operator, this.semver, this.options);
  };
  Comparator.prototype.intersects = function (comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError('a Comparator is required');
    }
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false,
      };
    }
    var rangeTmp;
    if (this.operator === '') {
      rangeTmp = new Range(comp.value, options);
      return satisfies(this.value, rangeTmp, options);
    } else if (comp.operator === '') {
      rangeTmp = new Range(this.value, options);
      return satisfies(comp.semver, rangeTmp, options);
    }
    var sameDirectionIncreasing =
      (this.operator === '>=' || this.operator === '>') &&
      (comp.operator === '>=' || comp.operator === '>');
    var sameDirectionDecreasing =
      (this.operator === '<=' || this.operator === '<') &&
      (comp.operator === '<=' || comp.operator === '<');
    var sameSemVer = this.semver.version === comp.semver.version;
    var differentDirectionsInclusive =
      (this.operator === '>=' || this.operator === '<=') &&
      (comp.operator === '>=' || comp.operator === '<=');
    var oppositeDirectionsLessThan =
      cmp(this.semver, '<', comp.semver, options) &&
      (this.operator === '>=' || this.operator === '>') &&
      (comp.operator === '<=' || comp.operator === '<');
    var oppositeDirectionsGreaterThan =
      cmp(this.semver, '>', comp.semver, options) &&
      (this.operator === '<=' || this.operator === '<') &&
      (comp.operator === '>=' || comp.operator === '>');
    return (
      sameDirectionIncreasing ||
      sameDirectionDecreasing ||
      (sameSemVer && differentDirectionsInclusive) ||
      oppositeDirectionsLessThan ||
      oppositeDirectionsGreaterThan
    );
  };
  exports2.Range = Range;
  function Range(range, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false,
      };
    }
    if (range instanceof Range) {
      if (
        range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease
      ) {
        return range;
      } else {
        return new Range(range.raw, options);
      }
    }
    if (range instanceof Comparator) {
      return new Range(range.value, options);
    }
    if (!(this instanceof Range)) {
      return new Range(range, options);
    }
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range;
    this.set = range
      .split(/\s*\|\|\s*/)
      .map(function (range2) {
        return this.parseRange(range2.trim());
      }, this)
      .filter(function (c) {
        return c.length;
      });
    if (!this.set.length) {
      throw new TypeError('Invalid SemVer Range: ' + range);
    }
    this.format();
  }
  Range.prototype.format = function () {
    this.range = this.set
      .map(function (comps) {
        return comps.join(' ').trim();
      })
      .join('||')
      .trim();
    return this.range;
  };
  Range.prototype.toString = function () {
    return this.range;
  };
  Range.prototype.parseRange = function (range) {
    var loose = this.options.loose;
    range = range.trim();
    var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
    range = range.replace(hr, hyphenReplace);
    debug('hyphen replace', range);
    range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
    debug('comparator trim', range, re[COMPARATORTRIM]);
    range = range.replace(re[TILDETRIM], tildeTrimReplace);
    range = range.replace(re[CARETTRIM], caretTrimReplace);
    range = range.split(/\s+/).join(' ');
    var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
    var set = range
      .split(' ')
      .map(function (comp) {
        return parseComparator(comp, this.options);
      }, this)
      .join(' ')
      .split(/\s+/);
    if (this.options.loose) {
      set = set.filter(function (comp) {
        return !!comp.match(compRe);
      });
    }
    set = set.map(function (comp) {
      return new Comparator(comp, this.options);
    }, this);
    return set;
  };
  Range.prototype.intersects = function (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError('a Range is required');
    }
    return this.set.some(function (thisComparators) {
      return thisComparators.every(function (thisComparator) {
        return range.set.some(function (rangeComparators) {
          return rangeComparators.every(function (rangeComparator) {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  };
  exports2.toComparators = toComparators;
  function toComparators(range, options) {
    return new Range(range, options).set.map(function (comp) {
      return comp
        .map(function (c) {
          return c.value;
        })
        .join(' ')
        .trim()
        .split(' ');
    });
  }
  function parseComparator(comp, options) {
    debug('comp', comp, options);
    comp = replaceCarets(comp, options);
    debug('caret', comp);
    comp = replaceTildes(comp, options);
    debug('tildes', comp);
    comp = replaceXRanges(comp, options);
    debug('xrange', comp);
    comp = replaceStars(comp, options);
    debug('stars', comp);
    return comp;
  }
  function isX(id) {
    return !id || id.toLowerCase() === 'x' || id === '*';
  }
  function replaceTildes(comp, options) {
    return comp
      .trim()
      .split(/\s+/)
      .map(function (comp2) {
        return replaceTilde(comp2, options);
      })
      .join(' ');
  }
  function replaceTilde(comp, options) {
    var r = options.loose ? re[TILDELOOSE] : re[TILDE];
    return comp.replace(r, function (_2, M, m, p, pr) {
      debug('tilde', comp, _2, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = '';
      } else if (isX(m)) {
        ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
      } else if (isX(p)) {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
      } else if (pr) {
        debug('replaceTilde pr', pr);
        ret =
          '>=' +
          M +
          '.' +
          m +
          '.' +
          p +
          '-' +
          pr +
          ' <' +
          M +
          '.' +
          (+m + 1) +
          '.0';
      } else {
        ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
      }
      debug('tilde return', ret);
      return ret;
    });
  }
  function replaceCarets(comp, options) {
    return comp
      .trim()
      .split(/\s+/)
      .map(function (comp2) {
        return replaceCaret(comp2, options);
      })
      .join(' ');
  }
  function replaceCaret(comp, options) {
    debug('caret', comp, options);
    var r = options.loose ? re[CARETLOOSE] : re[CARET];
    return comp.replace(r, function (_2, M, m, p, pr) {
      debug('caret', comp, _2, M, m, p, pr);
      var ret;
      if (isX(M)) {
        ret = '';
      } else if (isX(m)) {
        ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
      } else if (isX(p)) {
        if (M === '0') {
          ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
        } else {
          ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
        }
      } else if (pr) {
        debug('replaceCaret pr', pr);
        if (M === '0') {
          if (m === '0') {
            ret =
              '>=' +
              M +
              '.' +
              m +
              '.' +
              p +
              '-' +
              pr +
              ' <' +
              M +
              '.' +
              m +
              '.' +
              (+p + 1);
          } else {
            ret =
              '>=' +
              M +
              '.' +
              m +
              '.' +
              p +
              '-' +
              pr +
              ' <' +
              M +
              '.' +
              (+m + 1) +
              '.0';
          }
        } else {
          ret =
            '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + (+M + 1) + '.0.0';
        }
      } else {
        debug('no pr');
        if (M === '0') {
          if (m === '0') {
            ret =
              '>=' +
              M +
              '.' +
              m +
              '.' +
              p +
              ' <' +
              M +
              '.' +
              m +
              '.' +
              (+p + 1);
          } else {
            ret =
              '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
          }
        } else {
          ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';
        }
      }
      debug('caret return', ret);
      return ret;
    });
  }
  function replaceXRanges(comp, options) {
    debug('replaceXRanges', comp, options);
    return comp
      .split(/\s+/)
      .map(function (comp2) {
        return replaceXRange(comp2, options);
      })
      .join(' ');
  }
  function replaceXRange(comp, options) {
    comp = comp.trim();
    var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
    return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
      debug('xRange', comp, ret, gtlt, M, m, p, pr);
      var xM = isX(M);
      var xm = xM || isX(m);
      var xp = xm || isX(p);
      var anyX = xp;
      if (gtlt === '=' && anyX) {
        gtlt = '';
      }
      if (xM) {
        if (gtlt === '>' || gtlt === '<') {
          ret = '<0.0.0';
        } else {
          ret = '*';
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }
        p = 0;
        if (gtlt === '>') {
          gtlt = '>=';
          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === '<=') {
          gtlt = '<';
          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }
        ret = gtlt + M + '.' + m + '.' + p;
      } else if (xm) {
        ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
      } else if (xp) {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
      }
      debug('xRange return', ret);
      return ret;
    });
  }
  function replaceStars(comp, options) {
    debug('replaceStars', comp, options);
    return comp.trim().replace(re[STAR], '');
  }
  function hyphenReplace(
    $0,
    from,
    fM,
    fm,
    fp,
    fpr,
    fb,
    to,
    tM,
    tm,
    tp,
    tpr,
    tb,
  ) {
    if (isX(fM)) {
      from = '';
    } else if (isX(fm)) {
      from = '>=' + fM + '.0.0';
    } else if (isX(fp)) {
      from = '>=' + fM + '.' + fm + '.0';
    } else {
      from = '>=' + from;
    }
    if (isX(tM)) {
      to = '';
    } else if (isX(tm)) {
      to = '<' + (+tM + 1) + '.0.0';
    } else if (isX(tp)) {
      to = '<' + tM + '.' + (+tm + 1) + '.0';
    } else if (tpr) {
      to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
    } else {
      to = '<=' + to;
    }
    return (from + ' ' + to).trim();
  }
  Range.prototype.test = function (version) {
    if (!version) {
      return false;
    }
    if (typeof version === 'string') {
      version = new SemVer(version, this.options);
    }
    for (var i2 = 0; i2 < this.set.length; i2++) {
      if (testSet(this.set[i2], version, this.options)) {
        return true;
      }
    }
    return false;
  };
  function testSet(set, version, options) {
    for (var i2 = 0; i2 < set.length; i2++) {
      if (!set[i2].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (i2 = 0; i2 < set.length; i2++) {
        debug(set[i2].semver);
        if (set[i2].semver === ANY) {
          continue;
        }
        if (set[i2].semver.prerelease.length > 0) {
          var allowed = set[i2].semver;
          if (
            allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch
          ) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  }
  exports2.satisfies = satisfies;
  function satisfies(version, range, options) {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version);
  }
  exports2.maxSatisfying = maxSatisfying;
  function maxSatisfying(versions, range, options) {
    var max = null;
    var maxSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function (v) {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  }
  exports2.minSatisfying = minSatisfying;
  function minSatisfying(versions, range, options) {
    var min = null;
    var minSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach(function (v) {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  }
  exports2.minVersion = minVersion;
  function minVersion(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer('0.0.0');
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer('0.0.0-0');
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      comparators.forEach(function (comparator) {
        var compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case '>':
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case '':
          case '>=':
            if (!minver || gt2(minver, compver)) {
              minver = compver;
            }
            break;
          case '<':
          case '<=':
            break;
          default:
            throw new Error('Unexpected operation: ' + comparator.operator);
        }
      });
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  }
  exports2.validRange = validRange;
  function validRange(range, options) {
    try {
      return new Range(range, options).range || '*';
    } catch (er) {
      return null;
    }
  }
  exports2.ltr = ltr;
  function ltr(version, range, options) {
    return outside(version, range, '<', options);
  }
  exports2.gtr = gtr;
  function gtr(version, range, options) {
    return outside(version, range, '>', options);
  }
  exports2.outside = outside;
  function outside(version, range, hilo, options) {
    version = new SemVer(version, options);
    range = new Range(range, options);
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case '>':
        gtfn = gt2;
        ltefn = lte;
        ltfn = lt;
        comp = '>';
        ecomp = '>=';
        break;
      case '<':
        gtfn = lt;
        ltefn = gte;
        ltfn = gt2;
        comp = '<';
        ecomp = '<=';
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) {
      return false;
    }
    for (var i2 = 0; i2 < range.set.length; ++i2) {
      var comparators = range.set[i2];
      var high = null;
      var low = null;
      comparators.forEach(function (comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator('>=0.0.0');
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if (
        (!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)
      ) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  }
  exports2.prerelease = prerelease;
  function prerelease(version, options) {
    var parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  }
  exports2.intersects = intersects;
  function intersects(r1, r2, options) {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2);
  }
  exports2.coerce = coerce;
  function coerce(version) {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version !== 'string') {
      return null;
    }
    var match = version.match(re[COERCE]);
    if (match == null) {
      return null;
    }
    return parse(match[1] + '.' + (match[2] || '0') + '.' + (match[3] || '0'));
  }
});

// node_modules/jsonwebtoken/lib/psSupported.js
var require_psSupported = __commonJS((exports2, module2) => {
  var semver = require_semver();
  module2.exports = semver.satisfies(process.version, '^6.12.0 || >=8.0.0');
});

// node_modules/jsonwebtoken/verify.js
var require_verify2 = __commonJS((exports2, module2) => {
  var JsonWebTokenError = require_JsonWebTokenError();
  var NotBeforeError = require_NotBeforeError();
  var TokenExpiredError = require_TokenExpiredError();
  var decode = require_decode();
  var timespan = require_timespan();
  var PS_SUPPORTED = require_psSupported();
  var jws = require_jws();
  var PUB_KEY_ALGS = ['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512'];
  var RSA_KEY_ALGS = ['RS256', 'RS384', 'RS512'];
  var HS_ALGS = ['HS256', 'HS384', 'HS512'];
  if (PS_SUPPORTED) {
    PUB_KEY_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');
    RSA_KEY_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');
  }
  module2.exports = function (jwtString, secretOrPublicKey, options, callback) {
    if (typeof options === 'function' && !callback) {
      callback = options;
      options = {};
    }
    if (!options) {
      options = {};
    }
    options = Object.assign({}, options);
    var done;
    if (callback) {
      done = callback;
    } else {
      done = function (err, data) {
        if (err) throw err;
        return data;
      };
    }
    if (options.clockTimestamp && typeof options.clockTimestamp !== 'number') {
      return done(new JsonWebTokenError('clockTimestamp must be a number'));
    }
    if (
      options.nonce !== void 0 &&
      (typeof options.nonce !== 'string' || options.nonce.trim() === '')
    ) {
      return done(new JsonWebTokenError('nonce must be a non-empty string'));
    }
    var clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1e3);
    if (!jwtString) {
      return done(new JsonWebTokenError('jwt must be provided'));
    }
    if (typeof jwtString !== 'string') {
      return done(new JsonWebTokenError('jwt must be a string'));
    }
    var parts = jwtString.split('.');
    if (parts.length !== 3) {
      return done(new JsonWebTokenError('jwt malformed'));
    }
    var decodedToken;
    try {
      decodedToken = decode(jwtString, { complete: true });
    } catch (err) {
      return done(err);
    }
    if (!decodedToken) {
      return done(new JsonWebTokenError('invalid token'));
    }
    var header = decodedToken.header;
    var getSecret;
    if (typeof secretOrPublicKey === 'function') {
      if (!callback) {
        return done(
          new JsonWebTokenError(
            'verify must be called asynchronous if secret or public key is provided as a callback',
          ),
        );
      }
      getSecret = secretOrPublicKey;
    } else {
      getSecret = function (header2, secretCallback) {
        return secretCallback(null, secretOrPublicKey);
      };
    }
    return getSecret(header, function (err, secretOrPublicKey2) {
      if (err) {
        return done(
          new JsonWebTokenError(
            'error in secret or public key callback: ' + err.message,
          ),
        );
      }
      var hasSignature = parts[2].trim() !== '';
      if (!hasSignature && secretOrPublicKey2) {
        return done(new JsonWebTokenError('jwt signature is required'));
      }
      if (hasSignature && !secretOrPublicKey2) {
        return done(
          new JsonWebTokenError('secret or public key must be provided'),
        );
      }
      if (!hasSignature && !options.algorithms) {
        options.algorithms = ['none'];
      }
      if (!options.algorithms) {
        options.algorithms =
          ~secretOrPublicKey2.toString().indexOf('BEGIN CERTIFICATE') ||
          ~secretOrPublicKey2.toString().indexOf('BEGIN PUBLIC KEY')
            ? PUB_KEY_ALGS
            : ~secretOrPublicKey2.toString().indexOf('BEGIN RSA PUBLIC KEY')
            ? RSA_KEY_ALGS
            : HS_ALGS;
      }
      if (!~options.algorithms.indexOf(decodedToken.header.alg)) {
        return done(new JsonWebTokenError('invalid algorithm'));
      }
      var valid;
      try {
        valid = jws.verify(
          jwtString,
          decodedToken.header.alg,
          secretOrPublicKey2,
        );
      } catch (e) {
        return done(e);
      }
      if (!valid) {
        return done(new JsonWebTokenError('invalid signature'));
      }
      var payload = decodedToken.payload;
      if (typeof payload.nbf !== 'undefined' && !options.ignoreNotBefore) {
        if (typeof payload.nbf !== 'number') {
          return done(new JsonWebTokenError('invalid nbf value'));
        }
        if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
          return done(
            new NotBeforeError('jwt not active', new Date(payload.nbf * 1e3)),
          );
        }
      }
      if (typeof payload.exp !== 'undefined' && !options.ignoreExpiration) {
        if (typeof payload.exp !== 'number') {
          return done(new JsonWebTokenError('invalid exp value'));
        }
        if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
          return done(
            new TokenExpiredError('jwt expired', new Date(payload.exp * 1e3)),
          );
        }
      }
      if (options.audience) {
        var audiences = Array.isArray(options.audience)
          ? options.audience
          : [options.audience];
        var target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
        var match = target.some(function (targetAudience) {
          return audiences.some(function (audience) {
            return audience instanceof RegExp
              ? audience.test(targetAudience)
              : audience === targetAudience;
          });
        });
        if (!match) {
          return done(
            new JsonWebTokenError(
              'jwt audience invalid. expected: ' + audiences.join(' or '),
            ),
          );
        }
      }
      if (options.issuer) {
        var invalid_issuer =
          (typeof options.issuer === 'string' &&
            payload.iss !== options.issuer) ||
          (Array.isArray(options.issuer) &&
            options.issuer.indexOf(payload.iss) === -1);
        if (invalid_issuer) {
          return done(
            new JsonWebTokenError(
              'jwt issuer invalid. expected: ' + options.issuer,
            ),
          );
        }
      }
      if (options.subject) {
        if (payload.sub !== options.subject) {
          return done(
            new JsonWebTokenError(
              'jwt subject invalid. expected: ' + options.subject,
            ),
          );
        }
      }
      if (options.jwtid) {
        if (payload.jti !== options.jwtid) {
          return done(
            new JsonWebTokenError(
              'jwt jwtid invalid. expected: ' + options.jwtid,
            ),
          );
        }
      }
      if (options.nonce) {
        if (payload.nonce !== options.nonce) {
          return done(
            new JsonWebTokenError(
              'jwt nonce invalid. expected: ' + options.nonce,
            ),
          );
        }
      }
      if (options.maxAge) {
        if (typeof payload.iat !== 'number') {
          return done(
            new JsonWebTokenError('iat required when maxAge is specified'),
          );
        }
        var maxAgeTimestamp = timespan(options.maxAge, payload.iat);
        if (typeof maxAgeTimestamp === 'undefined') {
          return done(
            new JsonWebTokenError(
              '"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60',
            ),
          );
        }
        if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
          return done(
            new TokenExpiredError(
              'maxAge exceeded',
              new Date(maxAgeTimestamp * 1e3),
            ),
          );
        }
      }
      if (options.complete === true) {
        var signature = decodedToken.signature;
        return done(null, {
          header,
          payload,
          signature,
        });
      }
      return done(null, payload);
    });
  };
});

// node_modules/lodash.includes/index.js
var require_lodash4 = __commonJS((exports2, module2) => {
  var INFINITY = 1 / 0;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var MAX_INTEGER = 17976931348623157e292;
  var NAN = 0 / 0;
  var argsTag = '[object Arguments]';
  var funcTag = '[object Function]';
  var genTag = '[object GeneratorFunction]';
  var stringTag = '[object String]';
  var symbolTag = '[object Symbol]';
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var freeParseInt = parseInt;
  function arrayMap(array, iteratee) {
    var index = -1,
      length = array ? array.length : 0,
      result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }
  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return baseFindIndex(array, baseIsNaN, fromIndex);
    }
    var index = fromIndex - 1,
      length = array.length;
    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }
  function baseIsNaN(value) {
    return value !== value;
  }
  function baseTimes(n, iteratee) {
    var index = -1,
      result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  function baseValues(object, props) {
    return arrayMap(props, function (key) {
      return object[key];
    });
  }
  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var nativeKeys = overArg(Object.keys, Object);
  var nativeMax = Math.max;
  function arrayLikeKeys(value, inherited) {
    var result =
      isArray(value) || isArguments(value)
        ? baseTimes(value.length, String)
        : [];
    var length = result.length,
      skipIndexes = !!length;
    for (var key in value) {
      if (
        (inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))
      ) {
        result.push(key);
      }
    }
    return result;
  }
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }
    return result;
  }
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return (
      !!length &&
      (typeof value == 'number' || reIsUint.test(value)) &&
      value > -1 &&
      value % 1 == 0 &&
      value < length
    );
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
    return value === proto;
  }
  function includes(collection, value, fromIndex, guard) {
    collection = isArrayLike(collection) ? collection : values(collection);
    fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
    var length = collection.length;
    if (fromIndex < 0) {
      fromIndex = nativeMax(length + fromIndex, 0);
    }
    return isString(collection)
      ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1
      : !!length && baseIndexOf(collection, value, fromIndex) > -1;
  }
  function isArguments(value) {
    return (
      isArrayLikeObject(value) &&
      hasOwnProperty.call(value, 'callee') &&
      (!propertyIsEnumerable.call(value, 'callee') ||
        objectToString.call(value) == argsTag)
    );
  }
  var isArray = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
  }
  function isLength(value) {
    return (
      typeof value == 'number' &&
      value > -1 &&
      value % 1 == 0 &&
      value <= MAX_SAFE_INTEGER
    );
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }
  function isString(value) {
    return (
      typeof value == 'string' ||
      (!isArray(value) &&
        isObjectLike(value) &&
        objectToString.call(value) == stringTag)
    );
  }
  function isSymbol(value) {
    return (
      typeof value == 'symbol' ||
      (isObjectLike(value) && objectToString.call(value) == symbolTag)
    );
  }
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  function toInteger(value) {
    var result = toFinite(value),
      remainder = result % 1;
    return result === result ? (remainder ? result - remainder : result) : 0;
  }
  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject(other) ? other + '' : other;
    }
    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value)
      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
      : reIsBadHex.test(value)
      ? NAN
      : +value;
  }
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  function values(object) {
    return object ? baseValues(object, keys(object)) : [];
  }
  module2.exports = includes;
});

// node_modules/lodash.isboolean/index.js
var require_lodash5 = __commonJS((exports2, module2) => {
  var boolTag = '[object Boolean]';
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  function isBoolean(value) {
    return (
      value === true ||
      value === false ||
      (isObjectLike(value) && objectToString.call(value) == boolTag)
    );
  }
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }
  module2.exports = isBoolean;
});

// node_modules/lodash.isinteger/index.js
var require_lodash6 = __commonJS((exports2, module2) => {
  var INFINITY = 1 / 0;
  var MAX_INTEGER = 17976931348623157e292;
  var NAN = 0 / 0;
  var symbolTag = '[object Symbol]';
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  function isInteger(value) {
    return typeof value == 'number' && value == toInteger(value);
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }
  function isSymbol(value) {
    return (
      typeof value == 'symbol' ||
      (isObjectLike(value) && objectToString.call(value) == symbolTag)
    );
  }
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  function toInteger(value) {
    var result = toFinite(value),
      remainder = result % 1;
    return result === result ? (remainder ? result - remainder : result) : 0;
  }
  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject(other) ? other + '' : other;
    }
    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value)
      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
      : reIsBadHex.test(value)
      ? NAN
      : +value;
  }
  module2.exports = isInteger;
});

// node_modules/lodash.isnumber/index.js
var require_lodash7 = __commonJS((exports2, module2) => {
  var numberTag = '[object Number]';
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }
  function isNumber(value) {
    return (
      typeof value == 'number' ||
      (isObjectLike(value) && objectToString.call(value) == numberTag)
    );
  }
  module2.exports = isNumber;
});

// node_modules/lodash.isplainobject/index.js
var require_lodash8 = __commonJS((exports2, module2) => {
  var objectTag = '[object Object]';
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != 'function') {
      try {
        result = !!(value + '');
      } catch (e) {}
    }
    return result;
  }
  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  var objectToString = objectProto.toString;
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }
  function isPlainObject(value) {
    if (
      !isObjectLike(value) ||
      objectToString.call(value) != objectTag ||
      isHostObject(value)
    ) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
    return (
      typeof Ctor == 'function' &&
      Ctor instanceof Ctor &&
      funcToString.call(Ctor) == objectCtorString
    );
  }
  module2.exports = isPlainObject;
});

// node_modules/lodash.isstring/index.js
var require_lodash9 = __commonJS((exports2, module2) => {
  var stringTag = '[object String]';
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var isArray = Array.isArray;
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }
  function isString(value) {
    return (
      typeof value == 'string' ||
      (!isArray(value) &&
        isObjectLike(value) &&
        objectToString.call(value) == stringTag)
    );
  }
  module2.exports = isString;
});

// node_modules/lodash.once/index.js
var require_lodash10 = __commonJS((exports2, module2) => {
  var FUNC_ERROR_TEXT = 'Expected a function';
  var INFINITY = 1 / 0;
  var MAX_INTEGER = 17976931348623157e292;
  var NAN = 0 / 0;
  var symbolTag = '[object Symbol]';
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  function before(n, func) {
    var result;
    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    n = toInteger(n);
    return function () {
      if (--n > 0) {
        result = func.apply(this, arguments);
      }
      if (n <= 1) {
        func = void 0;
      }
      return result;
    };
  }
  function once(func) {
    return before(2, func);
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }
  function isSymbol(value) {
    return (
      typeof value == 'symbol' ||
      (isObjectLike(value) && objectToString.call(value) == symbolTag)
    );
  }
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  function toInteger(value) {
    var result = toFinite(value),
      remainder = result % 1;
    return result === result ? (remainder ? result - remainder : result) : 0;
  }
  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject(other) ? other + '' : other;
    }
    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value)
      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
      : reIsBadHex.test(value)
      ? NAN
      : +value;
  }
  module2.exports = once;
});

// node_modules/jsonwebtoken/sign.js
var require_sign = __commonJS((exports2, module2) => {
  var timespan = require_timespan();
  var PS_SUPPORTED = require_psSupported();
  var jws = require_jws();
  var includes = require_lodash4();
  var isBoolean = require_lodash5();
  var isInteger = require_lodash6();
  var isNumber = require_lodash7();
  var isPlainObject = require_lodash8();
  var isString = require_lodash9();
  var once = require_lodash10();
  var SUPPORTED_ALGS = [
    'RS256',
    'RS384',
    'RS512',
    'ES256',
    'ES384',
    'ES512',
    'HS256',
    'HS384',
    'HS512',
    'none',
  ];
  if (PS_SUPPORTED) {
    SUPPORTED_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');
  }
  var sign_options_schema = {
    expiresIn: {
      isValid: function (value) {
        return isInteger(value) || (isString(value) && value);
      },
      message:
        '"expiresIn" should be a number of seconds or string representing a timespan',
    },
    notBefore: {
      isValid: function (value) {
        return isInteger(value) || (isString(value) && value);
      },
      message:
        '"notBefore" should be a number of seconds or string representing a timespan',
    },
    audience: {
      isValid: function (value) {
        return isString(value) || Array.isArray(value);
      },
      message: '"audience" must be a string or array',
    },
    algorithm: {
      isValid: includes.bind(null, SUPPORTED_ALGS),
      message: '"algorithm" must be a valid string enum value',
    },
    header: { isValid: isPlainObject, message: '"header" must be an object' },
    encoding: { isValid: isString, message: '"encoding" must be a string' },
    issuer: { isValid: isString, message: '"issuer" must be a string' },
    subject: { isValid: isString, message: '"subject" must be a string' },
    jwtid: { isValid: isString, message: '"jwtid" must be a string' },
    noTimestamp: {
      isValid: isBoolean,
      message: '"noTimestamp" must be a boolean',
    },
    keyid: { isValid: isString, message: '"keyid" must be a string' },
    mutatePayload: {
      isValid: isBoolean,
      message: '"mutatePayload" must be a boolean',
    },
  };
  var registered_claims_schema = {
    iat: { isValid: isNumber, message: '"iat" should be a number of seconds' },
    exp: { isValid: isNumber, message: '"exp" should be a number of seconds' },
    nbf: { isValid: isNumber, message: '"nbf" should be a number of seconds' },
  };
  function validate(schema, allowUnknown, object, parameterName) {
    if (!isPlainObject(object)) {
      throw new Error('Expected "' + parameterName + '" to be a plain object.');
    }
    Object.keys(object).forEach(function (key) {
      var validator = schema[key];
      if (!validator) {
        if (!allowUnknown) {
          throw new Error(
            '"' + key + '" is not allowed in "' + parameterName + '"',
          );
        }
        return;
      }
      if (!validator.isValid(object[key])) {
        throw new Error(validator.message);
      }
    });
  }
  function validateOptions(options) {
    return validate(sign_options_schema, false, options, 'options');
  }
  function validatePayload(payload) {
    return validate(registered_claims_schema, true, payload, 'payload');
  }
  var options_to_payload = {
    audience: 'aud',
    issuer: 'iss',
    subject: 'sub',
    jwtid: 'jti',
  };
  var options_for_objects = [
    'expiresIn',
    'notBefore',
    'noTimestamp',
    'audience',
    'issuer',
    'subject',
    'jwtid',
  ];
  module2.exports = function (payload, secretOrPrivateKey, options, callback) {
    if (typeof options === 'function') {
      callback = options;
      options = {};
    } else {
      options = options || {};
    }
    var isObjectPayload =
      typeof payload === 'object' && !Buffer.isBuffer(payload);
    var header = Object.assign(
      {
        alg: options.algorithm || 'HS256',
        typ: isObjectPayload ? 'JWT' : void 0,
        kid: options.keyid,
      },
      options.header,
    );
    function failure(err) {
      if (callback) {
        return callback(err);
      }
      throw err;
    }
    if (!secretOrPrivateKey && options.algorithm !== 'none') {
      return failure(new Error('secretOrPrivateKey must have a value'));
    }
    if (typeof payload === 'undefined') {
      return failure(new Error('payload is required'));
    } else if (isObjectPayload) {
      try {
        validatePayload(payload);
      } catch (error) {
        return failure(error);
      }
      if (!options.mutatePayload) {
        payload = Object.assign({}, payload);
      }
    } else {
      var invalid_options = options_for_objects.filter(function (opt) {
        return typeof options[opt] !== 'undefined';
      });
      if (invalid_options.length > 0) {
        return failure(
          new Error(
            'invalid ' +
              invalid_options.join(',') +
              ' option for ' +
              typeof payload +
              ' payload',
          ),
        );
      }
    }
    if (
      typeof payload.exp !== 'undefined' &&
      typeof options.expiresIn !== 'undefined'
    ) {
      return failure(
        new Error(
          'Bad "options.expiresIn" option the payload already has an "exp" property.',
        ),
      );
    }
    if (
      typeof payload.nbf !== 'undefined' &&
      typeof options.notBefore !== 'undefined'
    ) {
      return failure(
        new Error(
          'Bad "options.notBefore" option the payload already has an "nbf" property.',
        ),
      );
    }
    try {
      validateOptions(options);
    } catch (error) {
      return failure(error);
    }
    var timestamp = payload.iat || Math.floor(Date.now() / 1e3);
    if (options.noTimestamp) {
      delete payload.iat;
    } else if (isObjectPayload) {
      payload.iat = timestamp;
    }
    if (typeof options.notBefore !== 'undefined') {
      try {
        payload.nbf = timespan(options.notBefore, timestamp);
      } catch (err) {
        return failure(err);
      }
      if (typeof payload.nbf === 'undefined') {
        return failure(
          new Error(
            '"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60',
          ),
        );
      }
    }
    if (
      typeof options.expiresIn !== 'undefined' &&
      typeof payload === 'object'
    ) {
      try {
        payload.exp = timespan(options.expiresIn, timestamp);
      } catch (err) {
        return failure(err);
      }
      if (typeof payload.exp === 'undefined') {
        return failure(
          new Error(
            '"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60',
          ),
        );
      }
    }
    Object.keys(options_to_payload).forEach(function (key) {
      var claim = options_to_payload[key];
      if (typeof options[key] !== 'undefined') {
        if (typeof payload[claim] !== 'undefined') {
          return failure(
            new Error(
              'Bad "options.' +
                key +
                '" option. The payload already has an "' +
                claim +
                '" property.',
            ),
          );
        }
        payload[claim] = options[key];
      }
    });
    var encoding = options.encoding || 'utf8';
    if (typeof callback === 'function') {
      callback = callback && once(callback);
      jws
        .createSign({
          header,
          privateKey: secretOrPrivateKey,
          payload,
          encoding,
        })
        .once('error', callback)
        .once('done', function (signature) {
          callback(null, signature);
        });
    } else {
      return jws.sign({
        header,
        payload,
        secret: secretOrPrivateKey,
        encoding,
      });
    }
  };
});

// node_modules/jsonwebtoken/index.js
var require_jsonwebtoken = __commonJS((exports2, module2) => {
  module2.exports = {
    decode: require_decode(),
    verify: require_verify2(),
    sign: require_sign(),
    JsonWebTokenError: require_JsonWebTokenError(),
    NotBeforeError: require_NotBeforeError(),
    TokenExpiredError: require_TokenExpiredError(),
  };
});

// node_modules/@cloudbase/node-sdk/lib/auth/index.js
var require_auth2 = __commonJS((exports2) => {
  'use strict';
  var __importDefault =
    (exports2 && exports2.__importDefault) ||
    function (mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
  Object.defineProperty(exports2, '__esModule', { value: true });
  var jsonwebtoken_1 = __importDefault(require_jsonwebtoken());
  var utils_1 = require_utils3();
  var code_1 = require_code3();
  var cloudbase_1 = require_cloudbase();
  var symbol_1 = require_symbol4();
  var httpRequest_1 = __importDefault(require_httpRequest());
  var checkCustomUserIdRegex = /^[a-zA-Z0-9_\-#@~=*(){}[\]:.,<>+]{4,32}$/;
  function validateUid(uid) {
    if (typeof uid !== 'string') {
      throw utils_1.E(
        Object.assign({}, code_1.ERROR.INVALID_PARAM, {
          message: 'uid must be a string',
        }),
      );
    }
    if (!checkCustomUserIdRegex.test(uid)) {
      throw utils_1.E(
        Object.assign({}, code_1.ERROR.INVALID_PARAM, {
          message: `Invalid uid: "${uid}"`,
        }),
      );
    }
  }
  function auth(cloudbase2) {
    return {
      getUserInfo() {
        const {
          WX_OPENID,
          WX_APPID,
          TCB_UUID,
          TCB_CUSTOM_USER_ID,
          TCB_ISANONYMOUS_USER,
        } = cloudbase_1.CloudBase.getCloudbaseContext();
        return {
          openId: WX_OPENID || '',
          appId: WX_APPID || '',
          uid: TCB_UUID || '',
          customUserId: TCB_CUSTOM_USER_ID || '',
          isAnonymous: TCB_ISANONYMOUS_USER === 'true' ? true : false,
        };
      },
      getEndUserInfo(uid, opts) {
        const {
          WX_OPENID,
          WX_APPID,
          TCB_UUID,
          TCB_CUSTOM_USER_ID,
          TCB_ISANONYMOUS_USER,
        } = cloudbase_1.CloudBase.getCloudbaseContext();
        const defaultUserInfo = {
          openId: WX_OPENID || '',
          appId: WX_APPID || '',
          uid: TCB_UUID || '',
          customUserId: TCB_CUSTOM_USER_ID || '',
          isAnonymous: TCB_ISANONYMOUS_USER === 'true' ? true : false,
        };
        if (uid === void 0) {
          return {
            userInfo: defaultUserInfo,
          };
        }
        validateUid(uid);
        const params = {
          action: 'auth.getUserInfoForAdmin',
          uuid: uid,
        };
        return httpRequest_1
          .default({
            config: cloudbase2.config,
            params,
            method: 'post',
            opts,
            headers: {
              'content-type': 'application/json',
            },
          })
          .then((res) => {
            if (res.code) {
              return res;
            }
            return {
              userInfo: Object.assign({}, defaultUserInfo, res.data),
              requestId: res.requestId,
            };
          });
      },
      async getAuthContext(context) {
        const {
          TCB_UUID,
          LOGINTYPE,
          QQ_OPENID,
          QQ_APPID,
        } = cloudbase_1.CloudBase.getCloudbaseContext(context);
        const res = {
          uid: TCB_UUID,
          loginType: LOGINTYPE,
        };
        if (LOGINTYPE === 'QQ-MINI') {
          res.appId = QQ_APPID;
          res.openId = QQ_OPENID;
        }
        return res;
      },
      getClientIP() {
        const { TCB_SOURCE_IP } = cloudbase_1.CloudBase.getCloudbaseContext();
        return TCB_SOURCE_IP || '';
      },
      createTicket: (uid, options = {}) => {
        validateUid(uid);
        const timestamp = new Date().getTime();
        const {
          TCB_ENV,
          SCF_NAMESPACE,
        } = cloudbase_1.CloudBase.getCloudbaseContext();
        const { credentials } = cloudbase2.config;
        const { env_id } = credentials;
        let { envName } = cloudbase2.config;
        if (!envName) {
          throw utils_1.E(
            Object.assign({}, code_1.ERROR.INVALID_PARAM, {
              message: 'no env in config',
            }),
          );
        }
        if (!env_id) {
          throw utils_1.E(
            Object.assign({}, code_1.ERROR.INVALID_PARAM, {
              message:
                '\u5F53\u524D\u79C1\u94A5\u672A\u5305\u542Benv_id \u4FE1\u606F\uFF0C \u8BF7\u524D\u5F80\u817E\u8BAF\u4E91\u4E91\u5F00\u53D1\u63A7\u5236\u53F0\uFF0C\u83B7\u53D6\u81EA\u5B9A\u4E49\u767B\u5F55\u6700\u65B0\u79C1\u94A5',
            }),
          );
        }
        if (envName === symbol_1.SYMBOL_CURRENT_ENV) {
          envName = TCB_ENV || SCF_NAMESPACE;
        }
        if (env_id && env_id !== envName) {
          throw utils_1.E(
            Object.assign({}, code_1.ERROR.INVALID_PARAM, {
              message:
                '\u5F53\u524D\u79C1\u94A5\u6240\u5C5E\u73AF\u5883\u4E0E init \u6307\u5B9A\u73AF\u5883\u4E0D\u4E00\u81F4\uFF01',
            }),
          );
        }
        const {
          refresh = 3600 * 1e3,
          expire = timestamp + 7 * 24 * 60 * 60 * 1e3,
        } = options;
        const token = jsonwebtoken_1.default.sign(
          {
            alg: 'RS256',
            env: envName,
            iat: timestamp,
            exp: timestamp + 10 * 60 * 1e3,
            uid,
            refresh,
            expire,
          },
          credentials.private_key,
          { algorithm: 'RS256' },
        );
        return credentials.private_key_id + '/@@/' + token;
      },
    };
  }
  exports2.auth = auth;
});

// node_modules/@cloudbase/node-sdk/lib/wx/index.js
var require_wx = __commonJS((exports2) => {
  'use strict';
  var __importDefault =
    (exports2 && exports2.__importDefault) ||
    function (mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
  Object.defineProperty(exports2, '__esModule', { value: true });
  var httpRequest_1 = __importDefault(require_httpRequest());
  var utils_1 = require_utils3();
  var code_1 = require_code3();
  function validateCrossAccount(config, opts = {}) {
    let getCrossAccountInfo =
      opts.getCrossAccountInfo || config.getCrossAccountInfo;
    if (getCrossAccountInfo) {
      throw utils_1.E(
        Object.assign({}, code_1.ERROR.INVALID_PARAM, {
          message: 'invalid config: getCrossAccountInfo',
        }),
      );
    }
  }
  async function callWxOpenApi(
    cloudbase2,
    { apiName, apiOptions, cgiName, requestData },
    opts,
  ) {
    let transformRequestData;
    try {
      transformRequestData = requestData ? JSON.stringify(requestData) : '';
    } catch (e) {
      throw utils_1.E(
        Object.assign({}, e, {
          code: code_1.ERROR.INVALID_PARAM.code,
          message: '\u5BF9\u8C61\u51FA\u73B0\u4E86\u5FAA\u73AF\u5F15\u7528',
        }),
      );
    }
    validateCrossAccount(cloudbase2.config, opts);
    const params = {
      action: 'wx.api',
      apiName,
      apiOptions,
      cgiName,
      requestData: transformRequestData,
    };
    return httpRequest_1
      .default({
        config: cloudbase2.config,
        params,
        method: 'post',
        opts,
        headers: {
          'content-type': 'application/json',
        },
      })
      .then((res) => {
        if (res.code) {
          return res;
        }
        let result;
        try {
          result = JSON.parse(res.data.responseData);
        } catch (e) {
          result = res.data.responseData;
        }
        return {
          result,
          requestId: res.requestId,
        };
      });
  }
  exports2.callWxOpenApi = callWxOpenApi;
  async function callCompatibleWxOpenApi(
    cloudbase2,
    { apiName, apiOptions, cgiName, requestData },
    opts,
  ) {
    validateCrossAccount(cloudbase2.config, opts);
    const params = {
      action: 'wx.openApi',
      apiName,
      apiOptions,
      cgiName,
      requestData,
    };
    return httpRequest_1
      .default({
        config: cloudbase2.config,
        method: 'post',
        headers: { 'content-type': 'multipart/form-data' },
        params,
        isFormData: true,
        opts,
      })
      .then((res) => res);
  }
  exports2.callCompatibleWxOpenApi = callCompatibleWxOpenApi;
  async function callWxPayApi(
    cloudbase2,
    { apiName, apiOptions, cgiName, requestData },
    opts,
  ) {
    validateCrossAccount(cloudbase2.config, opts);
    const params = {
      action: 'wx.wxPayApi',
      apiName,
      apiOptions,
      cgiName,
      requestData,
    };
    return httpRequest_1.default({
      config: cloudbase2.config,
      method: 'post',
      headers: { 'content-type': 'multipart/form-data' },
      params,
      isFormData: true,
      opts,
    });
  }
  exports2.callWxPayApi = callWxPayApi;
});

// node_modules/xml2js/lib/defaults.js
var require_defaults = __commonJS((exports2) => {
  (function () {
    exports2.defaults = {
      0.1: {
        explicitCharkey: false,
        trim: true,
        normalize: true,
        normalizeTags: false,
        attrkey: '@',
        charkey: '#',
        explicitArray: false,
        ignoreAttrs: false,
        mergeAttrs: false,
        explicitRoot: false,
        validator: null,
        xmlns: false,
        explicitChildren: false,
        childkey: '@@',
        charsAsChildren: false,
        includeWhiteChars: false,
        async: false,
        strict: true,
        attrNameProcessors: null,
        attrValueProcessors: null,
        tagNameProcessors: null,
        valueProcessors: null,
        emptyTag: '',
      },
      0.2: {
        explicitCharkey: false,
        trim: false,
        normalize: false,
        normalizeTags: false,
        attrkey: '$',
        charkey: '_',
        explicitArray: true,
        ignoreAttrs: false,
        mergeAttrs: false,
        explicitRoot: true,
        validator: null,
        xmlns: false,
        explicitChildren: false,
        preserveChildrenOrder: false,
        childkey: '$$',
        charsAsChildren: false,
        includeWhiteChars: false,
        async: false,
        strict: true,
        attrNameProcessors: null,
        attrValueProcessors: null,
        tagNameProcessors: null,
        valueProcessors: null,
        rootName: 'root',
        xmldec: {
          version: '1.0',
          encoding: 'UTF-8',
          standalone: true,
        },
        doctype: null,
        renderOpts: {
          pretty: true,
          indent: '  ',
          newline: '\n',
        },
        headless: false,
        chunkSize: 1e4,
        emptyTag: '',
        cdata: false,
      },
    };
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/Utility.js
var require_Utility = __commonJS((exports2, module2) => {
  (function () {
    var assign,
      getValue,
      isArray,
      isEmpty,
      isFunction,
      isObject,
      isPlainObject,
      slice = [].slice,
      hasProp = {}.hasOwnProperty;
    assign = function () {
      var i, key, len, source, sources, target;
      (target = arguments[0]),
        (sources = 2 <= arguments.length ? slice.call(arguments, 1) : []);
      if (isFunction(Object.assign)) {
        Object.assign.apply(null, arguments);
      } else {
        for (i = 0, len = sources.length; i < len; i++) {
          source = sources[i];
          if (source != null) {
            for (key in source) {
              if (!hasProp.call(source, key)) continue;
              target[key] = source[key];
            }
          }
        }
      }
      return target;
    };
    isFunction = function (val) {
      return (
        !!val && Object.prototype.toString.call(val) === '[object Function]'
      );
    };
    isObject = function (val) {
      var ref;
      return !!val && ((ref = typeof val) === 'function' || ref === 'object');
    };
    isArray = function (val) {
      if (isFunction(Array.isArray)) {
        return Array.isArray(val);
      } else {
        return Object.prototype.toString.call(val) === '[object Array]';
      }
    };
    isEmpty = function (val) {
      var key;
      if (isArray(val)) {
        return !val.length;
      } else {
        for (key in val) {
          if (!hasProp.call(val, key)) continue;
          return false;
        }
        return true;
      }
    };
    isPlainObject = function (val) {
      var ctor, proto;
      return (
        isObject(val) &&
        (proto = Object.getPrototypeOf(val)) &&
        (ctor = proto.constructor) &&
        typeof ctor === 'function' &&
        ctor instanceof ctor &&
        Function.prototype.toString.call(ctor) ===
          Function.prototype.toString.call(Object)
      );
    };
    getValue = function (obj) {
      if (isFunction(obj.valueOf)) {
        return obj.valueOf();
      } else {
        return obj;
      }
    };
    module2.exports.assign = assign;
    module2.exports.isFunction = isFunction;
    module2.exports.isObject = isObject;
    module2.exports.isArray = isArray;
    module2.exports.isEmpty = isEmpty;
    module2.exports.isPlainObject = isPlainObject;
    module2.exports.getValue = getValue;
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/XMLDOMImplementation.js
var require_XMLDOMImplementation = __commonJS((exports2, module2) => {
  (function () {
    var XMLDOMImplementation;
    module2.exports = XMLDOMImplementation = (function () {
      function XMLDOMImplementation2() {}
      XMLDOMImplementation2.prototype.hasFeature = function (feature, version) {
        return true;
      };
      XMLDOMImplementation2.prototype.createDocumentType = function (
        qualifiedName,
        publicId,
        systemId,
      ) {
        throw new Error('This DOM method is not implemented.');
      };
      XMLDOMImplementation2.prototype.createDocument = function (
        namespaceURI,
        qualifiedName,
        doctype,
      ) {
        throw new Error('This DOM method is not implemented.');
      };
      XMLDOMImplementation2.prototype.createHTMLDocument = function (title) {
        throw new Error('This DOM method is not implemented.');
      };
      XMLDOMImplementation2.prototype.getFeature = function (feature, version) {
        throw new Error('This DOM method is not implemented.');
      };
      return XMLDOMImplementation2;
    })();
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js
var require_XMLDOMErrorHandler = __commonJS((exports2, module2) => {
  (function () {
    var XMLDOMErrorHandler;
    module2.exports = XMLDOMErrorHandler = (function () {
      function XMLDOMErrorHandler2() {}
      XMLDOMErrorHandler2.prototype.handleError = function (error) {
        throw new Error(error);
      };
      return XMLDOMErrorHandler2;
    })();
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/XMLDOMStringList.js
var require_XMLDOMStringList = __commonJS((exports2, module2) => {
  (function () {
    var XMLDOMStringList;
    module2.exports = XMLDOMStringList = (function () {
      function XMLDOMStringList2(arr) {
        this.arr = arr || [];
      }
      Object.defineProperty(XMLDOMStringList2.prototype, 'length', {
        get: function () {
          return this.arr.length;
        },
      });
      XMLDOMStringList2.prototype.item = function (index) {
        return this.arr[index] || null;
      };
      XMLDOMStringList2.prototype.contains = function (str) {
        return this.arr.indexOf(str) !== -1;
      };
      return XMLDOMStringList2;
    })();
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/XMLDOMConfiguration.js
var require_XMLDOMConfiguration = __commonJS((exports2, module2) => {
  (function () {
    var XMLDOMConfiguration, XMLDOMErrorHandler, XMLDOMStringList;
    XMLDOMErrorHandler = require_XMLDOMErrorHandler();
    XMLDOMStringList = require_XMLDOMStringList();
    module2.exports = XMLDOMConfiguration = (function () {
      function XMLDOMConfiguration2() {
        var clonedSelf;
        this.defaultParams = {
          'canonical-form': false,
          'cdata-sections': false,
          comments: false,
          'datatype-normalization': false,
          'element-content-whitespace': true,
          entities: true,
          'error-handler': new XMLDOMErrorHandler(),
          infoset: true,
          'validate-if-schema': false,
          namespaces: true,
          'namespace-declarations': true,
          'normalize-characters': false,
          'schema-location': '',
          'schema-type': '',
          'split-cdata-sections': true,
          validate: false,
          'well-formed': true,
        };
        this.params = clonedSelf = Object.create(this.defaultParams);
      }
      Object.defineProperty(XMLDOMConfiguration2.prototype, 'parameterNames', {
        get: function () {
          return new XMLDOMStringList(Object.keys(this.defaultParams));
        },
      });
      XMLDOMConfiguration2.prototype.getParameter = function (name) {
        if (this.params.hasOwnProperty(name)) {
          return this.params[name];
        } else {
          return null;
        }
      };
      XMLDOMConfiguration2.prototype.canSetParameter = function (name, value) {
        return true;
      };
      XMLDOMConfiguration2.prototype.setParameter = function (name, value) {
        if (value != null) {
          return (this.params[name] = value);
        } else {
          return delete this.params[name];
        }
      };
      return XMLDOMConfiguration2;
    })();
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/NodeType.js
var require_NodeType = __commonJS((exports2, module2) => {
  (function () {
    module2.exports = {
      Element: 1,
      Attribute: 2,
      Text: 3,
      CData: 4,
      EntityReference: 5,
      EntityDeclaration: 6,
      ProcessingInstruction: 7,
      Comment: 8,
      Document: 9,
      DocType: 10,
      DocumentFragment: 11,
      NotationDeclaration: 12,
      Declaration: 201,
      Raw: 202,
      AttributeDeclaration: 203,
      ElementDeclaration: 204,
      Dummy: 205,
    };
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/XMLAttribute.js
var require_XMLAttribute = __commonJS((exports2, module2) => {
  (function () {
    var NodeType, XMLAttribute, XMLNode;
    NodeType = require_NodeType();
    XMLNode = require_XMLNode();
    module2.exports = XMLAttribute = (function () {
      function XMLAttribute2(parent, name, value) {
        this.parent = parent;
        if (this.parent) {
          this.options = this.parent.options;
          this.stringify = this.parent.stringify;
        }
        if (name == null) {
          throw new Error('Missing attribute name. ' + this.debugInfo(name));
        }
        this.name = this.stringify.name(name);
        this.value = this.stringify.attValue(value);
        this.type = NodeType.Attribute;
        this.isId = false;
        this.schemaTypeInfo = null;
      }
      Object.defineProperty(XMLAttribute2.prototype, 'nodeType', {
        get: function () {
          return this.type;
        },
      });
      Object.defineProperty(XMLAttribute2.prototype, 'ownerElement', {
        get: function () {
          return this.parent;
        },
      });
      Object.defineProperty(XMLAttribute2.prototype, 'textContent', {
        get: function () {
          return this.value;
        },
        set: function (value) {
          return (this.value = value || '');
        },
      });
      Object.defineProperty(XMLAttribute2.prototype, 'namespaceURI', {
        get: function () {
          return '';
        },
      });
      Object.defineProperty(XMLAttribute2.prototype, 'prefix', {
        get: function () {
          return '';
        },
      });
      Object.defineProperty(XMLAttribute2.prototype, 'localName', {
        get: function () {
          return this.name;
        },
      });
      Object.defineProperty(XMLAttribute2.prototype, 'specified', {
        get: function () {
          return true;
        },
      });
      XMLAttribute2.prototype.clone = function () {
        return Object.create(this);
      };
      XMLAttribute2.prototype.toString = function (options) {
        return this.options.writer.attribute(
          this,
          this.options.writer.filterOptions(options),
        );
      };
      XMLAttribute2.prototype.debugInfo = function (name) {
        name = name || this.name;
        if (name == null) {
          return 'parent: <' + this.parent.name + '>';
        } else {
          return (
            'attribute: {' + name + '}, parent: <' + this.parent.name + '>'
          );
        }
      };
      XMLAttribute2.prototype.isEqualNode = function (node) {
        if (node.namespaceURI !== this.namespaceURI) {
          return false;
        }
        if (node.prefix !== this.prefix) {
          return false;
        }
        if (node.localName !== this.localName) {
          return false;
        }
        if (node.value !== this.value) {
          return false;
        }
        return true;
      };
      return XMLAttribute2;
    })();
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/XMLNamedNodeMap.js
var require_XMLNamedNodeMap = __commonJS((exports2, module2) => {
  (function () {
    var XMLNamedNodeMap;
    module2.exports = XMLNamedNodeMap = (function () {
      function XMLNamedNodeMap2(nodes) {
        this.nodes = nodes;
      }
      Object.defineProperty(XMLNamedNodeMap2.prototype, 'length', {
        get: function () {
          return Object.keys(this.nodes).length || 0;
        },
      });
      XMLNamedNodeMap2.prototype.clone = function () {
        return (this.nodes = null);
      };
      XMLNamedNodeMap2.prototype.getNamedItem = function (name) {
        return this.nodes[name];
      };
      XMLNamedNodeMap2.prototype.setNamedItem = function (node) {
        var oldNode;
        oldNode = this.nodes[node.nodeName];
        this.nodes[node.nodeName] = node;
        return oldNode || null;
      };
      XMLNamedNodeMap2.prototype.removeNamedItem = function (name) {
        var oldNode;
        oldNode = this.nodes[name];
        delete this.nodes[name];
        return oldNode || null;
      };
      XMLNamedNodeMap2.prototype.item = function (index) {
        return this.nodes[Object.keys(this.nodes)[index]] || null;
      };
      XMLNamedNodeMap2.prototype.getNamedItemNS = function (
        namespaceURI,
        localName,
      ) {
        throw new Error('This DOM method is not implemented.');
      };
      XMLNamedNodeMap2.prototype.setNamedItemNS = function (node) {
        throw new Error('This DOM method is not implemented.');
      };
      XMLNamedNodeMap2.prototype.removeNamedItemNS = function (
        namespaceURI,
        localName,
      ) {
        throw new Error('This DOM method is not implemented.');
      };
      return XMLNamedNodeMap2;
    })();
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/XMLElement.js
var require_XMLElement = __commonJS((exports2, module2) => {
  (function () {
    var NodeType,
      XMLAttribute,
      XMLElement,
      XMLNamedNodeMap,
      XMLNode,
      getValue,
      isFunction,
      isObject,
      ref,
      extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
      hasProp = {}.hasOwnProperty;
    (ref = require_Utility()),
      (isObject = ref.isObject),
      (isFunction = ref.isFunction),
      (getValue = ref.getValue);
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    XMLAttribute = require_XMLAttribute();
    XMLNamedNodeMap = require_XMLNamedNodeMap();
    module2.exports = XMLElement = (function (superClass) {
      extend(XMLElement2, superClass);
      function XMLElement2(parent, name, attributes) {
        var child, j, len, ref1;
        XMLElement2.__super__.constructor.call(this, parent);
        if (name == null) {
          throw new Error('Missing element name. ' + this.debugInfo());
        }
        this.name = this.stringify.name(name);
        this.type = NodeType.Element;
        this.attribs = {};
        this.schemaTypeInfo = null;
        if (attributes != null) {
          this.attribute(attributes);
        }
        if (parent.type === NodeType.Document) {
          this.isRoot = true;
          this.documentObject = parent;
          parent.rootObject = this;
          if (parent.children) {
            ref1 = parent.children;
            for (j = 0, len = ref1.length; j < len; j++) {
              child = ref1[j];
              if (child.type === NodeType.DocType) {
                child.name = this.name;
                break;
              }
            }
          }
        }
      }
      Object.defineProperty(XMLElement2.prototype, 'tagName', {
        get: function () {
          return this.name;
        },
      });
      Object.defineProperty(XMLElement2.prototype, 'namespaceURI', {
        get: function () {
          return '';
        },
      });
      Object.defineProperty(XMLElement2.prototype, 'prefix', {
        get: function () {
          return '';
        },
      });
      Object.defineProperty(XMLElement2.prototype, 'localName', {
        get: function () {
          return this.name;
        },
      });
      Object.defineProperty(XMLElement2.prototype, 'id', {
        get: function () {
          throw new Error(
            'This DOM method is not implemented.' + this.debugInfo(),
          );
        },
      });
      Object.defineProperty(XMLElement2.prototype, 'className', {
        get: function () {
          throw new Error(
            'This DOM method is not implemented.' + this.debugInfo(),
          );
        },
      });
      Object.defineProperty(XMLElement2.prototype, 'classList', {
        get: function () {
          throw new Error(
            'This DOM method is not implemented.' + this.debugInfo(),
          );
        },
      });
      Object.defineProperty(XMLElement2.prototype, 'attributes', {
        get: function () {
          if (!this.attributeMap || !this.attributeMap.nodes) {
            this.attributeMap = new XMLNamedNodeMap(this.attribs);
          }
          return this.attributeMap;
        },
      });
      XMLElement2.prototype.clone = function () {
        var att, attName, clonedSelf, ref1;
        clonedSelf = Object.create(this);
        if (clonedSelf.isRoot) {
          clonedSelf.documentObject = null;
        }
        clonedSelf.attribs = {};
        ref1 = this.attribs;
        for (attName in ref1) {
          if (!hasProp.call(ref1, attName)) continue;
          att = ref1[attName];
          clonedSelf.attribs[attName] = att.clone();
        }
        clonedSelf.children = [];
        this.children.forEach(function (child) {
          var clonedChild;
          clonedChild = child.clone();
          clonedChild.parent = clonedSelf;
          return clonedSelf.children.push(clonedChild);
        });
        return clonedSelf;
      };
      XMLElement2.prototype.attribute = function (name, value) {
        var attName, attValue;
        if (name != null) {
          name = getValue(name);
        }
        if (isObject(name)) {
          for (attName in name) {
            if (!hasProp.call(name, attName)) continue;
            attValue = name[attName];
            this.attribute(attName, attValue);
          }
        } else {
          if (isFunction(value)) {
            value = value.apply();
          }
          if (this.options.keepNullAttributes && value == null) {
            this.attribs[name] = new XMLAttribute(this, name, '');
          } else if (value != null) {
            this.attribs[name] = new XMLAttribute(this, name, value);
          }
        }
        return this;
      };
      XMLElement2.prototype.removeAttribute = function (name) {
        var attName, j, len;
        if (name == null) {
          throw new Error('Missing attribute name. ' + this.debugInfo());
        }
        name = getValue(name);
        if (Array.isArray(name)) {
          for (j = 0, len = name.length; j < len; j++) {
            attName = name[j];
            delete this.attribs[attName];
          }
        } else {
          delete this.attribs[name];
        }
        return this;
      };
      XMLElement2.prototype.toString = function (options) {
        return this.options.writer.element(
          this,
          this.options.writer.filterOptions(options),
        );
      };
      XMLElement2.prototype.att = function (name, value) {
        return this.attribute(name, value);
      };
      XMLElement2.prototype.a = function (name, value) {
        return this.attribute(name, value);
      };
      XMLElement2.prototype.getAttribute = function (name) {
        if (this.attribs.hasOwnProperty(name)) {
          return this.attribs[name].value;
        } else {
          return null;
        }
      };
      XMLElement2.prototype.setAttribute = function (name, value) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLElement2.prototype.getAttributeNode = function (name) {
        if (this.attribs.hasOwnProperty(name)) {
          return this.attribs[name];
        } else {
          return null;
        }
      };
      XMLElement2.prototype.setAttributeNode = function (newAttr) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLElement2.prototype.removeAttributeNode = function (oldAttr) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLElement2.prototype.getElementsByTagName = function (name) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLElement2.prototype.getAttributeNS = function (
        namespaceURI,
        localName,
      ) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLElement2.prototype.setAttributeNS = function (
        namespaceURI,
        qualifiedName,
        value,
      ) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLElement2.prototype.removeAttributeNS = function (
        namespaceURI,
        localName,
      ) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLElement2.prototype.getAttributeNodeNS = function (
        namespaceURI,
        localName,
      ) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLElement2.prototype.setAttributeNodeNS = function (newAttr) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLElement2.prototype.getElementsByTagNameNS = function (
        namespaceURI,
        localName,
      ) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLElement2.prototype.hasAttribute = function (name) {
        return this.attribs.hasOwnProperty(name);
      };
      XMLElement2.prototype.hasAttributeNS = function (
        namespaceURI,
        localName,
      ) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLElement2.prototype.setIdAttribute = function (name, isId) {
        if (this.attribs.hasOwnProperty(name)) {
          return this.attribs[name].isId;
        } else {
          return isId;
        }
      };
      XMLElement2.prototype.setIdAttributeNS = function (
        namespaceURI,
        localName,
        isId,
      ) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLElement2.prototype.setIdAttributeNode = function (idAttr, isId) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLElement2.prototype.getElementsByTagName = function (tagname) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLElement2.prototype.getElementsByTagNameNS = function (
        namespaceURI,
        localName,
      ) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLElement2.prototype.getElementsByClassName = function (classNames) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLElement2.prototype.isEqualNode = function (node) {
        var i, j, ref1;
        if (
          !XMLElement2.__super__.isEqualNode
            .apply(this, arguments)
            .isEqualNode(node)
        ) {
          return false;
        }
        if (node.namespaceURI !== this.namespaceURI) {
          return false;
        }
        if (node.prefix !== this.prefix) {
          return false;
        }
        if (node.localName !== this.localName) {
          return false;
        }
        if (node.attribs.length !== this.attribs.length) {
          return false;
        }
        for (
          i = j = 0, ref1 = this.attribs.length - 1;
          0 <= ref1 ? j <= ref1 : j >= ref1;
          i = 0 <= ref1 ? ++j : --j
        ) {
          if (!this.attribs[i].isEqualNode(node.attribs[i])) {
            return false;
          }
        }
        return true;
      };
      return XMLElement2;
    })(XMLNode);
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/XMLCharacterData.js
var require_XMLCharacterData = __commonJS((exports2, module2) => {
  (function () {
    var XMLCharacterData,
      XMLNode,
      extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
      hasProp = {}.hasOwnProperty;
    XMLNode = require_XMLNode();
    module2.exports = XMLCharacterData = (function (superClass) {
      extend(XMLCharacterData2, superClass);
      function XMLCharacterData2(parent) {
        XMLCharacterData2.__super__.constructor.call(this, parent);
        this.value = '';
      }
      Object.defineProperty(XMLCharacterData2.prototype, 'data', {
        get: function () {
          return this.value;
        },
        set: function (value) {
          return (this.value = value || '');
        },
      });
      Object.defineProperty(XMLCharacterData2.prototype, 'length', {
        get: function () {
          return this.value.length;
        },
      });
      Object.defineProperty(XMLCharacterData2.prototype, 'textContent', {
        get: function () {
          return this.value;
        },
        set: function (value) {
          return (this.value = value || '');
        },
      });
      XMLCharacterData2.prototype.clone = function () {
        return Object.create(this);
      };
      XMLCharacterData2.prototype.substringData = function (offset, count) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLCharacterData2.prototype.appendData = function (arg) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLCharacterData2.prototype.insertData = function (offset, arg) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLCharacterData2.prototype.deleteData = function (offset, count) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLCharacterData2.prototype.replaceData = function (offset, count, arg) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLCharacterData2.prototype.isEqualNode = function (node) {
        if (
          !XMLCharacterData2.__super__.isEqualNode
            .apply(this, arguments)
            .isEqualNode(node)
        ) {
          return false;
        }
        if (node.data !== this.data) {
          return false;
        }
        return true;
      };
      return XMLCharacterData2;
    })(XMLNode);
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/XMLCData.js
var require_XMLCData = __commonJS((exports2, module2) => {
  (function () {
    var NodeType,
      XMLCData,
      XMLCharacterData,
      extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
      hasProp = {}.hasOwnProperty;
    NodeType = require_NodeType();
    XMLCharacterData = require_XMLCharacterData();
    module2.exports = XMLCData = (function (superClass) {
      extend(XMLCData2, superClass);
      function XMLCData2(parent, text) {
        XMLCData2.__super__.constructor.call(this, parent);
        if (text == null) {
          throw new Error('Missing CDATA text. ' + this.debugInfo());
        }
        this.name = '#cdata-section';
        this.type = NodeType.CData;
        this.value = this.stringify.cdata(text);
      }
      XMLCData2.prototype.clone = function () {
        return Object.create(this);
      };
      XMLCData2.prototype.toString = function (options) {
        return this.options.writer.cdata(
          this,
          this.options.writer.filterOptions(options),
        );
      };
      return XMLCData2;
    })(XMLCharacterData);
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/XMLComment.js
var require_XMLComment = __commonJS((exports2, module2) => {
  (function () {
    var NodeType,
      XMLCharacterData,
      XMLComment,
      extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
      hasProp = {}.hasOwnProperty;
    NodeType = require_NodeType();
    XMLCharacterData = require_XMLCharacterData();
    module2.exports = XMLComment = (function (superClass) {
      extend(XMLComment2, superClass);
      function XMLComment2(parent, text) {
        XMLComment2.__super__.constructor.call(this, parent);
        if (text == null) {
          throw new Error('Missing comment text. ' + this.debugInfo());
        }
        this.name = '#comment';
        this.type = NodeType.Comment;
        this.value = this.stringify.comment(text);
      }
      XMLComment2.prototype.clone = function () {
        return Object.create(this);
      };
      XMLComment2.prototype.toString = function (options) {
        return this.options.writer.comment(
          this,
          this.options.writer.filterOptions(options),
        );
      };
      return XMLComment2;
    })(XMLCharacterData);
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/XMLDeclaration.js
var require_XMLDeclaration = __commonJS((exports2, module2) => {
  (function () {
    var NodeType,
      XMLDeclaration,
      XMLNode,
      isObject,
      extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
      hasProp = {}.hasOwnProperty;
    isObject = require_Utility().isObject;
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    module2.exports = XMLDeclaration = (function (superClass) {
      extend(XMLDeclaration2, superClass);
      function XMLDeclaration2(parent, version, encoding, standalone) {
        var ref;
        XMLDeclaration2.__super__.constructor.call(this, parent);
        if (isObject(version)) {
          (ref = version),
            (version = ref.version),
            (encoding = ref.encoding),
            (standalone = ref.standalone);
        }
        if (!version) {
          version = '1.0';
        }
        this.type = NodeType.Declaration;
        this.version = this.stringify.xmlVersion(version);
        if (encoding != null) {
          this.encoding = this.stringify.xmlEncoding(encoding);
        }
        if (standalone != null) {
          this.standalone = this.stringify.xmlStandalone(standalone);
        }
      }
      XMLDeclaration2.prototype.toString = function (options) {
        return this.options.writer.declaration(
          this,
          this.options.writer.filterOptions(options),
        );
      };
      return XMLDeclaration2;
    })(XMLNode);
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/XMLDTDAttList.js
var require_XMLDTDAttList = __commonJS((exports2, module2) => {
  (function () {
    var NodeType,
      XMLDTDAttList,
      XMLNode,
      extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
      hasProp = {}.hasOwnProperty;
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    module2.exports = XMLDTDAttList = (function (superClass) {
      extend(XMLDTDAttList2, superClass);
      function XMLDTDAttList2(
        parent,
        elementName,
        attributeName,
        attributeType,
        defaultValueType,
        defaultValue,
      ) {
        XMLDTDAttList2.__super__.constructor.call(this, parent);
        if (elementName == null) {
          throw new Error('Missing DTD element name. ' + this.debugInfo());
        }
        if (attributeName == null) {
          throw new Error(
            'Missing DTD attribute name. ' + this.debugInfo(elementName),
          );
        }
        if (!attributeType) {
          throw new Error(
            'Missing DTD attribute type. ' + this.debugInfo(elementName),
          );
        }
        if (!defaultValueType) {
          throw new Error(
            'Missing DTD attribute default. ' + this.debugInfo(elementName),
          );
        }
        if (defaultValueType.indexOf('#') !== 0) {
          defaultValueType = '#' + defaultValueType;
        }
        if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
          throw new Error(
            'Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. ' +
              this.debugInfo(elementName),
          );
        }
        if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
          throw new Error(
            'Default value only applies to #FIXED or #DEFAULT. ' +
              this.debugInfo(elementName),
          );
        }
        this.elementName = this.stringify.name(elementName);
        this.type = NodeType.AttributeDeclaration;
        this.attributeName = this.stringify.name(attributeName);
        this.attributeType = this.stringify.dtdAttType(attributeType);
        if (defaultValue) {
          this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
        }
        this.defaultValueType = defaultValueType;
      }
      XMLDTDAttList2.prototype.toString = function (options) {
        return this.options.writer.dtdAttList(
          this,
          this.options.writer.filterOptions(options),
        );
      };
      return XMLDTDAttList2;
    })(XMLNode);
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/XMLDTDEntity.js
var require_XMLDTDEntity = __commonJS((exports2, module2) => {
  (function () {
    var NodeType,
      XMLDTDEntity,
      XMLNode,
      isObject,
      extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
      hasProp = {}.hasOwnProperty;
    isObject = require_Utility().isObject;
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    module2.exports = XMLDTDEntity = (function (superClass) {
      extend(XMLDTDEntity2, superClass);
      function XMLDTDEntity2(parent, pe, name, value) {
        XMLDTDEntity2.__super__.constructor.call(this, parent);
        if (name == null) {
          throw new Error('Missing DTD entity name. ' + this.debugInfo(name));
        }
        if (value == null) {
          throw new Error('Missing DTD entity value. ' + this.debugInfo(name));
        }
        this.pe = !!pe;
        this.name = this.stringify.name(name);
        this.type = NodeType.EntityDeclaration;
        if (!isObject(value)) {
          this.value = this.stringify.dtdEntityValue(value);
          this.internal = true;
        } else {
          if (!value.pubID && !value.sysID) {
            throw new Error(
              'Public and/or system identifiers are required for an external entity. ' +
                this.debugInfo(name),
            );
          }
          if (value.pubID && !value.sysID) {
            throw new Error(
              'System identifier is required for a public external entity. ' +
                this.debugInfo(name),
            );
          }
          this.internal = false;
          if (value.pubID != null) {
            this.pubID = this.stringify.dtdPubID(value.pubID);
          }
          if (value.sysID != null) {
            this.sysID = this.stringify.dtdSysID(value.sysID);
          }
          if (value.nData != null) {
            this.nData = this.stringify.dtdNData(value.nData);
          }
          if (this.pe && this.nData) {
            throw new Error(
              'Notation declaration is not allowed in a parameter entity. ' +
                this.debugInfo(name),
            );
          }
        }
      }
      Object.defineProperty(XMLDTDEntity2.prototype, 'publicId', {
        get: function () {
          return this.pubID;
        },
      });
      Object.defineProperty(XMLDTDEntity2.prototype, 'systemId', {
        get: function () {
          return this.sysID;
        },
      });
      Object.defineProperty(XMLDTDEntity2.prototype, 'notationName', {
        get: function () {
          return this.nData || null;
        },
      });
      Object.defineProperty(XMLDTDEntity2.prototype, 'inputEncoding', {
        get: function () {
          return null;
        },
      });
      Object.defineProperty(XMLDTDEntity2.prototype, 'xmlEncoding', {
        get: function () {
          return null;
        },
      });
      Object.defineProperty(XMLDTDEntity2.prototype, 'xmlVersion', {
        get: function () {
          return null;
        },
      });
      XMLDTDEntity2.prototype.toString = function (options) {
        return this.options.writer.dtdEntity(
          this,
          this.options.writer.filterOptions(options),
        );
      };
      return XMLDTDEntity2;
    })(XMLNode);
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/XMLDTDElement.js
var require_XMLDTDElement = __commonJS((exports2, module2) => {
  (function () {
    var NodeType,
      XMLDTDElement,
      XMLNode,
      extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
      hasProp = {}.hasOwnProperty;
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    module2.exports = XMLDTDElement = (function (superClass) {
      extend(XMLDTDElement2, superClass);
      function XMLDTDElement2(parent, name, value) {
        XMLDTDElement2.__super__.constructor.call(this, parent);
        if (name == null) {
          throw new Error('Missing DTD element name. ' + this.debugInfo());
        }
        if (!value) {
          value = '(#PCDATA)';
        }
        if (Array.isArray(value)) {
          value = '(' + value.join(',') + ')';
        }
        this.name = this.stringify.name(name);
        this.type = NodeType.ElementDeclaration;
        this.value = this.stringify.dtdElementValue(value);
      }
      XMLDTDElement2.prototype.toString = function (options) {
        return this.options.writer.dtdElement(
          this,
          this.options.writer.filterOptions(options),
        );
      };
      return XMLDTDElement2;
    })(XMLNode);
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/XMLDTDNotation.js
var require_XMLDTDNotation = __commonJS((exports2, module2) => {
  (function () {
    var NodeType,
      XMLDTDNotation,
      XMLNode,
      extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
      hasProp = {}.hasOwnProperty;
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    module2.exports = XMLDTDNotation = (function (superClass) {
      extend(XMLDTDNotation2, superClass);
      function XMLDTDNotation2(parent, name, value) {
        XMLDTDNotation2.__super__.constructor.call(this, parent);
        if (name == null) {
          throw new Error('Missing DTD notation name. ' + this.debugInfo(name));
        }
        if (!value.pubID && !value.sysID) {
          throw new Error(
            'Public or system identifiers are required for an external entity. ' +
              this.debugInfo(name),
          );
        }
        this.name = this.stringify.name(name);
        this.type = NodeType.NotationDeclaration;
        if (value.pubID != null) {
          this.pubID = this.stringify.dtdPubID(value.pubID);
        }
        if (value.sysID != null) {
          this.sysID = this.stringify.dtdSysID(value.sysID);
        }
      }
      Object.defineProperty(XMLDTDNotation2.prototype, 'publicId', {
        get: function () {
          return this.pubID;
        },
      });
      Object.defineProperty(XMLDTDNotation2.prototype, 'systemId', {
        get: function () {
          return this.sysID;
        },
      });
      XMLDTDNotation2.prototype.toString = function (options) {
        return this.options.writer.dtdNotation(
          this,
          this.options.writer.filterOptions(options),
        );
      };
      return XMLDTDNotation2;
    })(XMLNode);
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/XMLDocType.js
var require_XMLDocType = __commonJS((exports2, module2) => {
  (function () {
    var NodeType,
      XMLDTDAttList,
      XMLDTDElement,
      XMLDTDEntity,
      XMLDTDNotation,
      XMLDocType,
      XMLNamedNodeMap,
      XMLNode,
      isObject,
      extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
      hasProp = {}.hasOwnProperty;
    isObject = require_Utility().isObject;
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    XMLDTDAttList = require_XMLDTDAttList();
    XMLDTDEntity = require_XMLDTDEntity();
    XMLDTDElement = require_XMLDTDElement();
    XMLDTDNotation = require_XMLDTDNotation();
    XMLNamedNodeMap = require_XMLNamedNodeMap();
    module2.exports = XMLDocType = (function (superClass) {
      extend(XMLDocType2, superClass);
      function XMLDocType2(parent, pubID, sysID) {
        var child, i, len, ref, ref1, ref2;
        XMLDocType2.__super__.constructor.call(this, parent);
        this.type = NodeType.DocType;
        if (parent.children) {
          ref = parent.children;
          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            if (child.type === NodeType.Element) {
              this.name = child.name;
              break;
            }
          }
        }
        this.documentObject = parent;
        if (isObject(pubID)) {
          (ref1 = pubID), (pubID = ref1.pubID), (sysID = ref1.sysID);
        }
        if (sysID == null) {
          (ref2 = [pubID, sysID]), (sysID = ref2[0]), (pubID = ref2[1]);
        }
        if (pubID != null) {
          this.pubID = this.stringify.dtdPubID(pubID);
        }
        if (sysID != null) {
          this.sysID = this.stringify.dtdSysID(sysID);
        }
      }
      Object.defineProperty(XMLDocType2.prototype, 'entities', {
        get: function () {
          var child, i, len, nodes, ref;
          nodes = {};
          ref = this.children;
          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            if (child.type === NodeType.EntityDeclaration && !child.pe) {
              nodes[child.name] = child;
            }
          }
          return new XMLNamedNodeMap(nodes);
        },
      });
      Object.defineProperty(XMLDocType2.prototype, 'notations', {
        get: function () {
          var child, i, len, nodes, ref;
          nodes = {};
          ref = this.children;
          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            if (child.type === NodeType.NotationDeclaration) {
              nodes[child.name] = child;
            }
          }
          return new XMLNamedNodeMap(nodes);
        },
      });
      Object.defineProperty(XMLDocType2.prototype, 'publicId', {
        get: function () {
          return this.pubID;
        },
      });
      Object.defineProperty(XMLDocType2.prototype, 'systemId', {
        get: function () {
          return this.sysID;
        },
      });
      Object.defineProperty(XMLDocType2.prototype, 'internalSubset', {
        get: function () {
          throw new Error(
            'This DOM method is not implemented.' + this.debugInfo(),
          );
        },
      });
      XMLDocType2.prototype.element = function (name, value) {
        var child;
        child = new XMLDTDElement(this, name, value);
        this.children.push(child);
        return this;
      };
      XMLDocType2.prototype.attList = function (
        elementName,
        attributeName,
        attributeType,
        defaultValueType,
        defaultValue,
      ) {
        var child;
        child = new XMLDTDAttList(
          this,
          elementName,
          attributeName,
          attributeType,
          defaultValueType,
          defaultValue,
        );
        this.children.push(child);
        return this;
      };
      XMLDocType2.prototype.entity = function (name, value) {
        var child;
        child = new XMLDTDEntity(this, false, name, value);
        this.children.push(child);
        return this;
      };
      XMLDocType2.prototype.pEntity = function (name, value) {
        var child;
        child = new XMLDTDEntity(this, true, name, value);
        this.children.push(child);
        return this;
      };
      XMLDocType2.prototype.notation = function (name, value) {
        var child;
        child = new XMLDTDNotation(this, name, value);
        this.children.push(child);
        return this;
      };
      XMLDocType2.prototype.toString = function (options) {
        return this.options.writer.docType(
          this,
          this.options.writer.filterOptions(options),
        );
      };
      XMLDocType2.prototype.ele = function (name, value) {
        return this.element(name, value);
      };
      XMLDocType2.prototype.att = function (
        elementName,
        attributeName,
        attributeType,
        defaultValueType,
        defaultValue,
      ) {
        return this.attList(
          elementName,
          attributeName,
          attributeType,
          defaultValueType,
          defaultValue,
        );
      };
      XMLDocType2.prototype.ent = function (name, value) {
        return this.entity(name, value);
      };
      XMLDocType2.prototype.pent = function (name, value) {
        return this.pEntity(name, value);
      };
      XMLDocType2.prototype.not = function (name, value) {
        return this.notation(name, value);
      };
      XMLDocType2.prototype.up = function () {
        return this.root() || this.documentObject;
      };
      XMLDocType2.prototype.isEqualNode = function (node) {
        if (
          !XMLDocType2.__super__.isEqualNode
            .apply(this, arguments)
            .isEqualNode(node)
        ) {
          return false;
        }
        if (node.name !== this.name) {
          return false;
        }
        if (node.publicId !== this.publicId) {
          return false;
        }
        if (node.systemId !== this.systemId) {
          return false;
        }
        return true;
      };
      return XMLDocType2;
    })(XMLNode);
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/XMLRaw.js
var require_XMLRaw = __commonJS((exports2, module2) => {
  (function () {
    var NodeType,
      XMLNode,
      XMLRaw,
      extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
      hasProp = {}.hasOwnProperty;
    NodeType = require_NodeType();
    XMLNode = require_XMLNode();
    module2.exports = XMLRaw = (function (superClass) {
      extend(XMLRaw2, superClass);
      function XMLRaw2(parent, text) {
        XMLRaw2.__super__.constructor.call(this, parent);
        if (text == null) {
          throw new Error('Missing raw text. ' + this.debugInfo());
        }
        this.type = NodeType.Raw;
        this.value = this.stringify.raw(text);
      }
      XMLRaw2.prototype.clone = function () {
        return Object.create(this);
      };
      XMLRaw2.prototype.toString = function (options) {
        return this.options.writer.raw(
          this,
          this.options.writer.filterOptions(options),
        );
      };
      return XMLRaw2;
    })(XMLNode);
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/XMLText.js
var require_XMLText = __commonJS((exports2, module2) => {
  (function () {
    var NodeType,
      XMLCharacterData,
      XMLText,
      extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
      hasProp = {}.hasOwnProperty;
    NodeType = require_NodeType();
    XMLCharacterData = require_XMLCharacterData();
    module2.exports = XMLText = (function (superClass) {
      extend(XMLText2, superClass);
      function XMLText2(parent, text) {
        XMLText2.__super__.constructor.call(this, parent);
        if (text == null) {
          throw new Error('Missing element text. ' + this.debugInfo());
        }
        this.name = '#text';
        this.type = NodeType.Text;
        this.value = this.stringify.text(text);
      }
      Object.defineProperty(XMLText2.prototype, 'isElementContentWhitespace', {
        get: function () {
          throw new Error(
            'This DOM method is not implemented.' + this.debugInfo(),
          );
        },
      });
      Object.defineProperty(XMLText2.prototype, 'wholeText', {
        get: function () {
          var next, prev, str;
          str = '';
          prev = this.previousSibling;
          while (prev) {
            str = prev.data + str;
            prev = prev.previousSibling;
          }
          str += this.data;
          next = this.nextSibling;
          while (next) {
            str = str + next.data;
            next = next.nextSibling;
          }
          return str;
        },
      });
      XMLText2.prototype.clone = function () {
        return Object.create(this);
      };
      XMLText2.prototype.toString = function (options) {
        return this.options.writer.text(
          this,
          this.options.writer.filterOptions(options),
        );
      };
      XMLText2.prototype.splitText = function (offset) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLText2.prototype.replaceWholeText = function (content) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      return XMLText2;
    })(XMLCharacterData);
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/XMLProcessingInstruction.js
var require_XMLProcessingInstruction = __commonJS((exports2, module2) => {
  (function () {
    var NodeType,
      XMLCharacterData,
      XMLProcessingInstruction,
      extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
      hasProp = {}.hasOwnProperty;
    NodeType = require_NodeType();
    XMLCharacterData = require_XMLCharacterData();
    module2.exports = XMLProcessingInstruction = (function (superClass) {
      extend(XMLProcessingInstruction2, superClass);
      function XMLProcessingInstruction2(parent, target, value) {
        XMLProcessingInstruction2.__super__.constructor.call(this, parent);
        if (target == null) {
          throw new Error('Missing instruction target. ' + this.debugInfo());
        }
        this.type = NodeType.ProcessingInstruction;
        this.target = this.stringify.insTarget(target);
        this.name = this.target;
        if (value) {
          this.value = this.stringify.insValue(value);
        }
      }
      XMLProcessingInstruction2.prototype.clone = function () {
        return Object.create(this);
      };
      XMLProcessingInstruction2.prototype.toString = function (options) {
        return this.options.writer.processingInstruction(
          this,
          this.options.writer.filterOptions(options),
        );
      };
      XMLProcessingInstruction2.prototype.isEqualNode = function (node) {
        if (
          !XMLProcessingInstruction2.__super__.isEqualNode
            .apply(this, arguments)
            .isEqualNode(node)
        ) {
          return false;
        }
        if (node.target !== this.target) {
          return false;
        }
        return true;
      };
      return XMLProcessingInstruction2;
    })(XMLCharacterData);
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/XMLDummy.js
var require_XMLDummy = __commonJS((exports2, module2) => {
  (function () {
    var NodeType,
      XMLDummy,
      XMLNode,
      extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
      hasProp = {}.hasOwnProperty;
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    module2.exports = XMLDummy = (function (superClass) {
      extend(XMLDummy2, superClass);
      function XMLDummy2(parent) {
        XMLDummy2.__super__.constructor.call(this, parent);
        this.type = NodeType.Dummy;
      }
      XMLDummy2.prototype.clone = function () {
        return Object.create(this);
      };
      XMLDummy2.prototype.toString = function (options) {
        return '';
      };
      return XMLDummy2;
    })(XMLNode);
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/XMLNodeList.js
var require_XMLNodeList = __commonJS((exports2, module2) => {
  (function () {
    var XMLNodeList;
    module2.exports = XMLNodeList = (function () {
      function XMLNodeList2(nodes) {
        this.nodes = nodes;
      }
      Object.defineProperty(XMLNodeList2.prototype, 'length', {
        get: function () {
          return this.nodes.length || 0;
        },
      });
      XMLNodeList2.prototype.clone = function () {
        return (this.nodes = null);
      };
      XMLNodeList2.prototype.item = function (index) {
        return this.nodes[index] || null;
      };
      return XMLNodeList2;
    })();
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/DocumentPosition.js
var require_DocumentPosition = __commonJS((exports2, module2) => {
  (function () {
    module2.exports = {
      Disconnected: 1,
      Preceding: 2,
      Following: 4,
      Contains: 8,
      ContainedBy: 16,
      ImplementationSpecific: 32,
    };
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/XMLNode.js
var require_XMLNode = __commonJS((exports2, module2) => {
  (function () {
    var DocumentPosition,
      NodeType,
      XMLCData,
      XMLComment,
      XMLDeclaration,
      XMLDocType,
      XMLDummy,
      XMLElement,
      XMLNamedNodeMap,
      XMLNode,
      XMLNodeList,
      XMLProcessingInstruction,
      XMLRaw,
      XMLText,
      getValue,
      isEmpty,
      isFunction,
      isObject,
      ref1,
      hasProp = {}.hasOwnProperty;
    (ref1 = require_Utility()),
      (isObject = ref1.isObject),
      (isFunction = ref1.isFunction),
      (isEmpty = ref1.isEmpty),
      (getValue = ref1.getValue);
    XMLElement = null;
    XMLCData = null;
    XMLComment = null;
    XMLDeclaration = null;
    XMLDocType = null;
    XMLRaw = null;
    XMLText = null;
    XMLProcessingInstruction = null;
    XMLDummy = null;
    NodeType = null;
    XMLNodeList = null;
    XMLNamedNodeMap = null;
    DocumentPosition = null;
    module2.exports = XMLNode = (function () {
      function XMLNode2(parent1) {
        this.parent = parent1;
        if (this.parent) {
          this.options = this.parent.options;
          this.stringify = this.parent.stringify;
        }
        this.value = null;
        this.children = [];
        this.baseURI = null;
        if (!XMLElement) {
          XMLElement = require_XMLElement();
          XMLCData = require_XMLCData();
          XMLComment = require_XMLComment();
          XMLDeclaration = require_XMLDeclaration();
          XMLDocType = require_XMLDocType();
          XMLRaw = require_XMLRaw();
          XMLText = require_XMLText();
          XMLProcessingInstruction = require_XMLProcessingInstruction();
          XMLDummy = require_XMLDummy();
          NodeType = require_NodeType();
          XMLNodeList = require_XMLNodeList();
          XMLNamedNodeMap = require_XMLNamedNodeMap();
          DocumentPosition = require_DocumentPosition();
        }
      }
      Object.defineProperty(XMLNode2.prototype, 'nodeName', {
        get: function () {
          return this.name;
        },
      });
      Object.defineProperty(XMLNode2.prototype, 'nodeType', {
        get: function () {
          return this.type;
        },
      });
      Object.defineProperty(XMLNode2.prototype, 'nodeValue', {
        get: function () {
          return this.value;
        },
      });
      Object.defineProperty(XMLNode2.prototype, 'parentNode', {
        get: function () {
          return this.parent;
        },
      });
      Object.defineProperty(XMLNode2.prototype, 'childNodes', {
        get: function () {
          if (!this.childNodeList || !this.childNodeList.nodes) {
            this.childNodeList = new XMLNodeList(this.children);
          }
          return this.childNodeList;
        },
      });
      Object.defineProperty(XMLNode2.prototype, 'firstChild', {
        get: function () {
          return this.children[0] || null;
        },
      });
      Object.defineProperty(XMLNode2.prototype, 'lastChild', {
        get: function () {
          return this.children[this.children.length - 1] || null;
        },
      });
      Object.defineProperty(XMLNode2.prototype, 'previousSibling', {
        get: function () {
          var i;
          i = this.parent.children.indexOf(this);
          return this.parent.children[i - 1] || null;
        },
      });
      Object.defineProperty(XMLNode2.prototype, 'nextSibling', {
        get: function () {
          var i;
          i = this.parent.children.indexOf(this);
          return this.parent.children[i + 1] || null;
        },
      });
      Object.defineProperty(XMLNode2.prototype, 'ownerDocument', {
        get: function () {
          return this.document() || null;
        },
      });
      Object.defineProperty(XMLNode2.prototype, 'textContent', {
        get: function () {
          var child, j, len, ref2, str;
          if (
            this.nodeType === NodeType.Element ||
            this.nodeType === NodeType.DocumentFragment
          ) {
            str = '';
            ref2 = this.children;
            for (j = 0, len = ref2.length; j < len; j++) {
              child = ref2[j];
              if (child.textContent) {
                str += child.textContent;
              }
            }
            return str;
          } else {
            return null;
          }
        },
        set: function (value) {
          throw new Error(
            'This DOM method is not implemented.' + this.debugInfo(),
          );
        },
      });
      XMLNode2.prototype.setParent = function (parent) {
        var child, j, len, ref2, results;
        this.parent = parent;
        if (parent) {
          this.options = parent.options;
          this.stringify = parent.stringify;
        }
        ref2 = this.children;
        results = [];
        for (j = 0, len = ref2.length; j < len; j++) {
          child = ref2[j];
          results.push(child.setParent(this));
        }
        return results;
      };
      XMLNode2.prototype.element = function (name, attributes, text) {
        var childNode, item, j, k, key, lastChild, len, len1, ref2, ref3, val;
        lastChild = null;
        if (attributes === null && text == null) {
          (ref2 = [{}, null]), (attributes = ref2[0]), (text = ref2[1]);
        }
        if (attributes == null) {
          attributes = {};
        }
        attributes = getValue(attributes);
        if (!isObject(attributes)) {
          (ref3 = [attributes, text]), (text = ref3[0]), (attributes = ref3[1]);
        }
        if (name != null) {
          name = getValue(name);
        }
        if (Array.isArray(name)) {
          for (j = 0, len = name.length; j < len; j++) {
            item = name[j];
            lastChild = this.element(item);
          }
        } else if (isFunction(name)) {
          lastChild = this.element(name.apply());
        } else if (isObject(name)) {
          for (key in name) {
            if (!hasProp.call(name, key)) continue;
            val = name[key];
            if (isFunction(val)) {
              val = val.apply();
            }
            if (
              !this.options.ignoreDecorators &&
              this.stringify.convertAttKey &&
              key.indexOf(this.stringify.convertAttKey) === 0
            ) {
              lastChild = this.attribute(
                key.substr(this.stringify.convertAttKey.length),
                val,
              );
            } else if (
              !this.options.separateArrayItems &&
              Array.isArray(val) &&
              isEmpty(val)
            ) {
              lastChild = this.dummy();
            } else if (isObject(val) && isEmpty(val)) {
              lastChild = this.element(key);
            } else if (!this.options.keepNullNodes && val == null) {
              lastChild = this.dummy();
            } else if (!this.options.separateArrayItems && Array.isArray(val)) {
              for (k = 0, len1 = val.length; k < len1; k++) {
                item = val[k];
                childNode = {};
                childNode[key] = item;
                lastChild = this.element(childNode);
              }
            } else if (isObject(val)) {
              if (
                !this.options.ignoreDecorators &&
                this.stringify.convertTextKey &&
                key.indexOf(this.stringify.convertTextKey) === 0
              ) {
                lastChild = this.element(val);
              } else {
                lastChild = this.element(key);
                lastChild.element(val);
              }
            } else {
              lastChild = this.element(key, val);
            }
          }
        } else if (!this.options.keepNullNodes && text === null) {
          lastChild = this.dummy();
        } else {
          if (
            !this.options.ignoreDecorators &&
            this.stringify.convertTextKey &&
            name.indexOf(this.stringify.convertTextKey) === 0
          ) {
            lastChild = this.text(text);
          } else if (
            !this.options.ignoreDecorators &&
            this.stringify.convertCDataKey &&
            name.indexOf(this.stringify.convertCDataKey) === 0
          ) {
            lastChild = this.cdata(text);
          } else if (
            !this.options.ignoreDecorators &&
            this.stringify.convertCommentKey &&
            name.indexOf(this.stringify.convertCommentKey) === 0
          ) {
            lastChild = this.comment(text);
          } else if (
            !this.options.ignoreDecorators &&
            this.stringify.convertRawKey &&
            name.indexOf(this.stringify.convertRawKey) === 0
          ) {
            lastChild = this.raw(text);
          } else if (
            !this.options.ignoreDecorators &&
            this.stringify.convertPIKey &&
            name.indexOf(this.stringify.convertPIKey) === 0
          ) {
            lastChild = this.instruction(
              name.substr(this.stringify.convertPIKey.length),
              text,
            );
          } else {
            lastChild = this.node(name, attributes, text);
          }
        }
        if (lastChild == null) {
          throw new Error(
            'Could not create any elements with: ' +
              name +
              '. ' +
              this.debugInfo(),
          );
        }
        return lastChild;
      };
      XMLNode2.prototype.insertBefore = function (name, attributes, text) {
        var child, i, newChild, refChild, removed;
        if (name != null ? name.type : void 0) {
          newChild = name;
          refChild = attributes;
          newChild.setParent(this);
          if (refChild) {
            i = children.indexOf(refChild);
            removed = children.splice(i);
            children.push(newChild);
            Array.prototype.push.apply(children, removed);
          } else {
            children.push(newChild);
          }
          return newChild;
        } else {
          if (this.isRoot) {
            throw new Error(
              'Cannot insert elements at root level. ' + this.debugInfo(name),
            );
          }
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i);
          child = this.parent.element(name, attributes, text);
          Array.prototype.push.apply(this.parent.children, removed);
          return child;
        }
      };
      XMLNode2.prototype.insertAfter = function (name, attributes, text) {
        var child, i, removed;
        if (this.isRoot) {
          throw new Error(
            'Cannot insert elements at root level. ' + this.debugInfo(name),
          );
        }
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i + 1);
        child = this.parent.element(name, attributes, text);
        Array.prototype.push.apply(this.parent.children, removed);
        return child;
      };
      XMLNode2.prototype.remove = function () {
        var i, ref2;
        if (this.isRoot) {
          throw new Error(
            'Cannot remove the root element. ' + this.debugInfo(),
          );
        }
        i = this.parent.children.indexOf(this);
        [].splice.apply(
          this.parent.children,
          [i, i - i + 1].concat((ref2 = [])),
        ),
          ref2;
        return this.parent;
      };
      XMLNode2.prototype.node = function (name, attributes, text) {
        var child, ref2;
        if (name != null) {
          name = getValue(name);
        }
        attributes || (attributes = {});
        attributes = getValue(attributes);
        if (!isObject(attributes)) {
          (ref2 = [attributes, text]), (text = ref2[0]), (attributes = ref2[1]);
        }
        child = new XMLElement(this, name, attributes);
        if (text != null) {
          child.text(text);
        }
        this.children.push(child);
        return child;
      };
      XMLNode2.prototype.text = function (value) {
        var child;
        if (isObject(value)) {
          this.element(value);
        }
        child = new XMLText(this, value);
        this.children.push(child);
        return this;
      };
      XMLNode2.prototype.cdata = function (value) {
        var child;
        child = new XMLCData(this, value);
        this.children.push(child);
        return this;
      };
      XMLNode2.prototype.comment = function (value) {
        var child;
        child = new XMLComment(this, value);
        this.children.push(child);
        return this;
      };
      XMLNode2.prototype.commentBefore = function (value) {
        var child, i, removed;
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i);
        child = this.parent.comment(value);
        Array.prototype.push.apply(this.parent.children, removed);
        return this;
      };
      XMLNode2.prototype.commentAfter = function (value) {
        var child, i, removed;
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i + 1);
        child = this.parent.comment(value);
        Array.prototype.push.apply(this.parent.children, removed);
        return this;
      };
      XMLNode2.prototype.raw = function (value) {
        var child;
        child = new XMLRaw(this, value);
        this.children.push(child);
        return this;
      };
      XMLNode2.prototype.dummy = function () {
        var child;
        child = new XMLDummy(this);
        return child;
      };
      XMLNode2.prototype.instruction = function (target, value) {
        var insTarget, insValue, instruction, j, len;
        if (target != null) {
          target = getValue(target);
        }
        if (value != null) {
          value = getValue(value);
        }
        if (Array.isArray(target)) {
          for (j = 0, len = target.length; j < len; j++) {
            insTarget = target[j];
            this.instruction(insTarget);
          }
        } else if (isObject(target)) {
          for (insTarget in target) {
            if (!hasProp.call(target, insTarget)) continue;
            insValue = target[insTarget];
            this.instruction(insTarget, insValue);
          }
        } else {
          if (isFunction(value)) {
            value = value.apply();
          }
          instruction = new XMLProcessingInstruction(this, target, value);
          this.children.push(instruction);
        }
        return this;
      };
      XMLNode2.prototype.instructionBefore = function (target, value) {
        var child, i, removed;
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i);
        child = this.parent.instruction(target, value);
        Array.prototype.push.apply(this.parent.children, removed);
        return this;
      };
      XMLNode2.prototype.instructionAfter = function (target, value) {
        var child, i, removed;
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i + 1);
        child = this.parent.instruction(target, value);
        Array.prototype.push.apply(this.parent.children, removed);
        return this;
      };
      XMLNode2.prototype.declaration = function (
        version,
        encoding,
        standalone,
      ) {
        var doc, xmldec;
        doc = this.document();
        xmldec = new XMLDeclaration(doc, version, encoding, standalone);
        if (doc.children.length === 0) {
          doc.children.unshift(xmldec);
        } else if (doc.children[0].type === NodeType.Declaration) {
          doc.children[0] = xmldec;
        } else {
          doc.children.unshift(xmldec);
        }
        return doc.root() || doc;
      };
      XMLNode2.prototype.dtd = function (pubID, sysID) {
        var child, doc, doctype, i, j, k, len, len1, ref2, ref3;
        doc = this.document();
        doctype = new XMLDocType(doc, pubID, sysID);
        ref2 = doc.children;
        for (i = j = 0, len = ref2.length; j < len; i = ++j) {
          child = ref2[i];
          if (child.type === NodeType.DocType) {
            doc.children[i] = doctype;
            return doctype;
          }
        }
        ref3 = doc.children;
        for (i = k = 0, len1 = ref3.length; k < len1; i = ++k) {
          child = ref3[i];
          if (child.isRoot) {
            doc.children.splice(i, 0, doctype);
            return doctype;
          }
        }
        doc.children.push(doctype);
        return doctype;
      };
      XMLNode2.prototype.up = function () {
        if (this.isRoot) {
          throw new Error(
            'The root node has no parent. Use doc() if you need to get the document object.',
          );
        }
        return this.parent;
      };
      XMLNode2.prototype.root = function () {
        var node;
        node = this;
        while (node) {
          if (node.type === NodeType.Document) {
            return node.rootObject;
          } else if (node.isRoot) {
            return node;
          } else {
            node = node.parent;
          }
        }
      };
      XMLNode2.prototype.document = function () {
        var node;
        node = this;
        while (node) {
          if (node.type === NodeType.Document) {
            return node;
          } else {
            node = node.parent;
          }
        }
      };
      XMLNode2.prototype.end = function (options) {
        return this.document().end(options);
      };
      XMLNode2.prototype.prev = function () {
        var i;
        i = this.parent.children.indexOf(this);
        if (i < 1) {
          throw new Error('Already at the first node. ' + this.debugInfo());
        }
        return this.parent.children[i - 1];
      };
      XMLNode2.prototype.next = function () {
        var i;
        i = this.parent.children.indexOf(this);
        if (i === -1 || i === this.parent.children.length - 1) {
          throw new Error('Already at the last node. ' + this.debugInfo());
        }
        return this.parent.children[i + 1];
      };
      XMLNode2.prototype.importDocument = function (doc) {
        var clonedRoot;
        clonedRoot = doc.root().clone();
        clonedRoot.parent = this;
        clonedRoot.isRoot = false;
        this.children.push(clonedRoot);
        return this;
      };
      XMLNode2.prototype.debugInfo = function (name) {
        var ref2, ref3;
        name = name || this.name;
        if (
          name == null &&
          !((ref2 = this.parent) != null ? ref2.name : void 0)
        ) {
          return '';
        } else if (name == null) {
          return 'parent: <' + this.parent.name + '>';
        } else if (!((ref3 = this.parent) != null ? ref3.name : void 0)) {
          return 'node: <' + name + '>';
        } else {
          return 'node: <' + name + '>, parent: <' + this.parent.name + '>';
        }
      };
      XMLNode2.prototype.ele = function (name, attributes, text) {
        return this.element(name, attributes, text);
      };
      XMLNode2.prototype.nod = function (name, attributes, text) {
        return this.node(name, attributes, text);
      };
      XMLNode2.prototype.txt = function (value) {
        return this.text(value);
      };
      XMLNode2.prototype.dat = function (value) {
        return this.cdata(value);
      };
      XMLNode2.prototype.com = function (value) {
        return this.comment(value);
      };
      XMLNode2.prototype.ins = function (target, value) {
        return this.instruction(target, value);
      };
      XMLNode2.prototype.doc = function () {
        return this.document();
      };
      XMLNode2.prototype.dec = function (version, encoding, standalone) {
        return this.declaration(version, encoding, standalone);
      };
      XMLNode2.prototype.e = function (name, attributes, text) {
        return this.element(name, attributes, text);
      };
      XMLNode2.prototype.n = function (name, attributes, text) {
        return this.node(name, attributes, text);
      };
      XMLNode2.prototype.t = function (value) {
        return this.text(value);
      };
      XMLNode2.prototype.d = function (value) {
        return this.cdata(value);
      };
      XMLNode2.prototype.c = function (value) {
        return this.comment(value);
      };
      XMLNode2.prototype.r = function (value) {
        return this.raw(value);
      };
      XMLNode2.prototype.i = function (target, value) {
        return this.instruction(target, value);
      };
      XMLNode2.prototype.u = function () {
        return this.up();
      };
      XMLNode2.prototype.importXMLBuilder = function (doc) {
        return this.importDocument(doc);
      };
      XMLNode2.prototype.replaceChild = function (newChild, oldChild) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLNode2.prototype.removeChild = function (oldChild) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLNode2.prototype.appendChild = function (newChild) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLNode2.prototype.hasChildNodes = function () {
        return this.children.length !== 0;
      };
      XMLNode2.prototype.cloneNode = function (deep) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLNode2.prototype.normalize = function () {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLNode2.prototype.isSupported = function (feature, version) {
        return true;
      };
      XMLNode2.prototype.hasAttributes = function () {
        return this.attribs.length !== 0;
      };
      XMLNode2.prototype.compareDocumentPosition = function (other) {
        var ref, res;
        ref = this;
        if (ref === other) {
          return 0;
        } else if (this.document() !== other.document()) {
          res =
            DocumentPosition.Disconnected |
            DocumentPosition.ImplementationSpecific;
          if (Math.random() < 0.5) {
            res |= DocumentPosition.Preceding;
          } else {
            res |= DocumentPosition.Following;
          }
          return res;
        } else if (ref.isAncestor(other)) {
          return DocumentPosition.Contains | DocumentPosition.Preceding;
        } else if (ref.isDescendant(other)) {
          return DocumentPosition.Contains | DocumentPosition.Following;
        } else if (ref.isPreceding(other)) {
          return DocumentPosition.Preceding;
        } else {
          return DocumentPosition.Following;
        }
      };
      XMLNode2.prototype.isSameNode = function (other) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLNode2.prototype.lookupPrefix = function (namespaceURI) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLNode2.prototype.isDefaultNamespace = function (namespaceURI) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLNode2.prototype.lookupNamespaceURI = function (prefix) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLNode2.prototype.isEqualNode = function (node) {
        var i, j, ref2;
        if (node.nodeType !== this.nodeType) {
          return false;
        }
        if (node.children.length !== this.children.length) {
          return false;
        }
        for (
          i = j = 0, ref2 = this.children.length - 1;
          0 <= ref2 ? j <= ref2 : j >= ref2;
          i = 0 <= ref2 ? ++j : --j
        ) {
          if (!this.children[i].isEqualNode(node.children[i])) {
            return false;
          }
        }
        return true;
      };
      XMLNode2.prototype.getFeature = function (feature, version) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLNode2.prototype.setUserData = function (key, data, handler) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLNode2.prototype.getUserData = function (key) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLNode2.prototype.contains = function (other) {
        if (!other) {
          return false;
        }
        return other === this || this.isDescendant(other);
      };
      XMLNode2.prototype.isDescendant = function (node) {
        var child, isDescendantChild, j, len, ref2;
        ref2 = this.children;
        for (j = 0, len = ref2.length; j < len; j++) {
          child = ref2[j];
          if (node === child) {
            return true;
          }
          isDescendantChild = child.isDescendant(node);
          if (isDescendantChild) {
            return true;
          }
        }
        return false;
      };
      XMLNode2.prototype.isAncestor = function (node) {
        return node.isDescendant(this);
      };
      XMLNode2.prototype.isPreceding = function (node) {
        var nodePos, thisPos;
        nodePos = this.treePosition(node);
        thisPos = this.treePosition(this);
        if (nodePos === -1 || thisPos === -1) {
          return false;
        } else {
          return nodePos < thisPos;
        }
      };
      XMLNode2.prototype.isFollowing = function (node) {
        var nodePos, thisPos;
        nodePos = this.treePosition(node);
        thisPos = this.treePosition(this);
        if (nodePos === -1 || thisPos === -1) {
          return false;
        } else {
          return nodePos > thisPos;
        }
      };
      XMLNode2.prototype.treePosition = function (node) {
        var found, pos;
        pos = 0;
        found = false;
        this.foreachTreeNode(this.document(), function (childNode) {
          pos++;
          if (!found && childNode === node) {
            return (found = true);
          }
        });
        if (found) {
          return pos;
        } else {
          return -1;
        }
      };
      XMLNode2.prototype.foreachTreeNode = function (node, func) {
        var child, j, len, ref2, res;
        node || (node = this.document());
        ref2 = node.children;
        for (j = 0, len = ref2.length; j < len; j++) {
          child = ref2[j];
          if ((res = func(child))) {
            return res;
          } else {
            res = this.foreachTreeNode(child, func);
            if (res) {
              return res;
            }
          }
        }
      };
      return XMLNode2;
    })();
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/XMLStringifier.js
var require_XMLStringifier = __commonJS((exports2, module2) => {
  (function () {
    var XMLStringifier,
      bind = function (fn, me) {
        return function () {
          return fn.apply(me, arguments);
        };
      },
      hasProp = {}.hasOwnProperty;
    module2.exports = XMLStringifier = (function () {
      function XMLStringifier2(options) {
        this.assertLegalName = bind(this.assertLegalName, this);
        this.assertLegalChar = bind(this.assertLegalChar, this);
        var key, ref, value;
        options || (options = {});
        this.options = options;
        if (!this.options.version) {
          this.options.version = '1.0';
        }
        ref = options.stringify || {};
        for (key in ref) {
          if (!hasProp.call(ref, key)) continue;
          value = ref[key];
          this[key] = value;
        }
      }
      XMLStringifier2.prototype.name = function (val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalName('' + val || '');
      };
      XMLStringifier2.prototype.text = function (val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar(this.textEscape('' + val || ''));
      };
      XMLStringifier2.prototype.cdata = function (val) {
        if (this.options.noValidation) {
          return val;
        }
        val = '' + val || '';
        val = val.replace(']]>', ']]]]><![CDATA[>');
        return this.assertLegalChar(val);
      };
      XMLStringifier2.prototype.comment = function (val) {
        if (this.options.noValidation) {
          return val;
        }
        val = '' + val || '';
        if (val.match(/--/)) {
          throw new Error('Comment text cannot contain double-hypen: ' + val);
        }
        return this.assertLegalChar(val);
      };
      XMLStringifier2.prototype.raw = function (val) {
        if (this.options.noValidation) {
          return val;
        }
        return '' + val || '';
      };
      XMLStringifier2.prototype.attValue = function (val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar(this.attEscape((val = '' + val || '')));
      };
      XMLStringifier2.prototype.insTarget = function (val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar('' + val || '');
      };
      XMLStringifier2.prototype.insValue = function (val) {
        if (this.options.noValidation) {
          return val;
        }
        val = '' + val || '';
        if (val.match(/\?>/)) {
          throw new Error('Invalid processing instruction value: ' + val);
        }
        return this.assertLegalChar(val);
      };
      XMLStringifier2.prototype.xmlVersion = function (val) {
        if (this.options.noValidation) {
          return val;
        }
        val = '' + val || '';
        if (!val.match(/1\.[0-9]+/)) {
          throw new Error('Invalid version number: ' + val);
        }
        return val;
      };
      XMLStringifier2.prototype.xmlEncoding = function (val) {
        if (this.options.noValidation) {
          return val;
        }
        val = '' + val || '';
        if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
          throw new Error('Invalid encoding: ' + val);
        }
        return this.assertLegalChar(val);
      };
      XMLStringifier2.prototype.xmlStandalone = function (val) {
        if (this.options.noValidation) {
          return val;
        }
        if (val) {
          return 'yes';
        } else {
          return 'no';
        }
      };
      XMLStringifier2.prototype.dtdPubID = function (val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar('' + val || '');
      };
      XMLStringifier2.prototype.dtdSysID = function (val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar('' + val || '');
      };
      XMLStringifier2.prototype.dtdElementValue = function (val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar('' + val || '');
      };
      XMLStringifier2.prototype.dtdAttType = function (val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar('' + val || '');
      };
      XMLStringifier2.prototype.dtdAttDefault = function (val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar('' + val || '');
      };
      XMLStringifier2.prototype.dtdEntityValue = function (val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar('' + val || '');
      };
      XMLStringifier2.prototype.dtdNData = function (val) {
        if (this.options.noValidation) {
          return val;
        }
        return this.assertLegalChar('' + val || '');
      };
      XMLStringifier2.prototype.convertAttKey = '@';
      XMLStringifier2.prototype.convertPIKey = '?';
      XMLStringifier2.prototype.convertTextKey = '#text';
      XMLStringifier2.prototype.convertCDataKey = '#cdata';
      XMLStringifier2.prototype.convertCommentKey = '#comment';
      XMLStringifier2.prototype.convertRawKey = '#raw';
      XMLStringifier2.prototype.assertLegalChar = function (str) {
        var regex, res;
        if (this.options.noValidation) {
          return str;
        }
        regex = '';
        if (this.options.version === '1.0') {
          regex = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
          if ((res = str.match(regex))) {
            throw new Error(
              'Invalid character in string: ' + str + ' at index ' + res.index,
            );
          }
        } else if (this.options.version === '1.1') {
          regex = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
          if ((res = str.match(regex))) {
            throw new Error(
              'Invalid character in string: ' + str + ' at index ' + res.index,
            );
          }
        }
        return str;
      };
      XMLStringifier2.prototype.assertLegalName = function (str) {
        var regex;
        if (this.options.noValidation) {
          return str;
        }
        this.assertLegalChar(str);
        regex = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/;
        if (!str.match(regex)) {
          throw new Error('Invalid character in name');
        }
        return str;
      };
      XMLStringifier2.prototype.textEscape = function (str) {
        var ampregex;
        if (this.options.noValidation) {
          return str;
        }
        ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
        return str
          .replace(ampregex, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/\r/g, '&#xD;');
      };
      XMLStringifier2.prototype.attEscape = function (str) {
        var ampregex;
        if (this.options.noValidation) {
          return str;
        }
        ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
        return str
          .replace(ampregex, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/"/g, '&quot;')
          .replace(/\t/g, '&#x9;')
          .replace(/\n/g, '&#xA;')
          .replace(/\r/g, '&#xD;');
      };
      return XMLStringifier2;
    })();
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/WriterState.js
var require_WriterState = __commonJS((exports2, module2) => {
  (function () {
    module2.exports = {
      None: 0,
      OpenTag: 1,
      InsideTag: 2,
      CloseTag: 3,
    };
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/XMLWriterBase.js
var require_XMLWriterBase = __commonJS((exports2, module2) => {
  (function () {
    var NodeType,
      WriterState,
      XMLCData,
      XMLComment,
      XMLDTDAttList,
      XMLDTDElement,
      XMLDTDEntity,
      XMLDTDNotation,
      XMLDeclaration,
      XMLDocType,
      XMLDummy,
      XMLElement,
      XMLProcessingInstruction,
      XMLRaw,
      XMLText,
      XMLWriterBase,
      assign,
      hasProp = {}.hasOwnProperty;
    assign = require_Utility().assign;
    NodeType = require_NodeType();
    XMLDeclaration = require_XMLDeclaration();
    XMLDocType = require_XMLDocType();
    XMLCData = require_XMLCData();
    XMLComment = require_XMLComment();
    XMLElement = require_XMLElement();
    XMLRaw = require_XMLRaw();
    XMLText = require_XMLText();
    XMLProcessingInstruction = require_XMLProcessingInstruction();
    XMLDummy = require_XMLDummy();
    XMLDTDAttList = require_XMLDTDAttList();
    XMLDTDElement = require_XMLDTDElement();
    XMLDTDEntity = require_XMLDTDEntity();
    XMLDTDNotation = require_XMLDTDNotation();
    WriterState = require_WriterState();
    module2.exports = XMLWriterBase = (function () {
      function XMLWriterBase2(options) {
        var key, ref, value;
        options || (options = {});
        this.options = options;
        ref = options.writer || {};
        for (key in ref) {
          if (!hasProp.call(ref, key)) continue;
          value = ref[key];
          this['_' + key] = this[key];
          this[key] = value;
        }
      }
      XMLWriterBase2.prototype.filterOptions = function (options) {
        var filteredOptions, ref, ref1, ref2, ref3, ref4, ref5, ref6;
        options || (options = {});
        options = assign({}, this.options, options);
        filteredOptions = {
          writer: this,
        };
        filteredOptions.pretty = options.pretty || false;
        filteredOptions.allowEmpty = options.allowEmpty || false;
        filteredOptions.indent = (ref = options.indent) != null ? ref : '  ';
        filteredOptions.newline =
          (ref1 = options.newline) != null ? ref1 : '\n';
        filteredOptions.offset = (ref2 = options.offset) != null ? ref2 : 0;
        filteredOptions.dontPrettyTextNodes =
          (ref3 =
            (ref4 = options.dontPrettyTextNodes) != null
              ? ref4
              : options.dontprettytextnodes) != null
            ? ref3
            : 0;
        filteredOptions.spaceBeforeSlash =
          (ref5 =
            (ref6 = options.spaceBeforeSlash) != null
              ? ref6
              : options.spacebeforeslash) != null
            ? ref5
            : '';
        if (filteredOptions.spaceBeforeSlash === true) {
          filteredOptions.spaceBeforeSlash = ' ';
        }
        filteredOptions.suppressPrettyCount = 0;
        filteredOptions.user = {};
        filteredOptions.state = WriterState.None;
        return filteredOptions;
      };
      XMLWriterBase2.prototype.indent = function (node, options, level) {
        var indentLevel;
        if (!options.pretty || options.suppressPrettyCount) {
          return '';
        } else if (options.pretty) {
          indentLevel = (level || 0) + options.offset + 1;
          if (indentLevel > 0) {
            return new Array(indentLevel).join(options.indent);
          }
        }
        return '';
      };
      XMLWriterBase2.prototype.endline = function (node, options, level) {
        if (!options.pretty || options.suppressPrettyCount) {
          return '';
        } else {
          return options.newline;
        }
      };
      XMLWriterBase2.prototype.attribute = function (att, options, level) {
        var r;
        this.openAttribute(att, options, level);
        r = ' ' + att.name + '="' + att.value + '"';
        this.closeAttribute(att, options, level);
        return r;
      };
      XMLWriterBase2.prototype.cdata = function (node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level) + '<![CDATA[';
        options.state = WriterState.InsideTag;
        r += node.value;
        options.state = WriterState.CloseTag;
        r += ']]>' + this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.comment = function (node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level) + '<!-- ';
        options.state = WriterState.InsideTag;
        r += node.value;
        options.state = WriterState.CloseTag;
        r += ' -->' + this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.declaration = function (node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level) + '<?xml';
        options.state = WriterState.InsideTag;
        r += ' version="' + node.version + '"';
        if (node.encoding != null) {
          r += ' encoding="' + node.encoding + '"';
        }
        if (node.standalone != null) {
          r += ' standalone="' + node.standalone + '"';
        }
        options.state = WriterState.CloseTag;
        r += options.spaceBeforeSlash + '?>';
        r += this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.docType = function (node, options, level) {
        var child, i, len, r, ref;
        level || (level = 0);
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level);
        r += '<!DOCTYPE ' + node.root().name;
        if (node.pubID && node.sysID) {
          r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
        } else if (node.sysID) {
          r += ' SYSTEM "' + node.sysID + '"';
        }
        if (node.children.length > 0) {
          r += ' [';
          r += this.endline(node, options, level);
          options.state = WriterState.InsideTag;
          ref = node.children;
          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            r += this.writeChildNode(child, options, level + 1);
          }
          options.state = WriterState.CloseTag;
          r += ']';
        }
        options.state = WriterState.CloseTag;
        r += options.spaceBeforeSlash + '>';
        r += this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.element = function (node, options, level) {
        var att,
          child,
          childNodeCount,
          firstChildNode,
          i,
          j,
          len,
          len1,
          name,
          prettySuppressed,
          r,
          ref,
          ref1,
          ref2;
        level || (level = 0);
        prettySuppressed = false;
        r = '';
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r += this.indent(node, options, level) + '<' + node.name;
        ref = node.attribs;
        for (name in ref) {
          if (!hasProp.call(ref, name)) continue;
          att = ref[name];
          r += this.attribute(att, options, level);
        }
        childNodeCount = node.children.length;
        firstChildNode = childNodeCount === 0 ? null : node.children[0];
        if (
          childNodeCount === 0 ||
          node.children.every(function (e) {
            return (
              (e.type === NodeType.Text || e.type === NodeType.Raw) &&
              e.value === ''
            );
          })
        ) {
          if (options.allowEmpty) {
            r += '>';
            options.state = WriterState.CloseTag;
            r += '</' + node.name + '>' + this.endline(node, options, level);
          } else {
            options.state = WriterState.CloseTag;
            r +=
              options.spaceBeforeSlash +
              '/>' +
              this.endline(node, options, level);
          }
        } else if (
          options.pretty &&
          childNodeCount === 1 &&
          (firstChildNode.type === NodeType.Text ||
            firstChildNode.type === NodeType.Raw) &&
          firstChildNode.value != null
        ) {
          r += '>';
          options.state = WriterState.InsideTag;
          options.suppressPrettyCount++;
          prettySuppressed = true;
          r += this.writeChildNode(firstChildNode, options, level + 1);
          options.suppressPrettyCount--;
          prettySuppressed = false;
          options.state = WriterState.CloseTag;
          r += '</' + node.name + '>' + this.endline(node, options, level);
        } else {
          if (options.dontPrettyTextNodes) {
            ref1 = node.children;
            for (i = 0, len = ref1.length; i < len; i++) {
              child = ref1[i];
              if (
                (child.type === NodeType.Text || child.type === NodeType.Raw) &&
                child.value != null
              ) {
                options.suppressPrettyCount++;
                prettySuppressed = true;
                break;
              }
            }
          }
          r += '>' + this.endline(node, options, level);
          options.state = WriterState.InsideTag;
          ref2 = node.children;
          for (j = 0, len1 = ref2.length; j < len1; j++) {
            child = ref2[j];
            r += this.writeChildNode(child, options, level + 1);
          }
          options.state = WriterState.CloseTag;
          r += this.indent(node, options, level) + '</' + node.name + '>';
          if (prettySuppressed) {
            options.suppressPrettyCount--;
          }
          r += this.endline(node, options, level);
          options.state = WriterState.None;
        }
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.writeChildNode = function (
        node,
        options,
        level,
      ) {
        switch (node.type) {
          case NodeType.CData:
            return this.cdata(node, options, level);
          case NodeType.Comment:
            return this.comment(node, options, level);
          case NodeType.Element:
            return this.element(node, options, level);
          case NodeType.Raw:
            return this.raw(node, options, level);
          case NodeType.Text:
            return this.text(node, options, level);
          case NodeType.ProcessingInstruction:
            return this.processingInstruction(node, options, level);
          case NodeType.Dummy:
            return '';
          case NodeType.Declaration:
            return this.declaration(node, options, level);
          case NodeType.DocType:
            return this.docType(node, options, level);
          case NodeType.AttributeDeclaration:
            return this.dtdAttList(node, options, level);
          case NodeType.ElementDeclaration:
            return this.dtdElement(node, options, level);
          case NodeType.EntityDeclaration:
            return this.dtdEntity(node, options, level);
          case NodeType.NotationDeclaration:
            return this.dtdNotation(node, options, level);
          default:
            throw new Error('Unknown XML node type: ' + node.constructor.name);
        }
      };
      XMLWriterBase2.prototype.processingInstruction = function (
        node,
        options,
        level,
      ) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level) + '<?';
        options.state = WriterState.InsideTag;
        r += node.target;
        if (node.value) {
          r += ' ' + node.value;
        }
        options.state = WriterState.CloseTag;
        r += options.spaceBeforeSlash + '?>';
        r += this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.raw = function (node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level);
        options.state = WriterState.InsideTag;
        r += node.value;
        options.state = WriterState.CloseTag;
        r += this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.text = function (node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level);
        options.state = WriterState.InsideTag;
        r += node.value;
        options.state = WriterState.CloseTag;
        r += this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.dtdAttList = function (node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level) + '<!ATTLIST';
        options.state = WriterState.InsideTag;
        r +=
          ' ' +
          node.elementName +
          ' ' +
          node.attributeName +
          ' ' +
          node.attributeType;
        if (node.defaultValueType !== '#DEFAULT') {
          r += ' ' + node.defaultValueType;
        }
        if (node.defaultValue) {
          r += ' "' + node.defaultValue + '"';
        }
        options.state = WriterState.CloseTag;
        r +=
          options.spaceBeforeSlash + '>' + this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.dtdElement = function (node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level) + '<!ELEMENT';
        options.state = WriterState.InsideTag;
        r += ' ' + node.name + ' ' + node.value;
        options.state = WriterState.CloseTag;
        r +=
          options.spaceBeforeSlash + '>' + this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.dtdEntity = function (node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level) + '<!ENTITY';
        options.state = WriterState.InsideTag;
        if (node.pe) {
          r += ' %';
        }
        r += ' ' + node.name;
        if (node.value) {
          r += ' "' + node.value + '"';
        } else {
          if (node.pubID && node.sysID) {
            r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.sysID) {
            r += ' SYSTEM "' + node.sysID + '"';
          }
          if (node.nData) {
            r += ' NDATA ' + node.nData;
          }
        }
        options.state = WriterState.CloseTag;
        r +=
          options.spaceBeforeSlash + '>' + this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.dtdNotation = function (node, options, level) {
        var r;
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        r = this.indent(node, options, level) + '<!NOTATION';
        options.state = WriterState.InsideTag;
        r += ' ' + node.name;
        if (node.pubID && node.sysID) {
          r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
        } else if (node.pubID) {
          r += ' PUBLIC "' + node.pubID + '"';
        } else if (node.sysID) {
          r += ' SYSTEM "' + node.sysID + '"';
        }
        options.state = WriterState.CloseTag;
        r +=
          options.spaceBeforeSlash + '>' + this.endline(node, options, level);
        options.state = WriterState.None;
        this.closeNode(node, options, level);
        return r;
      };
      XMLWriterBase2.prototype.openNode = function (node, options, level) {};
      XMLWriterBase2.prototype.closeNode = function (node, options, level) {};
      XMLWriterBase2.prototype.openAttribute = function (
        att,
        options,
        level,
      ) {};
      XMLWriterBase2.prototype.closeAttribute = function (
        att,
        options,
        level,
      ) {};
      return XMLWriterBase2;
    })();
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/XMLStringWriter.js
var require_XMLStringWriter = __commonJS((exports2, module2) => {
  (function () {
    var XMLStringWriter,
      XMLWriterBase,
      extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
      hasProp = {}.hasOwnProperty;
    XMLWriterBase = require_XMLWriterBase();
    module2.exports = XMLStringWriter = (function (superClass) {
      extend(XMLStringWriter2, superClass);
      function XMLStringWriter2(options) {
        XMLStringWriter2.__super__.constructor.call(this, options);
      }
      XMLStringWriter2.prototype.document = function (doc, options) {
        var child, i, len, r, ref;
        options = this.filterOptions(options);
        r = '';
        ref = doc.children;
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          r += this.writeChildNode(child, options, 0);
        }
        if (
          options.pretty &&
          r.slice(-options.newline.length) === options.newline
        ) {
          r = r.slice(0, -options.newline.length);
        }
        return r;
      };
      return XMLStringWriter2;
    })(XMLWriterBase);
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/XMLDocument.js
var require_XMLDocument = __commonJS((exports2, module2) => {
  (function () {
    var NodeType,
      XMLDOMConfiguration,
      XMLDOMImplementation,
      XMLDocument,
      XMLNode,
      XMLStringWriter,
      XMLStringifier,
      isPlainObject,
      extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
      hasProp = {}.hasOwnProperty;
    isPlainObject = require_Utility().isPlainObject;
    XMLDOMImplementation = require_XMLDOMImplementation();
    XMLDOMConfiguration = require_XMLDOMConfiguration();
    XMLNode = require_XMLNode();
    NodeType = require_NodeType();
    XMLStringifier = require_XMLStringifier();
    XMLStringWriter = require_XMLStringWriter();
    module2.exports = XMLDocument = (function (superClass) {
      extend(XMLDocument2, superClass);
      function XMLDocument2(options) {
        XMLDocument2.__super__.constructor.call(this, null);
        this.name = '#document';
        this.type = NodeType.Document;
        this.documentURI = null;
        this.domConfig = new XMLDOMConfiguration();
        options || (options = {});
        if (!options.writer) {
          options.writer = new XMLStringWriter();
        }
        this.options = options;
        this.stringify = new XMLStringifier(options);
      }
      Object.defineProperty(XMLDocument2.prototype, 'implementation', {
        value: new XMLDOMImplementation(),
      });
      Object.defineProperty(XMLDocument2.prototype, 'doctype', {
        get: function () {
          var child, i, len, ref;
          ref = this.children;
          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            if (child.type === NodeType.DocType) {
              return child;
            }
          }
          return null;
        },
      });
      Object.defineProperty(XMLDocument2.prototype, 'documentElement', {
        get: function () {
          return this.rootObject || null;
        },
      });
      Object.defineProperty(XMLDocument2.prototype, 'inputEncoding', {
        get: function () {
          return null;
        },
      });
      Object.defineProperty(XMLDocument2.prototype, 'strictErrorChecking', {
        get: function () {
          return false;
        },
      });
      Object.defineProperty(XMLDocument2.prototype, 'xmlEncoding', {
        get: function () {
          if (
            this.children.length !== 0 &&
            this.children[0].type === NodeType.Declaration
          ) {
            return this.children[0].encoding;
          } else {
            return null;
          }
        },
      });
      Object.defineProperty(XMLDocument2.prototype, 'xmlStandalone', {
        get: function () {
          if (
            this.children.length !== 0 &&
            this.children[0].type === NodeType.Declaration
          ) {
            return this.children[0].standalone === 'yes';
          } else {
            return false;
          }
        },
      });
      Object.defineProperty(XMLDocument2.prototype, 'xmlVersion', {
        get: function () {
          if (
            this.children.length !== 0 &&
            this.children[0].type === NodeType.Declaration
          ) {
            return this.children[0].version;
          } else {
            return '1.0';
          }
        },
      });
      Object.defineProperty(XMLDocument2.prototype, 'URL', {
        get: function () {
          return this.documentURI;
        },
      });
      Object.defineProperty(XMLDocument2.prototype, 'origin', {
        get: function () {
          return null;
        },
      });
      Object.defineProperty(XMLDocument2.prototype, 'compatMode', {
        get: function () {
          return null;
        },
      });
      Object.defineProperty(XMLDocument2.prototype, 'characterSet', {
        get: function () {
          return null;
        },
      });
      Object.defineProperty(XMLDocument2.prototype, 'contentType', {
        get: function () {
          return null;
        },
      });
      XMLDocument2.prototype.end = function (writer) {
        var writerOptions;
        writerOptions = {};
        if (!writer) {
          writer = this.options.writer;
        } else if (isPlainObject(writer)) {
          writerOptions = writer;
          writer = this.options.writer;
        }
        return writer.document(this, writer.filterOptions(writerOptions));
      };
      XMLDocument2.prototype.toString = function (options) {
        return this.options.writer.document(
          this,
          this.options.writer.filterOptions(options),
        );
      };
      XMLDocument2.prototype.createElement = function (tagName) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLDocument2.prototype.createDocumentFragment = function () {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLDocument2.prototype.createTextNode = function (data) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLDocument2.prototype.createComment = function (data) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLDocument2.prototype.createCDATASection = function (data) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLDocument2.prototype.createProcessingInstruction = function (
        target,
        data,
      ) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLDocument2.prototype.createAttribute = function (name) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLDocument2.prototype.createEntityReference = function (name) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLDocument2.prototype.getElementsByTagName = function (tagname) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLDocument2.prototype.importNode = function (importedNode, deep) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLDocument2.prototype.createElementNS = function (
        namespaceURI,
        qualifiedName,
      ) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLDocument2.prototype.createAttributeNS = function (
        namespaceURI,
        qualifiedName,
      ) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLDocument2.prototype.getElementsByTagNameNS = function (
        namespaceURI,
        localName,
      ) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLDocument2.prototype.getElementById = function (elementId) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLDocument2.prototype.adoptNode = function (source) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLDocument2.prototype.normalizeDocument = function () {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLDocument2.prototype.renameNode = function (
        node,
        namespaceURI,
        qualifiedName,
      ) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLDocument2.prototype.getElementsByClassName = function (classNames) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLDocument2.prototype.createEvent = function (eventInterface) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLDocument2.prototype.createRange = function () {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLDocument2.prototype.createNodeIterator = function (
        root,
        whatToShow,
        filter,
      ) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      XMLDocument2.prototype.createTreeWalker = function (
        root,
        whatToShow,
        filter,
      ) {
        throw new Error(
          'This DOM method is not implemented.' + this.debugInfo(),
        );
      };
      return XMLDocument2;
    })(XMLNode);
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/XMLDocumentCB.js
var require_XMLDocumentCB = __commonJS((exports2, module2) => {
  (function () {
    var NodeType,
      WriterState,
      XMLAttribute,
      XMLCData,
      XMLComment,
      XMLDTDAttList,
      XMLDTDElement,
      XMLDTDEntity,
      XMLDTDNotation,
      XMLDeclaration,
      XMLDocType,
      XMLDocument,
      XMLDocumentCB,
      XMLElement,
      XMLProcessingInstruction,
      XMLRaw,
      XMLStringWriter,
      XMLStringifier,
      XMLText,
      getValue,
      isFunction,
      isObject,
      isPlainObject,
      ref,
      hasProp = {}.hasOwnProperty;
    (ref = require_Utility()),
      (isObject = ref.isObject),
      (isFunction = ref.isFunction),
      (isPlainObject = ref.isPlainObject),
      (getValue = ref.getValue);
    NodeType = require_NodeType();
    XMLDocument = require_XMLDocument();
    XMLElement = require_XMLElement();
    XMLCData = require_XMLCData();
    XMLComment = require_XMLComment();
    XMLRaw = require_XMLRaw();
    XMLText = require_XMLText();
    XMLProcessingInstruction = require_XMLProcessingInstruction();
    XMLDeclaration = require_XMLDeclaration();
    XMLDocType = require_XMLDocType();
    XMLDTDAttList = require_XMLDTDAttList();
    XMLDTDEntity = require_XMLDTDEntity();
    XMLDTDElement = require_XMLDTDElement();
    XMLDTDNotation = require_XMLDTDNotation();
    XMLAttribute = require_XMLAttribute();
    XMLStringifier = require_XMLStringifier();
    XMLStringWriter = require_XMLStringWriter();
    WriterState = require_WriterState();
    module2.exports = XMLDocumentCB = (function () {
      function XMLDocumentCB2(options, onData, onEnd) {
        var writerOptions;
        this.name = '?xml';
        this.type = NodeType.Document;
        options || (options = {});
        writerOptions = {};
        if (!options.writer) {
          options.writer = new XMLStringWriter();
        } else if (isPlainObject(options.writer)) {
          writerOptions = options.writer;
          options.writer = new XMLStringWriter();
        }
        this.options = options;
        this.writer = options.writer;
        this.writerOptions = this.writer.filterOptions(writerOptions);
        this.stringify = new XMLStringifier(options);
        this.onDataCallback = onData || function () {};
        this.onEndCallback = onEnd || function () {};
        this.currentNode = null;
        this.currentLevel = -1;
        this.openTags = {};
        this.documentStarted = false;
        this.documentCompleted = false;
        this.root = null;
      }
      XMLDocumentCB2.prototype.createChildNode = function (node) {
        var att, attName, attributes, child, i, len, ref1, ref2;
        switch (node.type) {
          case NodeType.CData:
            this.cdata(node.value);
            break;
          case NodeType.Comment:
            this.comment(node.value);
            break;
          case NodeType.Element:
            attributes = {};
            ref1 = node.attribs;
            for (attName in ref1) {
              if (!hasProp.call(ref1, attName)) continue;
              att = ref1[attName];
              attributes[attName] = att.value;
            }
            this.node(node.name, attributes);
            break;
          case NodeType.Dummy:
            this.dummy();
            break;
          case NodeType.Raw:
            this.raw(node.value);
            break;
          case NodeType.Text:
            this.text(node.value);
            break;
          case NodeType.ProcessingInstruction:
            this.instruction(node.target, node.value);
            break;
          default:
            throw new Error(
              'This XML node type is not supported in a JS object: ' +
                node.constructor.name,
            );
        }
        ref2 = node.children;
        for (i = 0, len = ref2.length; i < len; i++) {
          child = ref2[i];
          this.createChildNode(child);
          if (child.type === NodeType.Element) {
            this.up();
          }
        }
        return this;
      };
      XMLDocumentCB2.prototype.dummy = function () {
        return this;
      };
      XMLDocumentCB2.prototype.node = function (name, attributes, text) {
        var ref1;
        if (name == null) {
          throw new Error('Missing node name.');
        }
        if (this.root && this.currentLevel === -1) {
          throw new Error(
            'Document can only have one root node. ' + this.debugInfo(name),
          );
        }
        this.openCurrent();
        name = getValue(name);
        if (attributes == null) {
          attributes = {};
        }
        attributes = getValue(attributes);
        if (!isObject(attributes)) {
          (ref1 = [attributes, text]), (text = ref1[0]), (attributes = ref1[1]);
        }
        this.currentNode = new XMLElement(this, name, attributes);
        this.currentNode.children = false;
        this.currentLevel++;
        this.openTags[this.currentLevel] = this.currentNode;
        if (text != null) {
          this.text(text);
        }
        return this;
      };
      XMLDocumentCB2.prototype.element = function (name, attributes, text) {
        var child, i, len, oldValidationFlag, ref1, root;
        if (this.currentNode && this.currentNode.type === NodeType.DocType) {
          this.dtdElement.apply(this, arguments);
        } else {
          if (Array.isArray(name) || isObject(name) || isFunction(name)) {
            oldValidationFlag = this.options.noValidation;
            this.options.noValidation = true;
            root = new XMLDocument(this.options).element('TEMP_ROOT');
            root.element(name);
            this.options.noValidation = oldValidationFlag;
            ref1 = root.children;
            for (i = 0, len = ref1.length; i < len; i++) {
              child = ref1[i];
              this.createChildNode(child);
              if (child.type === NodeType.Element) {
                this.up();
              }
            }
          } else {
            this.node(name, attributes, text);
          }
        }
        return this;
      };
      XMLDocumentCB2.prototype.attribute = function (name, value) {
        var attName, attValue;
        if (!this.currentNode || this.currentNode.children) {
          throw new Error(
            'att() can only be used immediately after an ele() call in callback mode. ' +
              this.debugInfo(name),
          );
        }
        if (name != null) {
          name = getValue(name);
        }
        if (isObject(name)) {
          for (attName in name) {
            if (!hasProp.call(name, attName)) continue;
            attValue = name[attName];
            this.attribute(attName, attValue);
          }
        } else {
          if (isFunction(value)) {
            value = value.apply();
          }
          if (this.options.keepNullAttributes && value == null) {
            this.currentNode.attribs[name] = new XMLAttribute(this, name, '');
          } else if (value != null) {
            this.currentNode.attribs[name] = new XMLAttribute(
              this,
              name,
              value,
            );
          }
        }
        return this;
      };
      XMLDocumentCB2.prototype.text = function (value) {
        var node;
        this.openCurrent();
        node = new XMLText(this, value);
        this.onData(
          this.writer.text(node, this.writerOptions, this.currentLevel + 1),
          this.currentLevel + 1,
        );
        return this;
      };
      XMLDocumentCB2.prototype.cdata = function (value) {
        var node;
        this.openCurrent();
        node = new XMLCData(this, value);
        this.onData(
          this.writer.cdata(node, this.writerOptions, this.currentLevel + 1),
          this.currentLevel + 1,
        );
        return this;
      };
      XMLDocumentCB2.prototype.comment = function (value) {
        var node;
        this.openCurrent();
        node = new XMLComment(this, value);
        this.onData(
          this.writer.comment(node, this.writerOptions, this.currentLevel + 1),
          this.currentLevel + 1,
        );
        return this;
      };
      XMLDocumentCB2.prototype.raw = function (value) {
        var node;
        this.openCurrent();
        node = new XMLRaw(this, value);
        this.onData(
          this.writer.raw(node, this.writerOptions, this.currentLevel + 1),
          this.currentLevel + 1,
        );
        return this;
      };
      XMLDocumentCB2.prototype.instruction = function (target, value) {
        var i, insTarget, insValue, len, node;
        this.openCurrent();
        if (target != null) {
          target = getValue(target);
        }
        if (value != null) {
          value = getValue(value);
        }
        if (Array.isArray(target)) {
          for (i = 0, len = target.length; i < len; i++) {
            insTarget = target[i];
            this.instruction(insTarget);
          }
        } else if (isObject(target)) {
          for (insTarget in target) {
            if (!hasProp.call(target, insTarget)) continue;
            insValue = target[insTarget];
            this.instruction(insTarget, insValue);
          }
        } else {
          if (isFunction(value)) {
            value = value.apply();
          }
          node = new XMLProcessingInstruction(this, target, value);
          this.onData(
            this.writer.processingInstruction(
              node,
              this.writerOptions,
              this.currentLevel + 1,
            ),
            this.currentLevel + 1,
          );
        }
        return this;
      };
      XMLDocumentCB2.prototype.declaration = function (
        version,
        encoding,
        standalone,
      ) {
        var node;
        this.openCurrent();
        if (this.documentStarted) {
          throw new Error('declaration() must be the first node.');
        }
        node = new XMLDeclaration(this, version, encoding, standalone);
        this.onData(
          this.writer.declaration(
            node,
            this.writerOptions,
            this.currentLevel + 1,
          ),
          this.currentLevel + 1,
        );
        return this;
      };
      XMLDocumentCB2.prototype.doctype = function (root, pubID, sysID) {
        this.openCurrent();
        if (root == null) {
          throw new Error('Missing root node name.');
        }
        if (this.root) {
          throw new Error('dtd() must come before the root node.');
        }
        this.currentNode = new XMLDocType(this, pubID, sysID);
        this.currentNode.rootNodeName = root;
        this.currentNode.children = false;
        this.currentLevel++;
        this.openTags[this.currentLevel] = this.currentNode;
        return this;
      };
      XMLDocumentCB2.prototype.dtdElement = function (name, value) {
        var node;
        this.openCurrent();
        node = new XMLDTDElement(this, name, value);
        this.onData(
          this.writer.dtdElement(
            node,
            this.writerOptions,
            this.currentLevel + 1,
          ),
          this.currentLevel + 1,
        );
        return this;
      };
      XMLDocumentCB2.prototype.attList = function (
        elementName,
        attributeName,
        attributeType,
        defaultValueType,
        defaultValue,
      ) {
        var node;
        this.openCurrent();
        node = new XMLDTDAttList(
          this,
          elementName,
          attributeName,
          attributeType,
          defaultValueType,
          defaultValue,
        );
        this.onData(
          this.writer.dtdAttList(
            node,
            this.writerOptions,
            this.currentLevel + 1,
          ),
          this.currentLevel + 1,
        );
        return this;
      };
      XMLDocumentCB2.prototype.entity = function (name, value) {
        var node;
        this.openCurrent();
        node = new XMLDTDEntity(this, false, name, value);
        this.onData(
          this.writer.dtdEntity(
            node,
            this.writerOptions,
            this.currentLevel + 1,
          ),
          this.currentLevel + 1,
        );
        return this;
      };
      XMLDocumentCB2.prototype.pEntity = function (name, value) {
        var node;
        this.openCurrent();
        node = new XMLDTDEntity(this, true, name, value);
        this.onData(
          this.writer.dtdEntity(
            node,
            this.writerOptions,
            this.currentLevel + 1,
          ),
          this.currentLevel + 1,
        );
        return this;
      };
      XMLDocumentCB2.prototype.notation = function (name, value) {
        var node;
        this.openCurrent();
        node = new XMLDTDNotation(this, name, value);
        this.onData(
          this.writer.dtdNotation(
            node,
            this.writerOptions,
            this.currentLevel + 1,
          ),
          this.currentLevel + 1,
        );
        return this;
      };
      XMLDocumentCB2.prototype.up = function () {
        if (this.currentLevel < 0) {
          throw new Error('The document node has no parent.');
        }
        if (this.currentNode) {
          if (this.currentNode.children) {
            this.closeNode(this.currentNode);
          } else {
            this.openNode(this.currentNode);
          }
          this.currentNode = null;
        } else {
          this.closeNode(this.openTags[this.currentLevel]);
        }
        delete this.openTags[this.currentLevel];
        this.currentLevel--;
        return this;
      };
      XMLDocumentCB2.prototype.end = function () {
        while (this.currentLevel >= 0) {
          this.up();
        }
        return this.onEnd();
      };
      XMLDocumentCB2.prototype.openCurrent = function () {
        if (this.currentNode) {
          this.currentNode.children = true;
          return this.openNode(this.currentNode);
        }
      };
      XMLDocumentCB2.prototype.openNode = function (node) {
        var att, chunk, name, ref1;
        if (!node.isOpen) {
          if (
            !this.root &&
            this.currentLevel === 0 &&
            node.type === NodeType.Element
          ) {
            this.root = node;
          }
          chunk = '';
          if (node.type === NodeType.Element) {
            this.writerOptions.state = WriterState.OpenTag;
            chunk =
              this.writer.indent(node, this.writerOptions, this.currentLevel) +
              '<' +
              node.name;
            ref1 = node.attribs;
            for (name in ref1) {
              if (!hasProp.call(ref1, name)) continue;
              att = ref1[name];
              chunk += this.writer.attribute(
                att,
                this.writerOptions,
                this.currentLevel,
              );
            }
            chunk +=
              (node.children ? '>' : '/>') +
              this.writer.endline(node, this.writerOptions, this.currentLevel);
            this.writerOptions.state = WriterState.InsideTag;
          } else {
            this.writerOptions.state = WriterState.OpenTag;
            chunk =
              this.writer.indent(node, this.writerOptions, this.currentLevel) +
              '<!DOCTYPE ' +
              node.rootNodeName;
            if (node.pubID && node.sysID) {
              chunk += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            } else if (node.sysID) {
              chunk += ' SYSTEM "' + node.sysID + '"';
            }
            if (node.children) {
              chunk += ' [';
              this.writerOptions.state = WriterState.InsideTag;
            } else {
              this.writerOptions.state = WriterState.CloseTag;
              chunk += '>';
            }
            chunk += this.writer.endline(
              node,
              this.writerOptions,
              this.currentLevel,
            );
          }
          this.onData(chunk, this.currentLevel);
          return (node.isOpen = true);
        }
      };
      XMLDocumentCB2.prototype.closeNode = function (node) {
        var chunk;
        if (!node.isClosed) {
          chunk = '';
          this.writerOptions.state = WriterState.CloseTag;
          if (node.type === NodeType.Element) {
            chunk =
              this.writer.indent(node, this.writerOptions, this.currentLevel) +
              '</' +
              node.name +
              '>' +
              this.writer.endline(node, this.writerOptions, this.currentLevel);
          } else {
            chunk =
              this.writer.indent(node, this.writerOptions, this.currentLevel) +
              ']>' +
              this.writer.endline(node, this.writerOptions, this.currentLevel);
          }
          this.writerOptions.state = WriterState.None;
          this.onData(chunk, this.currentLevel);
          return (node.isClosed = true);
        }
      };
      XMLDocumentCB2.prototype.onData = function (chunk, level) {
        this.documentStarted = true;
        return this.onDataCallback(chunk, level + 1);
      };
      XMLDocumentCB2.prototype.onEnd = function () {
        this.documentCompleted = true;
        return this.onEndCallback();
      };
      XMLDocumentCB2.prototype.debugInfo = function (name) {
        if (name == null) {
          return '';
        } else {
          return 'node: <' + name + '>';
        }
      };
      XMLDocumentCB2.prototype.ele = function () {
        return this.element.apply(this, arguments);
      };
      XMLDocumentCB2.prototype.nod = function (name, attributes, text) {
        return this.node(name, attributes, text);
      };
      XMLDocumentCB2.prototype.txt = function (value) {
        return this.text(value);
      };
      XMLDocumentCB2.prototype.dat = function (value) {
        return this.cdata(value);
      };
      XMLDocumentCB2.prototype.com = function (value) {
        return this.comment(value);
      };
      XMLDocumentCB2.prototype.ins = function (target, value) {
        return this.instruction(target, value);
      };
      XMLDocumentCB2.prototype.dec = function (version, encoding, standalone) {
        return this.declaration(version, encoding, standalone);
      };
      XMLDocumentCB2.prototype.dtd = function (root, pubID, sysID) {
        return this.doctype(root, pubID, sysID);
      };
      XMLDocumentCB2.prototype.e = function (name, attributes, text) {
        return this.element(name, attributes, text);
      };
      XMLDocumentCB2.prototype.n = function (name, attributes, text) {
        return this.node(name, attributes, text);
      };
      XMLDocumentCB2.prototype.t = function (value) {
        return this.text(value);
      };
      XMLDocumentCB2.prototype.d = function (value) {
        return this.cdata(value);
      };
      XMLDocumentCB2.prototype.c = function (value) {
        return this.comment(value);
      };
      XMLDocumentCB2.prototype.r = function (value) {
        return this.raw(value);
      };
      XMLDocumentCB2.prototype.i = function (target, value) {
        return this.instruction(target, value);
      };
      XMLDocumentCB2.prototype.att = function () {
        if (this.currentNode && this.currentNode.type === NodeType.DocType) {
          return this.attList.apply(this, arguments);
        } else {
          return this.attribute.apply(this, arguments);
        }
      };
      XMLDocumentCB2.prototype.a = function () {
        if (this.currentNode && this.currentNode.type === NodeType.DocType) {
          return this.attList.apply(this, arguments);
        } else {
          return this.attribute.apply(this, arguments);
        }
      };
      XMLDocumentCB2.prototype.ent = function (name, value) {
        return this.entity(name, value);
      };
      XMLDocumentCB2.prototype.pent = function (name, value) {
        return this.pEntity(name, value);
      };
      XMLDocumentCB2.prototype.not = function (name, value) {
        return this.notation(name, value);
      };
      return XMLDocumentCB2;
    })();
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/XMLStreamWriter.js
var require_XMLStreamWriter = __commonJS((exports2, module2) => {
  (function () {
    var NodeType,
      WriterState,
      XMLStreamWriter,
      XMLWriterBase,
      extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
      hasProp = {}.hasOwnProperty;
    NodeType = require_NodeType();
    XMLWriterBase = require_XMLWriterBase();
    WriterState = require_WriterState();
    module2.exports = XMLStreamWriter = (function (superClass) {
      extend(XMLStreamWriter2, superClass);
      function XMLStreamWriter2(stream, options) {
        this.stream = stream;
        XMLStreamWriter2.__super__.constructor.call(this, options);
      }
      XMLStreamWriter2.prototype.endline = function (node, options, level) {
        if (node.isLastRootNode && options.state === WriterState.CloseTag) {
          return '';
        } else {
          return XMLStreamWriter2.__super__.endline.call(
            this,
            node,
            options,
            level,
          );
        }
      };
      XMLStreamWriter2.prototype.document = function (doc, options) {
        var child, i, j, k, len, len1, ref, ref1, results;
        ref = doc.children;
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          child = ref[i];
          child.isLastRootNode = i === doc.children.length - 1;
        }
        options = this.filterOptions(options);
        ref1 = doc.children;
        results = [];
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          child = ref1[k];
          results.push(this.writeChildNode(child, options, 0));
        }
        return results;
      };
      XMLStreamWriter2.prototype.attribute = function (att, options, level) {
        return this.stream.write(
          XMLStreamWriter2.__super__.attribute.call(this, att, options, level),
        );
      };
      XMLStreamWriter2.prototype.cdata = function (node, options, level) {
        return this.stream.write(
          XMLStreamWriter2.__super__.cdata.call(this, node, options, level),
        );
      };
      XMLStreamWriter2.prototype.comment = function (node, options, level) {
        return this.stream.write(
          XMLStreamWriter2.__super__.comment.call(this, node, options, level),
        );
      };
      XMLStreamWriter2.prototype.declaration = function (node, options, level) {
        return this.stream.write(
          XMLStreamWriter2.__super__.declaration.call(
            this,
            node,
            options,
            level,
          ),
        );
      };
      XMLStreamWriter2.prototype.docType = function (node, options, level) {
        var child, j, len, ref;
        level || (level = 0);
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        this.stream.write(this.indent(node, options, level));
        this.stream.write('<!DOCTYPE ' + node.root().name);
        if (node.pubID && node.sysID) {
          this.stream.write(
            ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"',
          );
        } else if (node.sysID) {
          this.stream.write(' SYSTEM "' + node.sysID + '"');
        }
        if (node.children.length > 0) {
          this.stream.write(' [');
          this.stream.write(this.endline(node, options, level));
          options.state = WriterState.InsideTag;
          ref = node.children;
          for (j = 0, len = ref.length; j < len; j++) {
            child = ref[j];
            this.writeChildNode(child, options, level + 1);
          }
          options.state = WriterState.CloseTag;
          this.stream.write(']');
        }
        options.state = WriterState.CloseTag;
        this.stream.write(options.spaceBeforeSlash + '>');
        this.stream.write(this.endline(node, options, level));
        options.state = WriterState.None;
        return this.closeNode(node, options, level);
      };
      XMLStreamWriter2.prototype.element = function (node, options, level) {
        var att,
          child,
          childNodeCount,
          firstChildNode,
          j,
          len,
          name,
          prettySuppressed,
          ref,
          ref1;
        level || (level = 0);
        this.openNode(node, options, level);
        options.state = WriterState.OpenTag;
        this.stream.write(this.indent(node, options, level) + '<' + node.name);
        ref = node.attribs;
        for (name in ref) {
          if (!hasProp.call(ref, name)) continue;
          att = ref[name];
          this.attribute(att, options, level);
        }
        childNodeCount = node.children.length;
        firstChildNode = childNodeCount === 0 ? null : node.children[0];
        if (
          childNodeCount === 0 ||
          node.children.every(function (e) {
            return (
              (e.type === NodeType.Text || e.type === NodeType.Raw) &&
              e.value === ''
            );
          })
        ) {
          if (options.allowEmpty) {
            this.stream.write('>');
            options.state = WriterState.CloseTag;
            this.stream.write('</' + node.name + '>');
          } else {
            options.state = WriterState.CloseTag;
            this.stream.write(options.spaceBeforeSlash + '/>');
          }
        } else if (
          options.pretty &&
          childNodeCount === 1 &&
          (firstChildNode.type === NodeType.Text ||
            firstChildNode.type === NodeType.Raw) &&
          firstChildNode.value != null
        ) {
          this.stream.write('>');
          options.state = WriterState.InsideTag;
          options.suppressPrettyCount++;
          prettySuppressed = true;
          this.writeChildNode(firstChildNode, options, level + 1);
          options.suppressPrettyCount--;
          prettySuppressed = false;
          options.state = WriterState.CloseTag;
          this.stream.write('</' + node.name + '>');
        } else {
          this.stream.write('>' + this.endline(node, options, level));
          options.state = WriterState.InsideTag;
          ref1 = node.children;
          for (j = 0, len = ref1.length; j < len; j++) {
            child = ref1[j];
            this.writeChildNode(child, options, level + 1);
          }
          options.state = WriterState.CloseTag;
          this.stream.write(
            this.indent(node, options, level) + '</' + node.name + '>',
          );
        }
        this.stream.write(this.endline(node, options, level));
        options.state = WriterState.None;
        return this.closeNode(node, options, level);
      };
      XMLStreamWriter2.prototype.processingInstruction = function (
        node,
        options,
        level,
      ) {
        return this.stream.write(
          XMLStreamWriter2.__super__.processingInstruction.call(
            this,
            node,
            options,
            level,
          ),
        );
      };
      XMLStreamWriter2.prototype.raw = function (node, options, level) {
        return this.stream.write(
          XMLStreamWriter2.__super__.raw.call(this, node, options, level),
        );
      };
      XMLStreamWriter2.prototype.text = function (node, options, level) {
        return this.stream.write(
          XMLStreamWriter2.__super__.text.call(this, node, options, level),
        );
      };
      XMLStreamWriter2.prototype.dtdAttList = function (node, options, level) {
        return this.stream.write(
          XMLStreamWriter2.__super__.dtdAttList.call(
            this,
            node,
            options,
            level,
          ),
        );
      };
      XMLStreamWriter2.prototype.dtdElement = function (node, options, level) {
        return this.stream.write(
          XMLStreamWriter2.__super__.dtdElement.call(
            this,
            node,
            options,
            level,
          ),
        );
      };
      XMLStreamWriter2.prototype.dtdEntity = function (node, options, level) {
        return this.stream.write(
          XMLStreamWriter2.__super__.dtdEntity.call(this, node, options, level),
        );
      };
      XMLStreamWriter2.prototype.dtdNotation = function (node, options, level) {
        return this.stream.write(
          XMLStreamWriter2.__super__.dtdNotation.call(
            this,
            node,
            options,
            level,
          ),
        );
      };
      return XMLStreamWriter2;
    })(XMLWriterBase);
  }.call(exports2));
});

// node_modules/xmlbuilder/lib/index.js
var require_lib7 = __commonJS((exports2, module2) => {
  (function () {
    var NodeType,
      WriterState,
      XMLDOMImplementation,
      XMLDocument,
      XMLDocumentCB,
      XMLStreamWriter,
      XMLStringWriter,
      assign,
      isFunction,
      ref;
    (ref = require_Utility()),
      (assign = ref.assign),
      (isFunction = ref.isFunction);
    XMLDOMImplementation = require_XMLDOMImplementation();
    XMLDocument = require_XMLDocument();
    XMLDocumentCB = require_XMLDocumentCB();
    XMLStringWriter = require_XMLStringWriter();
    XMLStreamWriter = require_XMLStreamWriter();
    NodeType = require_NodeType();
    WriterState = require_WriterState();
    module2.exports.create = function (name, xmldec, doctype, options) {
      var doc, root;
      if (name == null) {
        throw new Error('Root element needs a name.');
      }
      options = assign({}, xmldec, doctype, options);
      doc = new XMLDocument(options);
      root = doc.element(name);
      if (!options.headless) {
        doc.declaration(options);
        if (options.pubID != null || options.sysID != null) {
          doc.dtd(options);
        }
      }
      return root;
    };
    module2.exports.begin = function (options, onData, onEnd) {
      var ref1;
      if (isFunction(options)) {
        (ref1 = [options, onData]), (onData = ref1[0]), (onEnd = ref1[1]);
        options = {};
      }
      if (onData) {
        return new XMLDocumentCB(options, onData, onEnd);
      } else {
        return new XMLDocument(options);
      }
    };
    module2.exports.stringWriter = function (options) {
      return new XMLStringWriter(options);
    };
    module2.exports.streamWriter = function (stream, options) {
      return new XMLStreamWriter(stream, options);
    };
    module2.exports.implementation = new XMLDOMImplementation();
    module2.exports.nodeType = NodeType;
    module2.exports.writerState = WriterState;
  }.call(exports2));
});

// node_modules/xml2js/lib/builder.js
var require_builder = __commonJS((exports2) => {
  (function () {
    'use strict';
    var builder,
      defaults,
      escapeCDATA,
      requiresCDATA,
      wrapCDATA,
      hasProp = {}.hasOwnProperty;
    builder = require_lib7();
    defaults = require_defaults().defaults;
    requiresCDATA = function (entry) {
      return (
        typeof entry === 'string' &&
        (entry.indexOf('&') >= 0 ||
          entry.indexOf('>') >= 0 ||
          entry.indexOf('<') >= 0)
      );
    };
    wrapCDATA = function (entry) {
      return '<![CDATA[' + escapeCDATA(entry) + ']]>';
    };
    escapeCDATA = function (entry) {
      return entry.replace(']]>', ']]]]><![CDATA[>');
    };
    exports2.Builder = (function () {
      function Builder(opts) {
        var key, ref, value;
        this.options = {};
        ref = defaults['0.2'];
        for (key in ref) {
          if (!hasProp.call(ref, key)) continue;
          value = ref[key];
          this.options[key] = value;
        }
        for (key in opts) {
          if (!hasProp.call(opts, key)) continue;
          value = opts[key];
          this.options[key] = value;
        }
      }
      Builder.prototype.buildObject = function (rootObj) {
        var attrkey, charkey, render, rootElement, rootName;
        attrkey = this.options.attrkey;
        charkey = this.options.charkey;
        if (
          Object.keys(rootObj).length === 1 &&
          this.options.rootName === defaults['0.2'].rootName
        ) {
          rootName = Object.keys(rootObj)[0];
          rootObj = rootObj[rootName];
        } else {
          rootName = this.options.rootName;
        }
        render = (function (_this) {
          return function (element, obj) {
            var attr, child, entry, index, key, value;
            if (typeof obj !== 'object') {
              if (_this.options.cdata && requiresCDATA(obj)) {
                element.raw(wrapCDATA(obj));
              } else {
                element.txt(obj);
              }
            } else if (Array.isArray(obj)) {
              for (index in obj) {
                if (!hasProp.call(obj, index)) continue;
                child = obj[index];
                for (key in child) {
                  entry = child[key];
                  element = render(element.ele(key), entry).up();
                }
              }
            } else {
              for (key in obj) {
                if (!hasProp.call(obj, key)) continue;
                child = obj[key];
                if (key === attrkey) {
                  if (typeof child === 'object') {
                    for (attr in child) {
                      value = child[attr];
                      element = element.att(attr, value);
                    }
                  }
                } else if (key === charkey) {
                  if (_this.options.cdata && requiresCDATA(child)) {
                    element = element.raw(wrapCDATA(child));
                  } else {
                    element = element.txt(child);
                  }
                } else if (Array.isArray(child)) {
                  for (index in child) {
                    if (!hasProp.call(child, index)) continue;
                    entry = child[index];
                    if (typeof entry === 'string') {
                      if (_this.options.cdata && requiresCDATA(entry)) {
                        element = element.ele(key).raw(wrapCDATA(entry)).up();
                      } else {
                        element = element.ele(key, entry).up();
                      }
                    } else {
                      element = render(element.ele(key), entry).up();
                    }
                  }
                } else if (typeof child === 'object') {
                  element = render(element.ele(key), child).up();
                } else {
                  if (
                    typeof child === 'string' &&
                    _this.options.cdata &&
                    requiresCDATA(child)
                  ) {
                    element = element.ele(key).raw(wrapCDATA(child)).up();
                  } else {
                    if (child == null) {
                      child = '';
                    }
                    element = element.ele(key, child.toString()).up();
                  }
                }
              }
            }
            return element;
          };
        })(this);
        rootElement = builder.create(
          rootName,
          this.options.xmldec,
          this.options.doctype,
          {
            headless: this.options.headless,
            allowSurrogateChars: this.options.allowSurrogateChars,
          },
        );
        return render(rootElement, rootObj).end(this.options.renderOpts);
      };
      return Builder;
    })();
  }.call(exports2));
});

// node_modules/sax/lib/sax.js
var require_sax = __commonJS((exports2) => {
  (function (sax) {
    sax.parser = function (strict, opt) {
      return new SAXParser(strict, opt);
    };
    sax.SAXParser = SAXParser;
    sax.SAXStream = SAXStream;
    sax.createStream = createStream;
    sax.MAX_BUFFER_LENGTH = 64 * 1024;
    var buffers = [
      'comment',
      'sgmlDecl',
      'textNode',
      'tagName',
      'doctype',
      'procInstName',
      'procInstBody',
      'entity',
      'attribName',
      'attribValue',
      'cdata',
      'script',
    ];
    sax.EVENTS = [
      'text',
      'processinginstruction',
      'sgmldeclaration',
      'doctype',
      'comment',
      'opentagstart',
      'attribute',
      'opentag',
      'closetag',
      'opencdata',
      'cdata',
      'closecdata',
      'error',
      'end',
      'ready',
      'script',
      'opennamespace',
      'closenamespace',
    ];
    function SAXParser(strict, opt) {
      if (!(this instanceof SAXParser)) {
        return new SAXParser(strict, opt);
      }
      var parser = this;
      clearBuffers(parser);
      parser.q = parser.c = '';
      parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
      parser.opt = opt || {};
      parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
      parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase';
      parser.tags = [];
      parser.closed = parser.closedRoot = parser.sawRoot = false;
      parser.tag = parser.error = null;
      parser.strict = !!strict;
      parser.noscript = !!(strict || parser.opt.noscript);
      parser.state = S.BEGIN;
      parser.strictEntities = parser.opt.strictEntities;
      parser.ENTITIES = parser.strictEntities
        ? Object.create(sax.XML_ENTITIES)
        : Object.create(sax.ENTITIES);
      parser.attribList = [];
      if (parser.opt.xmlns) {
        parser.ns = Object.create(rootNS);
      }
      parser.trackPosition = parser.opt.position !== false;
      if (parser.trackPosition) {
        parser.position = parser.line = parser.column = 0;
      }
      emit(parser, 'onready');
    }
    if (!Object.create) {
      Object.create = function (o) {
        function F() {}
        F.prototype = o;
        var newf = new F();
        return newf;
      };
    }
    if (!Object.keys) {
      Object.keys = function (o) {
        var a = [];
        for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
        return a;
      };
    }
    function checkBufferLength(parser) {
      var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
      var maxActual = 0;
      for (var i = 0, l = buffers.length; i < l; i++) {
        var len = parser[buffers[i]].length;
        if (len > maxAllowed) {
          switch (buffers[i]) {
            case 'textNode':
              closeText(parser);
              break;
            case 'cdata':
              emitNode(parser, 'oncdata', parser.cdata);
              parser.cdata = '';
              break;
            case 'script':
              emitNode(parser, 'onscript', parser.script);
              parser.script = '';
              break;
            default:
              error(parser, 'Max buffer length exceeded: ' + buffers[i]);
          }
        }
        maxActual = Math.max(maxActual, len);
      }
      var m = sax.MAX_BUFFER_LENGTH - maxActual;
      parser.bufferCheckPosition = m + parser.position;
    }
    function clearBuffers(parser) {
      for (var i = 0, l = buffers.length; i < l; i++) {
        parser[buffers[i]] = '';
      }
    }
    function flushBuffers(parser) {
      closeText(parser);
      if (parser.cdata !== '') {
        emitNode(parser, 'oncdata', parser.cdata);
        parser.cdata = '';
      }
      if (parser.script !== '') {
        emitNode(parser, 'onscript', parser.script);
        parser.script = '';
      }
    }
    SAXParser.prototype = {
      end: function () {
        end(this);
      },
      write,
      resume: function () {
        this.error = null;
        return this;
      },
      close: function () {
        return this.write(null);
      },
      flush: function () {
        flushBuffers(this);
      },
    };
    var Stream;
    try {
      Stream = require('stream').Stream;
    } catch (ex) {
      Stream = function () {};
    }
    var streamWraps = sax.EVENTS.filter(function (ev) {
      return ev !== 'error' && ev !== 'end';
    });
    function createStream(strict, opt) {
      return new SAXStream(strict, opt);
    }
    function SAXStream(strict, opt) {
      if (!(this instanceof SAXStream)) {
        return new SAXStream(strict, opt);
      }
      Stream.apply(this);
      this._parser = new SAXParser(strict, opt);
      this.writable = true;
      this.readable = true;
      var me = this;
      this._parser.onend = function () {
        me.emit('end');
      };
      this._parser.onerror = function (er) {
        me.emit('error', er);
        me._parser.error = null;
      };
      this._decoder = null;
      streamWraps.forEach(function (ev) {
        Object.defineProperty(me, 'on' + ev, {
          get: function () {
            return me._parser['on' + ev];
          },
          set: function (h) {
            if (!h) {
              me.removeAllListeners(ev);
              me._parser['on' + ev] = h;
              return h;
            }
            me.on(ev, h);
          },
          enumerable: true,
          configurable: false,
        });
      });
    }
    SAXStream.prototype = Object.create(Stream.prototype, {
      constructor: {
        value: SAXStream,
      },
    });
    SAXStream.prototype.write = function (data) {
      if (
        typeof Buffer === 'function' &&
        typeof Buffer.isBuffer === 'function' &&
        Buffer.isBuffer(data)
      ) {
        if (!this._decoder) {
          var SD = require('string_decoder').StringDecoder;
          this._decoder = new SD('utf8');
        }
        data = this._decoder.write(data);
      }
      this._parser.write(data.toString());
      this.emit('data', data);
      return true;
    };
    SAXStream.prototype.end = function (chunk) {
      if (chunk && chunk.length) {
        this.write(chunk);
      }
      this._parser.end();
      return true;
    };
    SAXStream.prototype.on = function (ev, handler) {
      var me = this;
      if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
        me._parser['on' + ev] = function () {
          var args =
            arguments.length === 1
              ? [arguments[0]]
              : Array.apply(null, arguments);
          args.splice(0, 0, ev);
          me.emit.apply(me, args);
        };
      }
      return Stream.prototype.on.call(me, ev, handler);
    };
    var CDATA = '[CDATA[';
    var DOCTYPE = 'DOCTYPE';
    var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';
    var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';
    var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
    var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    function isWhitespace(c) {
      return c === ' ' || c === '\n' || c === '\r' || c === '	';
    }
    function isQuote(c) {
      return c === '"' || c === "'";
    }
    function isAttribEnd(c) {
      return c === '>' || isWhitespace(c);
    }
    function isMatch(regex, c) {
      return regex.test(c);
    }
    function notMatch(regex, c) {
      return !isMatch(regex, c);
    }
    var S = 0;
    sax.STATE = {
      BEGIN: S++,
      BEGIN_WHITESPACE: S++,
      TEXT: S++,
      TEXT_ENTITY: S++,
      OPEN_WAKA: S++,
      SGML_DECL: S++,
      SGML_DECL_QUOTED: S++,
      DOCTYPE: S++,
      DOCTYPE_QUOTED: S++,
      DOCTYPE_DTD: S++,
      DOCTYPE_DTD_QUOTED: S++,
      COMMENT_STARTING: S++,
      COMMENT: S++,
      COMMENT_ENDING: S++,
      COMMENT_ENDED: S++,
      CDATA: S++,
      CDATA_ENDING: S++,
      CDATA_ENDING_2: S++,
      PROC_INST: S++,
      PROC_INST_BODY: S++,
      PROC_INST_ENDING: S++,
      OPEN_TAG: S++,
      OPEN_TAG_SLASH: S++,
      ATTRIB: S++,
      ATTRIB_NAME: S++,
      ATTRIB_NAME_SAW_WHITE: S++,
      ATTRIB_VALUE: S++,
      ATTRIB_VALUE_QUOTED: S++,
      ATTRIB_VALUE_CLOSED: S++,
      ATTRIB_VALUE_UNQUOTED: S++,
      ATTRIB_VALUE_ENTITY_Q: S++,
      ATTRIB_VALUE_ENTITY_U: S++,
      CLOSE_TAG: S++,
      CLOSE_TAG_SAW_WHITE: S++,
      SCRIPT: S++,
      SCRIPT_ENDING: S++,
    };
    sax.XML_ENTITIES = {
      amp: '&',
      gt: '>',
      lt: '<',
      quot: '"',
      apos: "'",
    };
    sax.ENTITIES = {
      amp: '&',
      gt: '>',
      lt: '<',
      quot: '"',
      apos: "'",
      AElig: 198,
      Aacute: 193,
      Acirc: 194,
      Agrave: 192,
      Aring: 197,
      Atilde: 195,
      Auml: 196,
      Ccedil: 199,
      ETH: 208,
      Eacute: 201,
      Ecirc: 202,
      Egrave: 200,
      Euml: 203,
      Iacute: 205,
      Icirc: 206,
      Igrave: 204,
      Iuml: 207,
      Ntilde: 209,
      Oacute: 211,
      Ocirc: 212,
      Ograve: 210,
      Oslash: 216,
      Otilde: 213,
      Ouml: 214,
      THORN: 222,
      Uacute: 218,
      Ucirc: 219,
      Ugrave: 217,
      Uuml: 220,
      Yacute: 221,
      aacute: 225,
      acirc: 226,
      aelig: 230,
      agrave: 224,
      aring: 229,
      atilde: 227,
      auml: 228,
      ccedil: 231,
      eacute: 233,
      ecirc: 234,
      egrave: 232,
      eth: 240,
      euml: 235,
      iacute: 237,
      icirc: 238,
      igrave: 236,
      iuml: 239,
      ntilde: 241,
      oacute: 243,
      ocirc: 244,
      ograve: 242,
      oslash: 248,
      otilde: 245,
      ouml: 246,
      szlig: 223,
      thorn: 254,
      uacute: 250,
      ucirc: 251,
      ugrave: 249,
      uuml: 252,
      yacute: 253,
      yuml: 255,
      copy: 169,
      reg: 174,
      nbsp: 160,
      iexcl: 161,
      cent: 162,
      pound: 163,
      curren: 164,
      yen: 165,
      brvbar: 166,
      sect: 167,
      uml: 168,
      ordf: 170,
      laquo: 171,
      not: 172,
      shy: 173,
      macr: 175,
      deg: 176,
      plusmn: 177,
      sup1: 185,
      sup2: 178,
      sup3: 179,
      acute: 180,
      micro: 181,
      para: 182,
      middot: 183,
      cedil: 184,
      ordm: 186,
      raquo: 187,
      frac14: 188,
      frac12: 189,
      frac34: 190,
      iquest: 191,
      times: 215,
      divide: 247,
      OElig: 338,
      oelig: 339,
      Scaron: 352,
      scaron: 353,
      Yuml: 376,
      fnof: 402,
      circ: 710,
      tilde: 732,
      Alpha: 913,
      Beta: 914,
      Gamma: 915,
      Delta: 916,
      Epsilon: 917,
      Zeta: 918,
      Eta: 919,
      Theta: 920,
      Iota: 921,
      Kappa: 922,
      Lambda: 923,
      Mu: 924,
      Nu: 925,
      Xi: 926,
      Omicron: 927,
      Pi: 928,
      Rho: 929,
      Sigma: 931,
      Tau: 932,
      Upsilon: 933,
      Phi: 934,
      Chi: 935,
      Psi: 936,
      Omega: 937,
      alpha: 945,
      beta: 946,
      gamma: 947,
      delta: 948,
      epsilon: 949,
      zeta: 950,
      eta: 951,
      theta: 952,
      iota: 953,
      kappa: 954,
      lambda: 955,
      mu: 956,
      nu: 957,
      xi: 958,
      omicron: 959,
      pi: 960,
      rho: 961,
      sigmaf: 962,
      sigma: 963,
      tau: 964,
      upsilon: 965,
      phi: 966,
      chi: 967,
      psi: 968,
      omega: 969,
      thetasym: 977,
      upsih: 978,
      piv: 982,
      ensp: 8194,
      emsp: 8195,
      thinsp: 8201,
      zwnj: 8204,
      zwj: 8205,
      lrm: 8206,
      rlm: 8207,
      ndash: 8211,
      mdash: 8212,
      lsquo: 8216,
      rsquo: 8217,
      sbquo: 8218,
      ldquo: 8220,
      rdquo: 8221,
      bdquo: 8222,
      dagger: 8224,
      Dagger: 8225,
      bull: 8226,
      hellip: 8230,
      permil: 8240,
      prime: 8242,
      Prime: 8243,
      lsaquo: 8249,
      rsaquo: 8250,
      oline: 8254,
      frasl: 8260,
      euro: 8364,
      image: 8465,
      weierp: 8472,
      real: 8476,
      trade: 8482,
      alefsym: 8501,
      larr: 8592,
      uarr: 8593,
      rarr: 8594,
      darr: 8595,
      harr: 8596,
      crarr: 8629,
      lArr: 8656,
      uArr: 8657,
      rArr: 8658,
      dArr: 8659,
      hArr: 8660,
      forall: 8704,
      part: 8706,
      exist: 8707,
      empty: 8709,
      nabla: 8711,
      isin: 8712,
      notin: 8713,
      ni: 8715,
      prod: 8719,
      sum: 8721,
      minus: 8722,
      lowast: 8727,
      radic: 8730,
      prop: 8733,
      infin: 8734,
      ang: 8736,
      and: 8743,
      or: 8744,
      cap: 8745,
      cup: 8746,
      int: 8747,
      there4: 8756,
      sim: 8764,
      cong: 8773,
      asymp: 8776,
      ne: 8800,
      equiv: 8801,
      le: 8804,
      ge: 8805,
      sub: 8834,
      sup: 8835,
      nsub: 8836,
      sube: 8838,
      supe: 8839,
      oplus: 8853,
      otimes: 8855,
      perp: 8869,
      sdot: 8901,
      lceil: 8968,
      rceil: 8969,
      lfloor: 8970,
      rfloor: 8971,
      lang: 9001,
      rang: 9002,
      loz: 9674,
      spades: 9824,
      clubs: 9827,
      hearts: 9829,
      diams: 9830,
    };
    Object.keys(sax.ENTITIES).forEach(function (key) {
      var e = sax.ENTITIES[key];
      var s2 = typeof e === 'number' ? String.fromCharCode(e) : e;
      sax.ENTITIES[key] = s2;
    });
    for (var s in sax.STATE) {
      sax.STATE[sax.STATE[s]] = s;
    }
    S = sax.STATE;
    function emit(parser, event, data) {
      parser[event] && parser[event](data);
    }
    function emitNode(parser, nodeType, data) {
      if (parser.textNode) closeText(parser);
      emit(parser, nodeType, data);
    }
    function closeText(parser) {
      parser.textNode = textopts(parser.opt, parser.textNode);
      if (parser.textNode) emit(parser, 'ontext', parser.textNode);
      parser.textNode = '';
    }
    function textopts(opt, text) {
      if (opt.trim) text = text.trim();
      if (opt.normalize) text = text.replace(/\s+/g, ' ');
      return text;
    }
    function error(parser, er) {
      closeText(parser);
      if (parser.trackPosition) {
        er +=
          '\nLine: ' +
          parser.line +
          '\nColumn: ' +
          parser.column +
          '\nChar: ' +
          parser.c;
      }
      er = new Error(er);
      parser.error = er;
      emit(parser, 'onerror', er);
      return parser;
    }
    function end(parser) {
      if (parser.sawRoot && !parser.closedRoot)
        strictFail(parser, 'Unclosed root tag');
      if (
        parser.state !== S.BEGIN &&
        parser.state !== S.BEGIN_WHITESPACE &&
        parser.state !== S.TEXT
      ) {
        error(parser, 'Unexpected end');
      }
      closeText(parser);
      parser.c = '';
      parser.closed = true;
      emit(parser, 'onend');
      SAXParser.call(parser, parser.strict, parser.opt);
      return parser;
    }
    function strictFail(parser, message) {
      if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
        throw new Error('bad call to strictFail');
      }
      if (parser.strict) {
        error(parser, message);
      }
    }
    function newTag(parser) {
      if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
      var parent = parser.tags[parser.tags.length - 1] || parser;
      var tag = (parser.tag = { name: parser.tagName, attributes: {} });
      if (parser.opt.xmlns) {
        tag.ns = parent.ns;
      }
      parser.attribList.length = 0;
      emitNode(parser, 'onopentagstart', tag);
    }
    function qname(name, attribute) {
      var i = name.indexOf(':');
      var qualName = i < 0 ? ['', name] : name.split(':');
      var prefix = qualName[0];
      var local = qualName[1];
      if (attribute && name === 'xmlns') {
        prefix = 'xmlns';
        local = '';
      }
      return { prefix, local };
    }
    function attrib(parser) {
      if (!parser.strict) {
        parser.attribName = parser.attribName[parser.looseCase]();
      }
      if (
        parser.attribList.indexOf(parser.attribName) !== -1 ||
        parser.tag.attributes.hasOwnProperty(parser.attribName)
      ) {
        parser.attribName = parser.attribValue = '';
        return;
      }
      if (parser.opt.xmlns) {
        var qn = qname(parser.attribName, true);
        var prefix = qn.prefix;
        var local = qn.local;
        if (prefix === 'xmlns') {
          if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
            strictFail(
              parser,
              'xml: prefix must be bound to ' +
                XML_NAMESPACE +
                '\nActual: ' +
                parser.attribValue,
            );
          } else if (
            local === 'xmlns' &&
            parser.attribValue !== XMLNS_NAMESPACE
          ) {
            strictFail(
              parser,
              'xmlns: prefix must be bound to ' +
                XMLNS_NAMESPACE +
                '\nActual: ' +
                parser.attribValue,
            );
          } else {
            var tag = parser.tag;
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns === parent.ns) {
              tag.ns = Object.create(parent.ns);
            }
            tag.ns[local] = parser.attribValue;
          }
        }
        parser.attribList.push([parser.attribName, parser.attribValue]);
      } else {
        parser.tag.attributes[parser.attribName] = parser.attribValue;
        emitNode(parser, 'onattribute', {
          name: parser.attribName,
          value: parser.attribValue,
        });
      }
      parser.attribName = parser.attribValue = '';
    }
    function openTag(parser, selfClosing) {
      if (parser.opt.xmlns) {
        var tag = parser.tag;
        var qn = qname(parser.tagName);
        tag.prefix = qn.prefix;
        tag.local = qn.local;
        tag.uri = tag.ns[qn.prefix] || '';
        if (tag.prefix && !tag.uri) {
          strictFail(
            parser,
            'Unbound namespace prefix: ' + JSON.stringify(parser.tagName),
          );
          tag.uri = qn.prefix;
        }
        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (tag.ns && parent.ns !== tag.ns) {
          Object.keys(tag.ns).forEach(function (p) {
            emitNode(parser, 'onopennamespace', {
              prefix: p,
              uri: tag.ns[p],
            });
          });
        }
        for (var i = 0, l = parser.attribList.length; i < l; i++) {
          var nv = parser.attribList[i];
          var name = nv[0];
          var value = nv[1];
          var qualName = qname(name, true);
          var prefix = qualName.prefix;
          var local = qualName.local;
          var uri = prefix === '' ? '' : tag.ns[prefix] || '';
          var a = {
            name,
            value,
            prefix,
            local,
            uri,
          };
          if (prefix && prefix !== 'xmlns' && !uri) {
            strictFail(
              parser,
              'Unbound namespace prefix: ' + JSON.stringify(prefix),
            );
            a.uri = prefix;
          }
          parser.tag.attributes[name] = a;
          emitNode(parser, 'onattribute', a);
        }
        parser.attribList.length = 0;
      }
      parser.tag.isSelfClosing = !!selfClosing;
      parser.sawRoot = true;
      parser.tags.push(parser.tag);
      emitNode(parser, 'onopentag', parser.tag);
      if (!selfClosing) {
        if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
          parser.state = S.SCRIPT;
        } else {
          parser.state = S.TEXT;
        }
        parser.tag = null;
        parser.tagName = '';
      }
      parser.attribName = parser.attribValue = '';
      parser.attribList.length = 0;
    }
    function closeTag(parser) {
      if (!parser.tagName) {
        strictFail(parser, 'Weird empty close tag.');
        parser.textNode += '</>';
        parser.state = S.TEXT;
        return;
      }
      if (parser.script) {
        if (parser.tagName !== 'script') {
          parser.script += '</' + parser.tagName + '>';
          parser.tagName = '';
          parser.state = S.SCRIPT;
          return;
        }
        emitNode(parser, 'onscript', parser.script);
        parser.script = '';
      }
      var t = parser.tags.length;
      var tagName = parser.tagName;
      if (!parser.strict) {
        tagName = tagName[parser.looseCase]();
      }
      var closeTo = tagName;
      while (t--) {
        var close = parser.tags[t];
        if (close.name !== closeTo) {
          strictFail(parser, 'Unexpected close tag');
        } else {
          break;
        }
      }
      if (t < 0) {
        strictFail(parser, 'Unmatched closing tag: ' + parser.tagName);
        parser.textNode += '</' + parser.tagName + '>';
        parser.state = S.TEXT;
        return;
      }
      parser.tagName = tagName;
      var s2 = parser.tags.length;
      while (s2-- > t) {
        var tag = (parser.tag = parser.tags.pop());
        parser.tagName = parser.tag.name;
        emitNode(parser, 'onclosetag', parser.tagName);
        var x = {};
        for (var i in tag.ns) {
          x[i] = tag.ns[i];
        }
        var parent = parser.tags[parser.tags.length - 1] || parser;
        if (parser.opt.xmlns && tag.ns !== parent.ns) {
          Object.keys(tag.ns).forEach(function (p) {
            var n = tag.ns[p];
            emitNode(parser, 'onclosenamespace', { prefix: p, uri: n });
          });
        }
      }
      if (t === 0) parser.closedRoot = true;
      parser.tagName = parser.attribValue = parser.attribName = '';
      parser.attribList.length = 0;
      parser.state = S.TEXT;
    }
    function parseEntity(parser) {
      var entity = parser.entity;
      var entityLC = entity.toLowerCase();
      var num;
      var numStr = '';
      if (parser.ENTITIES[entity]) {
        return parser.ENTITIES[entity];
      }
      if (parser.ENTITIES[entityLC]) {
        return parser.ENTITIES[entityLC];
      }
      entity = entityLC;
      if (entity.charAt(0) === '#') {
        if (entity.charAt(1) === 'x') {
          entity = entity.slice(2);
          num = parseInt(entity, 16);
          numStr = num.toString(16);
        } else {
          entity = entity.slice(1);
          num = parseInt(entity, 10);
          numStr = num.toString(10);
        }
      }
      entity = entity.replace(/^0+/, '');
      if (isNaN(num) || numStr.toLowerCase() !== entity) {
        strictFail(parser, 'Invalid character entity');
        return '&' + parser.entity + ';';
      }
      return String.fromCodePoint(num);
    }
    function beginWhiteSpace(parser, c) {
      if (c === '<') {
        parser.state = S.OPEN_WAKA;
        parser.startTagPosition = parser.position;
      } else if (!isWhitespace(c)) {
        strictFail(parser, 'Non-whitespace before first tag.');
        parser.textNode = c;
        parser.state = S.TEXT;
      }
    }
    function charAt(chunk, i) {
      var result = '';
      if (i < chunk.length) {
        result = chunk.charAt(i);
      }
      return result;
    }
    function write(chunk) {
      var parser = this;
      if (this.error) {
        throw this.error;
      }
      if (parser.closed) {
        return error(
          parser,
          'Cannot write after close. Assign an onready handler.',
        );
      }
      if (chunk === null) {
        return end(parser);
      }
      if (typeof chunk === 'object') {
        chunk = chunk.toString();
      }
      var i = 0;
      var c = '';
      while (true) {
        c = charAt(chunk, i++);
        parser.c = c;
        if (!c) {
          break;
        }
        if (parser.trackPosition) {
          parser.position++;
          if (c === '\n') {
            parser.line++;
            parser.column = 0;
          } else {
            parser.column++;
          }
        }
        switch (parser.state) {
          case S.BEGIN:
            parser.state = S.BEGIN_WHITESPACE;
            if (c === '\uFEFF') {
              continue;
            }
            beginWhiteSpace(parser, c);
            continue;
          case S.BEGIN_WHITESPACE:
            beginWhiteSpace(parser, c);
            continue;
          case S.TEXT:
            if (parser.sawRoot && !parser.closedRoot) {
              var starti = i - 1;
              while (c && c !== '<' && c !== '&') {
                c = charAt(chunk, i++);
                if (c && parser.trackPosition) {
                  parser.position++;
                  if (c === '\n') {
                    parser.line++;
                    parser.column = 0;
                  } else {
                    parser.column++;
                  }
                }
              }
              parser.textNode += chunk.substring(starti, i - 1);
            }
            if (
              c === '<' &&
              !(parser.sawRoot && parser.closedRoot && !parser.strict)
            ) {
              parser.state = S.OPEN_WAKA;
              parser.startTagPosition = parser.position;
            } else {
              if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                strictFail(parser, 'Text data outside of root node.');
              }
              if (c === '&') {
                parser.state = S.TEXT_ENTITY;
              } else {
                parser.textNode += c;
              }
            }
            continue;
          case S.SCRIPT:
            if (c === '<') {
              parser.state = S.SCRIPT_ENDING;
            } else {
              parser.script += c;
            }
            continue;
          case S.SCRIPT_ENDING:
            if (c === '/') {
              parser.state = S.CLOSE_TAG;
            } else {
              parser.script += '<' + c;
              parser.state = S.SCRIPT;
            }
            continue;
          case S.OPEN_WAKA:
            if (c === '!') {
              parser.state = S.SGML_DECL;
              parser.sgmlDecl = '';
            } else if (isWhitespace(c)) {
            } else if (isMatch(nameStart, c)) {
              parser.state = S.OPEN_TAG;
              parser.tagName = c;
            } else if (c === '/') {
              parser.state = S.CLOSE_TAG;
              parser.tagName = '';
            } else if (c === '?') {
              parser.state = S.PROC_INST;
              parser.procInstName = parser.procInstBody = '';
            } else {
              strictFail(parser, 'Unencoded <');
              if (parser.startTagPosition + 1 < parser.position) {
                var pad = parser.position - parser.startTagPosition;
                c = new Array(pad).join(' ') + c;
              }
              parser.textNode += '<' + c;
              parser.state = S.TEXT;
            }
            continue;
          case S.SGML_DECL:
            if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
              emitNode(parser, 'onopencdata');
              parser.state = S.CDATA;
              parser.sgmlDecl = '';
              parser.cdata = '';
            } else if (parser.sgmlDecl + c === '--') {
              parser.state = S.COMMENT;
              parser.comment = '';
              parser.sgmlDecl = '';
            } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
              parser.state = S.DOCTYPE;
              if (parser.doctype || parser.sawRoot) {
                strictFail(
                  parser,
                  'Inappropriately located doctype declaration',
                );
              }
              parser.doctype = '';
              parser.sgmlDecl = '';
            } else if (c === '>') {
              emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl);
              parser.sgmlDecl = '';
              parser.state = S.TEXT;
            } else if (isQuote(c)) {
              parser.state = S.SGML_DECL_QUOTED;
              parser.sgmlDecl += c;
            } else {
              parser.sgmlDecl += c;
            }
            continue;
          case S.SGML_DECL_QUOTED:
            if (c === parser.q) {
              parser.state = S.SGML_DECL;
              parser.q = '';
            }
            parser.sgmlDecl += c;
            continue;
          case S.DOCTYPE:
            if (c === '>') {
              parser.state = S.TEXT;
              emitNode(parser, 'ondoctype', parser.doctype);
              parser.doctype = true;
            } else {
              parser.doctype += c;
              if (c === '[') {
                parser.state = S.DOCTYPE_DTD;
              } else if (isQuote(c)) {
                parser.state = S.DOCTYPE_QUOTED;
                parser.q = c;
              }
            }
            continue;
          case S.DOCTYPE_QUOTED:
            parser.doctype += c;
            if (c === parser.q) {
              parser.q = '';
              parser.state = S.DOCTYPE;
            }
            continue;
          case S.DOCTYPE_DTD:
            parser.doctype += c;
            if (c === ']') {
              parser.state = S.DOCTYPE;
            } else if (isQuote(c)) {
              parser.state = S.DOCTYPE_DTD_QUOTED;
              parser.q = c;
            }
            continue;
          case S.DOCTYPE_DTD_QUOTED:
            parser.doctype += c;
            if (c === parser.q) {
              parser.state = S.DOCTYPE_DTD;
              parser.q = '';
            }
            continue;
          case S.COMMENT:
            if (c === '-') {
              parser.state = S.COMMENT_ENDING;
            } else {
              parser.comment += c;
            }
            continue;
          case S.COMMENT_ENDING:
            if (c === '-') {
              parser.state = S.COMMENT_ENDED;
              parser.comment = textopts(parser.opt, parser.comment);
              if (parser.comment) {
                emitNode(parser, 'oncomment', parser.comment);
              }
              parser.comment = '';
            } else {
              parser.comment += '-' + c;
              parser.state = S.COMMENT;
            }
            continue;
          case S.COMMENT_ENDED:
            if (c !== '>') {
              strictFail(parser, 'Malformed comment');
              parser.comment += '--' + c;
              parser.state = S.COMMENT;
            } else {
              parser.state = S.TEXT;
            }
            continue;
          case S.CDATA:
            if (c === ']') {
              parser.state = S.CDATA_ENDING;
            } else {
              parser.cdata += c;
            }
            continue;
          case S.CDATA_ENDING:
            if (c === ']') {
              parser.state = S.CDATA_ENDING_2;
            } else {
              parser.cdata += ']' + c;
              parser.state = S.CDATA;
            }
            continue;
          case S.CDATA_ENDING_2:
            if (c === '>') {
              if (parser.cdata) {
                emitNode(parser, 'oncdata', parser.cdata);
              }
              emitNode(parser, 'onclosecdata');
              parser.cdata = '';
              parser.state = S.TEXT;
            } else if (c === ']') {
              parser.cdata += ']';
            } else {
              parser.cdata += ']]' + c;
              parser.state = S.CDATA;
            }
            continue;
          case S.PROC_INST:
            if (c === '?') {
              parser.state = S.PROC_INST_ENDING;
            } else if (isWhitespace(c)) {
              parser.state = S.PROC_INST_BODY;
            } else {
              parser.procInstName += c;
            }
            continue;
          case S.PROC_INST_BODY:
            if (!parser.procInstBody && isWhitespace(c)) {
              continue;
            } else if (c === '?') {
              parser.state = S.PROC_INST_ENDING;
            } else {
              parser.procInstBody += c;
            }
            continue;
          case S.PROC_INST_ENDING:
            if (c === '>') {
              emitNode(parser, 'onprocessinginstruction', {
                name: parser.procInstName,
                body: parser.procInstBody,
              });
              parser.procInstName = parser.procInstBody = '';
              parser.state = S.TEXT;
            } else {
              parser.procInstBody += '?' + c;
              parser.state = S.PROC_INST_BODY;
            }
            continue;
          case S.OPEN_TAG:
            if (isMatch(nameBody, c)) {
              parser.tagName += c;
            } else {
              newTag(parser);
              if (c === '>') {
                openTag(parser);
              } else if (c === '/') {
                parser.state = S.OPEN_TAG_SLASH;
              } else {
                if (!isWhitespace(c)) {
                  strictFail(parser, 'Invalid character in tag name');
                }
                parser.state = S.ATTRIB;
              }
            }
            continue;
          case S.OPEN_TAG_SLASH:
            if (c === '>') {
              openTag(parser, true);
              closeTag(parser);
            } else {
              strictFail(
                parser,
                'Forward-slash in opening tag not followed by >',
              );
              parser.state = S.ATTRIB;
            }
            continue;
          case S.ATTRIB:
            if (isWhitespace(c)) {
              continue;
            } else if (c === '>') {
              openTag(parser);
            } else if (c === '/') {
              parser.state = S.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c;
              parser.attribValue = '';
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, 'Invalid attribute name');
            }
            continue;
          case S.ATTRIB_NAME:
            if (c === '=') {
              parser.state = S.ATTRIB_VALUE;
            } else if (c === '>') {
              strictFail(parser, 'Attribute without value');
              parser.attribValue = parser.attribName;
              attrib(parser);
              openTag(parser);
            } else if (isWhitespace(c)) {
              parser.state = S.ATTRIB_NAME_SAW_WHITE;
            } else if (isMatch(nameBody, c)) {
              parser.attribName += c;
            } else {
              strictFail(parser, 'Invalid attribute name');
            }
            continue;
          case S.ATTRIB_NAME_SAW_WHITE:
            if (c === '=') {
              parser.state = S.ATTRIB_VALUE;
            } else if (isWhitespace(c)) {
              continue;
            } else {
              strictFail(parser, 'Attribute without value');
              parser.tag.attributes[parser.attribName] = '';
              parser.attribValue = '';
              emitNode(parser, 'onattribute', {
                name: parser.attribName,
                value: '',
              });
              parser.attribName = '';
              if (c === '>') {
                openTag(parser);
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, 'Invalid attribute name');
                parser.state = S.ATTRIB;
              }
            }
            continue;
          case S.ATTRIB_VALUE:
            if (isWhitespace(c)) {
              continue;
            } else if (isQuote(c)) {
              parser.q = c;
              parser.state = S.ATTRIB_VALUE_QUOTED;
            } else {
              strictFail(parser, 'Unquoted attribute value');
              parser.state = S.ATTRIB_VALUE_UNQUOTED;
              parser.attribValue = c;
            }
            continue;
          case S.ATTRIB_VALUE_QUOTED:
            if (c !== parser.q) {
              if (c === '&') {
                parser.state = S.ATTRIB_VALUE_ENTITY_Q;
              } else {
                parser.attribValue += c;
              }
              continue;
            }
            attrib(parser);
            parser.q = '';
            parser.state = S.ATTRIB_VALUE_CLOSED;
            continue;
          case S.ATTRIB_VALUE_CLOSED:
            if (isWhitespace(c)) {
              parser.state = S.ATTRIB;
            } else if (c === '>') {
              openTag(parser);
            } else if (c === '/') {
              parser.state = S.OPEN_TAG_SLASH;
            } else if (isMatch(nameStart, c)) {
              strictFail(parser, 'No whitespace between attributes');
              parser.attribName = c;
              parser.attribValue = '';
              parser.state = S.ATTRIB_NAME;
            } else {
              strictFail(parser, 'Invalid attribute name');
            }
            continue;
          case S.ATTRIB_VALUE_UNQUOTED:
            if (!isAttribEnd(c)) {
              if (c === '&') {
                parser.state = S.ATTRIB_VALUE_ENTITY_U;
              } else {
                parser.attribValue += c;
              }
              continue;
            }
            attrib(parser);
            if (c === '>') {
              openTag(parser);
            } else {
              parser.state = S.ATTRIB;
            }
            continue;
          case S.CLOSE_TAG:
            if (!parser.tagName) {
              if (isWhitespace(c)) {
                continue;
              } else if (notMatch(nameStart, c)) {
                if (parser.script) {
                  parser.script += '</' + c;
                  parser.state = S.SCRIPT;
                } else {
                  strictFail(parser, 'Invalid tagname in closing tag.');
                }
              } else {
                parser.tagName = c;
              }
            } else if (c === '>') {
              closeTag(parser);
            } else if (isMatch(nameBody, c)) {
              parser.tagName += c;
            } else if (parser.script) {
              parser.script += '</' + parser.tagName;
              parser.tagName = '';
              parser.state = S.SCRIPT;
            } else {
              if (!isWhitespace(c)) {
                strictFail(parser, 'Invalid tagname in closing tag');
              }
              parser.state = S.CLOSE_TAG_SAW_WHITE;
            }
            continue;
          case S.CLOSE_TAG_SAW_WHITE:
            if (isWhitespace(c)) {
              continue;
            }
            if (c === '>') {
              closeTag(parser);
            } else {
              strictFail(parser, 'Invalid characters in closing tag');
            }
            continue;
          case S.TEXT_ENTITY:
          case S.ATTRIB_VALUE_ENTITY_Q:
          case S.ATTRIB_VALUE_ENTITY_U:
            var returnState;
            var buffer;
            switch (parser.state) {
              case S.TEXT_ENTITY:
                returnState = S.TEXT;
                buffer = 'textNode';
                break;
              case S.ATTRIB_VALUE_ENTITY_Q:
                returnState = S.ATTRIB_VALUE_QUOTED;
                buffer = 'attribValue';
                break;
              case S.ATTRIB_VALUE_ENTITY_U:
                returnState = S.ATTRIB_VALUE_UNQUOTED;
                buffer = 'attribValue';
                break;
            }
            if (c === ';') {
              parser[buffer] += parseEntity(parser);
              parser.entity = '';
              parser.state = returnState;
            } else if (
              isMatch(parser.entity.length ? entityBody : entityStart, c)
            ) {
              parser.entity += c;
            } else {
              strictFail(parser, 'Invalid character in entity name');
              parser[buffer] += '&' + parser.entity + c;
              parser.entity = '';
              parser.state = returnState;
            }
            continue;
          default:
            throw new Error(parser, 'Unknown state: ' + parser.state);
        }
      }
      if (parser.position >= parser.bufferCheckPosition) {
        checkBufferLength(parser);
      }
      return parser;
    }
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
    if (!String.fromCodePoint) {
      (function () {
        var stringFromCharCode = String.fromCharCode;
        var floor = Math.floor;
        var fromCodePoint = function () {
          var MAX_SIZE = 16384;
          var codeUnits = [];
          var highSurrogate;
          var lowSurrogate;
          var index = -1;
          var length = arguments.length;
          if (!length) {
            return '';
          }
          var result = '';
          while (++index < length) {
            var codePoint = Number(arguments[index]);
            if (
              !isFinite(codePoint) ||
              codePoint < 0 ||
              codePoint > 1114111 ||
              floor(codePoint) !== codePoint
            ) {
              throw RangeError('Invalid code point: ' + codePoint);
            }
            if (codePoint <= 65535) {
              codeUnits.push(codePoint);
            } else {
              codePoint -= 65536;
              highSurrogate = (codePoint >> 10) + 55296;
              lowSurrogate = (codePoint % 1024) + 56320;
              codeUnits.push(highSurrogate, lowSurrogate);
            }
            if (index + 1 === length || codeUnits.length > MAX_SIZE) {
              result += stringFromCharCode.apply(null, codeUnits);
              codeUnits.length = 0;
            }
          }
          return result;
        };
        if (Object.defineProperty) {
          Object.defineProperty(String, 'fromCodePoint', {
            value: fromCodePoint,
            configurable: true,
            writable: true,
          });
        } else {
          String.fromCodePoint = fromCodePoint;
        }
      })();
    }
  })(typeof exports2 === 'undefined' ? (exports2.sax = {}) : exports2);
});

// node_modules/xml2js/lib/bom.js
var require_bom = __commonJS((exports2) => {
  (function () {
    'use strict';
    exports2.stripBOM = function (str) {
      if (str[0] === '\uFEFF') {
        return str.substring(1);
      } else {
        return str;
      }
    };
  }.call(exports2));
});

// node_modules/xml2js/lib/processors.js
var require_processors = __commonJS((exports2) => {
  (function () {
    'use strict';
    var prefixMatch;
    prefixMatch = new RegExp(/(?!xmlns)^.*:/);
    exports2.normalize = function (str) {
      return str.toLowerCase();
    };
    exports2.firstCharLowerCase = function (str) {
      return str.charAt(0).toLowerCase() + str.slice(1);
    };
    exports2.stripPrefix = function (str) {
      return str.replace(prefixMatch, '');
    };
    exports2.parseNumbers = function (str) {
      if (!isNaN(str)) {
        str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
      }
      return str;
    };
    exports2.parseBooleans = function (str) {
      if (/^(?:true|false)$/i.test(str)) {
        str = str.toLowerCase() === 'true';
      }
      return str;
    };
  }.call(exports2));
});

// node_modules/xml2js/lib/parser.js
var require_parser2 = __commonJS((exports2) => {
  (function () {
    'use strict';
    var bom,
      defaults,
      events,
      isEmpty,
      processItem,
      processors,
      sax,
      setImmediate2,
      bind = function (fn, me) {
        return function () {
          return fn.apply(me, arguments);
        };
      },
      extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
      hasProp = {}.hasOwnProperty;
    sax = require_sax();
    events = require('events');
    bom = require_bom();
    processors = require_processors();
    setImmediate2 = require('timers').setImmediate;
    defaults = require_defaults().defaults;
    isEmpty = function (thing) {
      return (
        typeof thing === 'object' &&
        thing != null &&
        Object.keys(thing).length === 0
      );
    };
    processItem = function (processors2, item, key) {
      var i, len, process2;
      for (i = 0, len = processors2.length; i < len; i++) {
        process2 = processors2[i];
        item = process2(item, key);
      }
      return item;
    };
    exports2.Parser = (function (superClass) {
      extend(Parser, superClass);
      function Parser(opts) {
        this.parseStringPromise = bind(this.parseStringPromise, this);
        this.parseString = bind(this.parseString, this);
        this.reset = bind(this.reset, this);
        this.assignOrPush = bind(this.assignOrPush, this);
        this.processAsync = bind(this.processAsync, this);
        var key, ref, value;
        if (!(this instanceof exports2.Parser)) {
          return new exports2.Parser(opts);
        }
        this.options = {};
        ref = defaults['0.2'];
        for (key in ref) {
          if (!hasProp.call(ref, key)) continue;
          value = ref[key];
          this.options[key] = value;
        }
        for (key in opts) {
          if (!hasProp.call(opts, key)) continue;
          value = opts[key];
          this.options[key] = value;
        }
        if (this.options.xmlns) {
          this.options.xmlnskey = this.options.attrkey + 'ns';
        }
        if (this.options.normalizeTags) {
          if (!this.options.tagNameProcessors) {
            this.options.tagNameProcessors = [];
          }
          this.options.tagNameProcessors.unshift(processors.normalize);
        }
        this.reset();
      }
      Parser.prototype.processAsync = function () {
        var chunk, err;
        try {
          if (this.remaining.length <= this.options.chunkSize) {
            chunk = this.remaining;
            this.remaining = '';
            this.saxParser = this.saxParser.write(chunk);
            return this.saxParser.close();
          } else {
            chunk = this.remaining.substr(0, this.options.chunkSize);
            this.remaining = this.remaining.substr(
              this.options.chunkSize,
              this.remaining.length,
            );
            this.saxParser = this.saxParser.write(chunk);
            return setImmediate2(this.processAsync);
          }
        } catch (error1) {
          err = error1;
          if (!this.saxParser.errThrown) {
            this.saxParser.errThrown = true;
            return this.emit(err);
          }
        }
      };
      Parser.prototype.assignOrPush = function (obj, key, newValue) {
        if (!(key in obj)) {
          if (!this.options.explicitArray) {
            return (obj[key] = newValue);
          } else {
            return (obj[key] = [newValue]);
          }
        } else {
          if (!(obj[key] instanceof Array)) {
            obj[key] = [obj[key]];
          }
          return obj[key].push(newValue);
        }
      };
      Parser.prototype.reset = function () {
        var attrkey, charkey, ontext, stack;
        this.removeAllListeners();
        this.saxParser = sax.parser(this.options.strict, {
          trim: false,
          normalize: false,
          xmlns: this.options.xmlns,
        });
        this.saxParser.errThrown = false;
        this.saxParser.onerror = (function (_this) {
          return function (error) {
            _this.saxParser.resume();
            if (!_this.saxParser.errThrown) {
              _this.saxParser.errThrown = true;
              return _this.emit('error', error);
            }
          };
        })(this);
        this.saxParser.onend = (function (_this) {
          return function () {
            if (!_this.saxParser.ended) {
              _this.saxParser.ended = true;
              return _this.emit('end', _this.resultObject);
            }
          };
        })(this);
        this.saxParser.ended = false;
        this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
        this.resultObject = null;
        stack = [];
        attrkey = this.options.attrkey;
        charkey = this.options.charkey;
        this.saxParser.onopentag = (function (_this) {
          return function (node) {
            var key, newValue, obj, processedKey, ref;
            obj = {};
            obj[charkey] = '';
            if (!_this.options.ignoreAttrs) {
              ref = node.attributes;
              for (key in ref) {
                if (!hasProp.call(ref, key)) continue;
                if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                  obj[attrkey] = {};
                }
                newValue = _this.options.attrValueProcessors
                  ? processItem(
                      _this.options.attrValueProcessors,
                      node.attributes[key],
                      key,
                    )
                  : node.attributes[key];
                processedKey = _this.options.attrNameProcessors
                  ? processItem(_this.options.attrNameProcessors, key)
                  : key;
                if (_this.options.mergeAttrs) {
                  _this.assignOrPush(obj, processedKey, newValue);
                } else {
                  obj[attrkey][processedKey] = newValue;
                }
              }
            }
            obj['#name'] = _this.options.tagNameProcessors
              ? processItem(_this.options.tagNameProcessors, node.name)
              : node.name;
            if (_this.options.xmlns) {
              obj[_this.options.xmlnskey] = {
                uri: node.uri,
                local: node.local,
              };
            }
            return stack.push(obj);
          };
        })(this);
        this.saxParser.onclosetag = (function (_this) {
          return function () {
            var cdata,
              emptyStr,
              key,
              node,
              nodeName,
              obj,
              objClone,
              old,
              s,
              xpath;
            obj = stack.pop();
            nodeName = obj['#name'];
            if (
              !_this.options.explicitChildren ||
              !_this.options.preserveChildrenOrder
            ) {
              delete obj['#name'];
            }
            if (obj.cdata === true) {
              cdata = obj.cdata;
              delete obj.cdata;
            }
            s = stack[stack.length - 1];
            if (obj[charkey].match(/^\s*$/) && !cdata) {
              emptyStr = obj[charkey];
              delete obj[charkey];
            } else {
              if (_this.options.trim) {
                obj[charkey] = obj[charkey].trim();
              }
              if (_this.options.normalize) {
                obj[charkey] = obj[charkey].replace(/\s{2,}/g, ' ').trim();
              }
              obj[charkey] = _this.options.valueProcessors
                ? processItem(
                    _this.options.valueProcessors,
                    obj[charkey],
                    nodeName,
                  )
                : obj[charkey];
              if (
                Object.keys(obj).length === 1 &&
                charkey in obj &&
                !_this.EXPLICIT_CHARKEY
              ) {
                obj = obj[charkey];
              }
            }
            if (isEmpty(obj)) {
              obj =
                _this.options.emptyTag !== ''
                  ? _this.options.emptyTag
                  : emptyStr;
            }
            if (_this.options.validator != null) {
              xpath =
                '/' +
                (function () {
                  var i, len, results;
                  results = [];
                  for (i = 0, len = stack.length; i < len; i++) {
                    node = stack[i];
                    results.push(node['#name']);
                  }
                  return results;
                })()
                  .concat(nodeName)
                  .join('/');
              (function () {
                var err;
                try {
                  return (obj = _this.options.validator(
                    xpath,
                    s && s[nodeName],
                    obj,
                  ));
                } catch (error1) {
                  err = error1;
                  return _this.emit('error', err);
                }
              })();
            }
            if (
              _this.options.explicitChildren &&
              !_this.options.mergeAttrs &&
              typeof obj === 'object'
            ) {
              if (!_this.options.preserveChildrenOrder) {
                node = {};
                if (_this.options.attrkey in obj) {
                  node[_this.options.attrkey] = obj[_this.options.attrkey];
                  delete obj[_this.options.attrkey];
                }
                if (
                  !_this.options.charsAsChildren &&
                  _this.options.charkey in obj
                ) {
                  node[_this.options.charkey] = obj[_this.options.charkey];
                  delete obj[_this.options.charkey];
                }
                if (Object.getOwnPropertyNames(obj).length > 0) {
                  node[_this.options.childkey] = obj;
                }
                obj = node;
              } else if (s) {
                s[_this.options.childkey] = s[_this.options.childkey] || [];
                objClone = {};
                for (key in obj) {
                  if (!hasProp.call(obj, key)) continue;
                  objClone[key] = obj[key];
                }
                s[_this.options.childkey].push(objClone);
                delete obj['#name'];
                if (
                  Object.keys(obj).length === 1 &&
                  charkey in obj &&
                  !_this.EXPLICIT_CHARKEY
                ) {
                  obj = obj[charkey];
                }
              }
            }
            if (stack.length > 0) {
              return _this.assignOrPush(s, nodeName, obj);
            } else {
              if (_this.options.explicitRoot) {
                old = obj;
                obj = {};
                obj[nodeName] = old;
              }
              _this.resultObject = obj;
              _this.saxParser.ended = true;
              return _this.emit('end', _this.resultObject);
            }
          };
        })(this);
        ontext = (function (_this) {
          return function (text) {
            var charChild, s;
            s = stack[stack.length - 1];
            if (s) {
              s[charkey] += text;
              if (
                _this.options.explicitChildren &&
                _this.options.preserveChildrenOrder &&
                _this.options.charsAsChildren &&
                (_this.options.includeWhiteChars ||
                  text.replace(/\\n/g, '').trim() !== '')
              ) {
                s[_this.options.childkey] = s[_this.options.childkey] || [];
                charChild = {
                  '#name': '__text__',
                };
                charChild[charkey] = text;
                if (_this.options.normalize) {
                  charChild[charkey] = charChild[charkey]
                    .replace(/\s{2,}/g, ' ')
                    .trim();
                }
                s[_this.options.childkey].push(charChild);
              }
              return s;
            }
          };
        })(this);
        this.saxParser.ontext = ontext;
        return (this.saxParser.oncdata = (function (_this) {
          return function (text) {
            var s;
            s = ontext(text);
            if (s) {
              return (s.cdata = true);
            }
          };
        })(this));
      };
      Parser.prototype.parseString = function (str, cb) {
        var err;
        if (cb != null && typeof cb === 'function') {
          this.on('end', function (result) {
            this.reset();
            return cb(null, result);
          });
          this.on('error', function (err2) {
            this.reset();
            return cb(err2);
          });
        }
        try {
          str = str.toString();
          if (str.trim() === '') {
            this.emit('end', null);
            return true;
          }
          str = bom.stripBOM(str);
          if (this.options.async) {
            this.remaining = str;
            setImmediate2(this.processAsync);
            return this.saxParser;
          }
          return this.saxParser.write(str).close();
        } catch (error1) {
          err = error1;
          if (!(this.saxParser.errThrown || this.saxParser.ended)) {
            this.emit('error', err);
            return (this.saxParser.errThrown = true);
          } else if (this.saxParser.ended) {
            throw err;
          }
        }
      };
      Parser.prototype.parseStringPromise = function (str) {
        return new Promise(
          (function (_this) {
            return function (resolve, reject) {
              return _this.parseString(str, function (err, value) {
                if (err) {
                  return reject(err);
                } else {
                  return resolve(value);
                }
              });
            };
          })(this),
        );
      };
      return Parser;
    })(events);
    exports2.parseString = function (str, a, b) {
      var cb, options, parser;
      if (b != null) {
        if (typeof b === 'function') {
          cb = b;
        }
        if (typeof a === 'object') {
          options = a;
        }
      } else {
        if (typeof a === 'function') {
          cb = a;
        }
        options = {};
      }
      parser = new exports2.Parser(options);
      return parser.parseString(str, cb);
    };
    exports2.parseStringPromise = function (str, a) {
      var options, parser;
      if (typeof a === 'object') {
        options = a;
      }
      parser = new exports2.Parser(options);
      return parser.parseStringPromise(str);
    };
  }.call(exports2));
});

// node_modules/xml2js/lib/xml2js.js
var require_xml2js = __commonJS((exports2) => {
  (function () {
    'use strict';
    var builder,
      defaults,
      parser,
      processors,
      extend = function (child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      },
      hasProp = {}.hasOwnProperty;
    defaults = require_defaults();
    builder = require_builder();
    parser = require_parser2();
    processors = require_processors();
    exports2.defaults = defaults.defaults;
    exports2.processors = processors;
    exports2.ValidationError = (function (superClass) {
      extend(ValidationError, superClass);
      function ValidationError(message) {
        this.message = message;
      }
      return ValidationError;
    })(Error);
    exports2.Builder = builder.Builder;
    exports2.Parser = parser.Parser;
    exports2.parseString = parser.parseString;
    exports2.parseStringPromise = parser.parseStringPromise;
  }.call(exports2));
});

// node_modules/@cloudbase/node-sdk/lib/storage/index.js
var require_storage = __commonJS((exports2) => {
  'use strict';
  var __importDefault =
    (exports2 && exports2.__importDefault) ||
    function (mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
  Object.defineProperty(exports2, '__esModule', { value: true });
  var request_1 = __importDefault(require_request3());
  var fs_1 = __importDefault(require('fs'));
  var httpRequest_1 = __importDefault(require_httpRequest());
  var xml2js_1 = require_xml2js();
  var utils_1 = require_utils3();
  var code_1 = require_code3();
  var cloudbase_1 = require_cloudbase();
  async function parseXML(str) {
    return new Promise((resolve, reject) => {
      xml2js_1.parseString(str, (err, result) => {
        if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      });
    });
  }
  exports2.parseXML = parseXML;
  async function uploadFile(cloudbase2, { cloudPath, fileContent }, opts) {
    const {
      data: { url, token, authorization, fileId, cosFileId },
    } = await getUploadMetadata(cloudbase2, { cloudPath }, opts);
    const formData = {
      Signature: authorization,
      'x-cos-security-token': token,
      'x-cos-meta-fileid': cosFileId,
      key: cloudPath,
      file: fileContent,
    };
    let body = await new Promise((resolve, reject) => {
      request_1.default(
        { url, formData, method: 'post' },
        function (err, res, body2) {
          if (err) {
            reject(err);
          } else {
            resolve(body2);
          }
        },
      );
    });
    body = await parseXML(body);
    if (body && body.Error) {
      const {
        Code: [code],
        Message: [message],
      } = body.Error;
      if (code === 'SignatureDoesNotMatch') {
        return utils_1.processReturn(
          cloudbase2.config.throwOnCode,
          Object.assign({}, code_1.ERROR.SYS_ERR, { message }),
        );
      }
      return utils_1.processReturn(
        cloudbase2.config.throwOnCode,
        Object.assign({}, code_1.ERROR.STORAGE_REQUEST_FAIL, { message }),
      );
    }
    return {
      fileID: fileId,
    };
  }
  exports2.uploadFile = uploadFile;
  async function deleteFile(cloudbase2, { fileList }, opts) {
    if (!fileList || !Array.isArray(fileList)) {
      return utils_1.processReturn(
        cloudbase2.config.throwOnCode,
        Object.assign({}, code_1.ERROR.INVALID_PARAM, {
          message: 'fileList\u5FC5\u987B\u662F\u975E\u7A7A\u7684\u6570\u7EC4',
        }),
      );
    }
    for (let file of fileList) {
      if (!file || typeof file !== 'string') {
        return utils_1.processReturn(
          cloudbase2.config.throwOnCode,
          Object.assign({}, code_1.ERROR.INVALID_PARAM, {
            message:
              'fileList\u7684\u5143\u7D20\u5FC5\u987B\u662F\u975E\u7A7A\u7684\u5B57\u7B26\u4E32',
          }),
        );
      }
    }
    let params = {
      action: 'storage.batchDeleteFile',
      fileid_list: fileList,
    };
    return httpRequest_1
      .default({
        config: cloudbase2.config,
        params,
        method: 'post',
        opts,
        headers: {
          'content-type': 'application/json',
        },
      })
      .then((res) => {
        if (res.code) {
          return res;
        }
        return {
          fileList: res.data.delete_list,
          requestId: res.requestId,
        };
      });
  }
  exports2.deleteFile = deleteFile;
  async function getTempFileURL(cloudbase2, { fileList }, opts) {
    if (!fileList || !Array.isArray(fileList)) {
      return utils_1.processReturn(
        cloudbase2.config.throwOnCode,
        Object.assign({}, code_1.ERROR.INVALID_PARAM, {
          message: 'fileList\u5FC5\u987B\u662F\u975E\u7A7A\u7684\u6570\u7EC4',
        }),
      );
    }
    let file_list = [];
    for (let file of fileList) {
      if (typeof file === 'object') {
        if (!file.hasOwnProperty('fileID') || !file.hasOwnProperty('maxAge')) {
          return utils_1.processReturn(
            cloudbase2.config.throwOnCode,
            Object.assign({}, code_1.ERROR.INVALID_PARAM, {
              message:
                'fileList\u7684\u5143\u7D20\u5982\u679C\u662F\u5BF9\u8C61\uFF0C\u5FC5\u987B\u662F\u5305\u542BfileID\u548CmaxAge\u7684\u5BF9\u8C61',
            }),
          );
        }
        file_list.push({
          fileid: file.fileID,
          max_age: file.maxAge,
        });
      } else if (typeof file === 'string') {
        file_list.push({
          fileid: file,
        });
      } else {
        return utils_1.processReturn(
          cloudbase2.config.throwOnCode,
          Object.assign({}, code_1.ERROR.INVALID_PARAM, {
            message:
              'fileList\u7684\u5143\u7D20\u5982\u679C\u4E0D\u662F\u5BF9\u8C61\uFF0C\u5219\u5FC5\u987B\u662F\u5B57\u7B26\u4E32',
          }),
        );
      }
    }
    let params = {
      action: 'storage.batchGetDownloadUrl',
      file_list,
    };
    return httpRequest_1
      .default({
        config: cloudbase2.config,
        params,
        method: 'post',
        opts,
        headers: {
          'content-type': 'application/json',
        },
      })
      .then((res) => {
        if (res.code) {
          return res;
        }
        return {
          fileList: res.data.download_list,
          requestId: res.requestId,
        };
      });
  }
  exports2.getTempFileURL = getTempFileURL;
  async function downloadFile(cloudbase2, params, opts) {
    let tmpUrl;
    const { fileID, tempFilePath } = params;
    const tmpUrlRes = await getTempFileURL(
      cloudbase2,
      {
        fileList: [
          {
            fileID,
            maxAge: 600,
          },
        ],
      },
      opts,
    );
    const res = tmpUrlRes.fileList[0];
    if (res.code !== 'SUCCESS') {
      return utils_1.processReturn(
        cloudbase2.config.throwOnCode,
        Object.assign({}, res),
      );
    }
    tmpUrl = res.tempFileURL;
    tmpUrl = encodeURI(tmpUrl);
    let req = request_1.default({
      url: tmpUrl,
      encoding: null,
      proxy: cloudbase2.config.proxy,
    });
    return new Promise((resolve, reject) => {
      let fileContent = Buffer.alloc(0);
      req.on('response', function (response) {
        if (response && Number(response.statusCode) === 200) {
          if (tempFilePath) {
            response.pipe(fs_1.default.createWriteStream(tempFilePath));
          } else {
            response.on('data', (data) => {
              fileContent = Buffer.concat([fileContent, data]);
            });
          }
          response.on('end', () => {
            resolve({
              fileContent: tempFilePath ? void 0 : fileContent,
              message: '\u6587\u4EF6\u4E0B\u8F7D\u5B8C\u6210',
            });
          });
        } else {
          reject(response);
        }
      });
    });
  }
  exports2.downloadFile = downloadFile;
  async function getUploadMetadata(cloudbase2, { cloudPath }, opts) {
    let params = {
      action: 'storage.getUploadMetadata',
      path: cloudPath,
    };
    const res = await httpRequest_1.default({
      config: cloudbase2.config,
      params,
      method: 'post',
      opts,
      headers: {
        'content-type': 'application/json',
      },
    });
    return res;
  }
  exports2.getUploadMetadata = getUploadMetadata;
  async function getFileAuthority(cloudbase2, { fileList }, opts) {
    const { LOGINTYPE } = cloudbase_1.CloudBase.getCloudbaseContext();
    if (!Array.isArray(fileList)) {
      throw utils_1.E(
        Object.assign({}, code_1.ERROR.INVALID_PARAM, {
          message: '[node-sdk] getCosFileAuthority fileList must be a array',
        }),
      );
    }
    if (
      fileList.some((file) => {
        if (!file || !file.path) {
          return true;
        }
        if (['READ', 'WRITE', 'READWRITE'].indexOf(file.type) === -1) {
          return true;
        }
        return false;
      })
    ) {
      throw utils_1.E(
        Object.assign({}, code_1.ERROR.INVALID_PARAM, {
          message: '[node-sdk] getCosFileAuthority fileList param error',
        }),
      );
    }
    const userInfo = cloudbase2.auth().getUserInfo();
    const { openId, uid } = userInfo;
    if (!openId && !uid) {
      throw utils_1.E(
        Object.assign({}, code_1.ERROR.INVALID_PARAM, {
          message: '[node-sdk] admin do not need getCosFileAuthority.',
        }),
      );
    }
    let params = {
      action: 'storage.getFileAuthority',
      openId,
      uid,
      loginType: LOGINTYPE,
      fileList,
    };
    const res = await httpRequest_1.default({
      config: cloudbase2.config,
      params,
      method: 'post',
      headers: {
        'content-type': 'application/json',
      },
    });
    if (res.code) {
      throw utils_1.E(
        Object.assign({}, res, {
          message: '[node-sdk] getCosFileAuthority failed: ' + res.code,
        }),
      );
    } else {
      return res;
    }
  }
  exports2.getFileAuthority = getFileAuthority;
});

// node_modules/@cloudbase/node-sdk/lib/analytics/index.js
var require_analytics = __commonJS((exports2) => {
  'use strict';
  var __importDefault =
    (exports2 && exports2.__importDefault) ||
    function (mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
  Object.defineProperty(exports2, '__esModule', { value: true });
  var httpRequest_1 = __importDefault(require_httpRequest());
  var utils_1 = require_utils3();
  var code_1 = require_code3();
  var cloudbase_1 = require_cloudbase();
  var reportTypes = ['mall'];
  function validateAnalyticsData(data) {
    if (Object.prototype.toString.call(data).slice(8, -1) !== 'Object') {
      return false;
    }
    const { report_data, report_type } = data;
    if (reportTypes.includes(report_type) === false) {
      return false;
    }
    if (Object.prototype.toString.call(report_data).slice(8, -1) !== 'Object') {
      return false;
    }
    if (
      report_data.action_time !== void 0 &&
      !Number.isInteger(report_data.action_time)
    ) {
      return false;
    }
    if (typeof report_data.action_type !== 'string') {
      return false;
    }
    return true;
  }
  async function analytics(cloudbase2, requestData) {
    const { WX_OPENID, WX_APPID } = cloudbase_1.CloudBase.getCloudbaseContext();
    if (!validateAnalyticsData(requestData)) {
      throw utils_1.E(
        Object.assign({}, code_1.ERROR.INVALID_PARAM, {
          message:
            '\u5F53\u524D\u7684\u4E0A\u62A5\u6570\u636E\u7ED3\u6784\u4E0D\u7B26\u5408\u89C4\u8303',
        }),
      );
    }
    const action_time =
      requestData.report_data.action_time === void 0
        ? Math.floor(Date.now() / 1e3)
        : requestData.report_data.action_time;
    const transformRequestData = {
      analytics_scene: requestData.report_type,
      analytics_data: Object.assign(
        { openid: WX_OPENID, wechat_mini_program_appid: WX_APPID },
        requestData.report_data,
        { action_time },
      ),
    };
    const params = {
      action: 'analytics.report',
      requestData: transformRequestData,
    };
    return httpRequest_1.default({
      config: cloudbase2.config,
      params,
      method: 'post',
      headers: {
        'content-type': 'application/json',
      },
    });
  }
  exports2.analytics = analytics;
});

// node_modules/@cloudbase/node-sdk/lib/utils/dbRequest.js
var require_dbRequest = __commonJS((exports2) => {
  'use strict';
  var __importDefault =
    (exports2 && exports2.__importDefault) ||
    function (mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
  Object.defineProperty(exports2, '__esModule', { value: true });
  var httpRequest_1 = __importDefault(require_httpRequest());
  var DBRequest = class {
    constructor(config) {
      this.config = config;
    }
    async send(api, data, opts) {
      const params = Object.assign({}, data, { action: api });
      return httpRequest_1.default({
        config: this.config,
        params,
        method: 'post',
        opts,
        headers: {
          'content-type': 'application/json',
        },
      });
    }
  };
  exports2.DBRequest = DBRequest;
});

// node_modules/@cloudbase/node-sdk/lib/log/index.js
var require_log2 = __commonJS((exports2) => {
  'use strict';
  Object.defineProperty(exports2, '__esModule', { value: true });
  var utils_1 = require_utils3();
  var code_1 = require_code3();
  var cloudbase_1 = require_cloudbase();
  var Log = class {
    constructor() {
      const { _SCF_TCB_LOG } = cloudbase_1.CloudBase.getCloudbaseContext();
      this.src = 'app';
      this.isSupportClsReport = true;
      if (`${_SCF_TCB_LOG}` !== '1') {
        this.isSupportClsReport = false;
      } else if (!console.__baseLog__) {
        this.isSupportClsReport = false;
      }
      if (!this.isSupportClsReport) {
        console.warn(
          '\u8BF7\u68C0\u67E5\u60A8\u662F\u5426\u5728\u672C\u5730\u73AF\u5883 \u6216\u8005 \u672A\u5F00\u901A\u9AD8\u7EA7\u65E5\u5FD7\u529F\u80FD\uFF0C\u5F53\u524D\u73AF\u5883\u4E0B\u65E0\u6CD5\u4E0A\u62A5cls\u65E5\u5FD7\uFF0C\u9ED8\u8BA4\u4F7F\u7528console',
        );
      }
    }
    transformMsg(logMsg) {
      let realMsg = {};
      realMsg = Object.assign({}, realMsg, logMsg);
      return realMsg;
    }
    baseLog(logMsg, logLevel) {
      if (Object.prototype.toString.call(logMsg).slice(8, -1) !== 'Object') {
        throw utils_1.E(
          Object.assign({}, code_1.ERROR.INVALID_PARAM, {
            message: 'log msg must be an object',
          }),
        );
      }
      const msgContent = this.transformMsg(logMsg);
      if (this.isSupportClsReport) {
        console.__baseLog__(msgContent, logLevel);
      } else {
        if (console[logLevel]) {
          console[logLevel](msgContent);
        }
      }
    }
    log(logMsg) {
      this.baseLog(logMsg, 'log');
    }
    info(logMsg) {
      this.baseLog(logMsg, 'info');
    }
    error(logMsg) {
      this.baseLog(logMsg, 'error');
    }
    warn(logMsg) {
      this.baseLog(logMsg, 'warn');
    }
  };
  exports2.Log = Log;
  function logger() {
    return new Log();
  }
  exports2.logger = logger;
});

// node_modules/@cloudbase/node-sdk/lib/cloudbase.js
var require_cloudbase = __commonJS((exports2) => {
  'use strict';
  var __rest =
    (exports2 && exports2.__rest) ||
    function (s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === 'function')
        for (
          var i = 0, p = Object.getOwnPropertySymbols(s);
          i < p.length;
          i++
        ) {
          if (
            e.indexOf(p[i]) < 0 &&
            Object.prototype.propertyIsEnumerable.call(s, p[i])
          )
            t[p[i]] = s[p[i]];
        }
      return t;
    };
  Object.defineProperty(exports2, '__esModule', { value: true });
  var database_1 = require_commonjs();
  var functions_1 = require_functions();
  var auth_1 = require_auth2();
  var wx_1 = require_wx();
  var storage_1 = require_storage();
  var analytics_1 = require_analytics();
  var dbRequest_1 = require_dbRequest();
  var log_1 = require_log2();
  var code_1 = require_code3();
  var utils_1 = require_utils3();
  var CloudBase = class {
    static parseContext(context) {
      if (typeof context !== 'object') {
        throw utils_1.E(
          Object.assign({}, code_1.ERROR.INVALID_CONTEXT, {
            message: 'context \u5FC5\u987B\u4E3A\u5BF9\u8C61\u7C7B\u578B',
          }),
        );
      }
      let {
        memory_limit_in_mb,
        time_limit_in_ms,
        request_id,
        environ,
        function_version,
        namespace,
        function_name,
        environment,
      } = context;
      let parseResult = {};
      try {
        parseResult.memoryLimitInMb = memory_limit_in_mb;
        parseResult.timeLimitIns = time_limit_in_ms;
        parseResult.requestId = request_id;
        parseResult.functionVersion = function_version;
        parseResult.namespace = namespace;
        parseResult.functionName = function_name;
        if (environment) {
          parseResult.environment = JSON.parse(environment);
          return parseResult;
        }
        const parseEnviron = environ.split(';');
        let parseEnvironObj = {};
        for (let i in parseEnviron) {
          if (parseEnviron[i].indexOf('=') >= 0) {
            const equalIndex = parseEnviron[i].indexOf('=');
            const key = parseEnviron[i].slice(0, equalIndex);
            let value = parseEnviron[i].slice(equalIndex + 1);
            if (value.indexOf(',') >= 0) {
              value = value.split(',');
            }
            parseEnvironObj[key] = value;
          }
        }
        parseResult.environ = parseEnvironObj;
      } catch (err) {
        throw utils_1.E(Object.assign({}, code_1.ERROR.INVALID_CONTEXT));
      }
      CloudBase.scfContext = parseResult;
      return parseResult;
    }
    static getCloudbaseContext(context) {
      const {
        TENCENTCLOUD_RUNENV,
        SCF_NAMESPACE,
        TCB_CONTEXT_KEYS,
        TENCENTCLOUD_SECRETID,
        TENCENTCLOUD_SECRETKEY,
        TENCENTCLOUD_SESSIONTOKEN,
        TRIGGER_SRC,
        WX_CONTEXT_KEYS,
        WX_TRIGGER_API_TOKEN_V0,
        WX_CLIENTIP,
        WX_CLIENTIPV6,
        _SCF_TCB_LOG,
        TCB_CONTEXT_CNFG,
        LOGINTYPE,
      } = process.env;
      let contextEnv = {};
      if (context) {
        const { environment, environ } = CloudBase.parseContext(context);
        contextEnv = environment || environ || {};
      }
      const tcb_context_keys = contextEnv.TCB_CONTEXT_KEYS || TCB_CONTEXT_KEYS;
      const wx_context_keys = contextEnv.WX_CONTEXT_KEYS || WX_CONTEXT_KEYS;
      let rawContext = {
        TENCENTCLOUD_RUNENV,
        SCF_NAMESPACE,
        TCB_CONTEXT_KEYS,
        TENCENTCLOUD_SECRETID,
        TENCENTCLOUD_SECRETKEY,
        TENCENTCLOUD_SESSIONTOKEN,
        TRIGGER_SRC,
        WX_TRIGGER_API_TOKEN_V0,
        WX_CLIENTIP,
        WX_CLIENTIPV6,
        WX_CONTEXT_KEYS,
        _SCF_TCB_LOG,
        TCB_CONTEXT_CNFG,
        LOGINTYPE,
      };
      if (tcb_context_keys) {
        try {
          const tcbKeysList = tcb_context_keys.split(',');
          for (let item of tcbKeysList) {
            rawContext[item] = contextEnv[item] || process.env[item];
          }
        } catch (e) {}
      }
      if (wx_context_keys) {
        try {
          const wxKeysList = wx_context_keys.split(',');
          for (let item of wxKeysList) {
            rawContext[item] = contextEnv[item] || process.env[item];
          }
        } catch (e) {}
      }
      rawContext = Object.assign({}, rawContext, contextEnv);
      let finalContext = {};
      for (let key in rawContext) {
        if (rawContext[key] !== void 0) {
          finalContext[key] = rawContext[key];
        }
      }
      return finalContext;
    }
    constructor(config) {
      this.init(config);
    }
    init(config = {}) {
      let {
          debug,
          secretId,
          secretKey,
          sessionToken,
          env,
          timeout,
          headers = {},
          throwOnCode,
        } = config,
        restConfig = __rest(config, [
          'debug',
          'secretId',
          'secretKey',
          'sessionToken',
          'env',
          'timeout',
          'headers',
          'throwOnCode',
        ]);
      if ((secretId && !secretKey) || (!secretId && secretKey)) {
        throw utils_1.E(
          Object.assign({}, code_1.ERROR.INVALID_PARAM, {
            message: 'secretId and secretKey must be a pair',
          }),
        );
      }
      const newConfig = Object.assign({}, restConfig, {
        debug: !!debug,
        secretId,
        secretKey,
        sessionToken,
        envName: env,
        headers: Object.assign({}, headers),
        timeout: timeout || 15e3,
        throwOnCode: throwOnCode !== void 0 ? throwOnCode : true,
      });
      this.config = newConfig;
      this.extensionMap = {};
    }
    registerExtension(ext) {
      this.extensionMap[ext.name] = ext;
    }
    async invokeExtension(name, opts) {
      const ext = this.extensionMap[name];
      if (!ext) {
        throw Error(`\u6269\u5C55${name} \u5FC5\u987B\u5148\u6CE8\u518C`);
      }
      return ext.invoke(opts, this);
    }
    database(dbConfig = {}) {
      database_1.Db.reqClass = dbRequest_1.DBRequest;
      if (Object.prototype.toString.call(dbConfig).slice(8, -1) !== 'Object') {
        throw utils_1.E(
          Object.assign({}, code_1.ERROR.INVALID_PARAM, {
            message: 'dbConfig must be an object',
          }),
        );
      }
      if (dbConfig && dbConfig.env) {
        dbConfig.envName = dbConfig.env;
        delete dbConfig.env;
      }
      return new database_1.Db(Object.assign({}, this.config, dbConfig));
    }
    callFunction({ name, data }, opts) {
      return functions_1.callFunction(this, { name, data }, opts);
    }
    auth() {
      return auth_1.auth(this);
    }
    callWxOpenApi({ apiName, apiOptions, cgiName, requestData }, opts) {
      return wx_1.callWxOpenApi(
        this,
        { apiName, apiOptions, cgiName, requestData },
        opts,
      );
    }
    callWxPayApi({ apiName, apiOptions, cgiName, requestData }, opts) {
      return wx_1.callWxPayApi(
        this,
        { apiName, apiOptions, cgiName, requestData },
        opts,
      );
    }
    callCompatibleWxOpenApi(
      { apiName, apiOptions, cgiName, requestData },
      opts,
    ) {
      return wx_1.callCompatibleWxOpenApi(
        this,
        { apiName, apiOptions, cgiName, requestData },
        opts,
      );
    }
    uploadFile({ cloudPath, fileContent }, opts) {
      return storage_1.uploadFile(this, { cloudPath, fileContent }, opts);
    }
    deleteFile({ fileList }, opts) {
      return storage_1.deleteFile(this, { fileList }, opts);
    }
    getTempFileURL({ fileList }, opts) {
      return storage_1.getTempFileURL(this, { fileList }, opts);
    }
    downloadFile(params, opts) {
      return storage_1.downloadFile(this, params, opts);
    }
    getUploadMetadata({ cloudPath }, opts) {
      return storage_1.getUploadMetadata(this, { cloudPath }, opts);
    }
    getFileAuthority({ fileList }, opts) {
      return storage_1.getFileAuthority(this, { fileList }, opts);
    }
    logger() {
      if (!this.clsLogger) {
        this.clsLogger = log_1.logger();
      }
      return this.clsLogger;
    }
    analytics(reportData) {
      return analytics_1.analytics(this, reportData);
    }
  };
  exports2.CloudBase = CloudBase;
});

// node_modules/@cloudbase/node-sdk/lib/index.js
var require_lib8 = __commonJS((exports2, module2) => {
  'use strict';
  var cloudbase_1 = require_cloudbase();
  var symbol_1 = require_symbol4();
  var request_1 = require_request4();
  var { version } = require_package();
  module2.exports = {
    request: request_1.extraRequest,
    init: (config) => {
      return new cloudbase_1.CloudBase(config);
    },
    parseContext: (context) => {
      return cloudbase_1.CloudBase.parseContext(context);
    },
    version,
    getCloudbaseContext: (context) => {
      return cloudbase_1.CloudBase.getCloudbaseContext(context);
    },
    SYMBOL_CURRENT_ENV: symbol_1.SYMBOL_CURRENT_ENV,
  };
});

// node_modules/uuid/v1.js
var require_v1 = __commonJS((exports2, module2) => {
  var rng = require_rng();
  var bytesToUuid = require_bytesToUuid();
  var _nodeId;
  var _clockseq;
  var _lastMSecs = 0;
  var _lastNSecs = 0;
  function v1(options, buf, offset) {
    var i = (buf && offset) || 0;
    var b = buf || [];
    options = options || {};
    var node = options.node || _nodeId;
    var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
    if (node == null || clockseq == null) {
      var seedBytes = rng();
      if (node == null) {
        node = _nodeId = [
          seedBytes[0] | 1,
          seedBytes[1],
          seedBytes[2],
          seedBytes[3],
          seedBytes[4],
          seedBytes[5],
        ];
      }
      if (clockseq == null) {
        clockseq = _clockseq = ((seedBytes[6] << 8) | seedBytes[7]) & 16383;
      }
    }
    var msecs = options.msecs !== void 0 ? options.msecs : new Date().getTime();
    var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
    var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === void 0) {
      clockseq = (clockseq + 1) & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 122192928e5;
    var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b[i++] = (tl >>> 24) & 255;
    b[i++] = (tl >>> 16) & 255;
    b[i++] = (tl >>> 8) & 255;
    b[i++] = tl & 255;
    var tmh = ((msecs / 4294967296) * 1e4) & 268435455;
    b[i++] = (tmh >>> 8) & 255;
    b[i++] = tmh & 255;
    b[i++] = ((tmh >>> 24) & 15) | 16;
    b[i++] = (tmh >>> 16) & 255;
    b[i++] = (clockseq >>> 8) | 128;
    b[i++] = clockseq & 255;
    for (var n = 0; n < 6; ++n) {
      b[i + n] = node[n];
    }
    return buf ? buf : bytesToUuid(b);
  }
  module2.exports = v1;
});

// node_modules/uuid/index.js
var require_uuid2 = __commonJS((exports2, module2) => {
  var v1 = require_v1();
  var v4 = require_v4();
  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  module2.exports = uuid;
});

// functions/src/until.ts
var cloudbase = __toModule(require_lib8());
var isDev = process.env.NODE_ENV === 'development';
var db = cloudbase
  .init({
    env: isDev ? 'atom-2gbnzw0gde4242dc' : 'law-build-9gbw1ney8060a480',
  })
  .database();
var _ = db.command;
var CaseStatus;
(function (CaseStatus2) {
  CaseStatus2[(CaseStatus2['AGREE'] = 0)] = 'AGREE';
  CaseStatus2[(CaseStatus2['WAITING'] = 1)] = 'WAITING';
  CaseStatus2[(CaseStatus2['REJECT'] = 2)] = 'REJECT';
})(CaseStatus || (CaseStatus = {}));
var noticeType;
(function (noticeType2) {
  noticeType2['approve'] = 'approve';
  noticeType2['approveResult'] = 'approveResult';
  noticeType2['msg'] = 'msg';
})(noticeType || (noticeType = {}));
var noticeState;
(function (noticeState2) {
  noticeState2[(noticeState2['unReade'] = 0)] = 'unReade';
  noticeState2[(noticeState2['read'] = 1)] = 'read';
})(noticeState || (noticeState = {}));
var CaseType;
(function (CaseType3) {
  CaseType3[(CaseType3['Civil'] = 0)] = 'Civil';
  CaseType3[(CaseType3['Criminal'] = 1)] = 'Criminal';
  CaseType3[(CaseType3['Administrative'] = 2)] = 'Administrative';
})(CaseType || (CaseType = {}));

// functions/src/create_case.ts
var { v4: uuidv4 } = require_uuid2();
var CaseCauseId = '28ee4e3e605adc2e0c514fe90a97ea26';
var updateCaseCause = async ({ caseCause }) => {
  const caseCauseCache = db.collection('Cache').doc(CaseCauseId);
  const Cache = await caseCauseCache.get();
  if (Cache.data[0].caseCauseList.indexOf(caseCause) !== -1) return;
  await caseCauseCache
    .update({
      caseCauseList: _.push(caseCause),
    })
    .catch(() => {});
};
var addNotice = async (Case, id) => {
  const res = await db
    .collection('User')
    .where({
      role: 'admin',
    })
    .get();
  res.data.forEach((user) => {
    if (user._openid !== Case.undertaker) {
      console.log('\u5BA1\u6279\u4E86');
      const notice = {
        title: '\u5BA1\u6279\u901A\u77E5',
        openId: user._openid,
        msg:
          '\u6709\u6848\u4EF6\u9700\u8981\u5BA1\u6279,\u8BF7\u70B9\u51FB\u67E5\u770B',
        caseId: id,
        state: noticeState.unReade,
        createTime: new Date(),
        type: noticeType.approve,
      };
      db.collection('Notice').add(notice);
    }
  });
};
var formatCase = (value, id) => {
  value.createTime = new Date();
  value.approveStatus = CaseStatus.WAITING;
  value._id = id;
  return value;
};
var CreateCase = async (Case) => {
  const id = uuidv4();
  console.log('id:', id);
  const res = await db.collection('Cases').add(formatCase(Case, id));
  await updateCaseCause(Case).catch((e) => {});
  await addNotice(Case, id).catch((e) => {});
  return res;
};

// functions/src/fetch_all_advisory.ts
var fetchAllAdvisory = async ({ name, undertaker }) => {
  const res = await db
    .collection('Advisory')
    .aggregate()
    .match({
      name: new db.RegExp({
        regexp: `.*${name || ''}.*`,
        options: 'i',
      }),
      _openid: new db.RegExp({
        regexp: `.*${undertaker || ''}.*`,
        options: 'i',
      }),
    })
    .limit(1e3)
    .sort({
      createTime: -1,
    })
    .lookup({
      from: 'User',
      localField: '_openid',
      foreignField: '_openid',
      as: 'User',
    })
    .addFields({
      userName: '$User.name',
    })
    .project({
      User: 0,
    })
    .end();
  return res;
};

// functions/src/fetch_all_user.ts
var fetchAllUser = async () => {
  const res = await db.collection('User').aggregate().limit(1e3).end();
  return res;
};

// functions/src/one_click_approve.ts
var dbCase = db.collection('Cases');
var dbNotice = db.collection('Notice');
var approveAgree = async (id, approverId, approveState, approveMsg) => {
  await dbCase.doc(id).update({
    approveStatus: approveState,
    approverId,
    approveMsg,
    approveTime: new Date(),
  });
  await addNotice2(id, approveState);
  await cleanNotice(id);
};
var addNotice2 = async (caseId, approveState) => {
  const res = await dbCase.doc(caseId).get();
  const resCase = res.data[0];
  const notice = {
    title: '\u7ACB\u6848\u5BA1\u6279\u7ED3\u679C',
    openId: resCase.undertaker,
    msg:
      approveState === CaseStatus.AGREE
        ? '\u7ACB\u6848\u5BA1\u6279\u5DF2\u7ECF\u901A\u8FC7'
        : '\u7ACB\u6848\u5BA1\u6279\u672A\u901A\u8FC7,\u70B9\u51FB\u67E5\u770B\u539F\u56E0',
    caseId,
    state: noticeState.unReade,
    createTime: new Date(),
    type: noticeType.approveResult,
  };
  dbNotice.add(notice);
};
var cleanNotice = async (caseId) => {
  const res = await dbNotice
    .where({
      type: noticeType.approve,
      caseId,
    })
    .get();
  res.data.forEach((item) => {
    dbNotice.doc(item._id).update({
      state: noticeState.read,
    });
  });
};
var oneClickApprove = async ({
  approverId,
  idList,
  approveState,
  approveMsg,
}) =>
  await Promise.all(
    idList.map((id) => approveAgree(id, approverId, approveState, approveMsg)),
  );

// functions/src/get_case_list.ts
var now = new Date();
var oldDate = new Date(now.setDate(now.getDate() - 30));
var { gt, neq } = db.command.aggregate;
var ConditionList = {
  approvedCases: {
    approveStatus: neq(CaseStatus.WAITING),
    approveTime: gt(oldDate),
  },
};
var getCaseList = async ({
  current,
  pageSize,
  condition,
  caseCause,
  litigant,
  undertaker,
  caseSituation,
  caseId,
  CaseType: CaseType3,
}) => {
  const conditionI =
    typeof condition === 'string' && condition === 'approvedCases'
      ? ConditionList[condition]
      : {
          caseCause: new db.RegExp({
            regexp: `.*${caseCause || ''}.*`,
          }),
          litigant: new db.RegExp({
            regexp: `.*${litigant || ''}.*`,
          }),
          caseSituation: new db.RegExp({
            regexp: `.*${caseSituation || ''}.*`,
          }),
          caseId: new db.RegExp({
            regexp: `.*${caseId || ''}.*`,
          }),
          undertaker: new db.RegExp({
            regexp: `.*${undertaker || ''}.*`,
          }),
          ...condition,
        };
  if (CaseType3) {
    conditionI['CaseType'] = Number(CaseType3);
  }
  const res = await db
    .collection('Cases')
    .aggregate()
    .match(conditionI)
    .sort({
      createTime: -1,
    })
    .skip((current - 1) * pageSize)
    .limit(pageSize)
    .lookup({
      from: 'User',
      localField: 'undertaker',
      foreignField: '_openid',
      as: 'undertaker',
    })
    .lookup({
      from: 'User',
      localField: 'approverId',
      foreignField: '_openid',
      as: 'approver',
    })
    .addFields({
      undertakerName: '$undertaker.name',
      approverName: '$approver.name',
    })
    .project({
      undertaker: 0,
      approver: 0,
    })
    .end();
  const resCount = await db
    .collection('Cases')
    .aggregate()
    .match(conditionI)
    .count('count')
    .end();
  return {
    caseList: res.data,
    count: resCount.data[0] && resCount.data[0].count,
    conditionI,
  };
};

// functions/src/update_user_info.ts
var UpdateUserInfo = async (data) => {
  return await db.collection('User').doc(data._id).update({
    name: data.name,
    phone: data.phone,
    role: data.role,
  });
};

// functions/src/index.ts
var fnList = {
  create_case: CreateCase,
  fetch_all_advisory: fetchAllAdvisory,
  fetch_all_user: fetchAllUser,
  one_click_approve: oneClickApprove,
  get_case_list: getCaseList,
  update_user_info: UpdateUserInfo,
};
exports.main = async function ({ fnName, data }) {
  return await fnList[fnName](data);
};
